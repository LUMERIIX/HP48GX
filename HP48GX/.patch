Index: bin/Release/HP48GX.eep
===================================================================
--- bin/Release/HP48GX.eep	(nonexistent)
+++ bin/Release/HP48GX.eep	(working copy)
@@ -0,0 +1 @@
+:00000001FF
Index: bin/Release/HP48GX.efs
===================================================================
--- bin/Release/HP48GX.efs	(nonexistent)
+++ bin/Release/HP48GX.efs	(working copy)
@@ -0,0 +1,3 @@
+:020000040000FA
+:01000000FF00
+:00000001FF
Index: bin/Release/HP48GX.elf
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: bin/Release/HP48GX.elf
===================================================================
--- bin/Release/HP48GX.elf	(nonexistent)
+++ bin/Release/HP48GX.elf	(working copy)

Property changes on: bin/Release/HP48GX.elf
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: bin/Release/HP48GX.fuse
===================================================================
--- bin/Release/HP48GX.fuse	(nonexistent)
+++ bin/Release/HP48GX.fuse	(working copy)
@@ -0,0 +1,2 @@
+:03000000ECDFFF33
+:00000001FF
Index: bin/Release/HP48GX.hex
===================================================================
--- bin/Release/HP48GX.hex	(nonexistent)
+++ bin/Release/HP48GX.hex	(working copy)
@@ -0,0 +1,164 @@
+:1000000067C0A4C380C07FC07EC07DC07CC07BC0F1
+:100010007AC079C078C077C076C075C0AFC073C0F1
+:1000200072C071C070C06FC005010906A1017501E1
+:100030009508050719E029E7150025FF81029501BC
+:1000400075088103950575010508190129FF9102BD
+:1000500095017503910395067508150025FF0507A1
+:10006000190029FF8100C004030904200363006F05
+:10007000006400650061006E0064006C0069006649
+:100080000065002E0063006F006D001003500061DA
+:100090000073007300670065006E0012011001001C
+:1000A000000008424231E100010102000109022280
+:1000B0000001010080190904000001030101000989
+:1000C0002101010001223F000705810308000A0009
+:1000D00011241FBECFEFD1E0DEBFCDBF11E0A0E005
+:1000E000B1E0E8EEF9E002C005900D92A034B1074E
+:1000F000D9F711E0A0E4B1E001C01D92A739B10722
+:10010000E1F767D16FC47CCFFC01808180768032BB
+:1001100061F581818230E1F0833018F4813029F576
+:1001200005C0893079F08A3001F51AC087E591E081
+:1001300090937C0180937B0110925701109259019A
+:1001400088E0089586819781019779F48FEF08956B
+:100150008FE591E090937C0180937B0181E008958D
+:10016000838180935F0180E0089580E0089581E0BD
+:100170000895109257018093590108951F920F928C
+:100180000FB60F9211248F939F9381E090E090938C
+:100190005501809354019F918F910F900FBE0F9046
+:1001A0001F9018958091540190915501892B09F465
+:1001B000A4C0109255011092540149B1437FA091FF
+:1001C00056012A2F30E0F901E65BFE4F808184273B
+:1001D0004083882309F465C0942F40FD0DC080FF43
+:1001E0000BC081E080934001C90166E070E0E8D374
+:1001F000FC01E050FF4F20C091FD0EC081FF0CC0FC
+:1002000081E080934001C90166E070E0D9D3FC0130
+:10021000E050FF4F818141C094FD10C084FF0EC0AB
+:1002200081E080934001C90163E070E0C9D3FC0123
+:10023000EE0FFF1FEE5FFE4F80812FC095FD0EC0B9
+:1002400085FF0CC081E080934001C90166E070E049
+:10025000B7D3FC01E050FF4F83811FC096FD0EC055
+:1002600086FF0CC081E080934001C90166E070E028
+:10027000A7D3FC01E050FF4F84810FC047FD11C0A0
+:1002800087FF0FC081E080934001C90166E070E004
+:1002900097D3FC01E050FF4F85818093430110927A
+:1002A000440180913C0190913D01880F991F9093EA
+:1002B0003D0180933C01AF5FA093560180349105CE
+:1002C00031F480E890E090933D0180933C0180916F
+:1002D0003C0190913D018050944041F481E090E0D8
+:1002E00090933D0180933C011092560190913C0106
+:1002F00080913D0197B984608DB908958091400146
+:10030000813081F083B190E08078907080935301C8
+:10031000892B41F481E085B981E090E0909342011E
+:100320008093410108958091410190914201892B70
+:10033000A9F11F991DC08091450190914601019638
+:1003400090934601809345018052934089F48CE359
+:1003500090E0909344018093430181E080934001B9
+:1003600010924201109241011092460110924501F3
+:10037000809145019091460189559240873C9105B5
+:1003800068F480913601809343011092440181E02A
+:100390008093400110924201109241010895109201
+:1003A0006B0010926D0010926A0017B818B88AB1ED
+:1003B0008C708AB98BB11BB884E08DB91EB81092CD
+:1003C0008000109281001092820081E084B915B8FB
+:1003D00008951F93E4DFE7E5F1E0119281E0EF3546
+:1003E000F807D9F72EE088E190E00FB6F894A895C9
+:1003F000809360000FBE209360003BD0539A20E0B2
+:1004000040E757E1A895CA010197F1F72F5F2A3F0E
+:10041000C9F73CD05398F89483E085BD81E0809380
+:100420006E00789412E07FDF69DFBCDEA8952ED0E5
+:1004300080916C0184FF18C0809140018823A1F055
+:10044000813019F0823071F409C08091430110921B
+:100450005701809359011093400106C01092570133
+:10046000109259011092400187E591E068E033D184
+:10047000DACFE9E6F0E0808182608083E89A8BE45D
+:1004800080936D018AE580936C0108951F93CF934B
+:10049000DF9360917D01635067FDC2C080917A0156
+:1004A000CCE0D0E0C81BD109CF57DE4F8091790155
+:1004B0008D3209F0A3C0683009F0B0C083EC80939E
+:1004C00061018AE580933E01109260018881807607
+:1004D00039F0CE0119DE282F8F3F09F47EC084C089
+:1004E0009A8110926A018981882321F410926B010C
+:1004F00022E06CC0853019F490937E0166C086308E
+:1005000009F04FC08B81813041F48BE990E09093EA
+:100510007C0180937B0122E140C0823041F48DEA6E
+:1005200090E090937C0180937B0122E236C083307F
+:10053000F9F48A81882341F487E690E090937C0166
+:1005400080937B0124E029C0813041F48BE690E068
+:1005500090937C0180937B0120E21FC08230E1F404
+:100560008BE890E090937C0180937B0120E115C0A3
+:10057000813241F48FEB90E090937C0180937B017A
+:1005800029E00BC0823241F488E290E090937C0134
+:1005900080937B012FE301C020E080E48093600121
+:1005A00023C0883021F421E080E891E011C0893037
+:1005B00019F49093800109C08A3011F421E006C03B
+:1005C0008B3019F48BE480936D0120E08AE691E092
+:1005D00090937C0180937B0107C0888187FD2E81E9
+:1005E00080E88093600106C08F81882319F48E8192
+:1005F000821708F0822F80933F0110C08091600124
+:1006000087FF0CC0CE01B3DD8F3F21F48EE18093D4
+:100610003E0104C0882311F010923F0110927D0129
+:1006200080913E0184FF49C080913F018F3F09F4D2
+:1006300044C0182F893008F018E0811B80933F01D7
+:100640008091610198E8892780936101112341F12C
+:1006500020917B0130917C018091600186FF0DC06B
+:10066000A2E6B1E080E090E0F901E80FF91FE49123
+:10067000ED9301961817C1F708C0912FD901E2E652
+:10068000F1E08D9181939150E1F71150812F90E02D
+:100690001F5F0196820F931F90937C0180937B01D3
+:1006A00082E691E0612F4ED0612F6C5F6C3019F0C3
+:1006B0008FEF80933F0160933E0194E189B18C708C
+:1006C00031F49150D9F710927E0110927801DF91A8
+:1006D000CF911F9108951F93DC01162F80916C011B
+:1006E00084FF07C080916D0198E8892780936D0190
+:1006F00003C08AE580936C01912FEEE6F1E08D91C5
+:10070000819391501916DCF38EE691E0612F1AD097
+:100710001C5F10936C011F910895A82FB92F80E0E2
+:1007200090E041E050EA609530E009C02D918227C9
+:100730009795879510F084279527305EC8F36F5FF3
+:10074000A8F30895EADF8D939D930895CF93CFB7D3
+:10075000CF93C3954B9BE9F74B9B09C04B9B07C0BD
+:100760004B9B05C04B9B03C04B9B01C0A3C0DF93B9
+:10077000C0917A01DD27CF57DE4F4B9B02C0DF913E
+:10078000EBCF2F930F931F9309B12FEF03FB20F9AA
+:100790004F933F9319B14FEF012703FB21F93BE042
+:1007A00031C04E7F012F19B1216028C0102F4D7F1D
+:1007B0002260000009B129C04B7F2460012F000096
+:1007C00019B12BC019B1477F28602AC04F7E09B1EB
+:1007D00020612CC04F7D19B120622FC04F7B09B121
+:1007E000206432C0422709B149934FEF000010271F
+:1007F00013FB20F919B11C70C9F1297F91F201276F
+:1008000003FB21F909B1237F89F2315058F11027F8
+:1008100013FB22F919B1277E79F2012703FB23F993
+:100820002F7C81F209B1102713FB24F92F7971F283
+:1008300000C019B1012703FB25F92F7359F200C03D
+:1008400009B1102713FB26F9223040F200C019B17C
+:10085000012703FB27F9243028F64F77206819B1C8
+:100860000000F9CF11E01CBB002719C03B503195A7
+:10087000C31BD04011E01CBB0881033CF9F00B34D2
+:10088000E9F0209178011981110F1213EDCF4A81FF
+:10089000441F093641F10D3211F0013E29F7009352
+:1008A0007F013F914F911F910F912F91DF91CCB319
+:1008B000C0FD4FCFCF91CFBFCF91189520917F0131
+:1008C000222379F310917D01112369F534306AF107
+:1008D00030937D012093790110917A013BE0311B27
+:1008E00030937A0122C000917D010130E4F40AE5E1
+:1008F0004F7049F430913E0134FD19C000933E0120
+:10090000C1E6D1E018C030916C0134FD10C00093F5
+:100910006C01CDE6D1E00FC02795A8F45150A9F4A1
+:10092000220F0000F9CF4AE503C042ED01C0432F7A
+:10093000C4E1D0E032E01AB11C605B9A1AB90BB185
+:1009400020E41CE05F93012756E00BB9279520F4C3
+:10095000515021F4220FF9CF012756E000003B5AF5
+:100960000BB9D0F2279528F4515029F4220F00003A
+:10097000F9CF012756E027950BB920F4515021F407
+:10098000220FF9CF012756E0299133230BB921F625
+:10099000037F10917E01110FC651D0400BB911F0A9
+:1009A0001093780111E01CBB08601AB1137F402F2F
+:1009B000437F5F9100C000C00BB91AB94BB971CF2A
+:1009C0005527002480FF02C0060E571F660F771FB1
+:1009D0006115710521F096958795009799F7952FE8
+:0809E000802D0895F894FFCF6B
+:1009E800000506070809000B0C0D0E0F0011121365
+:1009F8001415001718191A1B00581D1C4C2A2B1601
+:100A080024252654E10A21222355E0041E1F2056DE
+:100A1800001027372C5729000000000001005AFF5A
+:00000001FF
Index: bin/Release/HP48GX.hfs
===================================================================
--- bin/Release/HP48GX.hfs	(nonexistent)
+++ bin/Release/HP48GX.hfs	(working copy)
@@ -0,0 +1,3 @@
+:020000040000FA
+:01000000DF20
+:00000001FF
Index: bin/Release/HP48GX.lfs
===================================================================
--- bin/Release/HP48GX.lfs	(nonexistent)
+++ bin/Release/HP48GX.lfs	(working copy)
@@ -0,0 +1,3 @@
+:020000040000FA
+:01000000EC13
+:00000001FF
Index: bin/Release/HP48GX.lock
===================================================================
--- bin/Release/HP48GX.lock	(nonexistent)
+++ bin/Release/HP48GX.lock	(working copy)
@@ -0,0 +1 @@
+:00000001FF
Index: bin/Release/HP48GX.lss
===================================================================
--- bin/Release/HP48GX.lss	(nonexistent)
+++ bin/Release/HP48GX.lss	(working copy)
@@ -0,0 +1,1236 @@
+
+bin\Release\HP48GX.elf:     file format elf32-avr
+
+Sections:
+Idx Name          Size      VMA       LMA       File off  Algn
+  0 .data         00000040  00800100  000009e8  00000a9c  2**0
+                  CONTENTS, ALLOC, LOAD, DATA
+  1 .text         000009e8  00000000  00000000  000000b4  2**1
+                  CONTENTS, ALLOC, LOAD, READONLY, CODE
+  2 .bss          00000057  00800140  00800140  00000adc  2**0
+                  ALLOC
+  3 .fuse         00000003  00820000  00820000  00000adc  2**0
+                  CONTENTS, ALLOC, LOAD, DATA
+
+Disassembly of section .text:
+
+00000000 <__vectors>:
+   0:	67 c0       	rjmp	.+206    	; 0xd0 <__ctors_end>
+   2:	a4 c3       	rjmp	.+1864   	; 0x74c <__vector_1>
+   4:	80 c0       	rjmp	.+256    	; 0x106 <__bad_interrupt>
+   6:	7f c0       	rjmp	.+254    	; 0x106 <__bad_interrupt>
+   8:	7e c0       	rjmp	.+252    	; 0x106 <__bad_interrupt>
+   a:	7d c0       	rjmp	.+250    	; 0x106 <__bad_interrupt>
+   c:	7c c0       	rjmp	.+248    	; 0x106 <__bad_interrupt>
+   e:	7b c0       	rjmp	.+246    	; 0x106 <__bad_interrupt>
+  10:	7a c0       	rjmp	.+244    	; 0x106 <__bad_interrupt>
+  12:	79 c0       	rjmp	.+242    	; 0x106 <__bad_interrupt>
+  14:	78 c0       	rjmp	.+240    	; 0x106 <__bad_interrupt>
+  16:	77 c0       	rjmp	.+238    	; 0x106 <__bad_interrupt>
+  18:	76 c0       	rjmp	.+236    	; 0x106 <__bad_interrupt>
+  1a:	75 c0       	rjmp	.+234    	; 0x106 <__bad_interrupt>
+  1c:	af c0       	rjmp	.+350    	; 0x17c <__vector_14>
+  1e:	73 c0       	rjmp	.+230    	; 0x106 <__bad_interrupt>
+  20:	72 c0       	rjmp	.+228    	; 0x106 <__bad_interrupt>
+  22:	71 c0       	rjmp	.+226    	; 0x106 <__bad_interrupt>
+  24:	70 c0       	rjmp	.+224    	; 0x106 <__bad_interrupt>
+  26:	6f c0       	rjmp	.+222    	; 0x106 <__bad_interrupt>
+
+00000028 <usbDescriptorHidReport>:
+  28:	05 01 09 06 a1 01 75 01 95 08 05 07 19 e0 29 e7     ......u.......).
+  38:	15 00 25 ff 81 02 95 01 75 08 81 03 95 05 75 01     ..%.....u.....u.
+  48:	05 08 19 01 29 ff 91 02 95 01 75 03 91 03 95 06     ....).....u.....
+  58:	75 08 15 00 25 ff 05 07 19 00 29 ff 81 00 c0        u...%.....)....
+
+00000067 <usbDescriptorString0>:
+  67:	04 03 09 04                                         ....
+
+0000006b <usbDescriptorStringVendor>:
+  6b:	20 03 63 00 6f 00 64 00 65 00 61 00 6e 00 64 00      .c.o.d.e.a.n.d.
+  7b:	6c 00 69 00 66 00 65 00 2e 00 63 00 6f 00 6d 00     l.i.f.e...c.o.m.
+
+0000008b <usbDescriptorStringDevice>:
+  8b:	10 03 50 00 61 00 73 00 73 00 67 00 65 00 6e 00     ..P.a.s.s.g.e.n.
+
+0000009b <usbDescriptorDevice>:
+  9b:	12 01 10 01 00 00 00 08 42 42 31 e1 00 01 01 02     ........BB1.....
+  ab:	00 01                                               ..
+
+000000ad <usbDescriptorConfiguration>:
+  ad:	09 02 22 00 01 01 00 80 19 09 04 00 00 01 03 01     ..".............
+  bd:	01 00 09 21 01 01 00 01 22 3f 00 07 05 81 03 08     ...!...."?......
+  cd:	00 0a 00                                            ...
+
+000000d0 <__ctors_end>:
+  d0:	11 24       	eor	r1, r1
+  d2:	1f be       	out	0x3f, r1	; 63
+  d4:	cf ef       	ldi	r28, 0xFF	; 255
+  d6:	d1 e0       	ldi	r29, 0x01	; 1
+  d8:	de bf       	out	0x3e, r29	; 62
+  da:	cd bf       	out	0x3d, r28	; 61
+
+000000dc <__do_copy_data>:
+  dc:	11 e0       	ldi	r17, 0x01	; 1
+  de:	a0 e0       	ldi	r26, 0x00	; 0
+  e0:	b1 e0       	ldi	r27, 0x01	; 1
+  e2:	e8 ee       	ldi	r30, 0xE8	; 232
+  e4:	f9 e0       	ldi	r31, 0x09	; 9
+  e6:	02 c0       	rjmp	.+4      	; 0xec <.do_copy_data_start>
+
+000000e8 <.do_copy_data_loop>:
+  e8:	05 90       	lpm	r0, Z+
+  ea:	0d 92       	st	X+, r0
+
+000000ec <.do_copy_data_start>:
+  ec:	a0 34       	cpi	r26, 0x40	; 64
+  ee:	b1 07       	cpc	r27, r17
+  f0:	d9 f7       	brne	.-10     	; 0xe8 <.do_copy_data_loop>
+
+000000f2 <__do_clear_bss>:
+  f2:	11 e0       	ldi	r17, 0x01	; 1
+  f4:	a0 e4       	ldi	r26, 0x40	; 64
+  f6:	b1 e0       	ldi	r27, 0x01	; 1
+  f8:	01 c0       	rjmp	.+2      	; 0xfc <.do_clear_bss_start>
+
+000000fa <.do_clear_bss_loop>:
+  fa:	1d 92       	st	X+, r1
+
+000000fc <.do_clear_bss_start>:
+  fc:	a7 39       	cpi	r26, 0x97	; 151
+  fe:	b1 07       	cpc	r27, r17
+ 100:	e1 f7       	brne	.-8      	; 0xfa <.do_clear_bss_loop>
+ 102:	67 d1       	rcall	.+718    	; 0x3d2 <main>
+ 104:	6f c4       	rjmp	.+2270   	; 0x9e4 <_exit>
+
+00000106 <__bad_interrupt>:
+ 106:	7c cf       	rjmp	.-264    	; 0x0 <__vectors>
+
+00000108 <usbFunctionSetup>:
+ 108:	fc 01       	movw	r30, r24
+ 10a:	80 81       	ld	r24, Z
+ 10c:	80 76       	andi	r24, 0x60	; 96
+ 10e:	80 32       	cpi	r24, 0x20	; 32
+ 110:	61 f5       	brne	.+88     	; 0x16a <usbFunctionSetup+0x62>
+ 112:	81 81       	ldd	r24, Z+1	; 0x01
+ 114:	82 30       	cpi	r24, 0x02	; 2
+ 116:	e1 f0       	breq	.+56     	; 0x150 <usbFunctionSetup+0x48>
+ 118:	83 30       	cpi	r24, 0x03	; 3
+ 11a:	18 f4       	brcc	.+6      	; 0x122 <usbFunctionSetup+0x1a>
+ 11c:	81 30       	cpi	r24, 0x01	; 1
+ 11e:	29 f5       	brne	.+74     	; 0x16a <usbFunctionSetup+0x62>
+ 120:	05 c0       	rjmp	.+10     	; 0x12c <usbFunctionSetup+0x24>
+ 122:	89 30       	cpi	r24, 0x09	; 9
+ 124:	79 f0       	breq	.+30     	; 0x144 <usbFunctionSetup+0x3c>
+ 126:	8a 30       	cpi	r24, 0x0A	; 10
+ 128:	01 f5       	brne	.+64     	; 0x16a <usbFunctionSetup+0x62>
+ 12a:	1a c0       	rjmp	.+52     	; 0x160 <usbFunctionSetup+0x58>
+ 12c:	87 e5       	ldi	r24, 0x57	; 87
+ 12e:	91 e0       	ldi	r25, 0x01	; 1
+ 130:	90 93 7c 01 	sts	0x017C, r25
+ 134:	80 93 7b 01 	sts	0x017B, r24
+ 138:	10 92 57 01 	sts	0x0157, r1
+ 13c:	10 92 59 01 	sts	0x0159, r1
+ 140:	88 e0       	ldi	r24, 0x08	; 8
+ 142:	08 95       	ret
+ 144:	86 81       	ldd	r24, Z+6	; 0x06
+ 146:	97 81       	ldd	r25, Z+7	; 0x07
+ 148:	01 97       	sbiw	r24, 0x01	; 1
+ 14a:	79 f4       	brne	.+30     	; 0x16a <usbFunctionSetup+0x62>
+ 14c:	8f ef       	ldi	r24, 0xFF	; 255
+ 14e:	08 95       	ret
+ 150:	8f e5       	ldi	r24, 0x5F	; 95
+ 152:	91 e0       	ldi	r25, 0x01	; 1
+ 154:	90 93 7c 01 	sts	0x017C, r25
+ 158:	80 93 7b 01 	sts	0x017B, r24
+ 15c:	81 e0       	ldi	r24, 0x01	; 1
+ 15e:	08 95       	ret
+ 160:	83 81       	ldd	r24, Z+3	; 0x03
+ 162:	80 93 5f 01 	sts	0x015F, r24
+ 166:	80 e0       	ldi	r24, 0x00	; 0
+ 168:	08 95       	ret
+ 16a:	80 e0       	ldi	r24, 0x00	; 0
+ 16c:	08 95       	ret
+
+0000016e <usbFunctionWrite>:
+ 16e:	81 e0       	ldi	r24, 0x01	; 1
+ 170:	08 95       	ret
+
+00000172 <buildReport>:
+ 172:	10 92 57 01 	sts	0x0157, r1
+ 176:	80 93 59 01 	sts	0x0159, r24
+ 17a:	08 95       	ret
+
+0000017c <__vector_14>:
+ 17c:	1f 92       	push	r1
+ 17e:	0f 92       	push	r0
+ 180:	0f b6       	in	r0, 0x3f	; 63
+ 182:	0f 92       	push	r0
+ 184:	11 24       	eor	r1, r1
+ 186:	8f 93       	push	r24
+ 188:	9f 93       	push	r25
+ 18a:	81 e0       	ldi	r24, 0x01	; 1
+ 18c:	90 e0       	ldi	r25, 0x00	; 0
+ 18e:	90 93 55 01 	sts	0x0155, r25
+ 192:	80 93 54 01 	sts	0x0154, r24
+ 196:	9f 91       	pop	r25
+ 198:	8f 91       	pop	r24
+ 19a:	0f 90       	pop	r0
+ 19c:	0f be       	out	0x3f, r0	; 63
+ 19e:	0f 90       	pop	r0
+ 1a0:	1f 90       	pop	r1
+ 1a2:	18 95       	reti
+
+000001a4 <scanMatrix>:
+ 1a4:	80 91 54 01 	lds	r24, 0x0154
+ 1a8:	90 91 55 01 	lds	r25, 0x0155
+ 1ac:	89 2b       	or	r24, r25
+ 1ae:	09 f4       	brne	.+2      	; 0x1b2 <scanMatrix+0xe>
+ 1b0:	a4 c0       	rjmp	.+328    	; 0x2fa <__stack+0xfb>
+ 1b2:	10 92 55 01 	sts	0x0155, r1
+ 1b6:	10 92 54 01 	sts	0x0154, r1
+ 1ba:	49 b1       	in	r20, 0x09	; 9
+ 1bc:	43 7f       	andi	r20, 0xF3	; 243
+ 1be:	a0 91 56 01 	lds	r26, 0x0156
+ 1c2:	2a 2f       	mov	r18, r26
+ 1c4:	30 e0       	ldi	r19, 0x00	; 0
+ 1c6:	f9 01       	movw	r30, r18
+ 1c8:	e6 5b       	subi	r30, 0xB6	; 182
+ 1ca:	fe 4f       	sbci	r31, 0xFE	; 254
+ 1cc:	80 81       	ld	r24, Z
+ 1ce:	84 27       	eor	r24, r20
+ 1d0:	40 83       	st	Z, r20
+ 1d2:	88 23       	and	r24, r24
+ 1d4:	09 f4       	brne	.+2      	; 0x1d8 <scanMatrix+0x34>
+ 1d6:	65 c0       	rjmp	.+202    	; 0x2a2 <__stack+0xa3>
+ 1d8:	94 2f       	mov	r25, r20
+ 1da:	40 fd       	sbrc	r20, 0
+ 1dc:	0d c0       	rjmp	.+26     	; 0x1f8 <scanMatrix+0x54>
+ 1de:	80 ff       	sbrs	r24, 0
+ 1e0:	0b c0       	rjmp	.+22     	; 0x1f8 <scanMatrix+0x54>
+ 1e2:	81 e0       	ldi	r24, 0x01	; 1
+ 1e4:	80 93 40 01 	sts	0x0140, r24
+ 1e8:	c9 01       	movw	r24, r18
+ 1ea:	66 e0       	ldi	r22, 0x06	; 6
+ 1ec:	70 e0       	ldi	r23, 0x00	; 0
+ 1ee:	e8 d3       	rcall	.+2000   	; 0x9c0 <__mulhi3>
+ 1f0:	fc 01       	movw	r30, r24
+ 1f2:	e0 50       	subi	r30, 0x00	; 0
+ 1f4:	ff 4f       	sbci	r31, 0xFF	; 255
+ 1f6:	20 c0       	rjmp	.+64     	; 0x238 <__stack+0x39>
+ 1f8:	91 fd       	sbrc	r25, 1
+ 1fa:	0e c0       	rjmp	.+28     	; 0x218 <__stack+0x19>
+ 1fc:	81 ff       	sbrs	r24, 1
+ 1fe:	0c c0       	rjmp	.+24     	; 0x218 <__stack+0x19>
+ 200:	81 e0       	ldi	r24, 0x01	; 1
+ 202:	80 93 40 01 	sts	0x0140, r24
+ 206:	c9 01       	movw	r24, r18
+ 208:	66 e0       	ldi	r22, 0x06	; 6
+ 20a:	70 e0       	ldi	r23, 0x00	; 0
+ 20c:	d9 d3       	rcall	.+1970   	; 0x9c0 <__mulhi3>
+ 20e:	fc 01       	movw	r30, r24
+ 210:	e0 50       	subi	r30, 0x00	; 0
+ 212:	ff 4f       	sbci	r31, 0xFF	; 255
+ 214:	81 81       	ldd	r24, Z+1	; 0x01
+ 216:	41 c0       	rjmp	.+130    	; 0x29a <__stack+0x9b>
+ 218:	94 fd       	sbrc	r25, 4
+ 21a:	10 c0       	rjmp	.+32     	; 0x23c <__stack+0x3d>
+ 21c:	84 ff       	sbrs	r24, 4
+ 21e:	0e c0       	rjmp	.+28     	; 0x23c <__stack+0x3d>
+ 220:	81 e0       	ldi	r24, 0x01	; 1
+ 222:	80 93 40 01 	sts	0x0140, r24
+ 226:	c9 01       	movw	r24, r18
+ 228:	63 e0       	ldi	r22, 0x03	; 3
+ 22a:	70 e0       	ldi	r23, 0x00	; 0
+ 22c:	c9 d3       	rcall	.+1938   	; 0x9c0 <__mulhi3>
+ 22e:	fc 01       	movw	r30, r24
+ 230:	ee 0f       	add	r30, r30
+ 232:	ff 1f       	adc	r31, r31
+ 234:	ee 5f       	subi	r30, 0xFE	; 254
+ 236:	fe 4f       	sbci	r31, 0xFE	; 254
+ 238:	80 81       	ld	r24, Z
+ 23a:	2f c0       	rjmp	.+94     	; 0x29a <__stack+0x9b>
+ 23c:	95 fd       	sbrc	r25, 5
+ 23e:	0e c0       	rjmp	.+28     	; 0x25c <__stack+0x5d>
+ 240:	85 ff       	sbrs	r24, 5
+ 242:	0c c0       	rjmp	.+24     	; 0x25c <__stack+0x5d>
+ 244:	81 e0       	ldi	r24, 0x01	; 1
+ 246:	80 93 40 01 	sts	0x0140, r24
+ 24a:	c9 01       	movw	r24, r18
+ 24c:	66 e0       	ldi	r22, 0x06	; 6
+ 24e:	70 e0       	ldi	r23, 0x00	; 0
+ 250:	b7 d3       	rcall	.+1902   	; 0x9c0 <__mulhi3>
+ 252:	fc 01       	movw	r30, r24
+ 254:	e0 50       	subi	r30, 0x00	; 0
+ 256:	ff 4f       	sbci	r31, 0xFF	; 255
+ 258:	83 81       	ldd	r24, Z+3	; 0x03
+ 25a:	1f c0       	rjmp	.+62     	; 0x29a <__stack+0x9b>
+ 25c:	96 fd       	sbrc	r25, 6
+ 25e:	0e c0       	rjmp	.+28     	; 0x27c <__stack+0x7d>
+ 260:	86 ff       	sbrs	r24, 6
+ 262:	0c c0       	rjmp	.+24     	; 0x27c <__stack+0x7d>
+ 264:	81 e0       	ldi	r24, 0x01	; 1
+ 266:	80 93 40 01 	sts	0x0140, r24
+ 26a:	c9 01       	movw	r24, r18
+ 26c:	66 e0       	ldi	r22, 0x06	; 6
+ 26e:	70 e0       	ldi	r23, 0x00	; 0
+ 270:	a7 d3       	rcall	.+1870   	; 0x9c0 <__mulhi3>
+ 272:	fc 01       	movw	r30, r24
+ 274:	e0 50       	subi	r30, 0x00	; 0
+ 276:	ff 4f       	sbci	r31, 0xFF	; 255
+ 278:	84 81       	ldd	r24, Z+4	; 0x04
+ 27a:	0f c0       	rjmp	.+30     	; 0x29a <__stack+0x9b>
+ 27c:	47 fd       	sbrc	r20, 7
+ 27e:	11 c0       	rjmp	.+34     	; 0x2a2 <__stack+0xa3>
+ 280:	87 ff       	sbrs	r24, 7
+ 282:	0f c0       	rjmp	.+30     	; 0x2a2 <__stack+0xa3>
+ 284:	81 e0       	ldi	r24, 0x01	; 1
+ 286:	80 93 40 01 	sts	0x0140, r24
+ 28a:	c9 01       	movw	r24, r18
+ 28c:	66 e0       	ldi	r22, 0x06	; 6
+ 28e:	70 e0       	ldi	r23, 0x00	; 0
+ 290:	97 d3       	rcall	.+1838   	; 0x9c0 <__mulhi3>
+ 292:	fc 01       	movw	r30, r24
+ 294:	e0 50       	subi	r30, 0x00	; 0
+ 296:	ff 4f       	sbci	r31, 0xFF	; 255
+ 298:	85 81       	ldd	r24, Z+5	; 0x05
+ 29a:	80 93 43 01 	sts	0x0143, r24
+ 29e:	10 92 44 01 	sts	0x0144, r1
+ 2a2:	80 91 3c 01 	lds	r24, 0x013C
+ 2a6:	90 91 3d 01 	lds	r25, 0x013D
+ 2aa:	88 0f       	add	r24, r24
+ 2ac:	99 1f       	adc	r25, r25
+ 2ae:	90 93 3d 01 	sts	0x013D, r25
+ 2b2:	80 93 3c 01 	sts	0x013C, r24
+ 2b6:	af 5f       	subi	r26, 0xFF	; 255
+ 2b8:	a0 93 56 01 	sts	0x0156, r26
+ 2bc:	80 34       	cpi	r24, 0x40	; 64
+ 2be:	91 05       	cpc	r25, r1
+ 2c0:	31 f4       	brne	.+12     	; 0x2ce <__stack+0xcf>
+ 2c2:	80 e8       	ldi	r24, 0x80	; 128
+ 2c4:	90 e0       	ldi	r25, 0x00	; 0
+ 2c6:	90 93 3d 01 	sts	0x013D, r25
+ 2ca:	80 93 3c 01 	sts	0x013C, r24
+ 2ce:	80 91 3c 01 	lds	r24, 0x013C
+ 2d2:	90 91 3d 01 	lds	r25, 0x013D
+ 2d6:	80 50       	subi	r24, 0x00	; 0
+ 2d8:	94 40       	sbci	r25, 0x04	; 4
+ 2da:	41 f4       	brne	.+16     	; 0x2ec <__stack+0xed>
+ 2dc:	81 e0       	ldi	r24, 0x01	; 1
+ 2de:	90 e0       	ldi	r25, 0x00	; 0
+ 2e0:	90 93 3d 01 	sts	0x013D, r25
+ 2e4:	80 93 3c 01 	sts	0x013C, r24
+ 2e8:	10 92 56 01 	sts	0x0156, r1
+ 2ec:	90 91 3c 01 	lds	r25, 0x013C
+ 2f0:	80 91 3d 01 	lds	r24, 0x013D
+ 2f4:	97 b9       	out	0x07, r25	; 7
+ 2f6:	84 60       	ori	r24, 0x04	; 4
+ 2f8:	8d b9       	out	0x0d, r24	; 13
+ 2fa:	08 95       	ret
+
+000002fc <OnKey>:
+ 2fc:	80 91 40 01 	lds	r24, 0x0140
+ 300:	81 30       	cpi	r24, 0x01	; 1
+ 302:	81 f0       	breq	.+32     	; 0x324 <OnKey+0x28>
+ 304:	83 b1       	in	r24, 0x03	; 3
+ 306:	90 e0       	ldi	r25, 0x00	; 0
+ 308:	80 78       	andi	r24, 0x80	; 128
+ 30a:	90 70       	andi	r25, 0x00	; 0
+ 30c:	80 93 53 01 	sts	0x0153, r24
+ 310:	89 2b       	or	r24, r25
+ 312:	41 f4       	brne	.+16     	; 0x324 <OnKey+0x28>
+ 314:	81 e0       	ldi	r24, 0x01	; 1
+ 316:	85 b9       	out	0x05, r24	; 5
+ 318:	81 e0       	ldi	r24, 0x01	; 1
+ 31a:	90 e0       	ldi	r25, 0x00	; 0
+ 31c:	90 93 42 01 	sts	0x0142, r25
+ 320:	80 93 41 01 	sts	0x0141, r24
+ 324:	08 95       	ret
+
+00000326 <KeyPressed>:
+ 326:	80 91 41 01 	lds	r24, 0x0141
+ 32a:	90 91 42 01 	lds	r25, 0x0142
+ 32e:	89 2b       	or	r24, r25
+ 330:	a9 f1       	breq	.+106    	; 0x39c <KeyPressed+0x76>
+ 332:	1f 99       	sbic	0x03, 7	; 3
+ 334:	1d c0       	rjmp	.+58     	; 0x370 <KeyPressed+0x4a>
+ 336:	80 91 45 01 	lds	r24, 0x0145
+ 33a:	90 91 46 01 	lds	r25, 0x0146
+ 33e:	01 96       	adiw	r24, 0x01	; 1
+ 340:	90 93 46 01 	sts	0x0146, r25
+ 344:	80 93 45 01 	sts	0x0145, r24
+ 348:	80 52       	subi	r24, 0x20	; 32
+ 34a:	93 40       	sbci	r25, 0x03	; 3
+ 34c:	89 f4       	brne	.+34     	; 0x370 <KeyPressed+0x4a>
+ 34e:	8c e3       	ldi	r24, 0x3C	; 60
+ 350:	90 e0       	ldi	r25, 0x00	; 0
+ 352:	90 93 44 01 	sts	0x0144, r25
+ 356:	80 93 43 01 	sts	0x0143, r24
+ 35a:	81 e0       	ldi	r24, 0x01	; 1
+ 35c:	80 93 40 01 	sts	0x0140, r24
+ 360:	10 92 42 01 	sts	0x0142, r1
+ 364:	10 92 41 01 	sts	0x0141, r1
+ 368:	10 92 46 01 	sts	0x0146, r1
+ 36c:	10 92 45 01 	sts	0x0145, r1
+ 370:	80 91 45 01 	lds	r24, 0x0145
+ 374:	90 91 46 01 	lds	r25, 0x0146
+ 378:	89 55       	subi	r24, 0x59	; 89
+ 37a:	92 40       	sbci	r25, 0x02	; 2
+ 37c:	87 3c       	cpi	r24, 0xC7	; 199
+ 37e:	91 05       	cpc	r25, r1
+ 380:	68 f4       	brcc	.+26     	; 0x39c <KeyPressed+0x76>
+ 382:	80 91 36 01 	lds	r24, 0x0136
+ 386:	80 93 43 01 	sts	0x0143, r24
+ 38a:	10 92 44 01 	sts	0x0144, r1
+ 38e:	81 e0       	ldi	r24, 0x01	; 1
+ 390:	80 93 40 01 	sts	0x0140, r24
+ 394:	10 92 42 01 	sts	0x0142, r1
+ 398:	10 92 41 01 	sts	0x0141, r1
+ 39c:	08 95       	ret
+
+0000039e <Init>:
+ 39e:	10 92 6b 00 	sts	0x006B, r1
+ 3a2:	10 92 6d 00 	sts	0x006D, r1
+ 3a6:	10 92 6a 00 	sts	0x006A, r1
+ 3aa:	17 b8       	out	0x07, r1	; 7
+ 3ac:	18 b8       	out	0x08, r1	; 8
+ 3ae:	8a b1       	in	r24, 0x0a	; 10
+ 3b0:	8c 70       	andi	r24, 0x0C	; 12
+ 3b2:	8a b9       	out	0x0a, r24	; 10
+ 3b4:	8b b1       	in	r24, 0x0b	; 11
+ 3b6:	1b b8       	out	0x0b, r1	; 11
+ 3b8:	84 e0       	ldi	r24, 0x04	; 4
+ 3ba:	8d b9       	out	0x0d, r24	; 13
+ 3bc:	1e b8       	out	0x0e, r1	; 14
+ 3be:	10 92 80 00 	sts	0x0080, r1
+ 3c2:	10 92 81 00 	sts	0x0081, r1
+ 3c6:	10 92 82 00 	sts	0x0082, r1
+ 3ca:	81 e0       	ldi	r24, 0x01	; 1
+ 3cc:	84 b9       	out	0x04, r24	; 4
+ 3ce:	15 b8       	out	0x05, r1	; 5
+ 3d0:	08 95       	ret
+
+000003d2 <main>:
+ 3d2:	1f 93       	push	r17
+ 3d4:	e4 df       	rcall	.-56     	; 0x39e <Init>
+ 3d6:	e7 e5       	ldi	r30, 0x57	; 87
+ 3d8:	f1 e0       	ldi	r31, 0x01	; 1
+ 3da:	11 92       	st	Z+, r1
+ 3dc:	81 e0       	ldi	r24, 0x01	; 1
+ 3de:	ef 35       	cpi	r30, 0x5F	; 95
+ 3e0:	f8 07       	cpc	r31, r24
+ 3e2:	d9 f7       	brne	.-10     	; 0x3da <main+0x8>
+ 3e4:	2e e0       	ldi	r18, 0x0E	; 14
+ 3e6:	88 e1       	ldi	r24, 0x18	; 24
+ 3e8:	90 e0       	ldi	r25, 0x00	; 0
+ 3ea:	0f b6       	in	r0, 0x3f	; 63
+ 3ec:	f8 94       	cli
+ 3ee:	a8 95       	wdr
+ 3f0:	80 93 60 00 	sts	0x0060, r24
+ 3f4:	0f be       	out	0x3f, r0	; 63
+ 3f6:	20 93 60 00 	sts	0x0060, r18
+ 3fa:	3b d0       	rcall	.+118    	; 0x472 <usbInit>
+ 3fc:	53 9a       	sbi	0x0a, 3	; 10
+ 3fe:	20 e0       	ldi	r18, 0x00	; 0
+ 400:	40 e7       	ldi	r20, 0x70	; 112
+ 402:	57 e1       	ldi	r21, 0x17	; 23
+ 404:	a8 95       	wdr
+ 406:	ca 01       	movw	r24, r20
+ 408:	01 97       	sbiw	r24, 0x01	; 1
+ 40a:	f1 f7       	brne	.-4      	; 0x408 <main+0x36>
+ 40c:	2f 5f       	subi	r18, 0xFF	; 255
+ 40e:	2a 3f       	cpi	r18, 0xFA	; 250
+ 410:	c9 f7       	brne	.-14     	; 0x404 <main+0x32>
+ 412:	3c d0       	rcall	.+120    	; 0x48c <usbPoll>
+ 414:	53 98       	cbi	0x0a, 3	; 10
+ 416:	f8 94       	cli
+ 418:	83 e0       	ldi	r24, 0x03	; 3
+ 41a:	85 bd       	out	0x25, r24	; 37
+ 41c:	81 e0       	ldi	r24, 0x01	; 1
+ 41e:	80 93 6e 00 	sts	0x006E, r24
+ 422:	78 94       	sei
+ 424:	12 e0       	ldi	r17, 0x02	; 2
+ 426:	7f df       	rcall	.-258    	; 0x326 <KeyPressed>
+ 428:	69 df       	rcall	.-302    	; 0x2fc <OnKey>
+ 42a:	bc de       	rcall	.-648    	; 0x1a4 <scanMatrix>
+ 42c:	a8 95       	wdr
+ 42e:	2e d0       	rcall	.+92     	; 0x48c <usbPoll>
+ 430:	80 91 6c 01 	lds	r24, 0x016C
+ 434:	84 ff       	sbrs	r24, 4
+ 436:	18 c0       	rjmp	.+48     	; 0x468 <main+0x96>
+ 438:	80 91 40 01 	lds	r24, 0x0140
+ 43c:	88 23       	and	r24, r24
+ 43e:	a1 f0       	breq	.+40     	; 0x468 <main+0x96>
+ 440:	81 30       	cpi	r24, 0x01	; 1
+ 442:	19 f0       	breq	.+6      	; 0x44a <main+0x78>
+ 444:	82 30       	cpi	r24, 0x02	; 2
+ 446:	71 f4       	brne	.+28     	; 0x464 <main+0x92>
+ 448:	09 c0       	rjmp	.+18     	; 0x45c <main+0x8a>
+ 44a:	80 91 43 01 	lds	r24, 0x0143
+ 44e:	10 92 57 01 	sts	0x0157, r1
+ 452:	80 93 59 01 	sts	0x0159, r24
+ 456:	10 93 40 01 	sts	0x0140, r17
+ 45a:	06 c0       	rjmp	.+12     	; 0x468 <main+0x96>
+ 45c:	10 92 57 01 	sts	0x0157, r1
+ 460:	10 92 59 01 	sts	0x0159, r1
+ 464:	10 92 40 01 	sts	0x0140, r1
+ 468:	87 e5       	ldi	r24, 0x57	; 87
+ 46a:	91 e0       	ldi	r25, 0x01	; 1
+ 46c:	68 e0       	ldi	r22, 0x08	; 8
+ 46e:	33 d1       	rcall	.+614    	; 0x6d6 <usbSetInterrupt>
+ 470:	da cf       	rjmp	.-76     	; 0x426 <main+0x54>
+
+00000472 <usbInit>:
+ 472:	e9 e6       	ldi	r30, 0x69	; 105
+ 474:	f0 e0       	ldi	r31, 0x00	; 0
+ 476:	80 81       	ld	r24, Z
+ 478:	82 60       	ori	r24, 0x02	; 2
+ 47a:	80 83       	st	Z, r24
+ 47c:	e8 9a       	sbi	0x1d, 0	; 29
+ 47e:	8b e4       	ldi	r24, 0x4B	; 75
+ 480:	80 93 6d 01 	sts	0x016D, r24
+ 484:	8a e5       	ldi	r24, 0x5A	; 90
+ 486:	80 93 6c 01 	sts	0x016C, r24
+ 48a:	08 95       	ret
+
+0000048c <usbPoll>:
+ 48c:	1f 93       	push	r17
+ 48e:	cf 93       	push	r28
+ 490:	df 93       	push	r29
+ 492:	60 91 7d 01 	lds	r22, 0x017D
+ 496:	63 50       	subi	r22, 0x03	; 3
+ 498:	67 fd       	sbrc	r22, 7
+ 49a:	c2 c0       	rjmp	.+388    	; 0x620 <usbPoll+0x194>
+ 49c:	80 91 7a 01 	lds	r24, 0x017A
+ 4a0:	cc e0       	ldi	r28, 0x0C	; 12
+ 4a2:	d0 e0       	ldi	r29, 0x00	; 0
+ 4a4:	c8 1b       	sub	r28, r24
+ 4a6:	d1 09       	sbc	r29, r1
+ 4a8:	cf 57       	subi	r28, 0x7F	; 127
+ 4aa:	de 4f       	sbci	r29, 0xFE	; 254
+ 4ac:	80 91 79 01 	lds	r24, 0x0179
+ 4b0:	8d 32       	cpi	r24, 0x2D	; 45
+ 4b2:	09 f0       	breq	.+2      	; 0x4b6 <usbPoll+0x2a>
+ 4b4:	a3 c0       	rjmp	.+326    	; 0x5fc <usbPoll+0x170>
+ 4b6:	68 30       	cpi	r22, 0x08	; 8
+ 4b8:	09 f0       	breq	.+2      	; 0x4bc <usbPoll+0x30>
+ 4ba:	b0 c0       	rjmp	.+352    	; 0x61c <usbPoll+0x190>
+ 4bc:	83 ec       	ldi	r24, 0xC3	; 195
+ 4be:	80 93 61 01 	sts	0x0161, r24
+ 4c2:	8a e5       	ldi	r24, 0x5A	; 90
+ 4c4:	80 93 3e 01 	sts	0x013E, r24
+ 4c8:	10 92 60 01 	sts	0x0160, r1
+ 4cc:	88 81       	ld	r24, Y
+ 4ce:	80 76       	andi	r24, 0x60	; 96
+ 4d0:	39 f0       	breq	.+14     	; 0x4e0 <usbPoll+0x54>
+ 4d2:	ce 01       	movw	r24, r28
+ 4d4:	19 de       	rcall	.-974    	; 0x108 <usbFunctionSetup>
+ 4d6:	28 2f       	mov	r18, r24
+ 4d8:	8f 3f       	cpi	r24, 0xFF	; 255
+ 4da:	09 f4       	brne	.+2      	; 0x4de <usbPoll+0x52>
+ 4dc:	7e c0       	rjmp	.+252    	; 0x5da <usbPoll+0x14e>
+ 4de:	84 c0       	rjmp	.+264    	; 0x5e8 <usbPoll+0x15c>
+ 4e0:	9a 81       	ldd	r25, Y+2	; 0x02
+ 4e2:	10 92 6a 01 	sts	0x016A, r1
+ 4e6:	89 81       	ldd	r24, Y+1	; 0x01
+ 4e8:	88 23       	and	r24, r24
+ 4ea:	21 f4       	brne	.+8      	; 0x4f4 <usbPoll+0x68>
+ 4ec:	10 92 6b 01 	sts	0x016B, r1
+ 4f0:	22 e0       	ldi	r18, 0x02	; 2
+ 4f2:	6c c0       	rjmp	.+216    	; 0x5cc <usbPoll+0x140>
+ 4f4:	85 30       	cpi	r24, 0x05	; 5
+ 4f6:	19 f4       	brne	.+6      	; 0x4fe <usbPoll+0x72>
+ 4f8:	90 93 7e 01 	sts	0x017E, r25
+ 4fc:	66 c0       	rjmp	.+204    	; 0x5ca <usbPoll+0x13e>
+ 4fe:	86 30       	cpi	r24, 0x06	; 6
+ 500:	09 f0       	breq	.+2      	; 0x504 <usbPoll+0x78>
+ 502:	4f c0       	rjmp	.+158    	; 0x5a2 <usbPoll+0x116>
+ 504:	8b 81       	ldd	r24, Y+3	; 0x03
+ 506:	81 30       	cpi	r24, 0x01	; 1
+ 508:	41 f4       	brne	.+16     	; 0x51a <usbPoll+0x8e>
+ 50a:	8b e9       	ldi	r24, 0x9B	; 155
+ 50c:	90 e0       	ldi	r25, 0x00	; 0
+ 50e:	90 93 7c 01 	sts	0x017C, r25
+ 512:	80 93 7b 01 	sts	0x017B, r24
+ 516:	22 e1       	ldi	r18, 0x12	; 18
+ 518:	40 c0       	rjmp	.+128    	; 0x59a <usbPoll+0x10e>
+ 51a:	82 30       	cpi	r24, 0x02	; 2
+ 51c:	41 f4       	brne	.+16     	; 0x52e <usbPoll+0xa2>
+ 51e:	8d ea       	ldi	r24, 0xAD	; 173
+ 520:	90 e0       	ldi	r25, 0x00	; 0
+ 522:	90 93 7c 01 	sts	0x017C, r25
+ 526:	80 93 7b 01 	sts	0x017B, r24
+ 52a:	22 e2       	ldi	r18, 0x22	; 34
+ 52c:	36 c0       	rjmp	.+108    	; 0x59a <usbPoll+0x10e>
+ 52e:	83 30       	cpi	r24, 0x03	; 3
+ 530:	f9 f4       	brne	.+62     	; 0x570 <usbPoll+0xe4>
+ 532:	8a 81       	ldd	r24, Y+2	; 0x02
+ 534:	88 23       	and	r24, r24
+ 536:	41 f4       	brne	.+16     	; 0x548 <usbPoll+0xbc>
+ 538:	87 e6       	ldi	r24, 0x67	; 103
+ 53a:	90 e0       	ldi	r25, 0x00	; 0
+ 53c:	90 93 7c 01 	sts	0x017C, r25
+ 540:	80 93 7b 01 	sts	0x017B, r24
+ 544:	24 e0       	ldi	r18, 0x04	; 4
+ 546:	29 c0       	rjmp	.+82     	; 0x59a <usbPoll+0x10e>
+ 548:	81 30       	cpi	r24, 0x01	; 1
+ 54a:	41 f4       	brne	.+16     	; 0x55c <usbPoll+0xd0>
+ 54c:	8b e6       	ldi	r24, 0x6B	; 107
+ 54e:	90 e0       	ldi	r25, 0x00	; 0
+ 550:	90 93 7c 01 	sts	0x017C, r25
+ 554:	80 93 7b 01 	sts	0x017B, r24
+ 558:	20 e2       	ldi	r18, 0x20	; 32
+ 55a:	1f c0       	rjmp	.+62     	; 0x59a <usbPoll+0x10e>
+ 55c:	82 30       	cpi	r24, 0x02	; 2
+ 55e:	e1 f4       	brne	.+56     	; 0x598 <usbPoll+0x10c>
+ 560:	8b e8       	ldi	r24, 0x8B	; 139
+ 562:	90 e0       	ldi	r25, 0x00	; 0
+ 564:	90 93 7c 01 	sts	0x017C, r25
+ 568:	80 93 7b 01 	sts	0x017B, r24
+ 56c:	20 e1       	ldi	r18, 0x10	; 16
+ 56e:	15 c0       	rjmp	.+42     	; 0x59a <usbPoll+0x10e>
+ 570:	81 32       	cpi	r24, 0x21	; 33
+ 572:	41 f4       	brne	.+16     	; 0x584 <usbPoll+0xf8>
+ 574:	8f eb       	ldi	r24, 0xBF	; 191
+ 576:	90 e0       	ldi	r25, 0x00	; 0
+ 578:	90 93 7c 01 	sts	0x017C, r25
+ 57c:	80 93 7b 01 	sts	0x017B, r24
+ 580:	29 e0       	ldi	r18, 0x09	; 9
+ 582:	0b c0       	rjmp	.+22     	; 0x59a <usbPoll+0x10e>
+ 584:	82 32       	cpi	r24, 0x22	; 34
+ 586:	41 f4       	brne	.+16     	; 0x598 <usbPoll+0x10c>
+ 588:	88 e2       	ldi	r24, 0x28	; 40
+ 58a:	90 e0       	ldi	r25, 0x00	; 0
+ 58c:	90 93 7c 01 	sts	0x017C, r25
+ 590:	80 93 7b 01 	sts	0x017B, r24
+ 594:	2f e3       	ldi	r18, 0x3F	; 63
+ 596:	01 c0       	rjmp	.+2      	; 0x59a <usbPoll+0x10e>
+ 598:	20 e0       	ldi	r18, 0x00	; 0
+ 59a:	80 e4       	ldi	r24, 0x40	; 64
+ 59c:	80 93 60 01 	sts	0x0160, r24
+ 5a0:	23 c0       	rjmp	.+70     	; 0x5e8 <usbPoll+0x15c>
+ 5a2:	88 30       	cpi	r24, 0x08	; 8
+ 5a4:	21 f4       	brne	.+8      	; 0x5ae <usbPoll+0x122>
+ 5a6:	21 e0       	ldi	r18, 0x01	; 1
+ 5a8:	80 e8       	ldi	r24, 0x80	; 128
+ 5aa:	91 e0       	ldi	r25, 0x01	; 1
+ 5ac:	11 c0       	rjmp	.+34     	; 0x5d0 <usbPoll+0x144>
+ 5ae:	89 30       	cpi	r24, 0x09	; 9
+ 5b0:	19 f4       	brne	.+6      	; 0x5b8 <usbPoll+0x12c>
+ 5b2:	90 93 80 01 	sts	0x0180, r25
+ 5b6:	09 c0       	rjmp	.+18     	; 0x5ca <usbPoll+0x13e>
+ 5b8:	8a 30       	cpi	r24, 0x0A	; 10
+ 5ba:	11 f4       	brne	.+4      	; 0x5c0 <usbPoll+0x134>
+ 5bc:	21 e0       	ldi	r18, 0x01	; 1
+ 5be:	06 c0       	rjmp	.+12     	; 0x5cc <usbPoll+0x140>
+ 5c0:	8b 30       	cpi	r24, 0x0B	; 11
+ 5c2:	19 f4       	brne	.+6      	; 0x5ca <usbPoll+0x13e>
+ 5c4:	8b e4       	ldi	r24, 0x4B	; 75
+ 5c6:	80 93 6d 01 	sts	0x016D, r24
+ 5ca:	20 e0       	ldi	r18, 0x00	; 0
+ 5cc:	8a e6       	ldi	r24, 0x6A	; 106
+ 5ce:	91 e0       	ldi	r25, 0x01	; 1
+ 5d0:	90 93 7c 01 	sts	0x017C, r25
+ 5d4:	80 93 7b 01 	sts	0x017B, r24
+ 5d8:	07 c0       	rjmp	.+14     	; 0x5e8 <usbPoll+0x15c>
+ 5da:	88 81       	ld	r24, Y
+ 5dc:	87 fd       	sbrc	r24, 7
+ 5de:	2e 81       	ldd	r18, Y+6	; 0x06
+ 5e0:	80 e8       	ldi	r24, 0x80	; 128
+ 5e2:	80 93 60 01 	sts	0x0160, r24
+ 5e6:	06 c0       	rjmp	.+12     	; 0x5f4 <usbPoll+0x168>
+ 5e8:	8f 81       	ldd	r24, Y+7	; 0x07
+ 5ea:	88 23       	and	r24, r24
+ 5ec:	19 f4       	brne	.+6      	; 0x5f4 <usbPoll+0x168>
+ 5ee:	8e 81       	ldd	r24, Y+6	; 0x06
+ 5f0:	82 17       	cp	r24, r18
+ 5f2:	08 f0       	brcs	.+2      	; 0x5f6 <usbPoll+0x16a>
+ 5f4:	82 2f       	mov	r24, r18
+ 5f6:	80 93 3f 01 	sts	0x013F, r24
+ 5fa:	10 c0       	rjmp	.+32     	; 0x61c <usbPoll+0x190>
+ 5fc:	80 91 60 01 	lds	r24, 0x0160
+ 600:	87 ff       	sbrs	r24, 7
+ 602:	0c c0       	rjmp	.+24     	; 0x61c <usbPoll+0x190>
+ 604:	ce 01       	movw	r24, r28
+ 606:	b3 dd       	rcall	.-1178   	; 0x16e <usbFunctionWrite>
+ 608:	8f 3f       	cpi	r24, 0xFF	; 255
+ 60a:	21 f4       	brne	.+8      	; 0x614 <usbPoll+0x188>
+ 60c:	8e e1       	ldi	r24, 0x1E	; 30
+ 60e:	80 93 3e 01 	sts	0x013E, r24
+ 612:	04 c0       	rjmp	.+8      	; 0x61c <usbPoll+0x190>
+ 614:	88 23       	and	r24, r24
+ 616:	11 f0       	breq	.+4      	; 0x61c <usbPoll+0x190>
+ 618:	10 92 3f 01 	sts	0x013F, r1
+ 61c:	10 92 7d 01 	sts	0x017D, r1
+ 620:	80 91 3e 01 	lds	r24, 0x013E
+ 624:	84 ff       	sbrs	r24, 4
+ 626:	49 c0       	rjmp	.+146    	; 0x6ba <usbPoll+0x22e>
+ 628:	80 91 3f 01 	lds	r24, 0x013F
+ 62c:	8f 3f       	cpi	r24, 0xFF	; 255
+ 62e:	09 f4       	brne	.+2      	; 0x632 <usbPoll+0x1a6>
+ 630:	44 c0       	rjmp	.+136    	; 0x6ba <usbPoll+0x22e>
+ 632:	18 2f       	mov	r17, r24
+ 634:	89 30       	cpi	r24, 0x09	; 9
+ 636:	08 f0       	brcs	.+2      	; 0x63a <usbPoll+0x1ae>
+ 638:	18 e0       	ldi	r17, 0x08	; 8
+ 63a:	81 1b       	sub	r24, r17
+ 63c:	80 93 3f 01 	sts	0x013F, r24
+ 640:	80 91 61 01 	lds	r24, 0x0161
+ 644:	98 e8       	ldi	r25, 0x88	; 136
+ 646:	89 27       	eor	r24, r25
+ 648:	80 93 61 01 	sts	0x0161, r24
+ 64c:	11 23       	and	r17, r17
+ 64e:	41 f1       	breq	.+80     	; 0x6a0 <usbPoll+0x214>
+ 650:	20 91 7b 01 	lds	r18, 0x017B
+ 654:	30 91 7c 01 	lds	r19, 0x017C
+ 658:	80 91 60 01 	lds	r24, 0x0160
+ 65c:	86 ff       	sbrs	r24, 6
+ 65e:	0d c0       	rjmp	.+26     	; 0x67a <usbPoll+0x1ee>
+ 660:	a2 e6       	ldi	r26, 0x62	; 98
+ 662:	b1 e0       	ldi	r27, 0x01	; 1
+ 664:	80 e0       	ldi	r24, 0x00	; 0
+ 666:	90 e0       	ldi	r25, 0x00	; 0
+ 668:	f9 01       	movw	r30, r18
+ 66a:	e8 0f       	add	r30, r24
+ 66c:	f9 1f       	adc	r31, r25
+ 66e:	e4 91       	lpm	r30, Z+
+ 670:	ed 93       	st	X+, r30
+ 672:	01 96       	adiw	r24, 0x01	; 1
+ 674:	18 17       	cp	r17, r24
+ 676:	c1 f7       	brne	.-16     	; 0x668 <usbPoll+0x1dc>
+ 678:	08 c0       	rjmp	.+16     	; 0x68a <usbPoll+0x1fe>
+ 67a:	91 2f       	mov	r25, r17
+ 67c:	d9 01       	movw	r26, r18
+ 67e:	e2 e6       	ldi	r30, 0x62	; 98
+ 680:	f1 e0       	ldi	r31, 0x01	; 1
+ 682:	8d 91       	ld	r24, X+
+ 684:	81 93       	st	Z+, r24
+ 686:	91 50       	subi	r25, 0x01	; 1
+ 688:	e1 f7       	brne	.-8      	; 0x682 <usbPoll+0x1f6>
+ 68a:	11 50       	subi	r17, 0x01	; 1
+ 68c:	81 2f       	mov	r24, r17
+ 68e:	90 e0       	ldi	r25, 0x00	; 0
+ 690:	1f 5f       	subi	r17, 0xFF	; 255
+ 692:	01 96       	adiw	r24, 0x01	; 1
+ 694:	82 0f       	add	r24, r18
+ 696:	93 1f       	adc	r25, r19
+ 698:	90 93 7c 01 	sts	0x017C, r25
+ 69c:	80 93 7b 01 	sts	0x017B, r24
+ 6a0:	82 e6       	ldi	r24, 0x62	; 98
+ 6a2:	91 e0       	ldi	r25, 0x01	; 1
+ 6a4:	61 2f       	mov	r22, r17
+ 6a6:	4e d0       	rcall	.+156    	; 0x744 <usbCrc16Append>
+ 6a8:	61 2f       	mov	r22, r17
+ 6aa:	6c 5f       	subi	r22, 0xFC	; 252
+ 6ac:	6c 30       	cpi	r22, 0x0C	; 12
+ 6ae:	19 f0       	breq	.+6      	; 0x6b6 <usbPoll+0x22a>
+ 6b0:	8f ef       	ldi	r24, 0xFF	; 255
+ 6b2:	80 93 3f 01 	sts	0x013F, r24
+ 6b6:	60 93 3e 01 	sts	0x013E, r22
+ 6ba:	94 e1       	ldi	r25, 0x14	; 20
+ 6bc:	89 b1       	in	r24, 0x09	; 9
+ 6be:	8c 70       	andi	r24, 0x0C	; 12
+ 6c0:	31 f4       	brne	.+12     	; 0x6ce <usbPoll+0x242>
+ 6c2:	91 50       	subi	r25, 0x01	; 1
+ 6c4:	d9 f7       	brne	.-10     	; 0x6bc <usbPoll+0x230>
+ 6c6:	10 92 7e 01 	sts	0x017E, r1
+ 6ca:	10 92 78 01 	sts	0x0178, r1
+ 6ce:	df 91       	pop	r29
+ 6d0:	cf 91       	pop	r28
+ 6d2:	1f 91       	pop	r17
+ 6d4:	08 95       	ret
+
+000006d6 <usbSetInterrupt>:
+ 6d6:	1f 93       	push	r17
+ 6d8:	dc 01       	movw	r26, r24
+ 6da:	16 2f       	mov	r17, r22
+ 6dc:	80 91 6c 01 	lds	r24, 0x016C
+ 6e0:	84 ff       	sbrs	r24, 4
+ 6e2:	07 c0       	rjmp	.+14     	; 0x6f2 <usbSetInterrupt+0x1c>
+ 6e4:	80 91 6d 01 	lds	r24, 0x016D
+ 6e8:	98 e8       	ldi	r25, 0x88	; 136
+ 6ea:	89 27       	eor	r24, r25
+ 6ec:	80 93 6d 01 	sts	0x016D, r24
+ 6f0:	03 c0       	rjmp	.+6      	; 0x6f8 <usbSetInterrupt+0x22>
+ 6f2:	8a e5       	ldi	r24, 0x5A	; 90
+ 6f4:	80 93 6c 01 	sts	0x016C, r24
+ 6f8:	91 2f       	mov	r25, r17
+ 6fa:	ee e6       	ldi	r30, 0x6E	; 110
+ 6fc:	f1 e0       	ldi	r31, 0x01	; 1
+ 6fe:	8d 91       	ld	r24, X+
+ 700:	81 93       	st	Z+, r24
+ 702:	91 50       	subi	r25, 0x01	; 1
+ 704:	19 16       	cp	r1, r25
+ 706:	dc f3       	brlt	.-10     	; 0x6fe <usbSetInterrupt+0x28>
+ 708:	8e e6       	ldi	r24, 0x6E	; 110
+ 70a:	91 e0       	ldi	r25, 0x01	; 1
+ 70c:	61 2f       	mov	r22, r17
+ 70e:	1a d0       	rcall	.+52     	; 0x744 <usbCrc16Append>
+ 710:	1c 5f       	subi	r17, 0xFC	; 252
+ 712:	10 93 6c 01 	sts	0x016C, r17
+ 716:	1f 91       	pop	r17
+ 718:	08 95       	ret
+
+0000071a <usbCrc16>:
+ 71a:	a8 2f       	mov	r26, r24
+ 71c:	b9 2f       	mov	r27, r25
+ 71e:	80 e0       	ldi	r24, 0x00	; 0
+ 720:	90 e0       	ldi	r25, 0x00	; 0
+ 722:	41 e0       	ldi	r20, 0x01	; 1
+ 724:	50 ea       	ldi	r21, 0xA0	; 160
+ 726:	60 95       	com	r22
+ 728:	30 e0       	ldi	r19, 0x00	; 0
+ 72a:	09 c0       	rjmp	.+18     	; 0x73e <usbCrcLoopEntry>
+
+0000072c <usbCrcByteLoop>:
+ 72c:	2d 91       	ld	r18, X+
+ 72e:	82 27       	eor	r24, r18
+
+00000730 <usbCrcBitLoop>:
+ 730:	97 95       	ror	r25
+ 732:	87 95       	ror	r24
+ 734:	10 f0       	brcs	.+4      	; 0x73a <usbCrcNoXor>
+ 736:	84 27       	eor	r24, r20
+ 738:	95 27       	eor	r25, r21
+
+0000073a <usbCrcNoXor>:
+ 73a:	30 5e       	subi	r19, 0xE0	; 224
+ 73c:	c8 f3       	brcs	.-14     	; 0x730 <usbCrcBitLoop>
+
+0000073e <usbCrcLoopEntry>:
+ 73e:	6f 5f       	subi	r22, 0xFF	; 255
+ 740:	a8 f3       	brcs	.-22     	; 0x72c <usbCrcByteLoop>
+
+00000742 <usbCrcReady>:
+ 742:	08 95       	ret
+
+00000744 <usbCrc16Append>:
+ 744:	ea df       	rcall	.-44     	; 0x71a <usbCrc16>
+ 746:	8d 93       	st	X+, r24
+ 748:	9d 93       	st	X+, r25
+ 74a:	08 95       	ret
+
+0000074c <__vector_1>:
+ 74c:	cf 93       	push	r28
+ 74e:	cf b7       	in	r28, 0x3f	; 63
+ 750:	cf 93       	push	r28
+
+00000752 <waitForJ>:
+ 752:	c3 95       	inc	r28
+ 754:	4b 9b       	sbis	0x09, 3	; 9
+ 756:	e9 f7       	brne	.-6      	; 0x752 <waitForJ>
+
+00000758 <waitForK>:
+ 758:	4b 9b       	sbis	0x09, 3	; 9
+ 75a:	09 c0       	rjmp	.+18     	; 0x76e <foundK>
+ 75c:	4b 9b       	sbis	0x09, 3	; 9
+ 75e:	07 c0       	rjmp	.+14     	; 0x76e <foundK>
+ 760:	4b 9b       	sbis	0x09, 3	; 9
+ 762:	05 c0       	rjmp	.+10     	; 0x76e <foundK>
+ 764:	4b 9b       	sbis	0x09, 3	; 9
+ 766:	03 c0       	rjmp	.+6      	; 0x76e <foundK>
+ 768:	4b 9b       	sbis	0x09, 3	; 9
+ 76a:	01 c0       	rjmp	.+2      	; 0x76e <foundK>
+ 76c:	a3 c0       	rjmp	.+326    	; 0x8b4 <sofError>
+
+0000076e <foundK>:
+ 76e:	df 93       	push	r29
+ 770:	c0 91 7a 01 	lds	r28, 0x017A
+ 774:	dd 27       	eor	r29, r29
+ 776:	cf 57       	subi	r28, 0x7F	; 127
+ 778:	de 4f       	sbci	r29, 0xFE	; 254
+ 77a:	4b 9b       	sbis	0x09, 3	; 9
+ 77c:	02 c0       	rjmp	.+4      	; 0x782 <haveTwoBitsK>
+ 77e:	df 91       	pop	r29
+ 780:	eb cf       	rjmp	.-42     	; 0x758 <waitForK>
+
+00000782 <haveTwoBitsK>:
+ 782:	2f 93       	push	r18
+ 784:	0f 93       	push	r16
+ 786:	1f 93       	push	r17
+ 788:	09 b1       	in	r16, 0x09	; 9
+ 78a:	2f ef       	ldi	r18, 0xFF	; 255
+ 78c:	03 fb       	bst	r16, 3
+ 78e:	20 f9       	bld	r18, 0
+ 790:	4f 93       	push	r20
+ 792:	3f 93       	push	r19
+ 794:	19 b1       	in	r17, 0x09	; 9
+ 796:	4f ef       	ldi	r20, 0xFF	; 255
+ 798:	01 27       	eor	r16, r17
+ 79a:	03 fb       	bst	r16, 3
+ 79c:	21 f9       	bld	r18, 1
+ 79e:	3b e0       	ldi	r19, 0x0B	; 11
+ 7a0:	31 c0       	rjmp	.+98     	; 0x804 <rxbit2>
+
+000007a2 <unstuff0>:
+ 7a2:	4e 7f       	andi	r20, 0xFE	; 254
+ 7a4:	01 2f       	mov	r16, r17
+ 7a6:	19 b1       	in	r17, 0x09	; 9
+ 7a8:	21 60       	ori	r18, 0x01	; 1
+ 7aa:	28 c0       	rjmp	.+80     	; 0x7fc <didUnstuff0>
+
+000007ac <unstuff1>:
+ 7ac:	10 2f       	mov	r17, r16
+ 7ae:	4d 7f       	andi	r20, 0xFD	; 253
+ 7b0:	22 60       	ori	r18, 0x02	; 2
+ 7b2:	00 00       	nop
+ 7b4:	09 b1       	in	r16, 0x09	; 9
+ 7b6:	29 c0       	rjmp	.+82     	; 0x80a <didUnstuff1>
+
+000007b8 <unstuff2>:
+ 7b8:	4b 7f       	andi	r20, 0xFB	; 251
+ 7ba:	24 60       	ori	r18, 0x04	; 4
+ 7bc:	01 2f       	mov	r16, r17
+ 7be:	00 00       	nop
+ 7c0:	19 b1       	in	r17, 0x09	; 9
+ 7c2:	2b c0       	rjmp	.+86     	; 0x81a <didUnstuff2>
+
+000007c4 <unstuff3>:
+ 7c4:	19 b1       	in	r17, 0x09	; 9
+ 7c6:	47 7f       	andi	r20, 0xF7	; 247
+ 7c8:	28 60       	ori	r18, 0x08	; 8
+ 7ca:	2a c0       	rjmp	.+84     	; 0x820 <didUnstuff3>
+
+000007cc <unstuff4>:
+ 7cc:	4f 7e       	andi	r20, 0xEF	; 239
+ 7ce:	09 b1       	in	r16, 0x09	; 9
+ 7d0:	20 61       	ori	r18, 0x10	; 16
+ 7d2:	2c c0       	rjmp	.+88     	; 0x82c <didUnstuff4>
+
+000007d4 <unstuff5>:
+ 7d4:	4f 7d       	andi	r20, 0xDF	; 223
+ 7d6:	19 b1       	in	r17, 0x09	; 9
+ 7d8:	20 62       	ori	r18, 0x20	; 32
+ 7da:	2f c0       	rjmp	.+94     	; 0x83a <didUnstuff5>
+
+000007dc <unstuff6>:
+ 7dc:	4f 7b       	andi	r20, 0xBF	; 191
+ 7de:	09 b1       	in	r16, 0x09	; 9
+ 7e0:	20 64       	ori	r18, 0x40	; 64
+ 7e2:	32 c0       	rjmp	.+100    	; 0x848 <didUnstuff6>
+
+000007e4 <rxLoop>:
+ 7e4:	42 27       	eor	r20, r18
+ 7e6:	09 b1       	in	r16, 0x09	; 9
+ 7e8:	49 93       	st	Y+, r20
+ 7ea:	4f ef       	ldi	r20, 0xFF	; 255
+ 7ec:	00 00       	nop
+ 7ee:	10 27       	eor	r17, r16
+ 7f0:	13 fb       	bst	r17, 3
+ 7f2:	20 f9       	bld	r18, 0
+ 7f4:	19 b1       	in	r17, 0x09	; 9
+ 7f6:	1c 70       	andi	r17, 0x0C	; 12
+ 7f8:	c9 f1       	breq	.+114    	; 0x86c <se0>
+ 7fa:	29 7f       	andi	r18, 0xF9	; 249
+
+000007fc <didUnstuff0>:
+ 7fc:	91 f2       	breq	.-92     	; 0x7a2 <unstuff0>
+ 7fe:	01 27       	eor	r16, r17
+ 800:	03 fb       	bst	r16, 3
+ 802:	21 f9       	bld	r18, 1
+
+00000804 <rxbit2>:
+ 804:	09 b1       	in	r16, 0x09	; 9
+ 806:	23 7f       	andi	r18, 0xF3	; 243
+ 808:	89 f2       	breq	.-94     	; 0x7ac <unstuff1>
+
+0000080a <didUnstuff1>:
+ 80a:	31 50       	subi	r19, 0x01	; 1
+ 80c:	58 f1       	brcs	.+86     	; 0x864 <overflow>
+ 80e:	10 27       	eor	r17, r16
+ 810:	13 fb       	bst	r17, 3
+ 812:	22 f9       	bld	r18, 2
+ 814:	19 b1       	in	r17, 0x09	; 9
+ 816:	27 7e       	andi	r18, 0xE7	; 231
+ 818:	79 f2       	breq	.-98     	; 0x7b8 <unstuff2>
+
+0000081a <didUnstuff2>:
+ 81a:	01 27       	eor	r16, r17
+ 81c:	03 fb       	bst	r16, 3
+ 81e:	23 f9       	bld	r18, 3
+
+00000820 <didUnstuff3>:
+ 820:	2f 7c       	andi	r18, 0xCF	; 207
+ 822:	81 f2       	breq	.-96     	; 0x7c4 <unstuff3>
+ 824:	09 b1       	in	r16, 0x09	; 9
+ 826:	10 27       	eor	r17, r16
+ 828:	13 fb       	bst	r17, 3
+ 82a:	24 f9       	bld	r18, 4
+
+0000082c <didUnstuff4>:
+ 82c:	2f 79       	andi	r18, 0x9F	; 159
+ 82e:	71 f2       	breq	.-100    	; 0x7cc <unstuff4>
+ 830:	00 c0       	rjmp	.+0      	; 0x832 <didUnstuff4+0x6>
+ 832:	19 b1       	in	r17, 0x09	; 9
+ 834:	01 27       	eor	r16, r17
+ 836:	03 fb       	bst	r16, 3
+ 838:	25 f9       	bld	r18, 5
+
+0000083a <didUnstuff5>:
+ 83a:	2f 73       	andi	r18, 0x3F	; 63
+ 83c:	59 f2       	breq	.-106    	; 0x7d4 <unstuff5>
+ 83e:	00 c0       	rjmp	.+0      	; 0x840 <didUnstuff5+0x6>
+ 840:	09 b1       	in	r16, 0x09	; 9
+ 842:	10 27       	eor	r17, r16
+ 844:	13 fb       	bst	r17, 3
+ 846:	26 f9       	bld	r18, 6
+
+00000848 <didUnstuff6>:
+ 848:	22 30       	cpi	r18, 0x02	; 2
+ 84a:	40 f2       	brcs	.-112    	; 0x7dc <unstuff6>
+ 84c:	00 c0       	rjmp	.+0      	; 0x84e <didUnstuff6+0x6>
+ 84e:	19 b1       	in	r17, 0x09	; 9
+ 850:	01 27       	eor	r16, r17
+ 852:	03 fb       	bst	r16, 3
+ 854:	27 f9       	bld	r18, 7
+
+00000856 <didUnstuff7>:
+ 856:	24 30       	cpi	r18, 0x04	; 4
+ 858:	28 f6       	brcc	.-118    	; 0x7e4 <rxLoop>
+
+0000085a <unstuff7>:
+ 85a:	4f 77       	andi	r20, 0x7F	; 127
+ 85c:	20 68       	ori	r18, 0x80	; 128
+ 85e:	19 b1       	in	r17, 0x09	; 9
+ 860:	00 00       	nop
+ 862:	f9 cf       	rjmp	.-14     	; 0x856 <didUnstuff7>
+
+00000864 <overflow>:
+ 864:	11 e0       	ldi	r17, 0x01	; 1
+ 866:	1c bb       	out	0x1c, r17	; 28
+
+00000868 <ignorePacket>:
+ 868:	00 27       	eor	r16, r16
+ 86a:	19 c0       	rjmp	.+50     	; 0x89e <handleSetupOrOut>
+
+0000086c <se0>:
+ 86c:	3b 50       	subi	r19, 0x0B	; 11
+ 86e:	31 95       	neg	r19
+ 870:	c3 1b       	sub	r28, r19
+ 872:	d0 40       	sbci	r29, 0x00	; 0
+ 874:	11 e0       	ldi	r17, 0x01	; 1
+ 876:	1c bb       	out	0x1c, r17	; 28
+ 878:	08 81       	ld	r16, Y
+ 87a:	03 3c       	cpi	r16, 0xC3	; 195
+ 87c:	f9 f0       	breq	.+62     	; 0x8bc <handleData>
+ 87e:	0b 34       	cpi	r16, 0x4B	; 75
+ 880:	e9 f0       	breq	.+58     	; 0x8bc <handleData>
+ 882:	20 91 78 01 	lds	r18, 0x0178
+ 886:	19 81       	ldd	r17, Y+1	; 0x01
+ 888:	11 0f       	add	r17, r17
+ 88a:	12 13       	cpse	r17, r18
+ 88c:	ed cf       	rjmp	.-38     	; 0x868 <ignorePacket>
+ 88e:	4a 81       	ldd	r20, Y+2	; 0x02
+ 890:	44 1f       	adc	r20, r20
+ 892:	09 36       	cpi	r16, 0x69	; 105
+ 894:	41 f1       	breq	.+80     	; 0x8e6 <handleIn>
+ 896:	0d 32       	cpi	r16, 0x2D	; 45
+ 898:	11 f0       	breq	.+4      	; 0x89e <handleSetupOrOut>
+ 89a:	01 3e       	cpi	r16, 0xE1	; 225
+ 89c:	29 f7       	brne	.-54     	; 0x868 <ignorePacket>
+
+0000089e <handleSetupOrOut>:
+ 89e:	00 93 7f 01 	sts	0x017F, r16
+
+000008a2 <doReturn>:
+ 8a2:	3f 91       	pop	r19
+ 8a4:	4f 91       	pop	r20
+ 8a6:	1f 91       	pop	r17
+ 8a8:	0f 91       	pop	r16
+ 8aa:	2f 91       	pop	r18
+ 8ac:	df 91       	pop	r29
+ 8ae:	cc b3       	in	r28, 0x1c	; 28
+ 8b0:	c0 fd       	sbrc	r28, 0
+ 8b2:	4f cf       	rjmp	.-354    	; 0x752 <waitForJ>
+
+000008b4 <sofError>:
+ 8b4:	cf 91       	pop	r28
+ 8b6:	cf bf       	out	0x3f, r28	; 63
+ 8b8:	cf 91       	pop	r28
+ 8ba:	18 95       	reti
+
+000008bc <handleData>:
+ 8bc:	20 91 7f 01 	lds	r18, 0x017F
+ 8c0:	22 23       	and	r18, r18
+ 8c2:	79 f3       	breq	.-34     	; 0x8a2 <doReturn>
+ 8c4:	10 91 7d 01 	lds	r17, 0x017D
+ 8c8:	11 23       	and	r17, r17
+ 8ca:	69 f5       	brne	.+90     	; 0x926 <sendNakAndReti>
+ 8cc:	34 30       	cpi	r19, 0x04	; 4
+ 8ce:	6a f1       	brmi	.+90     	; 0x92a <sendAckAndReti>
+ 8d0:	30 93 7d 01 	sts	0x017D, r19
+ 8d4:	20 93 79 01 	sts	0x0179, r18
+ 8d8:	10 91 7a 01 	lds	r17, 0x017A
+ 8dc:	3b e0       	ldi	r19, 0x0B	; 11
+ 8de:	31 1b       	sub	r19, r17
+ 8e0:	30 93 7a 01 	sts	0x017A, r19
+ 8e4:	22 c0       	rjmp	.+68     	; 0x92a <sendAckAndReti>
+
+000008e6 <handleIn>:
+ 8e6:	00 91 7d 01 	lds	r16, 0x017D
+ 8ea:	01 30       	cpi	r16, 0x01	; 1
+ 8ec:	e4 f4       	brge	.+56     	; 0x926 <sendNakAndReti>
+ 8ee:	0a e5       	ldi	r16, 0x5A	; 90
+ 8f0:	4f 70       	andi	r20, 0x0F	; 15
+ 8f2:	49 f4       	brne	.+18     	; 0x906 <handleIn1>
+ 8f4:	30 91 3e 01 	lds	r19, 0x013E
+ 8f8:	34 fd       	sbrc	r19, 4
+ 8fa:	19 c0       	rjmp	.+50     	; 0x92e <sendCntAndReti>
+ 8fc:	00 93 3e 01 	sts	0x013E, r16
+ 900:	c1 e6       	ldi	r28, 0x61	; 97
+ 902:	d1 e0       	ldi	r29, 0x01	; 1
+ 904:	18 c0       	rjmp	.+48     	; 0x936 <usbSendAndReti>
+
+00000906 <handleIn1>:
+ 906:	30 91 6c 01 	lds	r19, 0x016C
+ 90a:	34 fd       	sbrc	r19, 4
+ 90c:	10 c0       	rjmp	.+32     	; 0x92e <sendCntAndReti>
+ 90e:	00 93 6c 01 	sts	0x016C, r16
+ 912:	cd e6       	ldi	r28, 0x6D	; 109
+ 914:	d1 e0       	ldi	r29, 0x01	; 1
+ 916:	0f c0       	rjmp	.+30     	; 0x936 <usbSendAndReti>
+
+00000918 <stuffN1Delay>:
+ 918:	27 95       	ror	r18
+ 91a:	a8 f4       	brcc	.+42     	; 0x946 <doExorN1>
+ 91c:	51 50       	subi	r21, 0x01	; 1
+ 91e:	a9 f4       	brne	.+42     	; 0x94a <commonN1>
+ 920:	22 0f       	add	r18, r18
+ 922:	00 00       	nop
+ 924:	f9 cf       	rjmp	.-14     	; 0x918 <stuffN1Delay>
+
+00000926 <sendNakAndReti>:
+ 926:	4a e5       	ldi	r20, 0x5A	; 90
+ 928:	03 c0       	rjmp	.+6      	; 0x930 <usbSendX3>
+
+0000092a <sendAckAndReti>:
+ 92a:	42 ed       	ldi	r20, 0xD2	; 210
+ 92c:	01 c0       	rjmp	.+2      	; 0x930 <usbSendX3>
+
+0000092e <sendCntAndReti>:
+ 92e:	43 2f       	mov	r20, r19
+
+00000930 <usbSendX3>:
+ 930:	c4 e1       	ldi	r28, 0x14	; 20
+ 932:	d0 e0       	ldi	r29, 0x00	; 0
+ 934:	32 e0       	ldi	r19, 0x02	; 2
+
+00000936 <usbSendAndReti>:
+ 936:	1a b1       	in	r17, 0x0a	; 10
+ 938:	1c 60       	ori	r17, 0x0C	; 12
+ 93a:	5b 9a       	sbi	0x0b, 3	; 11
+ 93c:	1a b9       	out	0x0a, r17	; 10
+ 93e:	0b b1       	in	r16, 0x0b	; 11
+ 940:	20 e4       	ldi	r18, 0x40	; 64
+ 942:	1c e0       	ldi	r17, 0x0C	; 12
+ 944:	5f 93       	push	r21
+
+00000946 <doExorN1>:
+ 946:	01 27       	eor	r16, r17
+ 948:	56 e0       	ldi	r21, 0x06	; 6
+
+0000094a <commonN1>:
+ 94a:	0b b9       	out	0x0b, r16	; 11
+ 94c:	27 95       	ror	r18
+ 94e:	20 f4       	brcc	.+8      	; 0x958 <doExorN2>
+ 950:	51 50       	subi	r21, 0x01	; 1
+ 952:	21 f4       	brne	.+8      	; 0x95c <commonN2>
+ 954:	22 0f       	add	r18, r18
+ 956:	f9 cf       	rjmp	.-14     	; 0x94a <commonN1>
+
+00000958 <doExorN2>:
+ 958:	01 27       	eor	r16, r17
+ 95a:	56 e0       	ldi	r21, 0x06	; 6
+
+0000095c <commonN2>:
+ 95c:	00 00       	nop
+ 95e:	3b 5a       	subi	r19, 0xAB	; 171
+ 960:	0b b9       	out	0x0b, r16	; 11
+ 962:	d0 f2       	brcs	.-76     	; 0x918 <stuffN1Delay>
+
+00000964 <stuff6Delay>:
+ 964:	27 95       	ror	r18
+ 966:	28 f4       	brcc	.+10     	; 0x972 <doExor6>
+ 968:	51 50       	subi	r21, 0x01	; 1
+ 96a:	29 f4       	brne	.+10     	; 0x976 <common6>
+ 96c:	22 0f       	add	r18, r18
+ 96e:	00 00       	nop
+ 970:	f9 cf       	rjmp	.-14     	; 0x964 <stuff6Delay>
+
+00000972 <doExor6>:
+ 972:	01 27       	eor	r16, r17
+ 974:	56 e0       	ldi	r21, 0x06	; 6
+
+00000976 <common6>:
+ 976:	27 95       	ror	r18
+ 978:	0b b9       	out	0x0b, r16	; 11
+ 97a:	20 f4       	brcc	.+8      	; 0x984 <doExor7>
+ 97c:	51 50       	subi	r21, 0x01	; 1
+ 97e:	21 f4       	brne	.+8      	; 0x988 <common7>
+ 980:	22 0f       	add	r18, r18
+ 982:	f9 cf       	rjmp	.-14     	; 0x976 <common6>
+
+00000984 <doExor7>:
+ 984:	01 27       	eor	r16, r17
+ 986:	56 e0       	ldi	r21, 0x06	; 6
+
+00000988 <common7>:
+ 988:	29 91       	ld	r18, Y+
+ 98a:	33 23       	and	r19, r19
+ 98c:	0b b9       	out	0x0b, r16	; 11
+ 98e:	21 f6       	brne	.-120    	; 0x918 <stuffN1Delay>
+ 990:	03 7f       	andi	r16, 0xF3	; 243
+ 992:	10 91 7e 01 	lds	r17, 0x017E
+ 996:	11 0f       	add	r17, r17
+ 998:	c6 51       	subi	r28, 0x16	; 22
+ 99a:	d0 40       	sbci	r29, 0x00	; 0
+ 99c:	0b b9       	out	0x0b, r16	; 11
+ 99e:	11 f0       	breq	.+4      	; 0x9a4 <skipAddrAssign>
+ 9a0:	10 93 78 01 	sts	0x0178, r17
+
+000009a4 <skipAddrAssign>:
+ 9a4:	11 e0       	ldi	r17, 0x01	; 1
+ 9a6:	1c bb       	out	0x1c, r17	; 28
+ 9a8:	08 60       	ori	r16, 0x08	; 8
+ 9aa:	1a b1       	in	r17, 0x0a	; 10
+ 9ac:	13 7f       	andi	r17, 0xF3	; 243
+ 9ae:	40 2f       	mov	r20, r16
+ 9b0:	43 7f       	andi	r20, 0xF3	; 243
+ 9b2:	5f 91       	pop	r21
+ 9b4:	00 c0       	rjmp	.+0      	; 0x9b6 <skipAddrAssign+0x12>
+ 9b6:	00 c0       	rjmp	.+0      	; 0x9b8 <skipAddrAssign+0x14>
+ 9b8:	0b b9       	out	0x0b, r16	; 11
+ 9ba:	1a b9       	out	0x0a, r17	; 10
+ 9bc:	4b b9       	out	0x0b, r20	; 11
+ 9be:	71 cf       	rjmp	.-286    	; 0x8a2 <doReturn>
+
+000009c0 <__mulhi3>:
+ 9c0:	55 27       	eor	r21, r21
+ 9c2:	00 24       	eor	r0, r0
+
+000009c4 <__mulhi3_loop>:
+ 9c4:	80 ff       	sbrs	r24, 0
+ 9c6:	02 c0       	rjmp	.+4      	; 0x9cc <__mulhi3_skip1>
+ 9c8:	06 0e       	add	r0, r22
+ 9ca:	57 1f       	adc	r21, r23
+
+000009cc <__mulhi3_skip1>:
+ 9cc:	66 0f       	add	r22, r22
+ 9ce:	77 1f       	adc	r23, r23
+ 9d0:	61 15       	cp	r22, r1
+ 9d2:	71 05       	cpc	r23, r1
+ 9d4:	21 f0       	breq	.+8      	; 0x9de <__mulhi3_exit>
+ 9d6:	96 95       	lsr	r25
+ 9d8:	87 95       	ror	r24
+ 9da:	00 97       	sbiw	r24, 0x00	; 0
+ 9dc:	99 f7       	brne	.-26     	; 0x9c4 <__mulhi3_loop>
+
+000009de <__mulhi3_exit>:
+ 9de:	95 2f       	mov	r25, r21
+ 9e0:	80 2d       	mov	r24, r0
+ 9e2:	08 95       	ret
+
+000009e4 <_exit>:
+ 9e4:	f8 94       	cli
+
+000009e6 <__stop_program>:
+ 9e6:	ff cf       	rjmp	.-2      	; 0x9e6 <__stop_program>
Index: bin/Release/HP48GX.map
===================================================================
--- bin/Release/HP48GX.map	(nonexistent)
+++ bin/Release/HP48GX.map	(working copy)
@@ -0,0 +1,536 @@
+Archive member included because of file (symbol)
+
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+                              obj\Release\main.o (__mulhi3)
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+                              c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o (exit)
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+                              obj\Release\main.o (__do_copy_data)
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                              obj\Release\main.o (__do_clear_bss)
+
+Allocating common symbols
+Common symbol       size              file
+
+usbTxBuf            0xb               obj\Release\usbdrv\usbdrv.o
+usbTxStatus1        0xc               obj\Release\usbdrv\usbdrv.o
+usbDeviceAddr       0x1               obj\Release\usbdrv\usbdrv.o
+usbRxToken          0x1               obj\Release\usbdrv\usbdrv.o
+usbInputBufOffset   0x1               obj\Release\usbdrv\usbdrv.o
+usbMsgPtr           0x2               obj\Release\usbdrv\usbdrv.o
+usbRxLen            0x1               obj\Release\usbdrv\usbdrv.o
+usbNewDeviceAddr    0x1               obj\Release\usbdrv\usbdrv.o
+usbCurrentTok       0x1               obj\Release\usbdrv\usbdrv.o
+usbConfiguration    0x1               obj\Release\usbdrv\usbdrv.o
+usbRxBuf            0x16              obj\Release\usbdrv\usbdrv.o
+
+Memory Configuration
+
+Name             Origin             Length             Attributes
+text             0x00000000         0x00002000         xr
+data             0x00800060         0x0000ffa0         rw !x
+eeprom           0x00810000         0x00010000         rw !x
+fuse             0x00820000         0x00000400         rw !x
+lock             0x00830000         0x00000400         rw !x
+signature        0x00840000         0x00000400         rw !x
+*default*        0x00000000         0xffffffff
+
+Linker script and memory map
+
+Address of section .data set to 0x800100
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+LOAD obj\Release\fuse.o
+LOAD obj\Release\main.o
+LOAD obj\Release\usbdrv\oddebug.o
+LOAD obj\Release\usbdrv\usbdrv.o
+LOAD obj\Release\usbdrv\usbdrvasm.o
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25\libm.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25\libc.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a
+
+.hash
+ *(.hash)
+
+.dynsym
+ *(.dynsym)
+
+.dynstr
+ *(.dynstr)
+
+.gnu.version
+ *(.gnu.version)
+
+.gnu.version_d
+ *(.gnu.version_d)
+
+.gnu.version_r
+ *(.gnu.version_r)
+
+.rel.init
+ *(.rel.init)
+
+.rela.init
+ *(.rela.init)
+
+.rel.text
+ *(.rel.text)
+ *(.rel.text.*)
+ *(.rel.gnu.linkonce.t*)
+
+.rela.text
+ *(.rela.text)
+ *(.rela.text.*)
+ *(.rela.gnu.linkonce.t*)
+
+.rel.fini
+ *(.rel.fini)
+
+.rela.fini
+ *(.rela.fini)
+
+.rel.rodata
+ *(.rel.rodata)
+ *(.rel.rodata.*)
+ *(.rel.gnu.linkonce.r*)
+
+.rela.rodata
+ *(.rela.rodata)
+ *(.rela.rodata.*)
+ *(.rela.gnu.linkonce.r*)
+
+.rel.data
+ *(.rel.data)
+ *(.rel.data.*)
+ *(.rel.gnu.linkonce.d*)
+
+.rela.data
+ *(.rela.data)
+ *(.rela.data.*)
+ *(.rela.gnu.linkonce.d*)
+
+.rel.ctors
+ *(.rel.ctors)
+
+.rela.ctors
+ *(.rela.ctors)
+
+.rel.dtors
+ *(.rel.dtors)
+
+.rela.dtors
+ *(.rela.dtors)
+
+.rel.got
+ *(.rel.got)
+
+.rela.got
+ *(.rela.got)
+
+.rel.bss
+ *(.rel.bss)
+
+.rela.bss
+ *(.rela.bss)
+
+.rel.plt
+ *(.rel.plt)
+
+.rela.plt
+ *(.rela.plt)
+
+.text           0x00000000      0x9e8
+ *(.vectors)
+ .vectors       0x00000000       0x28 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+                0x00000000                __vectors
+                0x00000000                __vector_default
+ *(.vectors)
+ *(.progmem.gcc*)
+ *(.progmem*)
+ .progmem.data  0x00000028       0x3f obj\Release\main.o
+                0x00000028                usbDescriptorHidReport
+ .progmem.data  0x00000067       0x68 obj\Release\usbdrv\usbdrv.o
+                0x0000009b                usbDescriptorDevice
+                0x00000067                usbDescriptorString0
+                0x000000ad                usbDescriptorConfiguration
+                0x0000006b                usbDescriptorStringVendor
+                0x0000008b                usbDescriptorStringDevice
+                0x000000d0                . = ALIGN (0x2)
+ *fill*         0x000000cf        0x1 00
+                0x000000d0                __trampolines_start = .
+ *(.trampolines)
+ .trampolines   0x000000d0        0x0 linker stubs
+ *(.trampolines*)
+                0x000000d0                __trampolines_end = .
+ *(.jumptables)
+ *(.jumptables*)
+ *(.lowtext)
+ *(.lowtext*)
+                0x000000d0                __ctors_start = .
+ *(.ctors)
+                0x000000d0                __ctors_end = .
+                0x000000d0                __dtors_start = .
+ *(.dtors)
+                0x000000d0                __dtors_end = .
+ SORT(*)(.ctors)
+ SORT(*)(.dtors)
+ *(.init0)
+ .init0         0x000000d0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+                0x000000d0                __init
+ *(.init0)
+ *(.init1)
+ *(.init1)
+ *(.init2)
+ .init2         0x000000d0        0xc c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ *(.init2)
+ *(.init3)
+ *(.init3)
+ *(.init4)
+ .init4         0x000000dc       0x16 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+                0x000000dc                __do_copy_data
+ .init4         0x000000f2       0x10 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                0x000000f2                __do_clear_bss
+ *(.init4)
+ *(.init5)
+ *(.init5)
+ *(.init6)
+ *(.init6)
+ *(.init7)
+ *(.init7)
+ *(.init8)
+ *(.init8)
+ *(.init9)
+ .init9         0x00000102        0x4 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ *(.init9)
+ *(.text)
+ .text          0x00000106        0x2 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+                0x00000106                __vector_12
+                0x00000106                __bad_interrupt
+                0x00000106                __vector_6
+                0x00000106                __vector_3
+                0x00000106                __vector_11
+                0x00000106                __vector_13
+                0x00000106                __vector_17
+                0x00000106                __vector_19
+                0x00000106                __vector_7
+                0x00000106                __vector_5
+                0x00000106                __vector_4
+                0x00000106                __vector_9
+                0x00000106                __vector_2
+                0x00000106                __vector_15
+                0x00000106                __vector_8
+                0x00000106                __vector_10
+                0x00000106                __vector_16
+                0x00000106                __vector_18
+ .text          0x00000108        0x0 obj\Release\fuse.o
+ .text          0x00000108      0x36a obj\Release\main.o
+                0x0000039e                Init
+                0x000002fc                OnKey
+                0x00000108                usbFunctionSetup
+                0x00000326                KeyPressed
+                0x00000172                buildReport
+                0x000003d2                main
+                0x000001a4                scanMatrix
+                0x0000017c                __vector_14
+                0x0000016e                usbFunctionWrite
+ .text          0x00000472        0x0 obj\Release\usbdrv\oddebug.o
+ .text          0x00000472      0x2a8 obj\Release\usbdrv\usbdrv.o
+                0x0000048c                usbPoll
+                0x000006d6                usbSetInterrupt
+                0x00000472                usbInit
+ .text          0x0000071a      0x2a6 obj\Release\usbdrv\usbdrvasm.o
+                0x0000074c                __vector_1
+                0x0000071a                usbCrc16
+                0x00000744                usbCrc16Append
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                0x000009c0                . = ALIGN (0x2)
+ *(.text.*)
+ .text.libgcc   0x000009c0       0x24 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+                0x000009c0                __mulhi3
+ .text.libgcc   0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .text.libgcc   0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .text.libgcc   0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                0x000009e4                . = ALIGN (0x2)
+ *(.fini9)
+ .fini9         0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+                0x000009e4                exit
+                0x000009e4                _exit
+ *(.fini9)
+ *(.fini8)
+ *(.fini8)
+ *(.fini7)
+ *(.fini7)
+ *(.fini6)
+ *(.fini6)
+ *(.fini5)
+ *(.fini5)
+ *(.fini4)
+ *(.fini4)
+ *(.fini3)
+ *(.fini3)
+ *(.fini2)
+ *(.fini2)
+ *(.fini1)
+ *(.fini1)
+ *(.fini0)
+ .fini0         0x000009e4        0x4 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ *(.fini0)
+                0x000009e8                _etext = .
+
+.data           0x00800100       0x40 load address 0x000009e8
+                0x00800100                PROVIDE (__data_start, .)
+ *(.data)
+ .data          0x00800100        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ .data          0x00800100        0x0 obj\Release\fuse.o
+ .data          0x00800100       0x3e obj\Release\main.o
+                0x00800100                ScanCode
+ .data          0x0080013e        0x0 obj\Release\usbdrv\oddebug.o
+ .data          0x0080013e        0x2 obj\Release\usbdrv\usbdrv.o
+                0x0080013e                usbTxLen
+ .data          0x00800140        0x0 obj\Release\usbdrv\usbdrvasm.o
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+ *(.data*)
+ *(.rodata)
+ *(.rodata*)
+ *(.gnu.linkonce.d*)
+                0x00800140                . = ALIGN (0x2)
+                0x00800140                _edata = .
+                0x00800140                PROVIDE (__data_end, .)
+
+.bss            0x00800140       0x57
+                0x00800140                PROVIDE (__bss_start, .)
+ *(.bss)
+ .bss           0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ .bss           0x00800140        0x0 obj\Release\fuse.o
+ .bss           0x00800140       0x20 obj\Release\main.o
+                0x00800143                keybuild
+                0x00800141                EnableKeyPressed
+                0x00800140                state
+                0x00800149                changedKeys
+                0x00800147                FAIL
+                0x00800145                OnCount
+ .bss           0x00800160        0x0 obj\Release\usbdrv\oddebug.o
+ .bss           0x00800160        0x1 obj\Release\usbdrv\usbdrv.o
+ .bss           0x00800161        0x0 obj\Release\usbdrv\usbdrvasm.o
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+ *(.bss*)
+ *(COMMON)
+ COMMON         0x00800161       0x36 obj\Release\usbdrv\usbdrv.o
+                0x00800161                usbTxBuf
+                0x0080016c                usbTxStatus1
+                0x00800178                usbDeviceAddr
+                0x00800179                usbRxToken
+                0x0080017a                usbInputBufOffset
+                0x0080017b                usbMsgPtr
+                0x0080017d                usbRxLen
+                0x0080017e                usbNewDeviceAddr
+                0x0080017f                usbCurrentTok
+                0x00800180                usbConfiguration
+                0x00800181                usbRxBuf
+                0x00800197                PROVIDE (__bss_end, .)
+                0x000009e8                __data_load_start = LOADADDR (.data)
+                0x00000a28                __data_load_end = (__data_load_start + SIZEOF (.data))
+
+.noinit         0x00800197        0x0
+                0x00800197                PROVIDE (__noinit_start, .)
+ *(.noinit*)
+                0x00800197                PROVIDE (__noinit_end, .)
+                0x00800197                _end = .
+                0x00800197                PROVIDE (__heap_start, .)
+
+.eeprom         0x00810000        0x0
+ *(.eeprom*)
+                0x00810000                __eeprom_end = .
+
+.fuse           0x00820000        0x3
+ *(.fuse)
+ .fuse          0x00820000        0x3 obj\Release\fuse.o
+                0x00820000                __fuse
+ *(.lfuse)
+ *(.hfuse)
+ *(.efuse)
+
+.lock
+ *(.lock*)
+
+.signature
+ *(.signature*)
+
+.stab
+ *(.stab)
+
+.stabstr
+ *(.stabstr)
+
+.stab.excl
+ *(.stab.excl)
+
+.stab.exclstr
+ *(.stab.exclstr)
+
+.stab.index
+ *(.stab.index)
+
+.stab.indexstr
+ *(.stab.indexstr)
+
+.comment
+ *(.comment)
+
+.debug
+ *(.debug)
+
+.line
+ *(.line)
+
+.debug_srcinfo
+ *(.debug_srcinfo)
+
+.debug_sfnames
+ *(.debug_sfnames)
+
+.debug_aranges
+ *(.debug_aranges)
+
+.debug_pubnames
+ *(.debug_pubnames)
+
+.debug_info
+ *(.debug_info)
+ *(.gnu.linkonce.wi.*)
+
+.debug_abbrev
+ *(.debug_abbrev)
+
+.debug_line
+ *(.debug_line)
+
+.debug_frame
+ *(.debug_frame)
+
+.debug_str
+ *(.debug_str)
+
+.debug_loc
+ *(.debug_loc)
+
+.debug_macinfo
+ *(.debug_macinfo)
+OUTPUT(bin\Release\HP48GX.elf elf32-avr)
+LOAD linker stubs
+
+Cross Reference Table
+
+Symbol                                            File
+EnableKeyPressed                                  obj\Release\main.o
+FAIL                                              obj\Release\main.o
+Init                                              obj\Release\main.o
+KeyPressed                                        obj\Release\main.o
+OnCount                                           obj\Release\main.o
+OnKey                                             obj\Release\main.o
+ScanCode                                          obj\Release\main.o
+__bad_interrupt                                   c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__bss_end                                         c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+__bss_start                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+__data_end                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+__data_load_start                                 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+__data_start                                      c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+__do_clear_bss                                    c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                                                  obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+__do_copy_data                                    c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+                                                  obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+__fuse                                            obj\Release\fuse.o
+__heap_end                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__init                                            c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__mulhi3                                          c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+                                                  obj\Release\main.o
+__stack                                           c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_1                                        obj\Release\usbdrv\usbdrvasm.o
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_10                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_11                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_12                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_13                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_14                                       obj\Release\main.o
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_15                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_16                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_17                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_18                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_19                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_2                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_3                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_4                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_5                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_6                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_7                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_8                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_9                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_default                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vectors                                         c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+_exit                                             c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+buildReport                                       obj\Release\main.o
+changedKeys                                       obj\Release\main.o
+exit                                              c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+keybuild                                          obj\Release\main.o
+main                                              obj\Release\main.o
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+scanMatrix                                        obj\Release\main.o
+state                                             obj\Release\main.o
+usbConfiguration                                  obj\Release\usbdrv\usbdrv.o
+usbCrc16                                          obj\Release\usbdrv\usbdrvasm.o
+usbCrc16Append                                    obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbCurrentTok                                     obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbDescriptorConfiguration                        obj\Release\usbdrv\usbdrv.o
+usbDescriptorDevice                               obj\Release\usbdrv\usbdrv.o
+usbDescriptorHidReport                            obj\Release\main.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbDescriptorString0                              obj\Release\usbdrv\usbdrv.o
+usbDescriptorStringDevice                         obj\Release\usbdrv\usbdrv.o
+usbDescriptorStringVendor                         obj\Release\usbdrv\usbdrv.o
+usbDeviceAddr                                     obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbFunctionSetup                                  obj\Release\main.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbFunctionWrite                                  obj\Release\main.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbInit                                           obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbInputBufOffset                                 obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbMsgPtr                                         obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbNewDeviceAddr                                  obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbPoll                                           obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbRxBuf                                          obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbRxLen                                          obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbRxToken                                        obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbSetInterrupt                                   obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbTxBuf                                          obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbTxLen                                          obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\usbdrv\usbdrvasm.o
+usbTxStatus1                                      obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
Index: bin/Release/HP48GX.sig
===================================================================
--- bin/Release/HP48GX.sig	(nonexistent)
+++ bin/Release/HP48GX.sig	(working copy)
@@ -0,0 +1 @@
+:00000001FF
Index: bin/Release/HP48GX.eep
===================================================================
--- bin/Release/HP48GX.eep	(nonexistent)
+++ bin/Release/HP48GX.eep	(working copy)
@@ -0,0 +1 @@
+:00000001FF
Index: bin/Release/HP48GX.efs
===================================================================
--- bin/Release/HP48GX.efs	(nonexistent)
+++ bin/Release/HP48GX.efs	(working copy)
@@ -0,0 +1,3 @@
+:020000040000FA
+:01000000FF00
+:00000001FF
Index: bin/Release/HP48GX.elf
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: bin/Release/HP48GX.elf
===================================================================
--- bin/Release/HP48GX.elf	(nonexistent)
+++ bin/Release/HP48GX.elf	(working copy)

Property changes on: bin/Release/HP48GX.elf
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: bin/Release/HP48GX.fuse
===================================================================
--- bin/Release/HP48GX.fuse	(nonexistent)
+++ bin/Release/HP48GX.fuse	(working copy)
@@ -0,0 +1,2 @@
+:03000000ECDFFF33
+:00000001FF
Index: bin/Release/HP48GX.hex
===================================================================
--- bin/Release/HP48GX.hex	(nonexistent)
+++ bin/Release/HP48GX.hex	(working copy)
@@ -0,0 +1,164 @@
+:1000000067C0A4C380C07FC07EC07DC07CC07BC0F1
+:100010007AC079C078C077C076C075C0AFC073C0F1
+:1000200072C071C070C06FC005010906A1017501E1
+:100030009508050719E029E7150025FF81029501BC
+:1000400075088103950575010508190129FF9102BD
+:1000500095017503910395067508150025FF0507A1
+:10006000190029FF8100C004030904200363006F05
+:10007000006400650061006E0064006C0069006649
+:100080000065002E0063006F006D001003500061DA
+:100090000073007300670065006E0012011001001C
+:1000A000000008424231E100010102000109022280
+:1000B0000001010080190904000001030101000989
+:1000C0002101010001223F000705810308000A0009
+:1000D00011241FBECFEFD1E0DEBFCDBF11E0A0E005
+:1000E000B1E0E8EEF9E002C005900D92A034B1074E
+:1000F000D9F711E0A0E4B1E001C01D92A739B10722
+:10010000E1F767D16FC47CCFFC01808180768032BB
+:1001100061F581818230E1F0833018F4813029F576
+:1001200005C0893079F08A3001F51AC087E591E081
+:1001300090937C0180937B0110925701109259019A
+:1001400088E0089586819781019779F48FEF08956B
+:100150008FE591E090937C0180937B0181E008958D
+:10016000838180935F0180E0089580E0089581E0BD
+:100170000895109257018093590108951F920F928C
+:100180000FB60F9211248F939F9381E090E090938C
+:100190005501809354019F918F910F900FBE0F9046
+:1001A0001F9018958091540190915501892B09F465
+:1001B000A4C0109255011092540149B1437FA091FF
+:1001C00056012A2F30E0F901E65BFE4F808184273B
+:1001D0004083882309F465C0942F40FD0DC080FF43
+:1001E0000BC081E080934001C90166E070E0E8D374
+:1001F000FC01E050FF4F20C091FD0EC081FF0CC0FC
+:1002000081E080934001C90166E070E0D9D3FC0130
+:10021000E050FF4F818141C094FD10C084FF0EC0AB
+:1002200081E080934001C90163E070E0C9D3FC0123
+:10023000EE0FFF1FEE5FFE4F80812FC095FD0EC0B9
+:1002400085FF0CC081E080934001C90166E070E049
+:10025000B7D3FC01E050FF4F83811FC096FD0EC055
+:1002600086FF0CC081E080934001C90166E070E028
+:10027000A7D3FC01E050FF4F84810FC047FD11C0A0
+:1002800087FF0FC081E080934001C90166E070E004
+:1002900097D3FC01E050FF4F85818093430110927A
+:1002A000440180913C0190913D01880F991F9093EA
+:1002B0003D0180933C01AF5FA093560180349105CE
+:1002C00031F480E890E090933D0180933C0180916F
+:1002D0003C0190913D018050944041F481E090E0D8
+:1002E00090933D0180933C011092560190913C0106
+:1002F00080913D0197B984608DB908958091400146
+:10030000813081F083B190E08078907080935301C8
+:10031000892B41F481E085B981E090E0909342011E
+:100320008093410108958091410190914201892B70
+:10033000A9F11F991DC08091450190914601019638
+:1003400090934601809345018052934089F48CE359
+:1003500090E0909344018093430181E080934001B9
+:1003600010924201109241011092460110924501F3
+:10037000809145019091460189559240873C9105B5
+:1003800068F480913601809343011092440181E02A
+:100390008093400110924201109241010895109201
+:1003A0006B0010926D0010926A0017B818B88AB1ED
+:1003B0008C708AB98BB11BB884E08DB91EB81092CD
+:1003C0008000109281001092820081E084B915B8FB
+:1003D00008951F93E4DFE7E5F1E0119281E0EF3546
+:1003E000F807D9F72EE088E190E00FB6F894A895C9
+:1003F000809360000FBE209360003BD0539A20E0B2
+:1004000040E757E1A895CA010197F1F72F5F2A3F0E
+:10041000C9F73CD05398F89483E085BD81E0809380
+:100420006E00789412E07FDF69DFBCDEA8952ED0E5
+:1004300080916C0184FF18C0809140018823A1F055
+:10044000813019F0823071F409C08091430110921B
+:100450005701809359011093400106C01092570133
+:10046000109259011092400187E591E068E033D184
+:10047000DACFE9E6F0E0808182608083E89A8BE45D
+:1004800080936D018AE580936C0108951F93CF934B
+:10049000DF9360917D01635067FDC2C080917A0156
+:1004A000CCE0D0E0C81BD109CF57DE4F8091790155
+:1004B0008D3209F0A3C0683009F0B0C083EC80939E
+:1004C00061018AE580933E01109260018881807607
+:1004D00039F0CE0119DE282F8F3F09F47EC084C089
+:1004E0009A8110926A018981882321F410926B010C
+:1004F00022E06CC0853019F490937E0166C086308E
+:1005000009F04FC08B81813041F48BE990E09093EA
+:100510007C0180937B0122E140C0823041F48DEA6E
+:1005200090E090937C0180937B0122E236C083307F
+:10053000F9F48A81882341F487E690E090937C0166
+:1005400080937B0124E029C0813041F48BE690E068
+:1005500090937C0180937B0120E21FC08230E1F404
+:100560008BE890E090937C0180937B0120E115C0A3
+:10057000813241F48FEB90E090937C0180937B017A
+:1005800029E00BC0823241F488E290E090937C0134
+:1005900080937B012FE301C020E080E48093600121
+:1005A00023C0883021F421E080E891E011C0893037
+:1005B00019F49093800109C08A3011F421E006C03B
+:1005C0008B3019F48BE480936D0120E08AE691E092
+:1005D00090937C0180937B0107C0888187FD2E81E9
+:1005E00080E88093600106C08F81882319F48E8192
+:1005F000821708F0822F80933F0110C08091600124
+:1006000087FF0CC0CE01B3DD8F3F21F48EE18093D4
+:100610003E0104C0882311F010923F0110927D0129
+:1006200080913E0184FF49C080913F018F3F09F4D2
+:1006300044C0182F893008F018E0811B80933F01D7
+:100640008091610198E8892780936101112341F12C
+:1006500020917B0130917C018091600186FF0DC06B
+:10066000A2E6B1E080E090E0F901E80FF91FE49123
+:10067000ED9301961817C1F708C0912FD901E2E652
+:10068000F1E08D9181939150E1F71150812F90E02D
+:100690001F5F0196820F931F90937C0180937B01D3
+:1006A00082E691E0612F4ED0612F6C5F6C3019F0C3
+:1006B0008FEF80933F0160933E0194E189B18C708C
+:1006C00031F49150D9F710927E0110927801DF91A8
+:1006D000CF911F9108951F93DC01162F80916C011B
+:1006E00084FF07C080916D0198E8892780936D0190
+:1006F00003C08AE580936C01912FEEE6F1E08D91C5
+:10070000819391501916DCF38EE691E0612F1AD097
+:100710001C5F10936C011F910895A82FB92F80E0E2
+:1007200090E041E050EA609530E009C02D918227C9
+:100730009795879510F084279527305EC8F36F5FF3
+:10074000A8F30895EADF8D939D930895CF93CFB7D3
+:10075000CF93C3954B9BE9F74B9B09C04B9B07C0BD
+:100760004B9B05C04B9B03C04B9B01C0A3C0DF93B9
+:10077000C0917A01DD27CF57DE4F4B9B02C0DF913E
+:10078000EBCF2F930F931F9309B12FEF03FB20F9AA
+:100790004F933F9319B14FEF012703FB21F93BE042
+:1007A00031C04E7F012F19B1216028C0102F4D7F1D
+:1007B0002260000009B129C04B7F2460012F000096
+:1007C00019B12BC019B1477F28602AC04F7E09B1EB
+:1007D00020612CC04F7D19B120622FC04F7B09B121
+:1007E000206432C0422709B149934FEF000010271F
+:1007F00013FB20F919B11C70C9F1297F91F201276F
+:1008000003FB21F909B1237F89F2315058F11027F8
+:1008100013FB22F919B1277E79F2012703FB23F993
+:100820002F7C81F209B1102713FB24F92F7971F283
+:1008300000C019B1012703FB25F92F7359F200C03D
+:1008400009B1102713FB26F9223040F200C019B17C
+:10085000012703FB27F9243028F64F77206819B1C8
+:100860000000F9CF11E01CBB002719C03B503195A7
+:10087000C31BD04011E01CBB0881033CF9F00B34D2
+:10088000E9F0209178011981110F1213EDCF4A81FF
+:10089000441F093641F10D3211F0013E29F7009352
+:1008A0007F013F914F911F910F912F91DF91CCB319
+:1008B000C0FD4FCFCF91CFBFCF91189520917F0131
+:1008C000222379F310917D01112369F534306AF107
+:1008D00030937D012093790110917A013BE0311B27
+:1008E00030937A0122C000917D010130E4F40AE5E1
+:1008F0004F7049F430913E0134FD19C000933E0120
+:10090000C1E6D1E018C030916C0134FD10C00093F5
+:100910006C01CDE6D1E00FC02795A8F45150A9F4A1
+:10092000220F0000F9CF4AE503C042ED01C0432F7A
+:10093000C4E1D0E032E01AB11C605B9A1AB90BB185
+:1009400020E41CE05F93012756E00BB9279520F4C3
+:10095000515021F4220FF9CF012756E000003B5AF5
+:100960000BB9D0F2279528F4515029F4220F00003A
+:10097000F9CF012756E027950BB920F4515021F407
+:10098000220FF9CF012756E0299133230BB921F625
+:10099000037F10917E01110FC651D0400BB911F0A9
+:1009A0001093780111E01CBB08601AB1137F402F2F
+:1009B000437F5F9100C000C00BB91AB94BB971CF2A
+:1009C0005527002480FF02C0060E571F660F771FB1
+:1009D0006115710521F096958795009799F7952FE8
+:0809E000802D0895F894FFCF6B
+:1009E800000506070809000B0C0D0E0F0011121365
+:1009F8001415001718191A1B00581D1C4C2A2B1601
+:100A080024252654E10A21222355E0041E1F2056DE
+:100A1800001027372C5729000000000001005AFF5A
+:00000001FF
Index: bin/Release/HP48GX.hfs
===================================================================
--- bin/Release/HP48GX.hfs	(nonexistent)
+++ bin/Release/HP48GX.hfs	(working copy)
@@ -0,0 +1,3 @@
+:020000040000FA
+:01000000DF20
+:00000001FF
Index: bin/Release/HP48GX.lfs
===================================================================
--- bin/Release/HP48GX.lfs	(nonexistent)
+++ bin/Release/HP48GX.lfs	(working copy)
@@ -0,0 +1,3 @@
+:020000040000FA
+:01000000EC13
+:00000001FF
Index: bin/Release/HP48GX.lock
===================================================================
--- bin/Release/HP48GX.lock	(nonexistent)
+++ bin/Release/HP48GX.lock	(working copy)
@@ -0,0 +1 @@
+:00000001FF
Index: bin/Release/HP48GX.lss
===================================================================
--- bin/Release/HP48GX.lss	(nonexistent)
+++ bin/Release/HP48GX.lss	(working copy)
@@ -0,0 +1,1236 @@
+
+bin\Release\HP48GX.elf:     file format elf32-avr
+
+Sections:
+Idx Name          Size      VMA       LMA       File off  Algn
+  0 .data         00000040  00800100  000009e8  00000a9c  2**0
+                  CONTENTS, ALLOC, LOAD, DATA
+  1 .text         000009e8  00000000  00000000  000000b4  2**1
+                  CONTENTS, ALLOC, LOAD, READONLY, CODE
+  2 .bss          00000057  00800140  00800140  00000adc  2**0
+                  ALLOC
+  3 .fuse         00000003  00820000  00820000  00000adc  2**0
+                  CONTENTS, ALLOC, LOAD, DATA
+
+Disassembly of section .text:
+
+00000000 <__vectors>:
+   0:	67 c0       	rjmp	.+206    	; 0xd0 <__ctors_end>
+   2:	a4 c3       	rjmp	.+1864   	; 0x74c <__vector_1>
+   4:	80 c0       	rjmp	.+256    	; 0x106 <__bad_interrupt>
+   6:	7f c0       	rjmp	.+254    	; 0x106 <__bad_interrupt>
+   8:	7e c0       	rjmp	.+252    	; 0x106 <__bad_interrupt>
+   a:	7d c0       	rjmp	.+250    	; 0x106 <__bad_interrupt>
+   c:	7c c0       	rjmp	.+248    	; 0x106 <__bad_interrupt>
+   e:	7b c0       	rjmp	.+246    	; 0x106 <__bad_interrupt>
+  10:	7a c0       	rjmp	.+244    	; 0x106 <__bad_interrupt>
+  12:	79 c0       	rjmp	.+242    	; 0x106 <__bad_interrupt>
+  14:	78 c0       	rjmp	.+240    	; 0x106 <__bad_interrupt>
+  16:	77 c0       	rjmp	.+238    	; 0x106 <__bad_interrupt>
+  18:	76 c0       	rjmp	.+236    	; 0x106 <__bad_interrupt>
+  1a:	75 c0       	rjmp	.+234    	; 0x106 <__bad_interrupt>
+  1c:	af c0       	rjmp	.+350    	; 0x17c <__vector_14>
+  1e:	73 c0       	rjmp	.+230    	; 0x106 <__bad_interrupt>
+  20:	72 c0       	rjmp	.+228    	; 0x106 <__bad_interrupt>
+  22:	71 c0       	rjmp	.+226    	; 0x106 <__bad_interrupt>
+  24:	70 c0       	rjmp	.+224    	; 0x106 <__bad_interrupt>
+  26:	6f c0       	rjmp	.+222    	; 0x106 <__bad_interrupt>
+
+00000028 <usbDescriptorHidReport>:
+  28:	05 01 09 06 a1 01 75 01 95 08 05 07 19 e0 29 e7     ......u.......).
+  38:	15 00 25 ff 81 02 95 01 75 08 81 03 95 05 75 01     ..%.....u.....u.
+  48:	05 08 19 01 29 ff 91 02 95 01 75 03 91 03 95 06     ....).....u.....
+  58:	75 08 15 00 25 ff 05 07 19 00 29 ff 81 00 c0        u...%.....)....
+
+00000067 <usbDescriptorString0>:
+  67:	04 03 09 04                                         ....
+
+0000006b <usbDescriptorStringVendor>:
+  6b:	20 03 63 00 6f 00 64 00 65 00 61 00 6e 00 64 00      .c.o.d.e.a.n.d.
+  7b:	6c 00 69 00 66 00 65 00 2e 00 63 00 6f 00 6d 00     l.i.f.e...c.o.m.
+
+0000008b <usbDescriptorStringDevice>:
+  8b:	10 03 50 00 61 00 73 00 73 00 67 00 65 00 6e 00     ..P.a.s.s.g.e.n.
+
+0000009b <usbDescriptorDevice>:
+  9b:	12 01 10 01 00 00 00 08 42 42 31 e1 00 01 01 02     ........BB1.....
+  ab:	00 01                                               ..
+
+000000ad <usbDescriptorConfiguration>:
+  ad:	09 02 22 00 01 01 00 80 19 09 04 00 00 01 03 01     ..".............
+  bd:	01 00 09 21 01 01 00 01 22 3f 00 07 05 81 03 08     ...!...."?......
+  cd:	00 0a 00                                            ...
+
+000000d0 <__ctors_end>:
+  d0:	11 24       	eor	r1, r1
+  d2:	1f be       	out	0x3f, r1	; 63
+  d4:	cf ef       	ldi	r28, 0xFF	; 255
+  d6:	d1 e0       	ldi	r29, 0x01	; 1
+  d8:	de bf       	out	0x3e, r29	; 62
+  da:	cd bf       	out	0x3d, r28	; 61
+
+000000dc <__do_copy_data>:
+  dc:	11 e0       	ldi	r17, 0x01	; 1
+  de:	a0 e0       	ldi	r26, 0x00	; 0
+  e0:	b1 e0       	ldi	r27, 0x01	; 1
+  e2:	e8 ee       	ldi	r30, 0xE8	; 232
+  e4:	f9 e0       	ldi	r31, 0x09	; 9
+  e6:	02 c0       	rjmp	.+4      	; 0xec <.do_copy_data_start>
+
+000000e8 <.do_copy_data_loop>:
+  e8:	05 90       	lpm	r0, Z+
+  ea:	0d 92       	st	X+, r0
+
+000000ec <.do_copy_data_start>:
+  ec:	a0 34       	cpi	r26, 0x40	; 64
+  ee:	b1 07       	cpc	r27, r17
+  f0:	d9 f7       	brne	.-10     	; 0xe8 <.do_copy_data_loop>
+
+000000f2 <__do_clear_bss>:
+  f2:	11 e0       	ldi	r17, 0x01	; 1
+  f4:	a0 e4       	ldi	r26, 0x40	; 64
+  f6:	b1 e0       	ldi	r27, 0x01	; 1
+  f8:	01 c0       	rjmp	.+2      	; 0xfc <.do_clear_bss_start>
+
+000000fa <.do_clear_bss_loop>:
+  fa:	1d 92       	st	X+, r1
+
+000000fc <.do_clear_bss_start>:
+  fc:	a7 39       	cpi	r26, 0x97	; 151
+  fe:	b1 07       	cpc	r27, r17
+ 100:	e1 f7       	brne	.-8      	; 0xfa <.do_clear_bss_loop>
+ 102:	67 d1       	rcall	.+718    	; 0x3d2 <main>
+ 104:	6f c4       	rjmp	.+2270   	; 0x9e4 <_exit>
+
+00000106 <__bad_interrupt>:
+ 106:	7c cf       	rjmp	.-264    	; 0x0 <__vectors>
+
+00000108 <usbFunctionSetup>:
+ 108:	fc 01       	movw	r30, r24
+ 10a:	80 81       	ld	r24, Z
+ 10c:	80 76       	andi	r24, 0x60	; 96
+ 10e:	80 32       	cpi	r24, 0x20	; 32
+ 110:	61 f5       	brne	.+88     	; 0x16a <usbFunctionSetup+0x62>
+ 112:	81 81       	ldd	r24, Z+1	; 0x01
+ 114:	82 30       	cpi	r24, 0x02	; 2
+ 116:	e1 f0       	breq	.+56     	; 0x150 <usbFunctionSetup+0x48>
+ 118:	83 30       	cpi	r24, 0x03	; 3
+ 11a:	18 f4       	brcc	.+6      	; 0x122 <usbFunctionSetup+0x1a>
+ 11c:	81 30       	cpi	r24, 0x01	; 1
+ 11e:	29 f5       	brne	.+74     	; 0x16a <usbFunctionSetup+0x62>
+ 120:	05 c0       	rjmp	.+10     	; 0x12c <usbFunctionSetup+0x24>
+ 122:	89 30       	cpi	r24, 0x09	; 9
+ 124:	79 f0       	breq	.+30     	; 0x144 <usbFunctionSetup+0x3c>
+ 126:	8a 30       	cpi	r24, 0x0A	; 10
+ 128:	01 f5       	brne	.+64     	; 0x16a <usbFunctionSetup+0x62>
+ 12a:	1a c0       	rjmp	.+52     	; 0x160 <usbFunctionSetup+0x58>
+ 12c:	87 e5       	ldi	r24, 0x57	; 87
+ 12e:	91 e0       	ldi	r25, 0x01	; 1
+ 130:	90 93 7c 01 	sts	0x017C, r25
+ 134:	80 93 7b 01 	sts	0x017B, r24
+ 138:	10 92 57 01 	sts	0x0157, r1
+ 13c:	10 92 59 01 	sts	0x0159, r1
+ 140:	88 e0       	ldi	r24, 0x08	; 8
+ 142:	08 95       	ret
+ 144:	86 81       	ldd	r24, Z+6	; 0x06
+ 146:	97 81       	ldd	r25, Z+7	; 0x07
+ 148:	01 97       	sbiw	r24, 0x01	; 1
+ 14a:	79 f4       	brne	.+30     	; 0x16a <usbFunctionSetup+0x62>
+ 14c:	8f ef       	ldi	r24, 0xFF	; 255
+ 14e:	08 95       	ret
+ 150:	8f e5       	ldi	r24, 0x5F	; 95
+ 152:	91 e0       	ldi	r25, 0x01	; 1
+ 154:	90 93 7c 01 	sts	0x017C, r25
+ 158:	80 93 7b 01 	sts	0x017B, r24
+ 15c:	81 e0       	ldi	r24, 0x01	; 1
+ 15e:	08 95       	ret
+ 160:	83 81       	ldd	r24, Z+3	; 0x03
+ 162:	80 93 5f 01 	sts	0x015F, r24
+ 166:	80 e0       	ldi	r24, 0x00	; 0
+ 168:	08 95       	ret
+ 16a:	80 e0       	ldi	r24, 0x00	; 0
+ 16c:	08 95       	ret
+
+0000016e <usbFunctionWrite>:
+ 16e:	81 e0       	ldi	r24, 0x01	; 1
+ 170:	08 95       	ret
+
+00000172 <buildReport>:
+ 172:	10 92 57 01 	sts	0x0157, r1
+ 176:	80 93 59 01 	sts	0x0159, r24
+ 17a:	08 95       	ret
+
+0000017c <__vector_14>:
+ 17c:	1f 92       	push	r1
+ 17e:	0f 92       	push	r0
+ 180:	0f b6       	in	r0, 0x3f	; 63
+ 182:	0f 92       	push	r0
+ 184:	11 24       	eor	r1, r1
+ 186:	8f 93       	push	r24
+ 188:	9f 93       	push	r25
+ 18a:	81 e0       	ldi	r24, 0x01	; 1
+ 18c:	90 e0       	ldi	r25, 0x00	; 0
+ 18e:	90 93 55 01 	sts	0x0155, r25
+ 192:	80 93 54 01 	sts	0x0154, r24
+ 196:	9f 91       	pop	r25
+ 198:	8f 91       	pop	r24
+ 19a:	0f 90       	pop	r0
+ 19c:	0f be       	out	0x3f, r0	; 63
+ 19e:	0f 90       	pop	r0
+ 1a0:	1f 90       	pop	r1
+ 1a2:	18 95       	reti
+
+000001a4 <scanMatrix>:
+ 1a4:	80 91 54 01 	lds	r24, 0x0154
+ 1a8:	90 91 55 01 	lds	r25, 0x0155
+ 1ac:	89 2b       	or	r24, r25
+ 1ae:	09 f4       	brne	.+2      	; 0x1b2 <scanMatrix+0xe>
+ 1b0:	a4 c0       	rjmp	.+328    	; 0x2fa <__stack+0xfb>
+ 1b2:	10 92 55 01 	sts	0x0155, r1
+ 1b6:	10 92 54 01 	sts	0x0154, r1
+ 1ba:	49 b1       	in	r20, 0x09	; 9
+ 1bc:	43 7f       	andi	r20, 0xF3	; 243
+ 1be:	a0 91 56 01 	lds	r26, 0x0156
+ 1c2:	2a 2f       	mov	r18, r26
+ 1c4:	30 e0       	ldi	r19, 0x00	; 0
+ 1c6:	f9 01       	movw	r30, r18
+ 1c8:	e6 5b       	subi	r30, 0xB6	; 182
+ 1ca:	fe 4f       	sbci	r31, 0xFE	; 254
+ 1cc:	80 81       	ld	r24, Z
+ 1ce:	84 27       	eor	r24, r20
+ 1d0:	40 83       	st	Z, r20
+ 1d2:	88 23       	and	r24, r24
+ 1d4:	09 f4       	brne	.+2      	; 0x1d8 <scanMatrix+0x34>
+ 1d6:	65 c0       	rjmp	.+202    	; 0x2a2 <__stack+0xa3>
+ 1d8:	94 2f       	mov	r25, r20
+ 1da:	40 fd       	sbrc	r20, 0
+ 1dc:	0d c0       	rjmp	.+26     	; 0x1f8 <scanMatrix+0x54>
+ 1de:	80 ff       	sbrs	r24, 0
+ 1e0:	0b c0       	rjmp	.+22     	; 0x1f8 <scanMatrix+0x54>
+ 1e2:	81 e0       	ldi	r24, 0x01	; 1
+ 1e4:	80 93 40 01 	sts	0x0140, r24
+ 1e8:	c9 01       	movw	r24, r18
+ 1ea:	66 e0       	ldi	r22, 0x06	; 6
+ 1ec:	70 e0       	ldi	r23, 0x00	; 0
+ 1ee:	e8 d3       	rcall	.+2000   	; 0x9c0 <__mulhi3>
+ 1f0:	fc 01       	movw	r30, r24
+ 1f2:	e0 50       	subi	r30, 0x00	; 0
+ 1f4:	ff 4f       	sbci	r31, 0xFF	; 255
+ 1f6:	20 c0       	rjmp	.+64     	; 0x238 <__stack+0x39>
+ 1f8:	91 fd       	sbrc	r25, 1
+ 1fa:	0e c0       	rjmp	.+28     	; 0x218 <__stack+0x19>
+ 1fc:	81 ff       	sbrs	r24, 1
+ 1fe:	0c c0       	rjmp	.+24     	; 0x218 <__stack+0x19>
+ 200:	81 e0       	ldi	r24, 0x01	; 1
+ 202:	80 93 40 01 	sts	0x0140, r24
+ 206:	c9 01       	movw	r24, r18
+ 208:	66 e0       	ldi	r22, 0x06	; 6
+ 20a:	70 e0       	ldi	r23, 0x00	; 0
+ 20c:	d9 d3       	rcall	.+1970   	; 0x9c0 <__mulhi3>
+ 20e:	fc 01       	movw	r30, r24
+ 210:	e0 50       	subi	r30, 0x00	; 0
+ 212:	ff 4f       	sbci	r31, 0xFF	; 255
+ 214:	81 81       	ldd	r24, Z+1	; 0x01
+ 216:	41 c0       	rjmp	.+130    	; 0x29a <__stack+0x9b>
+ 218:	94 fd       	sbrc	r25, 4
+ 21a:	10 c0       	rjmp	.+32     	; 0x23c <__stack+0x3d>
+ 21c:	84 ff       	sbrs	r24, 4
+ 21e:	0e c0       	rjmp	.+28     	; 0x23c <__stack+0x3d>
+ 220:	81 e0       	ldi	r24, 0x01	; 1
+ 222:	80 93 40 01 	sts	0x0140, r24
+ 226:	c9 01       	movw	r24, r18
+ 228:	63 e0       	ldi	r22, 0x03	; 3
+ 22a:	70 e0       	ldi	r23, 0x00	; 0
+ 22c:	c9 d3       	rcall	.+1938   	; 0x9c0 <__mulhi3>
+ 22e:	fc 01       	movw	r30, r24
+ 230:	ee 0f       	add	r30, r30
+ 232:	ff 1f       	adc	r31, r31
+ 234:	ee 5f       	subi	r30, 0xFE	; 254
+ 236:	fe 4f       	sbci	r31, 0xFE	; 254
+ 238:	80 81       	ld	r24, Z
+ 23a:	2f c0       	rjmp	.+94     	; 0x29a <__stack+0x9b>
+ 23c:	95 fd       	sbrc	r25, 5
+ 23e:	0e c0       	rjmp	.+28     	; 0x25c <__stack+0x5d>
+ 240:	85 ff       	sbrs	r24, 5
+ 242:	0c c0       	rjmp	.+24     	; 0x25c <__stack+0x5d>
+ 244:	81 e0       	ldi	r24, 0x01	; 1
+ 246:	80 93 40 01 	sts	0x0140, r24
+ 24a:	c9 01       	movw	r24, r18
+ 24c:	66 e0       	ldi	r22, 0x06	; 6
+ 24e:	70 e0       	ldi	r23, 0x00	; 0
+ 250:	b7 d3       	rcall	.+1902   	; 0x9c0 <__mulhi3>
+ 252:	fc 01       	movw	r30, r24
+ 254:	e0 50       	subi	r30, 0x00	; 0
+ 256:	ff 4f       	sbci	r31, 0xFF	; 255
+ 258:	83 81       	ldd	r24, Z+3	; 0x03
+ 25a:	1f c0       	rjmp	.+62     	; 0x29a <__stack+0x9b>
+ 25c:	96 fd       	sbrc	r25, 6
+ 25e:	0e c0       	rjmp	.+28     	; 0x27c <__stack+0x7d>
+ 260:	86 ff       	sbrs	r24, 6
+ 262:	0c c0       	rjmp	.+24     	; 0x27c <__stack+0x7d>
+ 264:	81 e0       	ldi	r24, 0x01	; 1
+ 266:	80 93 40 01 	sts	0x0140, r24
+ 26a:	c9 01       	movw	r24, r18
+ 26c:	66 e0       	ldi	r22, 0x06	; 6
+ 26e:	70 e0       	ldi	r23, 0x00	; 0
+ 270:	a7 d3       	rcall	.+1870   	; 0x9c0 <__mulhi3>
+ 272:	fc 01       	movw	r30, r24
+ 274:	e0 50       	subi	r30, 0x00	; 0
+ 276:	ff 4f       	sbci	r31, 0xFF	; 255
+ 278:	84 81       	ldd	r24, Z+4	; 0x04
+ 27a:	0f c0       	rjmp	.+30     	; 0x29a <__stack+0x9b>
+ 27c:	47 fd       	sbrc	r20, 7
+ 27e:	11 c0       	rjmp	.+34     	; 0x2a2 <__stack+0xa3>
+ 280:	87 ff       	sbrs	r24, 7
+ 282:	0f c0       	rjmp	.+30     	; 0x2a2 <__stack+0xa3>
+ 284:	81 e0       	ldi	r24, 0x01	; 1
+ 286:	80 93 40 01 	sts	0x0140, r24
+ 28a:	c9 01       	movw	r24, r18
+ 28c:	66 e0       	ldi	r22, 0x06	; 6
+ 28e:	70 e0       	ldi	r23, 0x00	; 0
+ 290:	97 d3       	rcall	.+1838   	; 0x9c0 <__mulhi3>
+ 292:	fc 01       	movw	r30, r24
+ 294:	e0 50       	subi	r30, 0x00	; 0
+ 296:	ff 4f       	sbci	r31, 0xFF	; 255
+ 298:	85 81       	ldd	r24, Z+5	; 0x05
+ 29a:	80 93 43 01 	sts	0x0143, r24
+ 29e:	10 92 44 01 	sts	0x0144, r1
+ 2a2:	80 91 3c 01 	lds	r24, 0x013C
+ 2a6:	90 91 3d 01 	lds	r25, 0x013D
+ 2aa:	88 0f       	add	r24, r24
+ 2ac:	99 1f       	adc	r25, r25
+ 2ae:	90 93 3d 01 	sts	0x013D, r25
+ 2b2:	80 93 3c 01 	sts	0x013C, r24
+ 2b6:	af 5f       	subi	r26, 0xFF	; 255
+ 2b8:	a0 93 56 01 	sts	0x0156, r26
+ 2bc:	80 34       	cpi	r24, 0x40	; 64
+ 2be:	91 05       	cpc	r25, r1
+ 2c0:	31 f4       	brne	.+12     	; 0x2ce <__stack+0xcf>
+ 2c2:	80 e8       	ldi	r24, 0x80	; 128
+ 2c4:	90 e0       	ldi	r25, 0x00	; 0
+ 2c6:	90 93 3d 01 	sts	0x013D, r25
+ 2ca:	80 93 3c 01 	sts	0x013C, r24
+ 2ce:	80 91 3c 01 	lds	r24, 0x013C
+ 2d2:	90 91 3d 01 	lds	r25, 0x013D
+ 2d6:	80 50       	subi	r24, 0x00	; 0
+ 2d8:	94 40       	sbci	r25, 0x04	; 4
+ 2da:	41 f4       	brne	.+16     	; 0x2ec <__stack+0xed>
+ 2dc:	81 e0       	ldi	r24, 0x01	; 1
+ 2de:	90 e0       	ldi	r25, 0x00	; 0
+ 2e0:	90 93 3d 01 	sts	0x013D, r25
+ 2e4:	80 93 3c 01 	sts	0x013C, r24
+ 2e8:	10 92 56 01 	sts	0x0156, r1
+ 2ec:	90 91 3c 01 	lds	r25, 0x013C
+ 2f0:	80 91 3d 01 	lds	r24, 0x013D
+ 2f4:	97 b9       	out	0x07, r25	; 7
+ 2f6:	84 60       	ori	r24, 0x04	; 4
+ 2f8:	8d b9       	out	0x0d, r24	; 13
+ 2fa:	08 95       	ret
+
+000002fc <OnKey>:
+ 2fc:	80 91 40 01 	lds	r24, 0x0140
+ 300:	81 30       	cpi	r24, 0x01	; 1
+ 302:	81 f0       	breq	.+32     	; 0x324 <OnKey+0x28>
+ 304:	83 b1       	in	r24, 0x03	; 3
+ 306:	90 e0       	ldi	r25, 0x00	; 0
+ 308:	80 78       	andi	r24, 0x80	; 128
+ 30a:	90 70       	andi	r25, 0x00	; 0
+ 30c:	80 93 53 01 	sts	0x0153, r24
+ 310:	89 2b       	or	r24, r25
+ 312:	41 f4       	brne	.+16     	; 0x324 <OnKey+0x28>
+ 314:	81 e0       	ldi	r24, 0x01	; 1
+ 316:	85 b9       	out	0x05, r24	; 5
+ 318:	81 e0       	ldi	r24, 0x01	; 1
+ 31a:	90 e0       	ldi	r25, 0x00	; 0
+ 31c:	90 93 42 01 	sts	0x0142, r25
+ 320:	80 93 41 01 	sts	0x0141, r24
+ 324:	08 95       	ret
+
+00000326 <KeyPressed>:
+ 326:	80 91 41 01 	lds	r24, 0x0141
+ 32a:	90 91 42 01 	lds	r25, 0x0142
+ 32e:	89 2b       	or	r24, r25
+ 330:	a9 f1       	breq	.+106    	; 0x39c <KeyPressed+0x76>
+ 332:	1f 99       	sbic	0x03, 7	; 3
+ 334:	1d c0       	rjmp	.+58     	; 0x370 <KeyPressed+0x4a>
+ 336:	80 91 45 01 	lds	r24, 0x0145
+ 33a:	90 91 46 01 	lds	r25, 0x0146
+ 33e:	01 96       	adiw	r24, 0x01	; 1
+ 340:	90 93 46 01 	sts	0x0146, r25
+ 344:	80 93 45 01 	sts	0x0145, r24
+ 348:	80 52       	subi	r24, 0x20	; 32
+ 34a:	93 40       	sbci	r25, 0x03	; 3
+ 34c:	89 f4       	brne	.+34     	; 0x370 <KeyPressed+0x4a>
+ 34e:	8c e3       	ldi	r24, 0x3C	; 60
+ 350:	90 e0       	ldi	r25, 0x00	; 0
+ 352:	90 93 44 01 	sts	0x0144, r25
+ 356:	80 93 43 01 	sts	0x0143, r24
+ 35a:	81 e0       	ldi	r24, 0x01	; 1
+ 35c:	80 93 40 01 	sts	0x0140, r24
+ 360:	10 92 42 01 	sts	0x0142, r1
+ 364:	10 92 41 01 	sts	0x0141, r1
+ 368:	10 92 46 01 	sts	0x0146, r1
+ 36c:	10 92 45 01 	sts	0x0145, r1
+ 370:	80 91 45 01 	lds	r24, 0x0145
+ 374:	90 91 46 01 	lds	r25, 0x0146
+ 378:	89 55       	subi	r24, 0x59	; 89
+ 37a:	92 40       	sbci	r25, 0x02	; 2
+ 37c:	87 3c       	cpi	r24, 0xC7	; 199
+ 37e:	91 05       	cpc	r25, r1
+ 380:	68 f4       	brcc	.+26     	; 0x39c <KeyPressed+0x76>
+ 382:	80 91 36 01 	lds	r24, 0x0136
+ 386:	80 93 43 01 	sts	0x0143, r24
+ 38a:	10 92 44 01 	sts	0x0144, r1
+ 38e:	81 e0       	ldi	r24, 0x01	; 1
+ 390:	80 93 40 01 	sts	0x0140, r24
+ 394:	10 92 42 01 	sts	0x0142, r1
+ 398:	10 92 41 01 	sts	0x0141, r1
+ 39c:	08 95       	ret
+
+0000039e <Init>:
+ 39e:	10 92 6b 00 	sts	0x006B, r1
+ 3a2:	10 92 6d 00 	sts	0x006D, r1
+ 3a6:	10 92 6a 00 	sts	0x006A, r1
+ 3aa:	17 b8       	out	0x07, r1	; 7
+ 3ac:	18 b8       	out	0x08, r1	; 8
+ 3ae:	8a b1       	in	r24, 0x0a	; 10
+ 3b0:	8c 70       	andi	r24, 0x0C	; 12
+ 3b2:	8a b9       	out	0x0a, r24	; 10
+ 3b4:	8b b1       	in	r24, 0x0b	; 11
+ 3b6:	1b b8       	out	0x0b, r1	; 11
+ 3b8:	84 e0       	ldi	r24, 0x04	; 4
+ 3ba:	8d b9       	out	0x0d, r24	; 13
+ 3bc:	1e b8       	out	0x0e, r1	; 14
+ 3be:	10 92 80 00 	sts	0x0080, r1
+ 3c2:	10 92 81 00 	sts	0x0081, r1
+ 3c6:	10 92 82 00 	sts	0x0082, r1
+ 3ca:	81 e0       	ldi	r24, 0x01	; 1
+ 3cc:	84 b9       	out	0x04, r24	; 4
+ 3ce:	15 b8       	out	0x05, r1	; 5
+ 3d0:	08 95       	ret
+
+000003d2 <main>:
+ 3d2:	1f 93       	push	r17
+ 3d4:	e4 df       	rcall	.-56     	; 0x39e <Init>
+ 3d6:	e7 e5       	ldi	r30, 0x57	; 87
+ 3d8:	f1 e0       	ldi	r31, 0x01	; 1
+ 3da:	11 92       	st	Z+, r1
+ 3dc:	81 e0       	ldi	r24, 0x01	; 1
+ 3de:	ef 35       	cpi	r30, 0x5F	; 95
+ 3e0:	f8 07       	cpc	r31, r24
+ 3e2:	d9 f7       	brne	.-10     	; 0x3da <main+0x8>
+ 3e4:	2e e0       	ldi	r18, 0x0E	; 14
+ 3e6:	88 e1       	ldi	r24, 0x18	; 24
+ 3e8:	90 e0       	ldi	r25, 0x00	; 0
+ 3ea:	0f b6       	in	r0, 0x3f	; 63
+ 3ec:	f8 94       	cli
+ 3ee:	a8 95       	wdr
+ 3f0:	80 93 60 00 	sts	0x0060, r24
+ 3f4:	0f be       	out	0x3f, r0	; 63
+ 3f6:	20 93 60 00 	sts	0x0060, r18
+ 3fa:	3b d0       	rcall	.+118    	; 0x472 <usbInit>
+ 3fc:	53 9a       	sbi	0x0a, 3	; 10
+ 3fe:	20 e0       	ldi	r18, 0x00	; 0
+ 400:	40 e7       	ldi	r20, 0x70	; 112
+ 402:	57 e1       	ldi	r21, 0x17	; 23
+ 404:	a8 95       	wdr
+ 406:	ca 01       	movw	r24, r20
+ 408:	01 97       	sbiw	r24, 0x01	; 1
+ 40a:	f1 f7       	brne	.-4      	; 0x408 <main+0x36>
+ 40c:	2f 5f       	subi	r18, 0xFF	; 255
+ 40e:	2a 3f       	cpi	r18, 0xFA	; 250
+ 410:	c9 f7       	brne	.-14     	; 0x404 <main+0x32>
+ 412:	3c d0       	rcall	.+120    	; 0x48c <usbPoll>
+ 414:	53 98       	cbi	0x0a, 3	; 10
+ 416:	f8 94       	cli
+ 418:	83 e0       	ldi	r24, 0x03	; 3
+ 41a:	85 bd       	out	0x25, r24	; 37
+ 41c:	81 e0       	ldi	r24, 0x01	; 1
+ 41e:	80 93 6e 00 	sts	0x006E, r24
+ 422:	78 94       	sei
+ 424:	12 e0       	ldi	r17, 0x02	; 2
+ 426:	7f df       	rcall	.-258    	; 0x326 <KeyPressed>
+ 428:	69 df       	rcall	.-302    	; 0x2fc <OnKey>
+ 42a:	bc de       	rcall	.-648    	; 0x1a4 <scanMatrix>
+ 42c:	a8 95       	wdr
+ 42e:	2e d0       	rcall	.+92     	; 0x48c <usbPoll>
+ 430:	80 91 6c 01 	lds	r24, 0x016C
+ 434:	84 ff       	sbrs	r24, 4
+ 436:	18 c0       	rjmp	.+48     	; 0x468 <main+0x96>
+ 438:	80 91 40 01 	lds	r24, 0x0140
+ 43c:	88 23       	and	r24, r24
+ 43e:	a1 f0       	breq	.+40     	; 0x468 <main+0x96>
+ 440:	81 30       	cpi	r24, 0x01	; 1
+ 442:	19 f0       	breq	.+6      	; 0x44a <main+0x78>
+ 444:	82 30       	cpi	r24, 0x02	; 2
+ 446:	71 f4       	brne	.+28     	; 0x464 <main+0x92>
+ 448:	09 c0       	rjmp	.+18     	; 0x45c <main+0x8a>
+ 44a:	80 91 43 01 	lds	r24, 0x0143
+ 44e:	10 92 57 01 	sts	0x0157, r1
+ 452:	80 93 59 01 	sts	0x0159, r24
+ 456:	10 93 40 01 	sts	0x0140, r17
+ 45a:	06 c0       	rjmp	.+12     	; 0x468 <main+0x96>
+ 45c:	10 92 57 01 	sts	0x0157, r1
+ 460:	10 92 59 01 	sts	0x0159, r1
+ 464:	10 92 40 01 	sts	0x0140, r1
+ 468:	87 e5       	ldi	r24, 0x57	; 87
+ 46a:	91 e0       	ldi	r25, 0x01	; 1
+ 46c:	68 e0       	ldi	r22, 0x08	; 8
+ 46e:	33 d1       	rcall	.+614    	; 0x6d6 <usbSetInterrupt>
+ 470:	da cf       	rjmp	.-76     	; 0x426 <main+0x54>
+
+00000472 <usbInit>:
+ 472:	e9 e6       	ldi	r30, 0x69	; 105
+ 474:	f0 e0       	ldi	r31, 0x00	; 0
+ 476:	80 81       	ld	r24, Z
+ 478:	82 60       	ori	r24, 0x02	; 2
+ 47a:	80 83       	st	Z, r24
+ 47c:	e8 9a       	sbi	0x1d, 0	; 29
+ 47e:	8b e4       	ldi	r24, 0x4B	; 75
+ 480:	80 93 6d 01 	sts	0x016D, r24
+ 484:	8a e5       	ldi	r24, 0x5A	; 90
+ 486:	80 93 6c 01 	sts	0x016C, r24
+ 48a:	08 95       	ret
+
+0000048c <usbPoll>:
+ 48c:	1f 93       	push	r17
+ 48e:	cf 93       	push	r28
+ 490:	df 93       	push	r29
+ 492:	60 91 7d 01 	lds	r22, 0x017D
+ 496:	63 50       	subi	r22, 0x03	; 3
+ 498:	67 fd       	sbrc	r22, 7
+ 49a:	c2 c0       	rjmp	.+388    	; 0x620 <usbPoll+0x194>
+ 49c:	80 91 7a 01 	lds	r24, 0x017A
+ 4a0:	cc e0       	ldi	r28, 0x0C	; 12
+ 4a2:	d0 e0       	ldi	r29, 0x00	; 0
+ 4a4:	c8 1b       	sub	r28, r24
+ 4a6:	d1 09       	sbc	r29, r1
+ 4a8:	cf 57       	subi	r28, 0x7F	; 127
+ 4aa:	de 4f       	sbci	r29, 0xFE	; 254
+ 4ac:	80 91 79 01 	lds	r24, 0x0179
+ 4b0:	8d 32       	cpi	r24, 0x2D	; 45
+ 4b2:	09 f0       	breq	.+2      	; 0x4b6 <usbPoll+0x2a>
+ 4b4:	a3 c0       	rjmp	.+326    	; 0x5fc <usbPoll+0x170>
+ 4b6:	68 30       	cpi	r22, 0x08	; 8
+ 4b8:	09 f0       	breq	.+2      	; 0x4bc <usbPoll+0x30>
+ 4ba:	b0 c0       	rjmp	.+352    	; 0x61c <usbPoll+0x190>
+ 4bc:	83 ec       	ldi	r24, 0xC3	; 195
+ 4be:	80 93 61 01 	sts	0x0161, r24
+ 4c2:	8a e5       	ldi	r24, 0x5A	; 90
+ 4c4:	80 93 3e 01 	sts	0x013E, r24
+ 4c8:	10 92 60 01 	sts	0x0160, r1
+ 4cc:	88 81       	ld	r24, Y
+ 4ce:	80 76       	andi	r24, 0x60	; 96
+ 4d0:	39 f0       	breq	.+14     	; 0x4e0 <usbPoll+0x54>
+ 4d2:	ce 01       	movw	r24, r28
+ 4d4:	19 de       	rcall	.-974    	; 0x108 <usbFunctionSetup>
+ 4d6:	28 2f       	mov	r18, r24
+ 4d8:	8f 3f       	cpi	r24, 0xFF	; 255
+ 4da:	09 f4       	brne	.+2      	; 0x4de <usbPoll+0x52>
+ 4dc:	7e c0       	rjmp	.+252    	; 0x5da <usbPoll+0x14e>
+ 4de:	84 c0       	rjmp	.+264    	; 0x5e8 <usbPoll+0x15c>
+ 4e0:	9a 81       	ldd	r25, Y+2	; 0x02
+ 4e2:	10 92 6a 01 	sts	0x016A, r1
+ 4e6:	89 81       	ldd	r24, Y+1	; 0x01
+ 4e8:	88 23       	and	r24, r24
+ 4ea:	21 f4       	brne	.+8      	; 0x4f4 <usbPoll+0x68>
+ 4ec:	10 92 6b 01 	sts	0x016B, r1
+ 4f0:	22 e0       	ldi	r18, 0x02	; 2
+ 4f2:	6c c0       	rjmp	.+216    	; 0x5cc <usbPoll+0x140>
+ 4f4:	85 30       	cpi	r24, 0x05	; 5
+ 4f6:	19 f4       	brne	.+6      	; 0x4fe <usbPoll+0x72>
+ 4f8:	90 93 7e 01 	sts	0x017E, r25
+ 4fc:	66 c0       	rjmp	.+204    	; 0x5ca <usbPoll+0x13e>
+ 4fe:	86 30       	cpi	r24, 0x06	; 6
+ 500:	09 f0       	breq	.+2      	; 0x504 <usbPoll+0x78>
+ 502:	4f c0       	rjmp	.+158    	; 0x5a2 <usbPoll+0x116>
+ 504:	8b 81       	ldd	r24, Y+3	; 0x03
+ 506:	81 30       	cpi	r24, 0x01	; 1
+ 508:	41 f4       	brne	.+16     	; 0x51a <usbPoll+0x8e>
+ 50a:	8b e9       	ldi	r24, 0x9B	; 155
+ 50c:	90 e0       	ldi	r25, 0x00	; 0
+ 50e:	90 93 7c 01 	sts	0x017C, r25
+ 512:	80 93 7b 01 	sts	0x017B, r24
+ 516:	22 e1       	ldi	r18, 0x12	; 18
+ 518:	40 c0       	rjmp	.+128    	; 0x59a <usbPoll+0x10e>
+ 51a:	82 30       	cpi	r24, 0x02	; 2
+ 51c:	41 f4       	brne	.+16     	; 0x52e <usbPoll+0xa2>
+ 51e:	8d ea       	ldi	r24, 0xAD	; 173
+ 520:	90 e0       	ldi	r25, 0x00	; 0
+ 522:	90 93 7c 01 	sts	0x017C, r25
+ 526:	80 93 7b 01 	sts	0x017B, r24
+ 52a:	22 e2       	ldi	r18, 0x22	; 34
+ 52c:	36 c0       	rjmp	.+108    	; 0x59a <usbPoll+0x10e>
+ 52e:	83 30       	cpi	r24, 0x03	; 3
+ 530:	f9 f4       	brne	.+62     	; 0x570 <usbPoll+0xe4>
+ 532:	8a 81       	ldd	r24, Y+2	; 0x02
+ 534:	88 23       	and	r24, r24
+ 536:	41 f4       	brne	.+16     	; 0x548 <usbPoll+0xbc>
+ 538:	87 e6       	ldi	r24, 0x67	; 103
+ 53a:	90 e0       	ldi	r25, 0x00	; 0
+ 53c:	90 93 7c 01 	sts	0x017C, r25
+ 540:	80 93 7b 01 	sts	0x017B, r24
+ 544:	24 e0       	ldi	r18, 0x04	; 4
+ 546:	29 c0       	rjmp	.+82     	; 0x59a <usbPoll+0x10e>
+ 548:	81 30       	cpi	r24, 0x01	; 1
+ 54a:	41 f4       	brne	.+16     	; 0x55c <usbPoll+0xd0>
+ 54c:	8b e6       	ldi	r24, 0x6B	; 107
+ 54e:	90 e0       	ldi	r25, 0x00	; 0
+ 550:	90 93 7c 01 	sts	0x017C, r25
+ 554:	80 93 7b 01 	sts	0x017B, r24
+ 558:	20 e2       	ldi	r18, 0x20	; 32
+ 55a:	1f c0       	rjmp	.+62     	; 0x59a <usbPoll+0x10e>
+ 55c:	82 30       	cpi	r24, 0x02	; 2
+ 55e:	e1 f4       	brne	.+56     	; 0x598 <usbPoll+0x10c>
+ 560:	8b e8       	ldi	r24, 0x8B	; 139
+ 562:	90 e0       	ldi	r25, 0x00	; 0
+ 564:	90 93 7c 01 	sts	0x017C, r25
+ 568:	80 93 7b 01 	sts	0x017B, r24
+ 56c:	20 e1       	ldi	r18, 0x10	; 16
+ 56e:	15 c0       	rjmp	.+42     	; 0x59a <usbPoll+0x10e>
+ 570:	81 32       	cpi	r24, 0x21	; 33
+ 572:	41 f4       	brne	.+16     	; 0x584 <usbPoll+0xf8>
+ 574:	8f eb       	ldi	r24, 0xBF	; 191
+ 576:	90 e0       	ldi	r25, 0x00	; 0
+ 578:	90 93 7c 01 	sts	0x017C, r25
+ 57c:	80 93 7b 01 	sts	0x017B, r24
+ 580:	29 e0       	ldi	r18, 0x09	; 9
+ 582:	0b c0       	rjmp	.+22     	; 0x59a <usbPoll+0x10e>
+ 584:	82 32       	cpi	r24, 0x22	; 34
+ 586:	41 f4       	brne	.+16     	; 0x598 <usbPoll+0x10c>
+ 588:	88 e2       	ldi	r24, 0x28	; 40
+ 58a:	90 e0       	ldi	r25, 0x00	; 0
+ 58c:	90 93 7c 01 	sts	0x017C, r25
+ 590:	80 93 7b 01 	sts	0x017B, r24
+ 594:	2f e3       	ldi	r18, 0x3F	; 63
+ 596:	01 c0       	rjmp	.+2      	; 0x59a <usbPoll+0x10e>
+ 598:	20 e0       	ldi	r18, 0x00	; 0
+ 59a:	80 e4       	ldi	r24, 0x40	; 64
+ 59c:	80 93 60 01 	sts	0x0160, r24
+ 5a0:	23 c0       	rjmp	.+70     	; 0x5e8 <usbPoll+0x15c>
+ 5a2:	88 30       	cpi	r24, 0x08	; 8
+ 5a4:	21 f4       	brne	.+8      	; 0x5ae <usbPoll+0x122>
+ 5a6:	21 e0       	ldi	r18, 0x01	; 1
+ 5a8:	80 e8       	ldi	r24, 0x80	; 128
+ 5aa:	91 e0       	ldi	r25, 0x01	; 1
+ 5ac:	11 c0       	rjmp	.+34     	; 0x5d0 <usbPoll+0x144>
+ 5ae:	89 30       	cpi	r24, 0x09	; 9
+ 5b0:	19 f4       	brne	.+6      	; 0x5b8 <usbPoll+0x12c>
+ 5b2:	90 93 80 01 	sts	0x0180, r25
+ 5b6:	09 c0       	rjmp	.+18     	; 0x5ca <usbPoll+0x13e>
+ 5b8:	8a 30       	cpi	r24, 0x0A	; 10
+ 5ba:	11 f4       	brne	.+4      	; 0x5c0 <usbPoll+0x134>
+ 5bc:	21 e0       	ldi	r18, 0x01	; 1
+ 5be:	06 c0       	rjmp	.+12     	; 0x5cc <usbPoll+0x140>
+ 5c0:	8b 30       	cpi	r24, 0x0B	; 11
+ 5c2:	19 f4       	brne	.+6      	; 0x5ca <usbPoll+0x13e>
+ 5c4:	8b e4       	ldi	r24, 0x4B	; 75
+ 5c6:	80 93 6d 01 	sts	0x016D, r24
+ 5ca:	20 e0       	ldi	r18, 0x00	; 0
+ 5cc:	8a e6       	ldi	r24, 0x6A	; 106
+ 5ce:	91 e0       	ldi	r25, 0x01	; 1
+ 5d0:	90 93 7c 01 	sts	0x017C, r25
+ 5d4:	80 93 7b 01 	sts	0x017B, r24
+ 5d8:	07 c0       	rjmp	.+14     	; 0x5e8 <usbPoll+0x15c>
+ 5da:	88 81       	ld	r24, Y
+ 5dc:	87 fd       	sbrc	r24, 7
+ 5de:	2e 81       	ldd	r18, Y+6	; 0x06
+ 5e0:	80 e8       	ldi	r24, 0x80	; 128
+ 5e2:	80 93 60 01 	sts	0x0160, r24
+ 5e6:	06 c0       	rjmp	.+12     	; 0x5f4 <usbPoll+0x168>
+ 5e8:	8f 81       	ldd	r24, Y+7	; 0x07
+ 5ea:	88 23       	and	r24, r24
+ 5ec:	19 f4       	brne	.+6      	; 0x5f4 <usbPoll+0x168>
+ 5ee:	8e 81       	ldd	r24, Y+6	; 0x06
+ 5f0:	82 17       	cp	r24, r18
+ 5f2:	08 f0       	brcs	.+2      	; 0x5f6 <usbPoll+0x16a>
+ 5f4:	82 2f       	mov	r24, r18
+ 5f6:	80 93 3f 01 	sts	0x013F, r24
+ 5fa:	10 c0       	rjmp	.+32     	; 0x61c <usbPoll+0x190>
+ 5fc:	80 91 60 01 	lds	r24, 0x0160
+ 600:	87 ff       	sbrs	r24, 7
+ 602:	0c c0       	rjmp	.+24     	; 0x61c <usbPoll+0x190>
+ 604:	ce 01       	movw	r24, r28
+ 606:	b3 dd       	rcall	.-1178   	; 0x16e <usbFunctionWrite>
+ 608:	8f 3f       	cpi	r24, 0xFF	; 255
+ 60a:	21 f4       	brne	.+8      	; 0x614 <usbPoll+0x188>
+ 60c:	8e e1       	ldi	r24, 0x1E	; 30
+ 60e:	80 93 3e 01 	sts	0x013E, r24
+ 612:	04 c0       	rjmp	.+8      	; 0x61c <usbPoll+0x190>
+ 614:	88 23       	and	r24, r24
+ 616:	11 f0       	breq	.+4      	; 0x61c <usbPoll+0x190>
+ 618:	10 92 3f 01 	sts	0x013F, r1
+ 61c:	10 92 7d 01 	sts	0x017D, r1
+ 620:	80 91 3e 01 	lds	r24, 0x013E
+ 624:	84 ff       	sbrs	r24, 4
+ 626:	49 c0       	rjmp	.+146    	; 0x6ba <usbPoll+0x22e>
+ 628:	80 91 3f 01 	lds	r24, 0x013F
+ 62c:	8f 3f       	cpi	r24, 0xFF	; 255
+ 62e:	09 f4       	brne	.+2      	; 0x632 <usbPoll+0x1a6>
+ 630:	44 c0       	rjmp	.+136    	; 0x6ba <usbPoll+0x22e>
+ 632:	18 2f       	mov	r17, r24
+ 634:	89 30       	cpi	r24, 0x09	; 9
+ 636:	08 f0       	brcs	.+2      	; 0x63a <usbPoll+0x1ae>
+ 638:	18 e0       	ldi	r17, 0x08	; 8
+ 63a:	81 1b       	sub	r24, r17
+ 63c:	80 93 3f 01 	sts	0x013F, r24
+ 640:	80 91 61 01 	lds	r24, 0x0161
+ 644:	98 e8       	ldi	r25, 0x88	; 136
+ 646:	89 27       	eor	r24, r25
+ 648:	80 93 61 01 	sts	0x0161, r24
+ 64c:	11 23       	and	r17, r17
+ 64e:	41 f1       	breq	.+80     	; 0x6a0 <usbPoll+0x214>
+ 650:	20 91 7b 01 	lds	r18, 0x017B
+ 654:	30 91 7c 01 	lds	r19, 0x017C
+ 658:	80 91 60 01 	lds	r24, 0x0160
+ 65c:	86 ff       	sbrs	r24, 6
+ 65e:	0d c0       	rjmp	.+26     	; 0x67a <usbPoll+0x1ee>
+ 660:	a2 e6       	ldi	r26, 0x62	; 98
+ 662:	b1 e0       	ldi	r27, 0x01	; 1
+ 664:	80 e0       	ldi	r24, 0x00	; 0
+ 666:	90 e0       	ldi	r25, 0x00	; 0
+ 668:	f9 01       	movw	r30, r18
+ 66a:	e8 0f       	add	r30, r24
+ 66c:	f9 1f       	adc	r31, r25
+ 66e:	e4 91       	lpm	r30, Z+
+ 670:	ed 93       	st	X+, r30
+ 672:	01 96       	adiw	r24, 0x01	; 1
+ 674:	18 17       	cp	r17, r24
+ 676:	c1 f7       	brne	.-16     	; 0x668 <usbPoll+0x1dc>
+ 678:	08 c0       	rjmp	.+16     	; 0x68a <usbPoll+0x1fe>
+ 67a:	91 2f       	mov	r25, r17
+ 67c:	d9 01       	movw	r26, r18
+ 67e:	e2 e6       	ldi	r30, 0x62	; 98
+ 680:	f1 e0       	ldi	r31, 0x01	; 1
+ 682:	8d 91       	ld	r24, X+
+ 684:	81 93       	st	Z+, r24
+ 686:	91 50       	subi	r25, 0x01	; 1
+ 688:	e1 f7       	brne	.-8      	; 0x682 <usbPoll+0x1f6>
+ 68a:	11 50       	subi	r17, 0x01	; 1
+ 68c:	81 2f       	mov	r24, r17
+ 68e:	90 e0       	ldi	r25, 0x00	; 0
+ 690:	1f 5f       	subi	r17, 0xFF	; 255
+ 692:	01 96       	adiw	r24, 0x01	; 1
+ 694:	82 0f       	add	r24, r18
+ 696:	93 1f       	adc	r25, r19
+ 698:	90 93 7c 01 	sts	0x017C, r25
+ 69c:	80 93 7b 01 	sts	0x017B, r24
+ 6a0:	82 e6       	ldi	r24, 0x62	; 98
+ 6a2:	91 e0       	ldi	r25, 0x01	; 1
+ 6a4:	61 2f       	mov	r22, r17
+ 6a6:	4e d0       	rcall	.+156    	; 0x744 <usbCrc16Append>
+ 6a8:	61 2f       	mov	r22, r17
+ 6aa:	6c 5f       	subi	r22, 0xFC	; 252
+ 6ac:	6c 30       	cpi	r22, 0x0C	; 12
+ 6ae:	19 f0       	breq	.+6      	; 0x6b6 <usbPoll+0x22a>
+ 6b0:	8f ef       	ldi	r24, 0xFF	; 255
+ 6b2:	80 93 3f 01 	sts	0x013F, r24
+ 6b6:	60 93 3e 01 	sts	0x013E, r22
+ 6ba:	94 e1       	ldi	r25, 0x14	; 20
+ 6bc:	89 b1       	in	r24, 0x09	; 9
+ 6be:	8c 70       	andi	r24, 0x0C	; 12
+ 6c0:	31 f4       	brne	.+12     	; 0x6ce <usbPoll+0x242>
+ 6c2:	91 50       	subi	r25, 0x01	; 1
+ 6c4:	d9 f7       	brne	.-10     	; 0x6bc <usbPoll+0x230>
+ 6c6:	10 92 7e 01 	sts	0x017E, r1
+ 6ca:	10 92 78 01 	sts	0x0178, r1
+ 6ce:	df 91       	pop	r29
+ 6d0:	cf 91       	pop	r28
+ 6d2:	1f 91       	pop	r17
+ 6d4:	08 95       	ret
+
+000006d6 <usbSetInterrupt>:
+ 6d6:	1f 93       	push	r17
+ 6d8:	dc 01       	movw	r26, r24
+ 6da:	16 2f       	mov	r17, r22
+ 6dc:	80 91 6c 01 	lds	r24, 0x016C
+ 6e0:	84 ff       	sbrs	r24, 4
+ 6e2:	07 c0       	rjmp	.+14     	; 0x6f2 <usbSetInterrupt+0x1c>
+ 6e4:	80 91 6d 01 	lds	r24, 0x016D
+ 6e8:	98 e8       	ldi	r25, 0x88	; 136
+ 6ea:	89 27       	eor	r24, r25
+ 6ec:	80 93 6d 01 	sts	0x016D, r24
+ 6f0:	03 c0       	rjmp	.+6      	; 0x6f8 <usbSetInterrupt+0x22>
+ 6f2:	8a e5       	ldi	r24, 0x5A	; 90
+ 6f4:	80 93 6c 01 	sts	0x016C, r24
+ 6f8:	91 2f       	mov	r25, r17
+ 6fa:	ee e6       	ldi	r30, 0x6E	; 110
+ 6fc:	f1 e0       	ldi	r31, 0x01	; 1
+ 6fe:	8d 91       	ld	r24, X+
+ 700:	81 93       	st	Z+, r24
+ 702:	91 50       	subi	r25, 0x01	; 1
+ 704:	19 16       	cp	r1, r25
+ 706:	dc f3       	brlt	.-10     	; 0x6fe <usbSetInterrupt+0x28>
+ 708:	8e e6       	ldi	r24, 0x6E	; 110
+ 70a:	91 e0       	ldi	r25, 0x01	; 1
+ 70c:	61 2f       	mov	r22, r17
+ 70e:	1a d0       	rcall	.+52     	; 0x744 <usbCrc16Append>
+ 710:	1c 5f       	subi	r17, 0xFC	; 252
+ 712:	10 93 6c 01 	sts	0x016C, r17
+ 716:	1f 91       	pop	r17
+ 718:	08 95       	ret
+
+0000071a <usbCrc16>:
+ 71a:	a8 2f       	mov	r26, r24
+ 71c:	b9 2f       	mov	r27, r25
+ 71e:	80 e0       	ldi	r24, 0x00	; 0
+ 720:	90 e0       	ldi	r25, 0x00	; 0
+ 722:	41 e0       	ldi	r20, 0x01	; 1
+ 724:	50 ea       	ldi	r21, 0xA0	; 160
+ 726:	60 95       	com	r22
+ 728:	30 e0       	ldi	r19, 0x00	; 0
+ 72a:	09 c0       	rjmp	.+18     	; 0x73e <usbCrcLoopEntry>
+
+0000072c <usbCrcByteLoop>:
+ 72c:	2d 91       	ld	r18, X+
+ 72e:	82 27       	eor	r24, r18
+
+00000730 <usbCrcBitLoop>:
+ 730:	97 95       	ror	r25
+ 732:	87 95       	ror	r24
+ 734:	10 f0       	brcs	.+4      	; 0x73a <usbCrcNoXor>
+ 736:	84 27       	eor	r24, r20
+ 738:	95 27       	eor	r25, r21
+
+0000073a <usbCrcNoXor>:
+ 73a:	30 5e       	subi	r19, 0xE0	; 224
+ 73c:	c8 f3       	brcs	.-14     	; 0x730 <usbCrcBitLoop>
+
+0000073e <usbCrcLoopEntry>:
+ 73e:	6f 5f       	subi	r22, 0xFF	; 255
+ 740:	a8 f3       	brcs	.-22     	; 0x72c <usbCrcByteLoop>
+
+00000742 <usbCrcReady>:
+ 742:	08 95       	ret
+
+00000744 <usbCrc16Append>:
+ 744:	ea df       	rcall	.-44     	; 0x71a <usbCrc16>
+ 746:	8d 93       	st	X+, r24
+ 748:	9d 93       	st	X+, r25
+ 74a:	08 95       	ret
+
+0000074c <__vector_1>:
+ 74c:	cf 93       	push	r28
+ 74e:	cf b7       	in	r28, 0x3f	; 63
+ 750:	cf 93       	push	r28
+
+00000752 <waitForJ>:
+ 752:	c3 95       	inc	r28
+ 754:	4b 9b       	sbis	0x09, 3	; 9
+ 756:	e9 f7       	brne	.-6      	; 0x752 <waitForJ>
+
+00000758 <waitForK>:
+ 758:	4b 9b       	sbis	0x09, 3	; 9
+ 75a:	09 c0       	rjmp	.+18     	; 0x76e <foundK>
+ 75c:	4b 9b       	sbis	0x09, 3	; 9
+ 75e:	07 c0       	rjmp	.+14     	; 0x76e <foundK>
+ 760:	4b 9b       	sbis	0x09, 3	; 9
+ 762:	05 c0       	rjmp	.+10     	; 0x76e <foundK>
+ 764:	4b 9b       	sbis	0x09, 3	; 9
+ 766:	03 c0       	rjmp	.+6      	; 0x76e <foundK>
+ 768:	4b 9b       	sbis	0x09, 3	; 9
+ 76a:	01 c0       	rjmp	.+2      	; 0x76e <foundK>
+ 76c:	a3 c0       	rjmp	.+326    	; 0x8b4 <sofError>
+
+0000076e <foundK>:
+ 76e:	df 93       	push	r29
+ 770:	c0 91 7a 01 	lds	r28, 0x017A
+ 774:	dd 27       	eor	r29, r29
+ 776:	cf 57       	subi	r28, 0x7F	; 127
+ 778:	de 4f       	sbci	r29, 0xFE	; 254
+ 77a:	4b 9b       	sbis	0x09, 3	; 9
+ 77c:	02 c0       	rjmp	.+4      	; 0x782 <haveTwoBitsK>
+ 77e:	df 91       	pop	r29
+ 780:	eb cf       	rjmp	.-42     	; 0x758 <waitForK>
+
+00000782 <haveTwoBitsK>:
+ 782:	2f 93       	push	r18
+ 784:	0f 93       	push	r16
+ 786:	1f 93       	push	r17
+ 788:	09 b1       	in	r16, 0x09	; 9
+ 78a:	2f ef       	ldi	r18, 0xFF	; 255
+ 78c:	03 fb       	bst	r16, 3
+ 78e:	20 f9       	bld	r18, 0
+ 790:	4f 93       	push	r20
+ 792:	3f 93       	push	r19
+ 794:	19 b1       	in	r17, 0x09	; 9
+ 796:	4f ef       	ldi	r20, 0xFF	; 255
+ 798:	01 27       	eor	r16, r17
+ 79a:	03 fb       	bst	r16, 3
+ 79c:	21 f9       	bld	r18, 1
+ 79e:	3b e0       	ldi	r19, 0x0B	; 11
+ 7a0:	31 c0       	rjmp	.+98     	; 0x804 <rxbit2>
+
+000007a2 <unstuff0>:
+ 7a2:	4e 7f       	andi	r20, 0xFE	; 254
+ 7a4:	01 2f       	mov	r16, r17
+ 7a6:	19 b1       	in	r17, 0x09	; 9
+ 7a8:	21 60       	ori	r18, 0x01	; 1
+ 7aa:	28 c0       	rjmp	.+80     	; 0x7fc <didUnstuff0>
+
+000007ac <unstuff1>:
+ 7ac:	10 2f       	mov	r17, r16
+ 7ae:	4d 7f       	andi	r20, 0xFD	; 253
+ 7b0:	22 60       	ori	r18, 0x02	; 2
+ 7b2:	00 00       	nop
+ 7b4:	09 b1       	in	r16, 0x09	; 9
+ 7b6:	29 c0       	rjmp	.+82     	; 0x80a <didUnstuff1>
+
+000007b8 <unstuff2>:
+ 7b8:	4b 7f       	andi	r20, 0xFB	; 251
+ 7ba:	24 60       	ori	r18, 0x04	; 4
+ 7bc:	01 2f       	mov	r16, r17
+ 7be:	00 00       	nop
+ 7c0:	19 b1       	in	r17, 0x09	; 9
+ 7c2:	2b c0       	rjmp	.+86     	; 0x81a <didUnstuff2>
+
+000007c4 <unstuff3>:
+ 7c4:	19 b1       	in	r17, 0x09	; 9
+ 7c6:	47 7f       	andi	r20, 0xF7	; 247
+ 7c8:	28 60       	ori	r18, 0x08	; 8
+ 7ca:	2a c0       	rjmp	.+84     	; 0x820 <didUnstuff3>
+
+000007cc <unstuff4>:
+ 7cc:	4f 7e       	andi	r20, 0xEF	; 239
+ 7ce:	09 b1       	in	r16, 0x09	; 9
+ 7d0:	20 61       	ori	r18, 0x10	; 16
+ 7d2:	2c c0       	rjmp	.+88     	; 0x82c <didUnstuff4>
+
+000007d4 <unstuff5>:
+ 7d4:	4f 7d       	andi	r20, 0xDF	; 223
+ 7d6:	19 b1       	in	r17, 0x09	; 9
+ 7d8:	20 62       	ori	r18, 0x20	; 32
+ 7da:	2f c0       	rjmp	.+94     	; 0x83a <didUnstuff5>
+
+000007dc <unstuff6>:
+ 7dc:	4f 7b       	andi	r20, 0xBF	; 191
+ 7de:	09 b1       	in	r16, 0x09	; 9
+ 7e0:	20 64       	ori	r18, 0x40	; 64
+ 7e2:	32 c0       	rjmp	.+100    	; 0x848 <didUnstuff6>
+
+000007e4 <rxLoop>:
+ 7e4:	42 27       	eor	r20, r18
+ 7e6:	09 b1       	in	r16, 0x09	; 9
+ 7e8:	49 93       	st	Y+, r20
+ 7ea:	4f ef       	ldi	r20, 0xFF	; 255
+ 7ec:	00 00       	nop
+ 7ee:	10 27       	eor	r17, r16
+ 7f0:	13 fb       	bst	r17, 3
+ 7f2:	20 f9       	bld	r18, 0
+ 7f4:	19 b1       	in	r17, 0x09	; 9
+ 7f6:	1c 70       	andi	r17, 0x0C	; 12
+ 7f8:	c9 f1       	breq	.+114    	; 0x86c <se0>
+ 7fa:	29 7f       	andi	r18, 0xF9	; 249
+
+000007fc <didUnstuff0>:
+ 7fc:	91 f2       	breq	.-92     	; 0x7a2 <unstuff0>
+ 7fe:	01 27       	eor	r16, r17
+ 800:	03 fb       	bst	r16, 3
+ 802:	21 f9       	bld	r18, 1
+
+00000804 <rxbit2>:
+ 804:	09 b1       	in	r16, 0x09	; 9
+ 806:	23 7f       	andi	r18, 0xF3	; 243
+ 808:	89 f2       	breq	.-94     	; 0x7ac <unstuff1>
+
+0000080a <didUnstuff1>:
+ 80a:	31 50       	subi	r19, 0x01	; 1
+ 80c:	58 f1       	brcs	.+86     	; 0x864 <overflow>
+ 80e:	10 27       	eor	r17, r16
+ 810:	13 fb       	bst	r17, 3
+ 812:	22 f9       	bld	r18, 2
+ 814:	19 b1       	in	r17, 0x09	; 9
+ 816:	27 7e       	andi	r18, 0xE7	; 231
+ 818:	79 f2       	breq	.-98     	; 0x7b8 <unstuff2>
+
+0000081a <didUnstuff2>:
+ 81a:	01 27       	eor	r16, r17
+ 81c:	03 fb       	bst	r16, 3
+ 81e:	23 f9       	bld	r18, 3
+
+00000820 <didUnstuff3>:
+ 820:	2f 7c       	andi	r18, 0xCF	; 207
+ 822:	81 f2       	breq	.-96     	; 0x7c4 <unstuff3>
+ 824:	09 b1       	in	r16, 0x09	; 9
+ 826:	10 27       	eor	r17, r16
+ 828:	13 fb       	bst	r17, 3
+ 82a:	24 f9       	bld	r18, 4
+
+0000082c <didUnstuff4>:
+ 82c:	2f 79       	andi	r18, 0x9F	; 159
+ 82e:	71 f2       	breq	.-100    	; 0x7cc <unstuff4>
+ 830:	00 c0       	rjmp	.+0      	; 0x832 <didUnstuff4+0x6>
+ 832:	19 b1       	in	r17, 0x09	; 9
+ 834:	01 27       	eor	r16, r17
+ 836:	03 fb       	bst	r16, 3
+ 838:	25 f9       	bld	r18, 5
+
+0000083a <didUnstuff5>:
+ 83a:	2f 73       	andi	r18, 0x3F	; 63
+ 83c:	59 f2       	breq	.-106    	; 0x7d4 <unstuff5>
+ 83e:	00 c0       	rjmp	.+0      	; 0x840 <didUnstuff5+0x6>
+ 840:	09 b1       	in	r16, 0x09	; 9
+ 842:	10 27       	eor	r17, r16
+ 844:	13 fb       	bst	r17, 3
+ 846:	26 f9       	bld	r18, 6
+
+00000848 <didUnstuff6>:
+ 848:	22 30       	cpi	r18, 0x02	; 2
+ 84a:	40 f2       	brcs	.-112    	; 0x7dc <unstuff6>
+ 84c:	00 c0       	rjmp	.+0      	; 0x84e <didUnstuff6+0x6>
+ 84e:	19 b1       	in	r17, 0x09	; 9
+ 850:	01 27       	eor	r16, r17
+ 852:	03 fb       	bst	r16, 3
+ 854:	27 f9       	bld	r18, 7
+
+00000856 <didUnstuff7>:
+ 856:	24 30       	cpi	r18, 0x04	; 4
+ 858:	28 f6       	brcc	.-118    	; 0x7e4 <rxLoop>
+
+0000085a <unstuff7>:
+ 85a:	4f 77       	andi	r20, 0x7F	; 127
+ 85c:	20 68       	ori	r18, 0x80	; 128
+ 85e:	19 b1       	in	r17, 0x09	; 9
+ 860:	00 00       	nop
+ 862:	f9 cf       	rjmp	.-14     	; 0x856 <didUnstuff7>
+
+00000864 <overflow>:
+ 864:	11 e0       	ldi	r17, 0x01	; 1
+ 866:	1c bb       	out	0x1c, r17	; 28
+
+00000868 <ignorePacket>:
+ 868:	00 27       	eor	r16, r16
+ 86a:	19 c0       	rjmp	.+50     	; 0x89e <handleSetupOrOut>
+
+0000086c <se0>:
+ 86c:	3b 50       	subi	r19, 0x0B	; 11
+ 86e:	31 95       	neg	r19
+ 870:	c3 1b       	sub	r28, r19
+ 872:	d0 40       	sbci	r29, 0x00	; 0
+ 874:	11 e0       	ldi	r17, 0x01	; 1
+ 876:	1c bb       	out	0x1c, r17	; 28
+ 878:	08 81       	ld	r16, Y
+ 87a:	03 3c       	cpi	r16, 0xC3	; 195
+ 87c:	f9 f0       	breq	.+62     	; 0x8bc <handleData>
+ 87e:	0b 34       	cpi	r16, 0x4B	; 75
+ 880:	e9 f0       	breq	.+58     	; 0x8bc <handleData>
+ 882:	20 91 78 01 	lds	r18, 0x0178
+ 886:	19 81       	ldd	r17, Y+1	; 0x01
+ 888:	11 0f       	add	r17, r17
+ 88a:	12 13       	cpse	r17, r18
+ 88c:	ed cf       	rjmp	.-38     	; 0x868 <ignorePacket>
+ 88e:	4a 81       	ldd	r20, Y+2	; 0x02
+ 890:	44 1f       	adc	r20, r20
+ 892:	09 36       	cpi	r16, 0x69	; 105
+ 894:	41 f1       	breq	.+80     	; 0x8e6 <handleIn>
+ 896:	0d 32       	cpi	r16, 0x2D	; 45
+ 898:	11 f0       	breq	.+4      	; 0x89e <handleSetupOrOut>
+ 89a:	01 3e       	cpi	r16, 0xE1	; 225
+ 89c:	29 f7       	brne	.-54     	; 0x868 <ignorePacket>
+
+0000089e <handleSetupOrOut>:
+ 89e:	00 93 7f 01 	sts	0x017F, r16
+
+000008a2 <doReturn>:
+ 8a2:	3f 91       	pop	r19
+ 8a4:	4f 91       	pop	r20
+ 8a6:	1f 91       	pop	r17
+ 8a8:	0f 91       	pop	r16
+ 8aa:	2f 91       	pop	r18
+ 8ac:	df 91       	pop	r29
+ 8ae:	cc b3       	in	r28, 0x1c	; 28
+ 8b0:	c0 fd       	sbrc	r28, 0
+ 8b2:	4f cf       	rjmp	.-354    	; 0x752 <waitForJ>
+
+000008b4 <sofError>:
+ 8b4:	cf 91       	pop	r28
+ 8b6:	cf bf       	out	0x3f, r28	; 63
+ 8b8:	cf 91       	pop	r28
+ 8ba:	18 95       	reti
+
+000008bc <handleData>:
+ 8bc:	20 91 7f 01 	lds	r18, 0x017F
+ 8c0:	22 23       	and	r18, r18
+ 8c2:	79 f3       	breq	.-34     	; 0x8a2 <doReturn>
+ 8c4:	10 91 7d 01 	lds	r17, 0x017D
+ 8c8:	11 23       	and	r17, r17
+ 8ca:	69 f5       	brne	.+90     	; 0x926 <sendNakAndReti>
+ 8cc:	34 30       	cpi	r19, 0x04	; 4
+ 8ce:	6a f1       	brmi	.+90     	; 0x92a <sendAckAndReti>
+ 8d0:	30 93 7d 01 	sts	0x017D, r19
+ 8d4:	20 93 79 01 	sts	0x0179, r18
+ 8d8:	10 91 7a 01 	lds	r17, 0x017A
+ 8dc:	3b e0       	ldi	r19, 0x0B	; 11
+ 8de:	31 1b       	sub	r19, r17
+ 8e0:	30 93 7a 01 	sts	0x017A, r19
+ 8e4:	22 c0       	rjmp	.+68     	; 0x92a <sendAckAndReti>
+
+000008e6 <handleIn>:
+ 8e6:	00 91 7d 01 	lds	r16, 0x017D
+ 8ea:	01 30       	cpi	r16, 0x01	; 1
+ 8ec:	e4 f4       	brge	.+56     	; 0x926 <sendNakAndReti>
+ 8ee:	0a e5       	ldi	r16, 0x5A	; 90
+ 8f0:	4f 70       	andi	r20, 0x0F	; 15
+ 8f2:	49 f4       	brne	.+18     	; 0x906 <handleIn1>
+ 8f4:	30 91 3e 01 	lds	r19, 0x013E
+ 8f8:	34 fd       	sbrc	r19, 4
+ 8fa:	19 c0       	rjmp	.+50     	; 0x92e <sendCntAndReti>
+ 8fc:	00 93 3e 01 	sts	0x013E, r16
+ 900:	c1 e6       	ldi	r28, 0x61	; 97
+ 902:	d1 e0       	ldi	r29, 0x01	; 1
+ 904:	18 c0       	rjmp	.+48     	; 0x936 <usbSendAndReti>
+
+00000906 <handleIn1>:
+ 906:	30 91 6c 01 	lds	r19, 0x016C
+ 90a:	34 fd       	sbrc	r19, 4
+ 90c:	10 c0       	rjmp	.+32     	; 0x92e <sendCntAndReti>
+ 90e:	00 93 6c 01 	sts	0x016C, r16
+ 912:	cd e6       	ldi	r28, 0x6D	; 109
+ 914:	d1 e0       	ldi	r29, 0x01	; 1
+ 916:	0f c0       	rjmp	.+30     	; 0x936 <usbSendAndReti>
+
+00000918 <stuffN1Delay>:
+ 918:	27 95       	ror	r18
+ 91a:	a8 f4       	brcc	.+42     	; 0x946 <doExorN1>
+ 91c:	51 50       	subi	r21, 0x01	; 1
+ 91e:	a9 f4       	brne	.+42     	; 0x94a <commonN1>
+ 920:	22 0f       	add	r18, r18
+ 922:	00 00       	nop
+ 924:	f9 cf       	rjmp	.-14     	; 0x918 <stuffN1Delay>
+
+00000926 <sendNakAndReti>:
+ 926:	4a e5       	ldi	r20, 0x5A	; 90
+ 928:	03 c0       	rjmp	.+6      	; 0x930 <usbSendX3>
+
+0000092a <sendAckAndReti>:
+ 92a:	42 ed       	ldi	r20, 0xD2	; 210
+ 92c:	01 c0       	rjmp	.+2      	; 0x930 <usbSendX3>
+
+0000092e <sendCntAndReti>:
+ 92e:	43 2f       	mov	r20, r19
+
+00000930 <usbSendX3>:
+ 930:	c4 e1       	ldi	r28, 0x14	; 20
+ 932:	d0 e0       	ldi	r29, 0x00	; 0
+ 934:	32 e0       	ldi	r19, 0x02	; 2
+
+00000936 <usbSendAndReti>:
+ 936:	1a b1       	in	r17, 0x0a	; 10
+ 938:	1c 60       	ori	r17, 0x0C	; 12
+ 93a:	5b 9a       	sbi	0x0b, 3	; 11
+ 93c:	1a b9       	out	0x0a, r17	; 10
+ 93e:	0b b1       	in	r16, 0x0b	; 11
+ 940:	20 e4       	ldi	r18, 0x40	; 64
+ 942:	1c e0       	ldi	r17, 0x0C	; 12
+ 944:	5f 93       	push	r21
+
+00000946 <doExorN1>:
+ 946:	01 27       	eor	r16, r17
+ 948:	56 e0       	ldi	r21, 0x06	; 6
+
+0000094a <commonN1>:
+ 94a:	0b b9       	out	0x0b, r16	; 11
+ 94c:	27 95       	ror	r18
+ 94e:	20 f4       	brcc	.+8      	; 0x958 <doExorN2>
+ 950:	51 50       	subi	r21, 0x01	; 1
+ 952:	21 f4       	brne	.+8      	; 0x95c <commonN2>
+ 954:	22 0f       	add	r18, r18
+ 956:	f9 cf       	rjmp	.-14     	; 0x94a <commonN1>
+
+00000958 <doExorN2>:
+ 958:	01 27       	eor	r16, r17
+ 95a:	56 e0       	ldi	r21, 0x06	; 6
+
+0000095c <commonN2>:
+ 95c:	00 00       	nop
+ 95e:	3b 5a       	subi	r19, 0xAB	; 171
+ 960:	0b b9       	out	0x0b, r16	; 11
+ 962:	d0 f2       	brcs	.-76     	; 0x918 <stuffN1Delay>
+
+00000964 <stuff6Delay>:
+ 964:	27 95       	ror	r18
+ 966:	28 f4       	brcc	.+10     	; 0x972 <doExor6>
+ 968:	51 50       	subi	r21, 0x01	; 1
+ 96a:	29 f4       	brne	.+10     	; 0x976 <common6>
+ 96c:	22 0f       	add	r18, r18
+ 96e:	00 00       	nop
+ 970:	f9 cf       	rjmp	.-14     	; 0x964 <stuff6Delay>
+
+00000972 <doExor6>:
+ 972:	01 27       	eor	r16, r17
+ 974:	56 e0       	ldi	r21, 0x06	; 6
+
+00000976 <common6>:
+ 976:	27 95       	ror	r18
+ 978:	0b b9       	out	0x0b, r16	; 11
+ 97a:	20 f4       	brcc	.+8      	; 0x984 <doExor7>
+ 97c:	51 50       	subi	r21, 0x01	; 1
+ 97e:	21 f4       	brne	.+8      	; 0x988 <common7>
+ 980:	22 0f       	add	r18, r18
+ 982:	f9 cf       	rjmp	.-14     	; 0x976 <common6>
+
+00000984 <doExor7>:
+ 984:	01 27       	eor	r16, r17
+ 986:	56 e0       	ldi	r21, 0x06	; 6
+
+00000988 <common7>:
+ 988:	29 91       	ld	r18, Y+
+ 98a:	33 23       	and	r19, r19
+ 98c:	0b b9       	out	0x0b, r16	; 11
+ 98e:	21 f6       	brne	.-120    	; 0x918 <stuffN1Delay>
+ 990:	03 7f       	andi	r16, 0xF3	; 243
+ 992:	10 91 7e 01 	lds	r17, 0x017E
+ 996:	11 0f       	add	r17, r17
+ 998:	c6 51       	subi	r28, 0x16	; 22
+ 99a:	d0 40       	sbci	r29, 0x00	; 0
+ 99c:	0b b9       	out	0x0b, r16	; 11
+ 99e:	11 f0       	breq	.+4      	; 0x9a4 <skipAddrAssign>
+ 9a0:	10 93 78 01 	sts	0x0178, r17
+
+000009a4 <skipAddrAssign>:
+ 9a4:	11 e0       	ldi	r17, 0x01	; 1
+ 9a6:	1c bb       	out	0x1c, r17	; 28
+ 9a8:	08 60       	ori	r16, 0x08	; 8
+ 9aa:	1a b1       	in	r17, 0x0a	; 10
+ 9ac:	13 7f       	andi	r17, 0xF3	; 243
+ 9ae:	40 2f       	mov	r20, r16
+ 9b0:	43 7f       	andi	r20, 0xF3	; 243
+ 9b2:	5f 91       	pop	r21
+ 9b4:	00 c0       	rjmp	.+0      	; 0x9b6 <skipAddrAssign+0x12>
+ 9b6:	00 c0       	rjmp	.+0      	; 0x9b8 <skipAddrAssign+0x14>
+ 9b8:	0b b9       	out	0x0b, r16	; 11
+ 9ba:	1a b9       	out	0x0a, r17	; 10
+ 9bc:	4b b9       	out	0x0b, r20	; 11
+ 9be:	71 cf       	rjmp	.-286    	; 0x8a2 <doReturn>
+
+000009c0 <__mulhi3>:
+ 9c0:	55 27       	eor	r21, r21
+ 9c2:	00 24       	eor	r0, r0
+
+000009c4 <__mulhi3_loop>:
+ 9c4:	80 ff       	sbrs	r24, 0
+ 9c6:	02 c0       	rjmp	.+4      	; 0x9cc <__mulhi3_skip1>
+ 9c8:	06 0e       	add	r0, r22
+ 9ca:	57 1f       	adc	r21, r23
+
+000009cc <__mulhi3_skip1>:
+ 9cc:	66 0f       	add	r22, r22
+ 9ce:	77 1f       	adc	r23, r23
+ 9d0:	61 15       	cp	r22, r1
+ 9d2:	71 05       	cpc	r23, r1
+ 9d4:	21 f0       	breq	.+8      	; 0x9de <__mulhi3_exit>
+ 9d6:	96 95       	lsr	r25
+ 9d8:	87 95       	ror	r24
+ 9da:	00 97       	sbiw	r24, 0x00	; 0
+ 9dc:	99 f7       	brne	.-26     	; 0x9c4 <__mulhi3_loop>
+
+000009de <__mulhi3_exit>:
+ 9de:	95 2f       	mov	r25, r21
+ 9e0:	80 2d       	mov	r24, r0
+ 9e2:	08 95       	ret
+
+000009e4 <_exit>:
+ 9e4:	f8 94       	cli
+
+000009e6 <__stop_program>:
+ 9e6:	ff cf       	rjmp	.-2      	; 0x9e6 <__stop_program>
Index: bin/Release/HP48GX.map
===================================================================
--- bin/Release/HP48GX.map	(nonexistent)
+++ bin/Release/HP48GX.map	(working copy)
@@ -0,0 +1,536 @@
+Archive member included because of file (symbol)
+
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+                              obj\Release\main.o (__mulhi3)
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+                              c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o (exit)
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+                              obj\Release\main.o (__do_copy_data)
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                              obj\Release\main.o (__do_clear_bss)
+
+Allocating common symbols
+Common symbol       size              file
+
+usbTxBuf            0xb               obj\Release\usbdrv\usbdrv.o
+usbTxStatus1        0xc               obj\Release\usbdrv\usbdrv.o
+usbDeviceAddr       0x1               obj\Release\usbdrv\usbdrv.o
+usbRxToken          0x1               obj\Release\usbdrv\usbdrv.o
+usbInputBufOffset   0x1               obj\Release\usbdrv\usbdrv.o
+usbMsgPtr           0x2               obj\Release\usbdrv\usbdrv.o
+usbRxLen            0x1               obj\Release\usbdrv\usbdrv.o
+usbNewDeviceAddr    0x1               obj\Release\usbdrv\usbdrv.o
+usbCurrentTok       0x1               obj\Release\usbdrv\usbdrv.o
+usbConfiguration    0x1               obj\Release\usbdrv\usbdrv.o
+usbRxBuf            0x16              obj\Release\usbdrv\usbdrv.o
+
+Memory Configuration
+
+Name             Origin             Length             Attributes
+text             0x00000000         0x00002000         xr
+data             0x00800060         0x0000ffa0         rw !x
+eeprom           0x00810000         0x00010000         rw !x
+fuse             0x00820000         0x00000400         rw !x
+lock             0x00830000         0x00000400         rw !x
+signature        0x00840000         0x00000400         rw !x
+*default*        0x00000000         0xffffffff
+
+Linker script and memory map
+
+Address of section .data set to 0x800100
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+LOAD obj\Release\fuse.o
+LOAD obj\Release\main.o
+LOAD obj\Release\usbdrv\oddebug.o
+LOAD obj\Release\usbdrv\usbdrv.o
+LOAD obj\Release\usbdrv\usbdrvasm.o
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25\libm.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25\libc.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a
+
+.hash
+ *(.hash)
+
+.dynsym
+ *(.dynsym)
+
+.dynstr
+ *(.dynstr)
+
+.gnu.version
+ *(.gnu.version)
+
+.gnu.version_d
+ *(.gnu.version_d)
+
+.gnu.version_r
+ *(.gnu.version_r)
+
+.rel.init
+ *(.rel.init)
+
+.rela.init
+ *(.rela.init)
+
+.rel.text
+ *(.rel.text)
+ *(.rel.text.*)
+ *(.rel.gnu.linkonce.t*)
+
+.rela.text
+ *(.rela.text)
+ *(.rela.text.*)
+ *(.rela.gnu.linkonce.t*)
+
+.rel.fini
+ *(.rel.fini)
+
+.rela.fini
+ *(.rela.fini)
+
+.rel.rodata
+ *(.rel.rodata)
+ *(.rel.rodata.*)
+ *(.rel.gnu.linkonce.r*)
+
+.rela.rodata
+ *(.rela.rodata)
+ *(.rela.rodata.*)
+ *(.rela.gnu.linkonce.r*)
+
+.rel.data
+ *(.rel.data)
+ *(.rel.data.*)
+ *(.rel.gnu.linkonce.d*)
+
+.rela.data
+ *(.rela.data)
+ *(.rela.data.*)
+ *(.rela.gnu.linkonce.d*)
+
+.rel.ctors
+ *(.rel.ctors)
+
+.rela.ctors
+ *(.rela.ctors)
+
+.rel.dtors
+ *(.rel.dtors)
+
+.rela.dtors
+ *(.rela.dtors)
+
+.rel.got
+ *(.rel.got)
+
+.rela.got
+ *(.rela.got)
+
+.rel.bss
+ *(.rel.bss)
+
+.rela.bss
+ *(.rela.bss)
+
+.rel.plt
+ *(.rel.plt)
+
+.rela.plt
+ *(.rela.plt)
+
+.text           0x00000000      0x9e8
+ *(.vectors)
+ .vectors       0x00000000       0x28 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+                0x00000000                __vectors
+                0x00000000                __vector_default
+ *(.vectors)
+ *(.progmem.gcc*)
+ *(.progmem*)
+ .progmem.data  0x00000028       0x3f obj\Release\main.o
+                0x00000028                usbDescriptorHidReport
+ .progmem.data  0x00000067       0x68 obj\Release\usbdrv\usbdrv.o
+                0x0000009b                usbDescriptorDevice
+                0x00000067                usbDescriptorString0
+                0x000000ad                usbDescriptorConfiguration
+                0x0000006b                usbDescriptorStringVendor
+                0x0000008b                usbDescriptorStringDevice
+                0x000000d0                . = ALIGN (0x2)
+ *fill*         0x000000cf        0x1 00
+                0x000000d0                __trampolines_start = .
+ *(.trampolines)
+ .trampolines   0x000000d0        0x0 linker stubs
+ *(.trampolines*)
+                0x000000d0                __trampolines_end = .
+ *(.jumptables)
+ *(.jumptables*)
+ *(.lowtext)
+ *(.lowtext*)
+                0x000000d0                __ctors_start = .
+ *(.ctors)
+                0x000000d0                __ctors_end = .
+                0x000000d0                __dtors_start = .
+ *(.dtors)
+                0x000000d0                __dtors_end = .
+ SORT(*)(.ctors)
+ SORT(*)(.dtors)
+ *(.init0)
+ .init0         0x000000d0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+                0x000000d0                __init
+ *(.init0)
+ *(.init1)
+ *(.init1)
+ *(.init2)
+ .init2         0x000000d0        0xc c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ *(.init2)
+ *(.init3)
+ *(.init3)
+ *(.init4)
+ .init4         0x000000dc       0x16 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+                0x000000dc                __do_copy_data
+ .init4         0x000000f2       0x10 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                0x000000f2                __do_clear_bss
+ *(.init4)
+ *(.init5)
+ *(.init5)
+ *(.init6)
+ *(.init6)
+ *(.init7)
+ *(.init7)
+ *(.init8)
+ *(.init8)
+ *(.init9)
+ .init9         0x00000102        0x4 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ *(.init9)
+ *(.text)
+ .text          0x00000106        0x2 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+                0x00000106                __vector_12
+                0x00000106                __bad_interrupt
+                0x00000106                __vector_6
+                0x00000106                __vector_3
+                0x00000106                __vector_11
+                0x00000106                __vector_13
+                0x00000106                __vector_17
+                0x00000106                __vector_19
+                0x00000106                __vector_7
+                0x00000106                __vector_5
+                0x00000106                __vector_4
+                0x00000106                __vector_9
+                0x00000106                __vector_2
+                0x00000106                __vector_15
+                0x00000106                __vector_8
+                0x00000106                __vector_10
+                0x00000106                __vector_16
+                0x00000106                __vector_18
+ .text          0x00000108        0x0 obj\Release\fuse.o
+ .text          0x00000108      0x36a obj\Release\main.o
+                0x0000039e                Init
+                0x000002fc                OnKey
+                0x00000108                usbFunctionSetup
+                0x00000326                KeyPressed
+                0x00000172                buildReport
+                0x000003d2                main
+                0x000001a4                scanMatrix
+                0x0000017c                __vector_14
+                0x0000016e                usbFunctionWrite
+ .text          0x00000472        0x0 obj\Release\usbdrv\oddebug.o
+ .text          0x00000472      0x2a8 obj\Release\usbdrv\usbdrv.o
+                0x0000048c                usbPoll
+                0x000006d6                usbSetInterrupt
+                0x00000472                usbInit
+ .text          0x0000071a      0x2a6 obj\Release\usbdrv\usbdrvasm.o
+                0x0000074c                __vector_1
+                0x0000071a                usbCrc16
+                0x00000744                usbCrc16Append
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                0x000009c0                . = ALIGN (0x2)
+ *(.text.*)
+ .text.libgcc   0x000009c0       0x24 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+                0x000009c0                __mulhi3
+ .text.libgcc   0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .text.libgcc   0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .text.libgcc   0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                0x000009e4                . = ALIGN (0x2)
+ *(.fini9)
+ .fini9         0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+                0x000009e4                exit
+                0x000009e4                _exit
+ *(.fini9)
+ *(.fini8)
+ *(.fini8)
+ *(.fini7)
+ *(.fini7)
+ *(.fini6)
+ *(.fini6)
+ *(.fini5)
+ *(.fini5)
+ *(.fini4)
+ *(.fini4)
+ *(.fini3)
+ *(.fini3)
+ *(.fini2)
+ *(.fini2)
+ *(.fini1)
+ *(.fini1)
+ *(.fini0)
+ .fini0         0x000009e4        0x4 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ *(.fini0)
+                0x000009e8                _etext = .
+
+.data           0x00800100       0x40 load address 0x000009e8
+                0x00800100                PROVIDE (__data_start, .)
+ *(.data)
+ .data          0x00800100        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ .data          0x00800100        0x0 obj\Release\fuse.o
+ .data          0x00800100       0x3e obj\Release\main.o
+                0x00800100                ScanCode
+ .data          0x0080013e        0x0 obj\Release\usbdrv\oddebug.o
+ .data          0x0080013e        0x2 obj\Release\usbdrv\usbdrv.o
+                0x0080013e                usbTxLen
+ .data          0x00800140        0x0 obj\Release\usbdrv\usbdrvasm.o
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+ *(.data*)
+ *(.rodata)
+ *(.rodata*)
+ *(.gnu.linkonce.d*)
+                0x00800140                . = ALIGN (0x2)
+                0x00800140                _edata = .
+                0x00800140                PROVIDE (__data_end, .)
+
+.bss            0x00800140       0x57
+                0x00800140                PROVIDE (__bss_start, .)
+ *(.bss)
+ .bss           0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ .bss           0x00800140        0x0 obj\Release\fuse.o
+ .bss           0x00800140       0x20 obj\Release\main.o
+                0x00800143                keybuild
+                0x00800141                EnableKeyPressed
+                0x00800140                state
+                0x00800149                changedKeys
+                0x00800147                FAIL
+                0x00800145                OnCount
+ .bss           0x00800160        0x0 obj\Release\usbdrv\oddebug.o
+ .bss           0x00800160        0x1 obj\Release\usbdrv\usbdrv.o
+ .bss           0x00800161        0x0 obj\Release\usbdrv\usbdrvasm.o
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+ *(.bss*)
+ *(COMMON)
+ COMMON         0x00800161       0x36 obj\Release\usbdrv\usbdrv.o
+                0x00800161                usbTxBuf
+                0x0080016c                usbTxStatus1
+                0x00800178                usbDeviceAddr
+                0x00800179                usbRxToken
+                0x0080017a                usbInputBufOffset
+                0x0080017b                usbMsgPtr
+                0x0080017d                usbRxLen
+                0x0080017e                usbNewDeviceAddr
+                0x0080017f                usbCurrentTok
+                0x00800180                usbConfiguration
+                0x00800181                usbRxBuf
+                0x00800197                PROVIDE (__bss_end, .)
+                0x000009e8                __data_load_start = LOADADDR (.data)
+                0x00000a28                __data_load_end = (__data_load_start + SIZEOF (.data))
+
+.noinit         0x00800197        0x0
+                0x00800197                PROVIDE (__noinit_start, .)
+ *(.noinit*)
+                0x00800197                PROVIDE (__noinit_end, .)
+                0x00800197                _end = .
+                0x00800197                PROVIDE (__heap_start, .)
+
+.eeprom         0x00810000        0x0
+ *(.eeprom*)
+                0x00810000                __eeprom_end = .
+
+.fuse           0x00820000        0x3
+ *(.fuse)
+ .fuse          0x00820000        0x3 obj\Release\fuse.o
+                0x00820000                __fuse
+ *(.lfuse)
+ *(.hfuse)
+ *(.efuse)
+
+.lock
+ *(.lock*)
+
+.signature
+ *(.signature*)
+
+.stab
+ *(.stab)
+
+.stabstr
+ *(.stabstr)
+
+.stab.excl
+ *(.stab.excl)
+
+.stab.exclstr
+ *(.stab.exclstr)
+
+.stab.index
+ *(.stab.index)
+
+.stab.indexstr
+ *(.stab.indexstr)
+
+.comment
+ *(.comment)
+
+.debug
+ *(.debug)
+
+.line
+ *(.line)
+
+.debug_srcinfo
+ *(.debug_srcinfo)
+
+.debug_sfnames
+ *(.debug_sfnames)
+
+.debug_aranges
+ *(.debug_aranges)
+
+.debug_pubnames
+ *(.debug_pubnames)
+
+.debug_info
+ *(.debug_info)
+ *(.gnu.linkonce.wi.*)
+
+.debug_abbrev
+ *(.debug_abbrev)
+
+.debug_line
+ *(.debug_line)
+
+.debug_frame
+ *(.debug_frame)
+
+.debug_str
+ *(.debug_str)
+
+.debug_loc
+ *(.debug_loc)
+
+.debug_macinfo
+ *(.debug_macinfo)
+OUTPUT(bin\Release\HP48GX.elf elf32-avr)
+LOAD linker stubs
+
+Cross Reference Table
+
+Symbol                                            File
+EnableKeyPressed                                  obj\Release\main.o
+FAIL                                              obj\Release\main.o
+Init                                              obj\Release\main.o
+KeyPressed                                        obj\Release\main.o
+OnCount                                           obj\Release\main.o
+OnKey                                             obj\Release\main.o
+ScanCode                                          obj\Release\main.o
+__bad_interrupt                                   c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__bss_end                                         c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+__bss_start                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+__data_end                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+__data_load_start                                 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+__data_start                                      c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+__do_clear_bss                                    c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                                                  obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+__do_copy_data                                    c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+                                                  obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+__fuse                                            obj\Release\fuse.o
+__heap_end                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__init                                            c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__mulhi3                                          c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+                                                  obj\Release\main.o
+__stack                                           c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_1                                        obj\Release\usbdrv\usbdrvasm.o
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_10                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_11                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_12                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_13                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_14                                       obj\Release\main.o
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_15                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_16                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_17                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_18                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_19                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_2                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_3                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_4                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_5                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_6                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_7                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_8                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_9                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_default                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vectors                                         c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+_exit                                             c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+buildReport                                       obj\Release\main.o
+changedKeys                                       obj\Release\main.o
+exit                                              c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+keybuild                                          obj\Release\main.o
+main                                              obj\Release\main.o
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+scanMatrix                                        obj\Release\main.o
+state                                             obj\Release\main.o
+usbConfiguration                                  obj\Release\usbdrv\usbdrv.o
+usbCrc16                                          obj\Release\usbdrv\usbdrvasm.o
+usbCrc16Append                                    obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbCurrentTok                                     obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbDescriptorConfiguration                        obj\Release\usbdrv\usbdrv.o
+usbDescriptorDevice                               obj\Release\usbdrv\usbdrv.o
+usbDescriptorHidReport                            obj\Release\main.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbDescriptorString0                              obj\Release\usbdrv\usbdrv.o
+usbDescriptorStringDevice                         obj\Release\usbdrv\usbdrv.o
+usbDescriptorStringVendor                         obj\Release\usbdrv\usbdrv.o
+usbDeviceAddr                                     obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbFunctionSetup                                  obj\Release\main.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbFunctionWrite                                  obj\Release\main.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbInit                                           obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbInputBufOffset                                 obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbMsgPtr                                         obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbNewDeviceAddr                                  obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbPoll                                           obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbRxBuf                                          obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbRxLen                                          obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbRxToken                                        obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbSetInterrupt                                   obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbTxBuf                                          obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbTxLen                                          obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\usbdrv\usbdrvasm.o
+usbTxStatus1                                      obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
Index: bin/Release/HP48GX.sig
===================================================================
--- bin/Release/HP48GX.sig	(nonexistent)
+++ bin/Release/HP48GX.sig	(working copy)
@@ -0,0 +1 @@
+:00000001FF
Index: bin/Release/HP48GX.eep
===================================================================
--- bin/Release/HP48GX.eep	(nonexistent)
+++ bin/Release/HP48GX.eep	(working copy)
@@ -0,0 +1 @@
+:00000001FF
Index: bin/Release/HP48GX.efs
===================================================================
--- bin/Release/HP48GX.efs	(nonexistent)
+++ bin/Release/HP48GX.efs	(working copy)
@@ -0,0 +1,3 @@
+:020000040000FA
+:01000000FF00
+:00000001FF
Index: bin/Release/HP48GX.elf
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: bin/Release/HP48GX.elf
===================================================================
--- bin/Release/HP48GX.elf	(nonexistent)
+++ bin/Release/HP48GX.elf	(working copy)

Property changes on: bin/Release/HP48GX.elf
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: bin/Release/HP48GX.fuse
===================================================================
--- bin/Release/HP48GX.fuse	(nonexistent)
+++ bin/Release/HP48GX.fuse	(working copy)
@@ -0,0 +1,2 @@
+:03000000ECDFFF33
+:00000001FF
Index: bin/Release/HP48GX.hex
===================================================================
--- bin/Release/HP48GX.hex	(nonexistent)
+++ bin/Release/HP48GX.hex	(working copy)
@@ -0,0 +1,164 @@
+:1000000067C0A4C380C07FC07EC07DC07CC07BC0F1
+:100010007AC079C078C077C076C075C0AFC073C0F1
+:1000200072C071C070C06FC005010906A1017501E1
+:100030009508050719E029E7150025FF81029501BC
+:1000400075088103950575010508190129FF9102BD
+:1000500095017503910395067508150025FF0507A1
+:10006000190029FF8100C004030904200363006F05
+:10007000006400650061006E0064006C0069006649
+:100080000065002E0063006F006D001003500061DA
+:100090000073007300670065006E0012011001001C
+:1000A000000008424231E100010102000109022280
+:1000B0000001010080190904000001030101000989
+:1000C0002101010001223F000705810308000A0009
+:1000D00011241FBECFEFD1E0DEBFCDBF11E0A0E005
+:1000E000B1E0E8EEF9E002C005900D92A034B1074E
+:1000F000D9F711E0A0E4B1E001C01D92A739B10722
+:10010000E1F767D16FC47CCFFC01808180768032BB
+:1001100061F581818230E1F0833018F4813029F576
+:1001200005C0893079F08A3001F51AC087E591E081
+:1001300090937C0180937B0110925701109259019A
+:1001400088E0089586819781019779F48FEF08956B
+:100150008FE591E090937C0180937B0181E008958D
+:10016000838180935F0180E0089580E0089581E0BD
+:100170000895109257018093590108951F920F928C
+:100180000FB60F9211248F939F9381E090E090938C
+:100190005501809354019F918F910F900FBE0F9046
+:1001A0001F9018958091540190915501892B09F465
+:1001B000A4C0109255011092540149B1437FA091FF
+:1001C00056012A2F30E0F901E65BFE4F808184273B
+:1001D0004083882309F465C0942F40FD0DC080FF43
+:1001E0000BC081E080934001C90166E070E0E8D374
+:1001F000FC01E050FF4F20C091FD0EC081FF0CC0FC
+:1002000081E080934001C90166E070E0D9D3FC0130
+:10021000E050FF4F818141C094FD10C084FF0EC0AB
+:1002200081E080934001C90163E070E0C9D3FC0123
+:10023000EE0FFF1FEE5FFE4F80812FC095FD0EC0B9
+:1002400085FF0CC081E080934001C90166E070E049
+:10025000B7D3FC01E050FF4F83811FC096FD0EC055
+:1002600086FF0CC081E080934001C90166E070E028
+:10027000A7D3FC01E050FF4F84810FC047FD11C0A0
+:1002800087FF0FC081E080934001C90166E070E004
+:1002900097D3FC01E050FF4F85818093430110927A
+:1002A000440180913C0190913D01880F991F9093EA
+:1002B0003D0180933C01AF5FA093560180349105CE
+:1002C00031F480E890E090933D0180933C0180916F
+:1002D0003C0190913D018050944041F481E090E0D8
+:1002E00090933D0180933C011092560190913C0106
+:1002F00080913D0197B984608DB908958091400146
+:10030000813081F083B190E08078907080935301C8
+:10031000892B41F481E085B981E090E0909342011E
+:100320008093410108958091410190914201892B70
+:10033000A9F11F991DC08091450190914601019638
+:1003400090934601809345018052934089F48CE359
+:1003500090E0909344018093430181E080934001B9
+:1003600010924201109241011092460110924501F3
+:10037000809145019091460189559240873C9105B5
+:1003800068F480913601809343011092440181E02A
+:100390008093400110924201109241010895109201
+:1003A0006B0010926D0010926A0017B818B88AB1ED
+:1003B0008C708AB98BB11BB884E08DB91EB81092CD
+:1003C0008000109281001092820081E084B915B8FB
+:1003D00008951F93E4DFE7E5F1E0119281E0EF3546
+:1003E000F807D9F72EE088E190E00FB6F894A895C9
+:1003F000809360000FBE209360003BD0539A20E0B2
+:1004000040E757E1A895CA010197F1F72F5F2A3F0E
+:10041000C9F73CD05398F89483E085BD81E0809380
+:100420006E00789412E07FDF69DFBCDEA8952ED0E5
+:1004300080916C0184FF18C0809140018823A1F055
+:10044000813019F0823071F409C08091430110921B
+:100450005701809359011093400106C01092570133
+:10046000109259011092400187E591E068E033D184
+:10047000DACFE9E6F0E0808182608083E89A8BE45D
+:1004800080936D018AE580936C0108951F93CF934B
+:10049000DF9360917D01635067FDC2C080917A0156
+:1004A000CCE0D0E0C81BD109CF57DE4F8091790155
+:1004B0008D3209F0A3C0683009F0B0C083EC80939E
+:1004C00061018AE580933E01109260018881807607
+:1004D00039F0CE0119DE282F8F3F09F47EC084C089
+:1004E0009A8110926A018981882321F410926B010C
+:1004F00022E06CC0853019F490937E0166C086308E
+:1005000009F04FC08B81813041F48BE990E09093EA
+:100510007C0180937B0122E140C0823041F48DEA6E
+:1005200090E090937C0180937B0122E236C083307F
+:10053000F9F48A81882341F487E690E090937C0166
+:1005400080937B0124E029C0813041F48BE690E068
+:1005500090937C0180937B0120E21FC08230E1F404
+:100560008BE890E090937C0180937B0120E115C0A3
+:10057000813241F48FEB90E090937C0180937B017A
+:1005800029E00BC0823241F488E290E090937C0134
+:1005900080937B012FE301C020E080E48093600121
+:1005A00023C0883021F421E080E891E011C0893037
+:1005B00019F49093800109C08A3011F421E006C03B
+:1005C0008B3019F48BE480936D0120E08AE691E092
+:1005D00090937C0180937B0107C0888187FD2E81E9
+:1005E00080E88093600106C08F81882319F48E8192
+:1005F000821708F0822F80933F0110C08091600124
+:1006000087FF0CC0CE01B3DD8F3F21F48EE18093D4
+:100610003E0104C0882311F010923F0110927D0129
+:1006200080913E0184FF49C080913F018F3F09F4D2
+:1006300044C0182F893008F018E0811B80933F01D7
+:100640008091610198E8892780936101112341F12C
+:1006500020917B0130917C018091600186FF0DC06B
+:10066000A2E6B1E080E090E0F901E80FF91FE49123
+:10067000ED9301961817C1F708C0912FD901E2E652
+:10068000F1E08D9181939150E1F71150812F90E02D
+:100690001F5F0196820F931F90937C0180937B01D3
+:1006A00082E691E0612F4ED0612F6C5F6C3019F0C3
+:1006B0008FEF80933F0160933E0194E189B18C708C
+:1006C00031F49150D9F710927E0110927801DF91A8
+:1006D000CF911F9108951F93DC01162F80916C011B
+:1006E00084FF07C080916D0198E8892780936D0190
+:1006F00003C08AE580936C01912FEEE6F1E08D91C5
+:10070000819391501916DCF38EE691E0612F1AD097
+:100710001C5F10936C011F910895A82FB92F80E0E2
+:1007200090E041E050EA609530E009C02D918227C9
+:100730009795879510F084279527305EC8F36F5FF3
+:10074000A8F30895EADF8D939D930895CF93CFB7D3
+:10075000CF93C3954B9BE9F74B9B09C04B9B07C0BD
+:100760004B9B05C04B9B03C04B9B01C0A3C0DF93B9
+:10077000C0917A01DD27CF57DE4F4B9B02C0DF913E
+:10078000EBCF2F930F931F9309B12FEF03FB20F9AA
+:100790004F933F9319B14FEF012703FB21F93BE042
+:1007A00031C04E7F012F19B1216028C0102F4D7F1D
+:1007B0002260000009B129C04B7F2460012F000096
+:1007C00019B12BC019B1477F28602AC04F7E09B1EB
+:1007D00020612CC04F7D19B120622FC04F7B09B121
+:1007E000206432C0422709B149934FEF000010271F
+:1007F00013FB20F919B11C70C9F1297F91F201276F
+:1008000003FB21F909B1237F89F2315058F11027F8
+:1008100013FB22F919B1277E79F2012703FB23F993
+:100820002F7C81F209B1102713FB24F92F7971F283
+:1008300000C019B1012703FB25F92F7359F200C03D
+:1008400009B1102713FB26F9223040F200C019B17C
+:10085000012703FB27F9243028F64F77206819B1C8
+:100860000000F9CF11E01CBB002719C03B503195A7
+:10087000C31BD04011E01CBB0881033CF9F00B34D2
+:10088000E9F0209178011981110F1213EDCF4A81FF
+:10089000441F093641F10D3211F0013E29F7009352
+:1008A0007F013F914F911F910F912F91DF91CCB319
+:1008B000C0FD4FCFCF91CFBFCF91189520917F0131
+:1008C000222379F310917D01112369F534306AF107
+:1008D00030937D012093790110917A013BE0311B27
+:1008E00030937A0122C000917D010130E4F40AE5E1
+:1008F0004F7049F430913E0134FD19C000933E0120
+:10090000C1E6D1E018C030916C0134FD10C00093F5
+:100910006C01CDE6D1E00FC02795A8F45150A9F4A1
+:10092000220F0000F9CF4AE503C042ED01C0432F7A
+:10093000C4E1D0E032E01AB11C605B9A1AB90BB185
+:1009400020E41CE05F93012756E00BB9279520F4C3
+:10095000515021F4220FF9CF012756E000003B5AF5
+:100960000BB9D0F2279528F4515029F4220F00003A
+:10097000F9CF012756E027950BB920F4515021F407
+:10098000220FF9CF012756E0299133230BB921F625
+:10099000037F10917E01110FC651D0400BB911F0A9
+:1009A0001093780111E01CBB08601AB1137F402F2F
+:1009B000437F5F9100C000C00BB91AB94BB971CF2A
+:1009C0005527002480FF02C0060E571F660F771FB1
+:1009D0006115710521F096958795009799F7952FE8
+:0809E000802D0895F894FFCF6B
+:1009E800000506070809000B0C0D0E0F0011121365
+:1009F8001415001718191A1B00581D1C4C2A2B1601
+:100A080024252654E10A21222355E0041E1F2056DE
+:100A1800001027372C5729000000000001005AFF5A
+:00000001FF
Index: bin/Release/HP48GX.hfs
===================================================================
--- bin/Release/HP48GX.hfs	(nonexistent)
+++ bin/Release/HP48GX.hfs	(working copy)
@@ -0,0 +1,3 @@
+:020000040000FA
+:01000000DF20
+:00000001FF
Index: bin/Release/HP48GX.lfs
===================================================================
--- bin/Release/HP48GX.lfs	(nonexistent)
+++ bin/Release/HP48GX.lfs	(working copy)
@@ -0,0 +1,3 @@
+:020000040000FA
+:01000000EC13
+:00000001FF
Index: bin/Release/HP48GX.lock
===================================================================
--- bin/Release/HP48GX.lock	(nonexistent)
+++ bin/Release/HP48GX.lock	(working copy)
@@ -0,0 +1 @@
+:00000001FF
Index: bin/Release/HP48GX.lss
===================================================================
--- bin/Release/HP48GX.lss	(nonexistent)
+++ bin/Release/HP48GX.lss	(working copy)
@@ -0,0 +1,1236 @@
+
+bin\Release\HP48GX.elf:     file format elf32-avr
+
+Sections:
+Idx Name          Size      VMA       LMA       File off  Algn
+  0 .data         00000040  00800100  000009e8  00000a9c  2**0
+                  CONTENTS, ALLOC, LOAD, DATA
+  1 .text         000009e8  00000000  00000000  000000b4  2**1
+                  CONTENTS, ALLOC, LOAD, READONLY, CODE
+  2 .bss          00000057  00800140  00800140  00000adc  2**0
+                  ALLOC
+  3 .fuse         00000003  00820000  00820000  00000adc  2**0
+                  CONTENTS, ALLOC, LOAD, DATA
+
+Disassembly of section .text:
+
+00000000 <__vectors>:
+   0:	67 c0       	rjmp	.+206    	; 0xd0 <__ctors_end>
+   2:	a4 c3       	rjmp	.+1864   	; 0x74c <__vector_1>
+   4:	80 c0       	rjmp	.+256    	; 0x106 <__bad_interrupt>
+   6:	7f c0       	rjmp	.+254    	; 0x106 <__bad_interrupt>
+   8:	7e c0       	rjmp	.+252    	; 0x106 <__bad_interrupt>
+   a:	7d c0       	rjmp	.+250    	; 0x106 <__bad_interrupt>
+   c:	7c c0       	rjmp	.+248    	; 0x106 <__bad_interrupt>
+   e:	7b c0       	rjmp	.+246    	; 0x106 <__bad_interrupt>
+  10:	7a c0       	rjmp	.+244    	; 0x106 <__bad_interrupt>
+  12:	79 c0       	rjmp	.+242    	; 0x106 <__bad_interrupt>
+  14:	78 c0       	rjmp	.+240    	; 0x106 <__bad_interrupt>
+  16:	77 c0       	rjmp	.+238    	; 0x106 <__bad_interrupt>
+  18:	76 c0       	rjmp	.+236    	; 0x106 <__bad_interrupt>
+  1a:	75 c0       	rjmp	.+234    	; 0x106 <__bad_interrupt>
+  1c:	af c0       	rjmp	.+350    	; 0x17c <__vector_14>
+  1e:	73 c0       	rjmp	.+230    	; 0x106 <__bad_interrupt>
+  20:	72 c0       	rjmp	.+228    	; 0x106 <__bad_interrupt>
+  22:	71 c0       	rjmp	.+226    	; 0x106 <__bad_interrupt>
+  24:	70 c0       	rjmp	.+224    	; 0x106 <__bad_interrupt>
+  26:	6f c0       	rjmp	.+222    	; 0x106 <__bad_interrupt>
+
+00000028 <usbDescriptorHidReport>:
+  28:	05 01 09 06 a1 01 75 01 95 08 05 07 19 e0 29 e7     ......u.......).
+  38:	15 00 25 ff 81 02 95 01 75 08 81 03 95 05 75 01     ..%.....u.....u.
+  48:	05 08 19 01 29 ff 91 02 95 01 75 03 91 03 95 06     ....).....u.....
+  58:	75 08 15 00 25 ff 05 07 19 00 29 ff 81 00 c0        u...%.....)....
+
+00000067 <usbDescriptorString0>:
+  67:	04 03 09 04                                         ....
+
+0000006b <usbDescriptorStringVendor>:
+  6b:	20 03 63 00 6f 00 64 00 65 00 61 00 6e 00 64 00      .c.o.d.e.a.n.d.
+  7b:	6c 00 69 00 66 00 65 00 2e 00 63 00 6f 00 6d 00     l.i.f.e...c.o.m.
+
+0000008b <usbDescriptorStringDevice>:
+  8b:	10 03 50 00 61 00 73 00 73 00 67 00 65 00 6e 00     ..P.a.s.s.g.e.n.
+
+0000009b <usbDescriptorDevice>:
+  9b:	12 01 10 01 00 00 00 08 42 42 31 e1 00 01 01 02     ........BB1.....
+  ab:	00 01                                               ..
+
+000000ad <usbDescriptorConfiguration>:
+  ad:	09 02 22 00 01 01 00 80 19 09 04 00 00 01 03 01     ..".............
+  bd:	01 00 09 21 01 01 00 01 22 3f 00 07 05 81 03 08     ...!...."?......
+  cd:	00 0a 00                                            ...
+
+000000d0 <__ctors_end>:
+  d0:	11 24       	eor	r1, r1
+  d2:	1f be       	out	0x3f, r1	; 63
+  d4:	cf ef       	ldi	r28, 0xFF	; 255
+  d6:	d1 e0       	ldi	r29, 0x01	; 1
+  d8:	de bf       	out	0x3e, r29	; 62
+  da:	cd bf       	out	0x3d, r28	; 61
+
+000000dc <__do_copy_data>:
+  dc:	11 e0       	ldi	r17, 0x01	; 1
+  de:	a0 e0       	ldi	r26, 0x00	; 0
+  e0:	b1 e0       	ldi	r27, 0x01	; 1
+  e2:	e8 ee       	ldi	r30, 0xE8	; 232
+  e4:	f9 e0       	ldi	r31, 0x09	; 9
+  e6:	02 c0       	rjmp	.+4      	; 0xec <.do_copy_data_start>
+
+000000e8 <.do_copy_data_loop>:
+  e8:	05 90       	lpm	r0, Z+
+  ea:	0d 92       	st	X+, r0
+
+000000ec <.do_copy_data_start>:
+  ec:	a0 34       	cpi	r26, 0x40	; 64
+  ee:	b1 07       	cpc	r27, r17
+  f0:	d9 f7       	brne	.-10     	; 0xe8 <.do_copy_data_loop>
+
+000000f2 <__do_clear_bss>:
+  f2:	11 e0       	ldi	r17, 0x01	; 1
+  f4:	a0 e4       	ldi	r26, 0x40	; 64
+  f6:	b1 e0       	ldi	r27, 0x01	; 1
+  f8:	01 c0       	rjmp	.+2      	; 0xfc <.do_clear_bss_start>
+
+000000fa <.do_clear_bss_loop>:
+  fa:	1d 92       	st	X+, r1
+
+000000fc <.do_clear_bss_start>:
+  fc:	a7 39       	cpi	r26, 0x97	; 151
+  fe:	b1 07       	cpc	r27, r17
+ 100:	e1 f7       	brne	.-8      	; 0xfa <.do_clear_bss_loop>
+ 102:	67 d1       	rcall	.+718    	; 0x3d2 <main>
+ 104:	6f c4       	rjmp	.+2270   	; 0x9e4 <_exit>
+
+00000106 <__bad_interrupt>:
+ 106:	7c cf       	rjmp	.-264    	; 0x0 <__vectors>
+
+00000108 <usbFunctionSetup>:
+ 108:	fc 01       	movw	r30, r24
+ 10a:	80 81       	ld	r24, Z
+ 10c:	80 76       	andi	r24, 0x60	; 96
+ 10e:	80 32       	cpi	r24, 0x20	; 32
+ 110:	61 f5       	brne	.+88     	; 0x16a <usbFunctionSetup+0x62>
+ 112:	81 81       	ldd	r24, Z+1	; 0x01
+ 114:	82 30       	cpi	r24, 0x02	; 2
+ 116:	e1 f0       	breq	.+56     	; 0x150 <usbFunctionSetup+0x48>
+ 118:	83 30       	cpi	r24, 0x03	; 3
+ 11a:	18 f4       	brcc	.+6      	; 0x122 <usbFunctionSetup+0x1a>
+ 11c:	81 30       	cpi	r24, 0x01	; 1
+ 11e:	29 f5       	brne	.+74     	; 0x16a <usbFunctionSetup+0x62>
+ 120:	05 c0       	rjmp	.+10     	; 0x12c <usbFunctionSetup+0x24>
+ 122:	89 30       	cpi	r24, 0x09	; 9
+ 124:	79 f0       	breq	.+30     	; 0x144 <usbFunctionSetup+0x3c>
+ 126:	8a 30       	cpi	r24, 0x0A	; 10
+ 128:	01 f5       	brne	.+64     	; 0x16a <usbFunctionSetup+0x62>
+ 12a:	1a c0       	rjmp	.+52     	; 0x160 <usbFunctionSetup+0x58>
+ 12c:	87 e5       	ldi	r24, 0x57	; 87
+ 12e:	91 e0       	ldi	r25, 0x01	; 1
+ 130:	90 93 7c 01 	sts	0x017C, r25
+ 134:	80 93 7b 01 	sts	0x017B, r24
+ 138:	10 92 57 01 	sts	0x0157, r1
+ 13c:	10 92 59 01 	sts	0x0159, r1
+ 140:	88 e0       	ldi	r24, 0x08	; 8
+ 142:	08 95       	ret
+ 144:	86 81       	ldd	r24, Z+6	; 0x06
+ 146:	97 81       	ldd	r25, Z+7	; 0x07
+ 148:	01 97       	sbiw	r24, 0x01	; 1
+ 14a:	79 f4       	brne	.+30     	; 0x16a <usbFunctionSetup+0x62>
+ 14c:	8f ef       	ldi	r24, 0xFF	; 255
+ 14e:	08 95       	ret
+ 150:	8f e5       	ldi	r24, 0x5F	; 95
+ 152:	91 e0       	ldi	r25, 0x01	; 1
+ 154:	90 93 7c 01 	sts	0x017C, r25
+ 158:	80 93 7b 01 	sts	0x017B, r24
+ 15c:	81 e0       	ldi	r24, 0x01	; 1
+ 15e:	08 95       	ret
+ 160:	83 81       	ldd	r24, Z+3	; 0x03
+ 162:	80 93 5f 01 	sts	0x015F, r24
+ 166:	80 e0       	ldi	r24, 0x00	; 0
+ 168:	08 95       	ret
+ 16a:	80 e0       	ldi	r24, 0x00	; 0
+ 16c:	08 95       	ret
+
+0000016e <usbFunctionWrite>:
+ 16e:	81 e0       	ldi	r24, 0x01	; 1
+ 170:	08 95       	ret
+
+00000172 <buildReport>:
+ 172:	10 92 57 01 	sts	0x0157, r1
+ 176:	80 93 59 01 	sts	0x0159, r24
+ 17a:	08 95       	ret
+
+0000017c <__vector_14>:
+ 17c:	1f 92       	push	r1
+ 17e:	0f 92       	push	r0
+ 180:	0f b6       	in	r0, 0x3f	; 63
+ 182:	0f 92       	push	r0
+ 184:	11 24       	eor	r1, r1
+ 186:	8f 93       	push	r24
+ 188:	9f 93       	push	r25
+ 18a:	81 e0       	ldi	r24, 0x01	; 1
+ 18c:	90 e0       	ldi	r25, 0x00	; 0
+ 18e:	90 93 55 01 	sts	0x0155, r25
+ 192:	80 93 54 01 	sts	0x0154, r24
+ 196:	9f 91       	pop	r25
+ 198:	8f 91       	pop	r24
+ 19a:	0f 90       	pop	r0
+ 19c:	0f be       	out	0x3f, r0	; 63
+ 19e:	0f 90       	pop	r0
+ 1a0:	1f 90       	pop	r1
+ 1a2:	18 95       	reti
+
+000001a4 <scanMatrix>:
+ 1a4:	80 91 54 01 	lds	r24, 0x0154
+ 1a8:	90 91 55 01 	lds	r25, 0x0155
+ 1ac:	89 2b       	or	r24, r25
+ 1ae:	09 f4       	brne	.+2      	; 0x1b2 <scanMatrix+0xe>
+ 1b0:	a4 c0       	rjmp	.+328    	; 0x2fa <__stack+0xfb>
+ 1b2:	10 92 55 01 	sts	0x0155, r1
+ 1b6:	10 92 54 01 	sts	0x0154, r1
+ 1ba:	49 b1       	in	r20, 0x09	; 9
+ 1bc:	43 7f       	andi	r20, 0xF3	; 243
+ 1be:	a0 91 56 01 	lds	r26, 0x0156
+ 1c2:	2a 2f       	mov	r18, r26
+ 1c4:	30 e0       	ldi	r19, 0x00	; 0
+ 1c6:	f9 01       	movw	r30, r18
+ 1c8:	e6 5b       	subi	r30, 0xB6	; 182
+ 1ca:	fe 4f       	sbci	r31, 0xFE	; 254
+ 1cc:	80 81       	ld	r24, Z
+ 1ce:	84 27       	eor	r24, r20
+ 1d0:	40 83       	st	Z, r20
+ 1d2:	88 23       	and	r24, r24
+ 1d4:	09 f4       	brne	.+2      	; 0x1d8 <scanMatrix+0x34>
+ 1d6:	65 c0       	rjmp	.+202    	; 0x2a2 <__stack+0xa3>
+ 1d8:	94 2f       	mov	r25, r20
+ 1da:	40 fd       	sbrc	r20, 0
+ 1dc:	0d c0       	rjmp	.+26     	; 0x1f8 <scanMatrix+0x54>
+ 1de:	80 ff       	sbrs	r24, 0
+ 1e0:	0b c0       	rjmp	.+22     	; 0x1f8 <scanMatrix+0x54>
+ 1e2:	81 e0       	ldi	r24, 0x01	; 1
+ 1e4:	80 93 40 01 	sts	0x0140, r24
+ 1e8:	c9 01       	movw	r24, r18
+ 1ea:	66 e0       	ldi	r22, 0x06	; 6
+ 1ec:	70 e0       	ldi	r23, 0x00	; 0
+ 1ee:	e8 d3       	rcall	.+2000   	; 0x9c0 <__mulhi3>
+ 1f0:	fc 01       	movw	r30, r24
+ 1f2:	e0 50       	subi	r30, 0x00	; 0
+ 1f4:	ff 4f       	sbci	r31, 0xFF	; 255
+ 1f6:	20 c0       	rjmp	.+64     	; 0x238 <__stack+0x39>
+ 1f8:	91 fd       	sbrc	r25, 1
+ 1fa:	0e c0       	rjmp	.+28     	; 0x218 <__stack+0x19>
+ 1fc:	81 ff       	sbrs	r24, 1
+ 1fe:	0c c0       	rjmp	.+24     	; 0x218 <__stack+0x19>
+ 200:	81 e0       	ldi	r24, 0x01	; 1
+ 202:	80 93 40 01 	sts	0x0140, r24
+ 206:	c9 01       	movw	r24, r18
+ 208:	66 e0       	ldi	r22, 0x06	; 6
+ 20a:	70 e0       	ldi	r23, 0x00	; 0
+ 20c:	d9 d3       	rcall	.+1970   	; 0x9c0 <__mulhi3>
+ 20e:	fc 01       	movw	r30, r24
+ 210:	e0 50       	subi	r30, 0x00	; 0
+ 212:	ff 4f       	sbci	r31, 0xFF	; 255
+ 214:	81 81       	ldd	r24, Z+1	; 0x01
+ 216:	41 c0       	rjmp	.+130    	; 0x29a <__stack+0x9b>
+ 218:	94 fd       	sbrc	r25, 4
+ 21a:	10 c0       	rjmp	.+32     	; 0x23c <__stack+0x3d>
+ 21c:	84 ff       	sbrs	r24, 4
+ 21e:	0e c0       	rjmp	.+28     	; 0x23c <__stack+0x3d>
+ 220:	81 e0       	ldi	r24, 0x01	; 1
+ 222:	80 93 40 01 	sts	0x0140, r24
+ 226:	c9 01       	movw	r24, r18
+ 228:	63 e0       	ldi	r22, 0x03	; 3
+ 22a:	70 e0       	ldi	r23, 0x00	; 0
+ 22c:	c9 d3       	rcall	.+1938   	; 0x9c0 <__mulhi3>
+ 22e:	fc 01       	movw	r30, r24
+ 230:	ee 0f       	add	r30, r30
+ 232:	ff 1f       	adc	r31, r31
+ 234:	ee 5f       	subi	r30, 0xFE	; 254
+ 236:	fe 4f       	sbci	r31, 0xFE	; 254
+ 238:	80 81       	ld	r24, Z
+ 23a:	2f c0       	rjmp	.+94     	; 0x29a <__stack+0x9b>
+ 23c:	95 fd       	sbrc	r25, 5
+ 23e:	0e c0       	rjmp	.+28     	; 0x25c <__stack+0x5d>
+ 240:	85 ff       	sbrs	r24, 5
+ 242:	0c c0       	rjmp	.+24     	; 0x25c <__stack+0x5d>
+ 244:	81 e0       	ldi	r24, 0x01	; 1
+ 246:	80 93 40 01 	sts	0x0140, r24
+ 24a:	c9 01       	movw	r24, r18
+ 24c:	66 e0       	ldi	r22, 0x06	; 6
+ 24e:	70 e0       	ldi	r23, 0x00	; 0
+ 250:	b7 d3       	rcall	.+1902   	; 0x9c0 <__mulhi3>
+ 252:	fc 01       	movw	r30, r24
+ 254:	e0 50       	subi	r30, 0x00	; 0
+ 256:	ff 4f       	sbci	r31, 0xFF	; 255
+ 258:	83 81       	ldd	r24, Z+3	; 0x03
+ 25a:	1f c0       	rjmp	.+62     	; 0x29a <__stack+0x9b>
+ 25c:	96 fd       	sbrc	r25, 6
+ 25e:	0e c0       	rjmp	.+28     	; 0x27c <__stack+0x7d>
+ 260:	86 ff       	sbrs	r24, 6
+ 262:	0c c0       	rjmp	.+24     	; 0x27c <__stack+0x7d>
+ 264:	81 e0       	ldi	r24, 0x01	; 1
+ 266:	80 93 40 01 	sts	0x0140, r24
+ 26a:	c9 01       	movw	r24, r18
+ 26c:	66 e0       	ldi	r22, 0x06	; 6
+ 26e:	70 e0       	ldi	r23, 0x00	; 0
+ 270:	a7 d3       	rcall	.+1870   	; 0x9c0 <__mulhi3>
+ 272:	fc 01       	movw	r30, r24
+ 274:	e0 50       	subi	r30, 0x00	; 0
+ 276:	ff 4f       	sbci	r31, 0xFF	; 255
+ 278:	84 81       	ldd	r24, Z+4	; 0x04
+ 27a:	0f c0       	rjmp	.+30     	; 0x29a <__stack+0x9b>
+ 27c:	47 fd       	sbrc	r20, 7
+ 27e:	11 c0       	rjmp	.+34     	; 0x2a2 <__stack+0xa3>
+ 280:	87 ff       	sbrs	r24, 7
+ 282:	0f c0       	rjmp	.+30     	; 0x2a2 <__stack+0xa3>
+ 284:	81 e0       	ldi	r24, 0x01	; 1
+ 286:	80 93 40 01 	sts	0x0140, r24
+ 28a:	c9 01       	movw	r24, r18
+ 28c:	66 e0       	ldi	r22, 0x06	; 6
+ 28e:	70 e0       	ldi	r23, 0x00	; 0
+ 290:	97 d3       	rcall	.+1838   	; 0x9c0 <__mulhi3>
+ 292:	fc 01       	movw	r30, r24
+ 294:	e0 50       	subi	r30, 0x00	; 0
+ 296:	ff 4f       	sbci	r31, 0xFF	; 255
+ 298:	85 81       	ldd	r24, Z+5	; 0x05
+ 29a:	80 93 43 01 	sts	0x0143, r24
+ 29e:	10 92 44 01 	sts	0x0144, r1
+ 2a2:	80 91 3c 01 	lds	r24, 0x013C
+ 2a6:	90 91 3d 01 	lds	r25, 0x013D
+ 2aa:	88 0f       	add	r24, r24
+ 2ac:	99 1f       	adc	r25, r25
+ 2ae:	90 93 3d 01 	sts	0x013D, r25
+ 2b2:	80 93 3c 01 	sts	0x013C, r24
+ 2b6:	af 5f       	subi	r26, 0xFF	; 255
+ 2b8:	a0 93 56 01 	sts	0x0156, r26
+ 2bc:	80 34       	cpi	r24, 0x40	; 64
+ 2be:	91 05       	cpc	r25, r1
+ 2c0:	31 f4       	brne	.+12     	; 0x2ce <__stack+0xcf>
+ 2c2:	80 e8       	ldi	r24, 0x80	; 128
+ 2c4:	90 e0       	ldi	r25, 0x00	; 0
+ 2c6:	90 93 3d 01 	sts	0x013D, r25
+ 2ca:	80 93 3c 01 	sts	0x013C, r24
+ 2ce:	80 91 3c 01 	lds	r24, 0x013C
+ 2d2:	90 91 3d 01 	lds	r25, 0x013D
+ 2d6:	80 50       	subi	r24, 0x00	; 0
+ 2d8:	94 40       	sbci	r25, 0x04	; 4
+ 2da:	41 f4       	brne	.+16     	; 0x2ec <__stack+0xed>
+ 2dc:	81 e0       	ldi	r24, 0x01	; 1
+ 2de:	90 e0       	ldi	r25, 0x00	; 0
+ 2e0:	90 93 3d 01 	sts	0x013D, r25
+ 2e4:	80 93 3c 01 	sts	0x013C, r24
+ 2e8:	10 92 56 01 	sts	0x0156, r1
+ 2ec:	90 91 3c 01 	lds	r25, 0x013C
+ 2f0:	80 91 3d 01 	lds	r24, 0x013D
+ 2f4:	97 b9       	out	0x07, r25	; 7
+ 2f6:	84 60       	ori	r24, 0x04	; 4
+ 2f8:	8d b9       	out	0x0d, r24	; 13
+ 2fa:	08 95       	ret
+
+000002fc <OnKey>:
+ 2fc:	80 91 40 01 	lds	r24, 0x0140
+ 300:	81 30       	cpi	r24, 0x01	; 1
+ 302:	81 f0       	breq	.+32     	; 0x324 <OnKey+0x28>
+ 304:	83 b1       	in	r24, 0x03	; 3
+ 306:	90 e0       	ldi	r25, 0x00	; 0
+ 308:	80 78       	andi	r24, 0x80	; 128
+ 30a:	90 70       	andi	r25, 0x00	; 0
+ 30c:	80 93 53 01 	sts	0x0153, r24
+ 310:	89 2b       	or	r24, r25
+ 312:	41 f4       	brne	.+16     	; 0x324 <OnKey+0x28>
+ 314:	81 e0       	ldi	r24, 0x01	; 1
+ 316:	85 b9       	out	0x05, r24	; 5
+ 318:	81 e0       	ldi	r24, 0x01	; 1
+ 31a:	90 e0       	ldi	r25, 0x00	; 0
+ 31c:	90 93 42 01 	sts	0x0142, r25
+ 320:	80 93 41 01 	sts	0x0141, r24
+ 324:	08 95       	ret
+
+00000326 <KeyPressed>:
+ 326:	80 91 41 01 	lds	r24, 0x0141
+ 32a:	90 91 42 01 	lds	r25, 0x0142
+ 32e:	89 2b       	or	r24, r25
+ 330:	a9 f1       	breq	.+106    	; 0x39c <KeyPressed+0x76>
+ 332:	1f 99       	sbic	0x03, 7	; 3
+ 334:	1d c0       	rjmp	.+58     	; 0x370 <KeyPressed+0x4a>
+ 336:	80 91 45 01 	lds	r24, 0x0145
+ 33a:	90 91 46 01 	lds	r25, 0x0146
+ 33e:	01 96       	adiw	r24, 0x01	; 1
+ 340:	90 93 46 01 	sts	0x0146, r25
+ 344:	80 93 45 01 	sts	0x0145, r24
+ 348:	80 52       	subi	r24, 0x20	; 32
+ 34a:	93 40       	sbci	r25, 0x03	; 3
+ 34c:	89 f4       	brne	.+34     	; 0x370 <KeyPressed+0x4a>
+ 34e:	8c e3       	ldi	r24, 0x3C	; 60
+ 350:	90 e0       	ldi	r25, 0x00	; 0
+ 352:	90 93 44 01 	sts	0x0144, r25
+ 356:	80 93 43 01 	sts	0x0143, r24
+ 35a:	81 e0       	ldi	r24, 0x01	; 1
+ 35c:	80 93 40 01 	sts	0x0140, r24
+ 360:	10 92 42 01 	sts	0x0142, r1
+ 364:	10 92 41 01 	sts	0x0141, r1
+ 368:	10 92 46 01 	sts	0x0146, r1
+ 36c:	10 92 45 01 	sts	0x0145, r1
+ 370:	80 91 45 01 	lds	r24, 0x0145
+ 374:	90 91 46 01 	lds	r25, 0x0146
+ 378:	89 55       	subi	r24, 0x59	; 89
+ 37a:	92 40       	sbci	r25, 0x02	; 2
+ 37c:	87 3c       	cpi	r24, 0xC7	; 199
+ 37e:	91 05       	cpc	r25, r1
+ 380:	68 f4       	brcc	.+26     	; 0x39c <KeyPressed+0x76>
+ 382:	80 91 36 01 	lds	r24, 0x0136
+ 386:	80 93 43 01 	sts	0x0143, r24
+ 38a:	10 92 44 01 	sts	0x0144, r1
+ 38e:	81 e0       	ldi	r24, 0x01	; 1
+ 390:	80 93 40 01 	sts	0x0140, r24
+ 394:	10 92 42 01 	sts	0x0142, r1
+ 398:	10 92 41 01 	sts	0x0141, r1
+ 39c:	08 95       	ret
+
+0000039e <Init>:
+ 39e:	10 92 6b 00 	sts	0x006B, r1
+ 3a2:	10 92 6d 00 	sts	0x006D, r1
+ 3a6:	10 92 6a 00 	sts	0x006A, r1
+ 3aa:	17 b8       	out	0x07, r1	; 7
+ 3ac:	18 b8       	out	0x08, r1	; 8
+ 3ae:	8a b1       	in	r24, 0x0a	; 10
+ 3b0:	8c 70       	andi	r24, 0x0C	; 12
+ 3b2:	8a b9       	out	0x0a, r24	; 10
+ 3b4:	8b b1       	in	r24, 0x0b	; 11
+ 3b6:	1b b8       	out	0x0b, r1	; 11
+ 3b8:	84 e0       	ldi	r24, 0x04	; 4
+ 3ba:	8d b9       	out	0x0d, r24	; 13
+ 3bc:	1e b8       	out	0x0e, r1	; 14
+ 3be:	10 92 80 00 	sts	0x0080, r1
+ 3c2:	10 92 81 00 	sts	0x0081, r1
+ 3c6:	10 92 82 00 	sts	0x0082, r1
+ 3ca:	81 e0       	ldi	r24, 0x01	; 1
+ 3cc:	84 b9       	out	0x04, r24	; 4
+ 3ce:	15 b8       	out	0x05, r1	; 5
+ 3d0:	08 95       	ret
+
+000003d2 <main>:
+ 3d2:	1f 93       	push	r17
+ 3d4:	e4 df       	rcall	.-56     	; 0x39e <Init>
+ 3d6:	e7 e5       	ldi	r30, 0x57	; 87
+ 3d8:	f1 e0       	ldi	r31, 0x01	; 1
+ 3da:	11 92       	st	Z+, r1
+ 3dc:	81 e0       	ldi	r24, 0x01	; 1
+ 3de:	ef 35       	cpi	r30, 0x5F	; 95
+ 3e0:	f8 07       	cpc	r31, r24
+ 3e2:	d9 f7       	brne	.-10     	; 0x3da <main+0x8>
+ 3e4:	2e e0       	ldi	r18, 0x0E	; 14
+ 3e6:	88 e1       	ldi	r24, 0x18	; 24
+ 3e8:	90 e0       	ldi	r25, 0x00	; 0
+ 3ea:	0f b6       	in	r0, 0x3f	; 63
+ 3ec:	f8 94       	cli
+ 3ee:	a8 95       	wdr
+ 3f0:	80 93 60 00 	sts	0x0060, r24
+ 3f4:	0f be       	out	0x3f, r0	; 63
+ 3f6:	20 93 60 00 	sts	0x0060, r18
+ 3fa:	3b d0       	rcall	.+118    	; 0x472 <usbInit>
+ 3fc:	53 9a       	sbi	0x0a, 3	; 10
+ 3fe:	20 e0       	ldi	r18, 0x00	; 0
+ 400:	40 e7       	ldi	r20, 0x70	; 112
+ 402:	57 e1       	ldi	r21, 0x17	; 23
+ 404:	a8 95       	wdr
+ 406:	ca 01       	movw	r24, r20
+ 408:	01 97       	sbiw	r24, 0x01	; 1
+ 40a:	f1 f7       	brne	.-4      	; 0x408 <main+0x36>
+ 40c:	2f 5f       	subi	r18, 0xFF	; 255
+ 40e:	2a 3f       	cpi	r18, 0xFA	; 250
+ 410:	c9 f7       	brne	.-14     	; 0x404 <main+0x32>
+ 412:	3c d0       	rcall	.+120    	; 0x48c <usbPoll>
+ 414:	53 98       	cbi	0x0a, 3	; 10
+ 416:	f8 94       	cli
+ 418:	83 e0       	ldi	r24, 0x03	; 3
+ 41a:	85 bd       	out	0x25, r24	; 37
+ 41c:	81 e0       	ldi	r24, 0x01	; 1
+ 41e:	80 93 6e 00 	sts	0x006E, r24
+ 422:	78 94       	sei
+ 424:	12 e0       	ldi	r17, 0x02	; 2
+ 426:	7f df       	rcall	.-258    	; 0x326 <KeyPressed>
+ 428:	69 df       	rcall	.-302    	; 0x2fc <OnKey>
+ 42a:	bc de       	rcall	.-648    	; 0x1a4 <scanMatrix>
+ 42c:	a8 95       	wdr
+ 42e:	2e d0       	rcall	.+92     	; 0x48c <usbPoll>
+ 430:	80 91 6c 01 	lds	r24, 0x016C
+ 434:	84 ff       	sbrs	r24, 4
+ 436:	18 c0       	rjmp	.+48     	; 0x468 <main+0x96>
+ 438:	80 91 40 01 	lds	r24, 0x0140
+ 43c:	88 23       	and	r24, r24
+ 43e:	a1 f0       	breq	.+40     	; 0x468 <main+0x96>
+ 440:	81 30       	cpi	r24, 0x01	; 1
+ 442:	19 f0       	breq	.+6      	; 0x44a <main+0x78>
+ 444:	82 30       	cpi	r24, 0x02	; 2
+ 446:	71 f4       	brne	.+28     	; 0x464 <main+0x92>
+ 448:	09 c0       	rjmp	.+18     	; 0x45c <main+0x8a>
+ 44a:	80 91 43 01 	lds	r24, 0x0143
+ 44e:	10 92 57 01 	sts	0x0157, r1
+ 452:	80 93 59 01 	sts	0x0159, r24
+ 456:	10 93 40 01 	sts	0x0140, r17
+ 45a:	06 c0       	rjmp	.+12     	; 0x468 <main+0x96>
+ 45c:	10 92 57 01 	sts	0x0157, r1
+ 460:	10 92 59 01 	sts	0x0159, r1
+ 464:	10 92 40 01 	sts	0x0140, r1
+ 468:	87 e5       	ldi	r24, 0x57	; 87
+ 46a:	91 e0       	ldi	r25, 0x01	; 1
+ 46c:	68 e0       	ldi	r22, 0x08	; 8
+ 46e:	33 d1       	rcall	.+614    	; 0x6d6 <usbSetInterrupt>
+ 470:	da cf       	rjmp	.-76     	; 0x426 <main+0x54>
+
+00000472 <usbInit>:
+ 472:	e9 e6       	ldi	r30, 0x69	; 105
+ 474:	f0 e0       	ldi	r31, 0x00	; 0
+ 476:	80 81       	ld	r24, Z
+ 478:	82 60       	ori	r24, 0x02	; 2
+ 47a:	80 83       	st	Z, r24
+ 47c:	e8 9a       	sbi	0x1d, 0	; 29
+ 47e:	8b e4       	ldi	r24, 0x4B	; 75
+ 480:	80 93 6d 01 	sts	0x016D, r24
+ 484:	8a e5       	ldi	r24, 0x5A	; 90
+ 486:	80 93 6c 01 	sts	0x016C, r24
+ 48a:	08 95       	ret
+
+0000048c <usbPoll>:
+ 48c:	1f 93       	push	r17
+ 48e:	cf 93       	push	r28
+ 490:	df 93       	push	r29
+ 492:	60 91 7d 01 	lds	r22, 0x017D
+ 496:	63 50       	subi	r22, 0x03	; 3
+ 498:	67 fd       	sbrc	r22, 7
+ 49a:	c2 c0       	rjmp	.+388    	; 0x620 <usbPoll+0x194>
+ 49c:	80 91 7a 01 	lds	r24, 0x017A
+ 4a0:	cc e0       	ldi	r28, 0x0C	; 12
+ 4a2:	d0 e0       	ldi	r29, 0x00	; 0
+ 4a4:	c8 1b       	sub	r28, r24
+ 4a6:	d1 09       	sbc	r29, r1
+ 4a8:	cf 57       	subi	r28, 0x7F	; 127
+ 4aa:	de 4f       	sbci	r29, 0xFE	; 254
+ 4ac:	80 91 79 01 	lds	r24, 0x0179
+ 4b0:	8d 32       	cpi	r24, 0x2D	; 45
+ 4b2:	09 f0       	breq	.+2      	; 0x4b6 <usbPoll+0x2a>
+ 4b4:	a3 c0       	rjmp	.+326    	; 0x5fc <usbPoll+0x170>
+ 4b6:	68 30       	cpi	r22, 0x08	; 8
+ 4b8:	09 f0       	breq	.+2      	; 0x4bc <usbPoll+0x30>
+ 4ba:	b0 c0       	rjmp	.+352    	; 0x61c <usbPoll+0x190>
+ 4bc:	83 ec       	ldi	r24, 0xC3	; 195
+ 4be:	80 93 61 01 	sts	0x0161, r24
+ 4c2:	8a e5       	ldi	r24, 0x5A	; 90
+ 4c4:	80 93 3e 01 	sts	0x013E, r24
+ 4c8:	10 92 60 01 	sts	0x0160, r1
+ 4cc:	88 81       	ld	r24, Y
+ 4ce:	80 76       	andi	r24, 0x60	; 96
+ 4d0:	39 f0       	breq	.+14     	; 0x4e0 <usbPoll+0x54>
+ 4d2:	ce 01       	movw	r24, r28
+ 4d4:	19 de       	rcall	.-974    	; 0x108 <usbFunctionSetup>
+ 4d6:	28 2f       	mov	r18, r24
+ 4d8:	8f 3f       	cpi	r24, 0xFF	; 255
+ 4da:	09 f4       	brne	.+2      	; 0x4de <usbPoll+0x52>
+ 4dc:	7e c0       	rjmp	.+252    	; 0x5da <usbPoll+0x14e>
+ 4de:	84 c0       	rjmp	.+264    	; 0x5e8 <usbPoll+0x15c>
+ 4e0:	9a 81       	ldd	r25, Y+2	; 0x02
+ 4e2:	10 92 6a 01 	sts	0x016A, r1
+ 4e6:	89 81       	ldd	r24, Y+1	; 0x01
+ 4e8:	88 23       	and	r24, r24
+ 4ea:	21 f4       	brne	.+8      	; 0x4f4 <usbPoll+0x68>
+ 4ec:	10 92 6b 01 	sts	0x016B, r1
+ 4f0:	22 e0       	ldi	r18, 0x02	; 2
+ 4f2:	6c c0       	rjmp	.+216    	; 0x5cc <usbPoll+0x140>
+ 4f4:	85 30       	cpi	r24, 0x05	; 5
+ 4f6:	19 f4       	brne	.+6      	; 0x4fe <usbPoll+0x72>
+ 4f8:	90 93 7e 01 	sts	0x017E, r25
+ 4fc:	66 c0       	rjmp	.+204    	; 0x5ca <usbPoll+0x13e>
+ 4fe:	86 30       	cpi	r24, 0x06	; 6
+ 500:	09 f0       	breq	.+2      	; 0x504 <usbPoll+0x78>
+ 502:	4f c0       	rjmp	.+158    	; 0x5a2 <usbPoll+0x116>
+ 504:	8b 81       	ldd	r24, Y+3	; 0x03
+ 506:	81 30       	cpi	r24, 0x01	; 1
+ 508:	41 f4       	brne	.+16     	; 0x51a <usbPoll+0x8e>
+ 50a:	8b e9       	ldi	r24, 0x9B	; 155
+ 50c:	90 e0       	ldi	r25, 0x00	; 0
+ 50e:	90 93 7c 01 	sts	0x017C, r25
+ 512:	80 93 7b 01 	sts	0x017B, r24
+ 516:	22 e1       	ldi	r18, 0x12	; 18
+ 518:	40 c0       	rjmp	.+128    	; 0x59a <usbPoll+0x10e>
+ 51a:	82 30       	cpi	r24, 0x02	; 2
+ 51c:	41 f4       	brne	.+16     	; 0x52e <usbPoll+0xa2>
+ 51e:	8d ea       	ldi	r24, 0xAD	; 173
+ 520:	90 e0       	ldi	r25, 0x00	; 0
+ 522:	90 93 7c 01 	sts	0x017C, r25
+ 526:	80 93 7b 01 	sts	0x017B, r24
+ 52a:	22 e2       	ldi	r18, 0x22	; 34
+ 52c:	36 c0       	rjmp	.+108    	; 0x59a <usbPoll+0x10e>
+ 52e:	83 30       	cpi	r24, 0x03	; 3
+ 530:	f9 f4       	brne	.+62     	; 0x570 <usbPoll+0xe4>
+ 532:	8a 81       	ldd	r24, Y+2	; 0x02
+ 534:	88 23       	and	r24, r24
+ 536:	41 f4       	brne	.+16     	; 0x548 <usbPoll+0xbc>
+ 538:	87 e6       	ldi	r24, 0x67	; 103
+ 53a:	90 e0       	ldi	r25, 0x00	; 0
+ 53c:	90 93 7c 01 	sts	0x017C, r25
+ 540:	80 93 7b 01 	sts	0x017B, r24
+ 544:	24 e0       	ldi	r18, 0x04	; 4
+ 546:	29 c0       	rjmp	.+82     	; 0x59a <usbPoll+0x10e>
+ 548:	81 30       	cpi	r24, 0x01	; 1
+ 54a:	41 f4       	brne	.+16     	; 0x55c <usbPoll+0xd0>
+ 54c:	8b e6       	ldi	r24, 0x6B	; 107
+ 54e:	90 e0       	ldi	r25, 0x00	; 0
+ 550:	90 93 7c 01 	sts	0x017C, r25
+ 554:	80 93 7b 01 	sts	0x017B, r24
+ 558:	20 e2       	ldi	r18, 0x20	; 32
+ 55a:	1f c0       	rjmp	.+62     	; 0x59a <usbPoll+0x10e>
+ 55c:	82 30       	cpi	r24, 0x02	; 2
+ 55e:	e1 f4       	brne	.+56     	; 0x598 <usbPoll+0x10c>
+ 560:	8b e8       	ldi	r24, 0x8B	; 139
+ 562:	90 e0       	ldi	r25, 0x00	; 0
+ 564:	90 93 7c 01 	sts	0x017C, r25
+ 568:	80 93 7b 01 	sts	0x017B, r24
+ 56c:	20 e1       	ldi	r18, 0x10	; 16
+ 56e:	15 c0       	rjmp	.+42     	; 0x59a <usbPoll+0x10e>
+ 570:	81 32       	cpi	r24, 0x21	; 33
+ 572:	41 f4       	brne	.+16     	; 0x584 <usbPoll+0xf8>
+ 574:	8f eb       	ldi	r24, 0xBF	; 191
+ 576:	90 e0       	ldi	r25, 0x00	; 0
+ 578:	90 93 7c 01 	sts	0x017C, r25
+ 57c:	80 93 7b 01 	sts	0x017B, r24
+ 580:	29 e0       	ldi	r18, 0x09	; 9
+ 582:	0b c0       	rjmp	.+22     	; 0x59a <usbPoll+0x10e>
+ 584:	82 32       	cpi	r24, 0x22	; 34
+ 586:	41 f4       	brne	.+16     	; 0x598 <usbPoll+0x10c>
+ 588:	88 e2       	ldi	r24, 0x28	; 40
+ 58a:	90 e0       	ldi	r25, 0x00	; 0
+ 58c:	90 93 7c 01 	sts	0x017C, r25
+ 590:	80 93 7b 01 	sts	0x017B, r24
+ 594:	2f e3       	ldi	r18, 0x3F	; 63
+ 596:	01 c0       	rjmp	.+2      	; 0x59a <usbPoll+0x10e>
+ 598:	20 e0       	ldi	r18, 0x00	; 0
+ 59a:	80 e4       	ldi	r24, 0x40	; 64
+ 59c:	80 93 60 01 	sts	0x0160, r24
+ 5a0:	23 c0       	rjmp	.+70     	; 0x5e8 <usbPoll+0x15c>
+ 5a2:	88 30       	cpi	r24, 0x08	; 8
+ 5a4:	21 f4       	brne	.+8      	; 0x5ae <usbPoll+0x122>
+ 5a6:	21 e0       	ldi	r18, 0x01	; 1
+ 5a8:	80 e8       	ldi	r24, 0x80	; 128
+ 5aa:	91 e0       	ldi	r25, 0x01	; 1
+ 5ac:	11 c0       	rjmp	.+34     	; 0x5d0 <usbPoll+0x144>
+ 5ae:	89 30       	cpi	r24, 0x09	; 9
+ 5b0:	19 f4       	brne	.+6      	; 0x5b8 <usbPoll+0x12c>
+ 5b2:	90 93 80 01 	sts	0x0180, r25
+ 5b6:	09 c0       	rjmp	.+18     	; 0x5ca <usbPoll+0x13e>
+ 5b8:	8a 30       	cpi	r24, 0x0A	; 10
+ 5ba:	11 f4       	brne	.+4      	; 0x5c0 <usbPoll+0x134>
+ 5bc:	21 e0       	ldi	r18, 0x01	; 1
+ 5be:	06 c0       	rjmp	.+12     	; 0x5cc <usbPoll+0x140>
+ 5c0:	8b 30       	cpi	r24, 0x0B	; 11
+ 5c2:	19 f4       	brne	.+6      	; 0x5ca <usbPoll+0x13e>
+ 5c4:	8b e4       	ldi	r24, 0x4B	; 75
+ 5c6:	80 93 6d 01 	sts	0x016D, r24
+ 5ca:	20 e0       	ldi	r18, 0x00	; 0
+ 5cc:	8a e6       	ldi	r24, 0x6A	; 106
+ 5ce:	91 e0       	ldi	r25, 0x01	; 1
+ 5d0:	90 93 7c 01 	sts	0x017C, r25
+ 5d4:	80 93 7b 01 	sts	0x017B, r24
+ 5d8:	07 c0       	rjmp	.+14     	; 0x5e8 <usbPoll+0x15c>
+ 5da:	88 81       	ld	r24, Y
+ 5dc:	87 fd       	sbrc	r24, 7
+ 5de:	2e 81       	ldd	r18, Y+6	; 0x06
+ 5e0:	80 e8       	ldi	r24, 0x80	; 128
+ 5e2:	80 93 60 01 	sts	0x0160, r24
+ 5e6:	06 c0       	rjmp	.+12     	; 0x5f4 <usbPoll+0x168>
+ 5e8:	8f 81       	ldd	r24, Y+7	; 0x07
+ 5ea:	88 23       	and	r24, r24
+ 5ec:	19 f4       	brne	.+6      	; 0x5f4 <usbPoll+0x168>
+ 5ee:	8e 81       	ldd	r24, Y+6	; 0x06
+ 5f0:	82 17       	cp	r24, r18
+ 5f2:	08 f0       	brcs	.+2      	; 0x5f6 <usbPoll+0x16a>
+ 5f4:	82 2f       	mov	r24, r18
+ 5f6:	80 93 3f 01 	sts	0x013F, r24
+ 5fa:	10 c0       	rjmp	.+32     	; 0x61c <usbPoll+0x190>
+ 5fc:	80 91 60 01 	lds	r24, 0x0160
+ 600:	87 ff       	sbrs	r24, 7
+ 602:	0c c0       	rjmp	.+24     	; 0x61c <usbPoll+0x190>
+ 604:	ce 01       	movw	r24, r28
+ 606:	b3 dd       	rcall	.-1178   	; 0x16e <usbFunctionWrite>
+ 608:	8f 3f       	cpi	r24, 0xFF	; 255
+ 60a:	21 f4       	brne	.+8      	; 0x614 <usbPoll+0x188>
+ 60c:	8e e1       	ldi	r24, 0x1E	; 30
+ 60e:	80 93 3e 01 	sts	0x013E, r24
+ 612:	04 c0       	rjmp	.+8      	; 0x61c <usbPoll+0x190>
+ 614:	88 23       	and	r24, r24
+ 616:	11 f0       	breq	.+4      	; 0x61c <usbPoll+0x190>
+ 618:	10 92 3f 01 	sts	0x013F, r1
+ 61c:	10 92 7d 01 	sts	0x017D, r1
+ 620:	80 91 3e 01 	lds	r24, 0x013E
+ 624:	84 ff       	sbrs	r24, 4
+ 626:	49 c0       	rjmp	.+146    	; 0x6ba <usbPoll+0x22e>
+ 628:	80 91 3f 01 	lds	r24, 0x013F
+ 62c:	8f 3f       	cpi	r24, 0xFF	; 255
+ 62e:	09 f4       	brne	.+2      	; 0x632 <usbPoll+0x1a6>
+ 630:	44 c0       	rjmp	.+136    	; 0x6ba <usbPoll+0x22e>
+ 632:	18 2f       	mov	r17, r24
+ 634:	89 30       	cpi	r24, 0x09	; 9
+ 636:	08 f0       	brcs	.+2      	; 0x63a <usbPoll+0x1ae>
+ 638:	18 e0       	ldi	r17, 0x08	; 8
+ 63a:	81 1b       	sub	r24, r17
+ 63c:	80 93 3f 01 	sts	0x013F, r24
+ 640:	80 91 61 01 	lds	r24, 0x0161
+ 644:	98 e8       	ldi	r25, 0x88	; 136
+ 646:	89 27       	eor	r24, r25
+ 648:	80 93 61 01 	sts	0x0161, r24
+ 64c:	11 23       	and	r17, r17
+ 64e:	41 f1       	breq	.+80     	; 0x6a0 <usbPoll+0x214>
+ 650:	20 91 7b 01 	lds	r18, 0x017B
+ 654:	30 91 7c 01 	lds	r19, 0x017C
+ 658:	80 91 60 01 	lds	r24, 0x0160
+ 65c:	86 ff       	sbrs	r24, 6
+ 65e:	0d c0       	rjmp	.+26     	; 0x67a <usbPoll+0x1ee>
+ 660:	a2 e6       	ldi	r26, 0x62	; 98
+ 662:	b1 e0       	ldi	r27, 0x01	; 1
+ 664:	80 e0       	ldi	r24, 0x00	; 0
+ 666:	90 e0       	ldi	r25, 0x00	; 0
+ 668:	f9 01       	movw	r30, r18
+ 66a:	e8 0f       	add	r30, r24
+ 66c:	f9 1f       	adc	r31, r25
+ 66e:	e4 91       	lpm	r30, Z+
+ 670:	ed 93       	st	X+, r30
+ 672:	01 96       	adiw	r24, 0x01	; 1
+ 674:	18 17       	cp	r17, r24
+ 676:	c1 f7       	brne	.-16     	; 0x668 <usbPoll+0x1dc>
+ 678:	08 c0       	rjmp	.+16     	; 0x68a <usbPoll+0x1fe>
+ 67a:	91 2f       	mov	r25, r17
+ 67c:	d9 01       	movw	r26, r18
+ 67e:	e2 e6       	ldi	r30, 0x62	; 98
+ 680:	f1 e0       	ldi	r31, 0x01	; 1
+ 682:	8d 91       	ld	r24, X+
+ 684:	81 93       	st	Z+, r24
+ 686:	91 50       	subi	r25, 0x01	; 1
+ 688:	e1 f7       	brne	.-8      	; 0x682 <usbPoll+0x1f6>
+ 68a:	11 50       	subi	r17, 0x01	; 1
+ 68c:	81 2f       	mov	r24, r17
+ 68e:	90 e0       	ldi	r25, 0x00	; 0
+ 690:	1f 5f       	subi	r17, 0xFF	; 255
+ 692:	01 96       	adiw	r24, 0x01	; 1
+ 694:	82 0f       	add	r24, r18
+ 696:	93 1f       	adc	r25, r19
+ 698:	90 93 7c 01 	sts	0x017C, r25
+ 69c:	80 93 7b 01 	sts	0x017B, r24
+ 6a0:	82 e6       	ldi	r24, 0x62	; 98
+ 6a2:	91 e0       	ldi	r25, 0x01	; 1
+ 6a4:	61 2f       	mov	r22, r17
+ 6a6:	4e d0       	rcall	.+156    	; 0x744 <usbCrc16Append>
+ 6a8:	61 2f       	mov	r22, r17
+ 6aa:	6c 5f       	subi	r22, 0xFC	; 252
+ 6ac:	6c 30       	cpi	r22, 0x0C	; 12
+ 6ae:	19 f0       	breq	.+6      	; 0x6b6 <usbPoll+0x22a>
+ 6b0:	8f ef       	ldi	r24, 0xFF	; 255
+ 6b2:	80 93 3f 01 	sts	0x013F, r24
+ 6b6:	60 93 3e 01 	sts	0x013E, r22
+ 6ba:	94 e1       	ldi	r25, 0x14	; 20
+ 6bc:	89 b1       	in	r24, 0x09	; 9
+ 6be:	8c 70       	andi	r24, 0x0C	; 12
+ 6c0:	31 f4       	brne	.+12     	; 0x6ce <usbPoll+0x242>
+ 6c2:	91 50       	subi	r25, 0x01	; 1
+ 6c4:	d9 f7       	brne	.-10     	; 0x6bc <usbPoll+0x230>
+ 6c6:	10 92 7e 01 	sts	0x017E, r1
+ 6ca:	10 92 78 01 	sts	0x0178, r1
+ 6ce:	df 91       	pop	r29
+ 6d0:	cf 91       	pop	r28
+ 6d2:	1f 91       	pop	r17
+ 6d4:	08 95       	ret
+
+000006d6 <usbSetInterrupt>:
+ 6d6:	1f 93       	push	r17
+ 6d8:	dc 01       	movw	r26, r24
+ 6da:	16 2f       	mov	r17, r22
+ 6dc:	80 91 6c 01 	lds	r24, 0x016C
+ 6e0:	84 ff       	sbrs	r24, 4
+ 6e2:	07 c0       	rjmp	.+14     	; 0x6f2 <usbSetInterrupt+0x1c>
+ 6e4:	80 91 6d 01 	lds	r24, 0x016D
+ 6e8:	98 e8       	ldi	r25, 0x88	; 136
+ 6ea:	89 27       	eor	r24, r25
+ 6ec:	80 93 6d 01 	sts	0x016D, r24
+ 6f0:	03 c0       	rjmp	.+6      	; 0x6f8 <usbSetInterrupt+0x22>
+ 6f2:	8a e5       	ldi	r24, 0x5A	; 90
+ 6f4:	80 93 6c 01 	sts	0x016C, r24
+ 6f8:	91 2f       	mov	r25, r17
+ 6fa:	ee e6       	ldi	r30, 0x6E	; 110
+ 6fc:	f1 e0       	ldi	r31, 0x01	; 1
+ 6fe:	8d 91       	ld	r24, X+
+ 700:	81 93       	st	Z+, r24
+ 702:	91 50       	subi	r25, 0x01	; 1
+ 704:	19 16       	cp	r1, r25
+ 706:	dc f3       	brlt	.-10     	; 0x6fe <usbSetInterrupt+0x28>
+ 708:	8e e6       	ldi	r24, 0x6E	; 110
+ 70a:	91 e0       	ldi	r25, 0x01	; 1
+ 70c:	61 2f       	mov	r22, r17
+ 70e:	1a d0       	rcall	.+52     	; 0x744 <usbCrc16Append>
+ 710:	1c 5f       	subi	r17, 0xFC	; 252
+ 712:	10 93 6c 01 	sts	0x016C, r17
+ 716:	1f 91       	pop	r17
+ 718:	08 95       	ret
+
+0000071a <usbCrc16>:
+ 71a:	a8 2f       	mov	r26, r24
+ 71c:	b9 2f       	mov	r27, r25
+ 71e:	80 e0       	ldi	r24, 0x00	; 0
+ 720:	90 e0       	ldi	r25, 0x00	; 0
+ 722:	41 e0       	ldi	r20, 0x01	; 1
+ 724:	50 ea       	ldi	r21, 0xA0	; 160
+ 726:	60 95       	com	r22
+ 728:	30 e0       	ldi	r19, 0x00	; 0
+ 72a:	09 c0       	rjmp	.+18     	; 0x73e <usbCrcLoopEntry>
+
+0000072c <usbCrcByteLoop>:
+ 72c:	2d 91       	ld	r18, X+
+ 72e:	82 27       	eor	r24, r18
+
+00000730 <usbCrcBitLoop>:
+ 730:	97 95       	ror	r25
+ 732:	87 95       	ror	r24
+ 734:	10 f0       	brcs	.+4      	; 0x73a <usbCrcNoXor>
+ 736:	84 27       	eor	r24, r20
+ 738:	95 27       	eor	r25, r21
+
+0000073a <usbCrcNoXor>:
+ 73a:	30 5e       	subi	r19, 0xE0	; 224
+ 73c:	c8 f3       	brcs	.-14     	; 0x730 <usbCrcBitLoop>
+
+0000073e <usbCrcLoopEntry>:
+ 73e:	6f 5f       	subi	r22, 0xFF	; 255
+ 740:	a8 f3       	brcs	.-22     	; 0x72c <usbCrcByteLoop>
+
+00000742 <usbCrcReady>:
+ 742:	08 95       	ret
+
+00000744 <usbCrc16Append>:
+ 744:	ea df       	rcall	.-44     	; 0x71a <usbCrc16>
+ 746:	8d 93       	st	X+, r24
+ 748:	9d 93       	st	X+, r25
+ 74a:	08 95       	ret
+
+0000074c <__vector_1>:
+ 74c:	cf 93       	push	r28
+ 74e:	cf b7       	in	r28, 0x3f	; 63
+ 750:	cf 93       	push	r28
+
+00000752 <waitForJ>:
+ 752:	c3 95       	inc	r28
+ 754:	4b 9b       	sbis	0x09, 3	; 9
+ 756:	e9 f7       	brne	.-6      	; 0x752 <waitForJ>
+
+00000758 <waitForK>:
+ 758:	4b 9b       	sbis	0x09, 3	; 9
+ 75a:	09 c0       	rjmp	.+18     	; 0x76e <foundK>
+ 75c:	4b 9b       	sbis	0x09, 3	; 9
+ 75e:	07 c0       	rjmp	.+14     	; 0x76e <foundK>
+ 760:	4b 9b       	sbis	0x09, 3	; 9
+ 762:	05 c0       	rjmp	.+10     	; 0x76e <foundK>
+ 764:	4b 9b       	sbis	0x09, 3	; 9
+ 766:	03 c0       	rjmp	.+6      	; 0x76e <foundK>
+ 768:	4b 9b       	sbis	0x09, 3	; 9
+ 76a:	01 c0       	rjmp	.+2      	; 0x76e <foundK>
+ 76c:	a3 c0       	rjmp	.+326    	; 0x8b4 <sofError>
+
+0000076e <foundK>:
+ 76e:	df 93       	push	r29
+ 770:	c0 91 7a 01 	lds	r28, 0x017A
+ 774:	dd 27       	eor	r29, r29
+ 776:	cf 57       	subi	r28, 0x7F	; 127
+ 778:	de 4f       	sbci	r29, 0xFE	; 254
+ 77a:	4b 9b       	sbis	0x09, 3	; 9
+ 77c:	02 c0       	rjmp	.+4      	; 0x782 <haveTwoBitsK>
+ 77e:	df 91       	pop	r29
+ 780:	eb cf       	rjmp	.-42     	; 0x758 <waitForK>
+
+00000782 <haveTwoBitsK>:
+ 782:	2f 93       	push	r18
+ 784:	0f 93       	push	r16
+ 786:	1f 93       	push	r17
+ 788:	09 b1       	in	r16, 0x09	; 9
+ 78a:	2f ef       	ldi	r18, 0xFF	; 255
+ 78c:	03 fb       	bst	r16, 3
+ 78e:	20 f9       	bld	r18, 0
+ 790:	4f 93       	push	r20
+ 792:	3f 93       	push	r19
+ 794:	19 b1       	in	r17, 0x09	; 9
+ 796:	4f ef       	ldi	r20, 0xFF	; 255
+ 798:	01 27       	eor	r16, r17
+ 79a:	03 fb       	bst	r16, 3
+ 79c:	21 f9       	bld	r18, 1
+ 79e:	3b e0       	ldi	r19, 0x0B	; 11
+ 7a0:	31 c0       	rjmp	.+98     	; 0x804 <rxbit2>
+
+000007a2 <unstuff0>:
+ 7a2:	4e 7f       	andi	r20, 0xFE	; 254
+ 7a4:	01 2f       	mov	r16, r17
+ 7a6:	19 b1       	in	r17, 0x09	; 9
+ 7a8:	21 60       	ori	r18, 0x01	; 1
+ 7aa:	28 c0       	rjmp	.+80     	; 0x7fc <didUnstuff0>
+
+000007ac <unstuff1>:
+ 7ac:	10 2f       	mov	r17, r16
+ 7ae:	4d 7f       	andi	r20, 0xFD	; 253
+ 7b0:	22 60       	ori	r18, 0x02	; 2
+ 7b2:	00 00       	nop
+ 7b4:	09 b1       	in	r16, 0x09	; 9
+ 7b6:	29 c0       	rjmp	.+82     	; 0x80a <didUnstuff1>
+
+000007b8 <unstuff2>:
+ 7b8:	4b 7f       	andi	r20, 0xFB	; 251
+ 7ba:	24 60       	ori	r18, 0x04	; 4
+ 7bc:	01 2f       	mov	r16, r17
+ 7be:	00 00       	nop
+ 7c0:	19 b1       	in	r17, 0x09	; 9
+ 7c2:	2b c0       	rjmp	.+86     	; 0x81a <didUnstuff2>
+
+000007c4 <unstuff3>:
+ 7c4:	19 b1       	in	r17, 0x09	; 9
+ 7c6:	47 7f       	andi	r20, 0xF7	; 247
+ 7c8:	28 60       	ori	r18, 0x08	; 8
+ 7ca:	2a c0       	rjmp	.+84     	; 0x820 <didUnstuff3>
+
+000007cc <unstuff4>:
+ 7cc:	4f 7e       	andi	r20, 0xEF	; 239
+ 7ce:	09 b1       	in	r16, 0x09	; 9
+ 7d0:	20 61       	ori	r18, 0x10	; 16
+ 7d2:	2c c0       	rjmp	.+88     	; 0x82c <didUnstuff4>
+
+000007d4 <unstuff5>:
+ 7d4:	4f 7d       	andi	r20, 0xDF	; 223
+ 7d6:	19 b1       	in	r17, 0x09	; 9
+ 7d8:	20 62       	ori	r18, 0x20	; 32
+ 7da:	2f c0       	rjmp	.+94     	; 0x83a <didUnstuff5>
+
+000007dc <unstuff6>:
+ 7dc:	4f 7b       	andi	r20, 0xBF	; 191
+ 7de:	09 b1       	in	r16, 0x09	; 9
+ 7e0:	20 64       	ori	r18, 0x40	; 64
+ 7e2:	32 c0       	rjmp	.+100    	; 0x848 <didUnstuff6>
+
+000007e4 <rxLoop>:
+ 7e4:	42 27       	eor	r20, r18
+ 7e6:	09 b1       	in	r16, 0x09	; 9
+ 7e8:	49 93       	st	Y+, r20
+ 7ea:	4f ef       	ldi	r20, 0xFF	; 255
+ 7ec:	00 00       	nop
+ 7ee:	10 27       	eor	r17, r16
+ 7f0:	13 fb       	bst	r17, 3
+ 7f2:	20 f9       	bld	r18, 0
+ 7f4:	19 b1       	in	r17, 0x09	; 9
+ 7f6:	1c 70       	andi	r17, 0x0C	; 12
+ 7f8:	c9 f1       	breq	.+114    	; 0x86c <se0>
+ 7fa:	29 7f       	andi	r18, 0xF9	; 249
+
+000007fc <didUnstuff0>:
+ 7fc:	91 f2       	breq	.-92     	; 0x7a2 <unstuff0>
+ 7fe:	01 27       	eor	r16, r17
+ 800:	03 fb       	bst	r16, 3
+ 802:	21 f9       	bld	r18, 1
+
+00000804 <rxbit2>:
+ 804:	09 b1       	in	r16, 0x09	; 9
+ 806:	23 7f       	andi	r18, 0xF3	; 243
+ 808:	89 f2       	breq	.-94     	; 0x7ac <unstuff1>
+
+0000080a <didUnstuff1>:
+ 80a:	31 50       	subi	r19, 0x01	; 1
+ 80c:	58 f1       	brcs	.+86     	; 0x864 <overflow>
+ 80e:	10 27       	eor	r17, r16
+ 810:	13 fb       	bst	r17, 3
+ 812:	22 f9       	bld	r18, 2
+ 814:	19 b1       	in	r17, 0x09	; 9
+ 816:	27 7e       	andi	r18, 0xE7	; 231
+ 818:	79 f2       	breq	.-98     	; 0x7b8 <unstuff2>
+
+0000081a <didUnstuff2>:
+ 81a:	01 27       	eor	r16, r17
+ 81c:	03 fb       	bst	r16, 3
+ 81e:	23 f9       	bld	r18, 3
+
+00000820 <didUnstuff3>:
+ 820:	2f 7c       	andi	r18, 0xCF	; 207
+ 822:	81 f2       	breq	.-96     	; 0x7c4 <unstuff3>
+ 824:	09 b1       	in	r16, 0x09	; 9
+ 826:	10 27       	eor	r17, r16
+ 828:	13 fb       	bst	r17, 3
+ 82a:	24 f9       	bld	r18, 4
+
+0000082c <didUnstuff4>:
+ 82c:	2f 79       	andi	r18, 0x9F	; 159
+ 82e:	71 f2       	breq	.-100    	; 0x7cc <unstuff4>
+ 830:	00 c0       	rjmp	.+0      	; 0x832 <didUnstuff4+0x6>
+ 832:	19 b1       	in	r17, 0x09	; 9
+ 834:	01 27       	eor	r16, r17
+ 836:	03 fb       	bst	r16, 3
+ 838:	25 f9       	bld	r18, 5
+
+0000083a <didUnstuff5>:
+ 83a:	2f 73       	andi	r18, 0x3F	; 63
+ 83c:	59 f2       	breq	.-106    	; 0x7d4 <unstuff5>
+ 83e:	00 c0       	rjmp	.+0      	; 0x840 <didUnstuff5+0x6>
+ 840:	09 b1       	in	r16, 0x09	; 9
+ 842:	10 27       	eor	r17, r16
+ 844:	13 fb       	bst	r17, 3
+ 846:	26 f9       	bld	r18, 6
+
+00000848 <didUnstuff6>:
+ 848:	22 30       	cpi	r18, 0x02	; 2
+ 84a:	40 f2       	brcs	.-112    	; 0x7dc <unstuff6>
+ 84c:	00 c0       	rjmp	.+0      	; 0x84e <didUnstuff6+0x6>
+ 84e:	19 b1       	in	r17, 0x09	; 9
+ 850:	01 27       	eor	r16, r17
+ 852:	03 fb       	bst	r16, 3
+ 854:	27 f9       	bld	r18, 7
+
+00000856 <didUnstuff7>:
+ 856:	24 30       	cpi	r18, 0x04	; 4
+ 858:	28 f6       	brcc	.-118    	; 0x7e4 <rxLoop>
+
+0000085a <unstuff7>:
+ 85a:	4f 77       	andi	r20, 0x7F	; 127
+ 85c:	20 68       	ori	r18, 0x80	; 128
+ 85e:	19 b1       	in	r17, 0x09	; 9
+ 860:	00 00       	nop
+ 862:	f9 cf       	rjmp	.-14     	; 0x856 <didUnstuff7>
+
+00000864 <overflow>:
+ 864:	11 e0       	ldi	r17, 0x01	; 1
+ 866:	1c bb       	out	0x1c, r17	; 28
+
+00000868 <ignorePacket>:
+ 868:	00 27       	eor	r16, r16
+ 86a:	19 c0       	rjmp	.+50     	; 0x89e <handleSetupOrOut>
+
+0000086c <se0>:
+ 86c:	3b 50       	subi	r19, 0x0B	; 11
+ 86e:	31 95       	neg	r19
+ 870:	c3 1b       	sub	r28, r19
+ 872:	d0 40       	sbci	r29, 0x00	; 0
+ 874:	11 e0       	ldi	r17, 0x01	; 1
+ 876:	1c bb       	out	0x1c, r17	; 28
+ 878:	08 81       	ld	r16, Y
+ 87a:	03 3c       	cpi	r16, 0xC3	; 195
+ 87c:	f9 f0       	breq	.+62     	; 0x8bc <handleData>
+ 87e:	0b 34       	cpi	r16, 0x4B	; 75
+ 880:	e9 f0       	breq	.+58     	; 0x8bc <handleData>
+ 882:	20 91 78 01 	lds	r18, 0x0178
+ 886:	19 81       	ldd	r17, Y+1	; 0x01
+ 888:	11 0f       	add	r17, r17
+ 88a:	12 13       	cpse	r17, r18
+ 88c:	ed cf       	rjmp	.-38     	; 0x868 <ignorePacket>
+ 88e:	4a 81       	ldd	r20, Y+2	; 0x02
+ 890:	44 1f       	adc	r20, r20
+ 892:	09 36       	cpi	r16, 0x69	; 105
+ 894:	41 f1       	breq	.+80     	; 0x8e6 <handleIn>
+ 896:	0d 32       	cpi	r16, 0x2D	; 45
+ 898:	11 f0       	breq	.+4      	; 0x89e <handleSetupOrOut>
+ 89a:	01 3e       	cpi	r16, 0xE1	; 225
+ 89c:	29 f7       	brne	.-54     	; 0x868 <ignorePacket>
+
+0000089e <handleSetupOrOut>:
+ 89e:	00 93 7f 01 	sts	0x017F, r16
+
+000008a2 <doReturn>:
+ 8a2:	3f 91       	pop	r19
+ 8a4:	4f 91       	pop	r20
+ 8a6:	1f 91       	pop	r17
+ 8a8:	0f 91       	pop	r16
+ 8aa:	2f 91       	pop	r18
+ 8ac:	df 91       	pop	r29
+ 8ae:	cc b3       	in	r28, 0x1c	; 28
+ 8b0:	c0 fd       	sbrc	r28, 0
+ 8b2:	4f cf       	rjmp	.-354    	; 0x752 <waitForJ>
+
+000008b4 <sofError>:
+ 8b4:	cf 91       	pop	r28
+ 8b6:	cf bf       	out	0x3f, r28	; 63
+ 8b8:	cf 91       	pop	r28
+ 8ba:	18 95       	reti
+
+000008bc <handleData>:
+ 8bc:	20 91 7f 01 	lds	r18, 0x017F
+ 8c0:	22 23       	and	r18, r18
+ 8c2:	79 f3       	breq	.-34     	; 0x8a2 <doReturn>
+ 8c4:	10 91 7d 01 	lds	r17, 0x017D
+ 8c8:	11 23       	and	r17, r17
+ 8ca:	69 f5       	brne	.+90     	; 0x926 <sendNakAndReti>
+ 8cc:	34 30       	cpi	r19, 0x04	; 4
+ 8ce:	6a f1       	brmi	.+90     	; 0x92a <sendAckAndReti>
+ 8d0:	30 93 7d 01 	sts	0x017D, r19
+ 8d4:	20 93 79 01 	sts	0x0179, r18
+ 8d8:	10 91 7a 01 	lds	r17, 0x017A
+ 8dc:	3b e0       	ldi	r19, 0x0B	; 11
+ 8de:	31 1b       	sub	r19, r17
+ 8e0:	30 93 7a 01 	sts	0x017A, r19
+ 8e4:	22 c0       	rjmp	.+68     	; 0x92a <sendAckAndReti>
+
+000008e6 <handleIn>:
+ 8e6:	00 91 7d 01 	lds	r16, 0x017D
+ 8ea:	01 30       	cpi	r16, 0x01	; 1
+ 8ec:	e4 f4       	brge	.+56     	; 0x926 <sendNakAndReti>
+ 8ee:	0a e5       	ldi	r16, 0x5A	; 90
+ 8f0:	4f 70       	andi	r20, 0x0F	; 15
+ 8f2:	49 f4       	brne	.+18     	; 0x906 <handleIn1>
+ 8f4:	30 91 3e 01 	lds	r19, 0x013E
+ 8f8:	34 fd       	sbrc	r19, 4
+ 8fa:	19 c0       	rjmp	.+50     	; 0x92e <sendCntAndReti>
+ 8fc:	00 93 3e 01 	sts	0x013E, r16
+ 900:	c1 e6       	ldi	r28, 0x61	; 97
+ 902:	d1 e0       	ldi	r29, 0x01	; 1
+ 904:	18 c0       	rjmp	.+48     	; 0x936 <usbSendAndReti>
+
+00000906 <handleIn1>:
+ 906:	30 91 6c 01 	lds	r19, 0x016C
+ 90a:	34 fd       	sbrc	r19, 4
+ 90c:	10 c0       	rjmp	.+32     	; 0x92e <sendCntAndReti>
+ 90e:	00 93 6c 01 	sts	0x016C, r16
+ 912:	cd e6       	ldi	r28, 0x6D	; 109
+ 914:	d1 e0       	ldi	r29, 0x01	; 1
+ 916:	0f c0       	rjmp	.+30     	; 0x936 <usbSendAndReti>
+
+00000918 <stuffN1Delay>:
+ 918:	27 95       	ror	r18
+ 91a:	a8 f4       	brcc	.+42     	; 0x946 <doExorN1>
+ 91c:	51 50       	subi	r21, 0x01	; 1
+ 91e:	a9 f4       	brne	.+42     	; 0x94a <commonN1>
+ 920:	22 0f       	add	r18, r18
+ 922:	00 00       	nop
+ 924:	f9 cf       	rjmp	.-14     	; 0x918 <stuffN1Delay>
+
+00000926 <sendNakAndReti>:
+ 926:	4a e5       	ldi	r20, 0x5A	; 90
+ 928:	03 c0       	rjmp	.+6      	; 0x930 <usbSendX3>
+
+0000092a <sendAckAndReti>:
+ 92a:	42 ed       	ldi	r20, 0xD2	; 210
+ 92c:	01 c0       	rjmp	.+2      	; 0x930 <usbSendX3>
+
+0000092e <sendCntAndReti>:
+ 92e:	43 2f       	mov	r20, r19
+
+00000930 <usbSendX3>:
+ 930:	c4 e1       	ldi	r28, 0x14	; 20
+ 932:	d0 e0       	ldi	r29, 0x00	; 0
+ 934:	32 e0       	ldi	r19, 0x02	; 2
+
+00000936 <usbSendAndReti>:
+ 936:	1a b1       	in	r17, 0x0a	; 10
+ 938:	1c 60       	ori	r17, 0x0C	; 12
+ 93a:	5b 9a       	sbi	0x0b, 3	; 11
+ 93c:	1a b9       	out	0x0a, r17	; 10
+ 93e:	0b b1       	in	r16, 0x0b	; 11
+ 940:	20 e4       	ldi	r18, 0x40	; 64
+ 942:	1c e0       	ldi	r17, 0x0C	; 12
+ 944:	5f 93       	push	r21
+
+00000946 <doExorN1>:
+ 946:	01 27       	eor	r16, r17
+ 948:	56 e0       	ldi	r21, 0x06	; 6
+
+0000094a <commonN1>:
+ 94a:	0b b9       	out	0x0b, r16	; 11
+ 94c:	27 95       	ror	r18
+ 94e:	20 f4       	brcc	.+8      	; 0x958 <doExorN2>
+ 950:	51 50       	subi	r21, 0x01	; 1
+ 952:	21 f4       	brne	.+8      	; 0x95c <commonN2>
+ 954:	22 0f       	add	r18, r18
+ 956:	f9 cf       	rjmp	.-14     	; 0x94a <commonN1>
+
+00000958 <doExorN2>:
+ 958:	01 27       	eor	r16, r17
+ 95a:	56 e0       	ldi	r21, 0x06	; 6
+
+0000095c <commonN2>:
+ 95c:	00 00       	nop
+ 95e:	3b 5a       	subi	r19, 0xAB	; 171
+ 960:	0b b9       	out	0x0b, r16	; 11
+ 962:	d0 f2       	brcs	.-76     	; 0x918 <stuffN1Delay>
+
+00000964 <stuff6Delay>:
+ 964:	27 95       	ror	r18
+ 966:	28 f4       	brcc	.+10     	; 0x972 <doExor6>
+ 968:	51 50       	subi	r21, 0x01	; 1
+ 96a:	29 f4       	brne	.+10     	; 0x976 <common6>
+ 96c:	22 0f       	add	r18, r18
+ 96e:	00 00       	nop
+ 970:	f9 cf       	rjmp	.-14     	; 0x964 <stuff6Delay>
+
+00000972 <doExor6>:
+ 972:	01 27       	eor	r16, r17
+ 974:	56 e0       	ldi	r21, 0x06	; 6
+
+00000976 <common6>:
+ 976:	27 95       	ror	r18
+ 978:	0b b9       	out	0x0b, r16	; 11
+ 97a:	20 f4       	brcc	.+8      	; 0x984 <doExor7>
+ 97c:	51 50       	subi	r21, 0x01	; 1
+ 97e:	21 f4       	brne	.+8      	; 0x988 <common7>
+ 980:	22 0f       	add	r18, r18
+ 982:	f9 cf       	rjmp	.-14     	; 0x976 <common6>
+
+00000984 <doExor7>:
+ 984:	01 27       	eor	r16, r17
+ 986:	56 e0       	ldi	r21, 0x06	; 6
+
+00000988 <common7>:
+ 988:	29 91       	ld	r18, Y+
+ 98a:	33 23       	and	r19, r19
+ 98c:	0b b9       	out	0x0b, r16	; 11
+ 98e:	21 f6       	brne	.-120    	; 0x918 <stuffN1Delay>
+ 990:	03 7f       	andi	r16, 0xF3	; 243
+ 992:	10 91 7e 01 	lds	r17, 0x017E
+ 996:	11 0f       	add	r17, r17
+ 998:	c6 51       	subi	r28, 0x16	; 22
+ 99a:	d0 40       	sbci	r29, 0x00	; 0
+ 99c:	0b b9       	out	0x0b, r16	; 11
+ 99e:	11 f0       	breq	.+4      	; 0x9a4 <skipAddrAssign>
+ 9a0:	10 93 78 01 	sts	0x0178, r17
+
+000009a4 <skipAddrAssign>:
+ 9a4:	11 e0       	ldi	r17, 0x01	; 1
+ 9a6:	1c bb       	out	0x1c, r17	; 28
+ 9a8:	08 60       	ori	r16, 0x08	; 8
+ 9aa:	1a b1       	in	r17, 0x0a	; 10
+ 9ac:	13 7f       	andi	r17, 0xF3	; 243
+ 9ae:	40 2f       	mov	r20, r16
+ 9b0:	43 7f       	andi	r20, 0xF3	; 243
+ 9b2:	5f 91       	pop	r21
+ 9b4:	00 c0       	rjmp	.+0      	; 0x9b6 <skipAddrAssign+0x12>
+ 9b6:	00 c0       	rjmp	.+0      	; 0x9b8 <skipAddrAssign+0x14>
+ 9b8:	0b b9       	out	0x0b, r16	; 11
+ 9ba:	1a b9       	out	0x0a, r17	; 10
+ 9bc:	4b b9       	out	0x0b, r20	; 11
+ 9be:	71 cf       	rjmp	.-286    	; 0x8a2 <doReturn>
+
+000009c0 <__mulhi3>:
+ 9c0:	55 27       	eor	r21, r21
+ 9c2:	00 24       	eor	r0, r0
+
+000009c4 <__mulhi3_loop>:
+ 9c4:	80 ff       	sbrs	r24, 0
+ 9c6:	02 c0       	rjmp	.+4      	; 0x9cc <__mulhi3_skip1>
+ 9c8:	06 0e       	add	r0, r22
+ 9ca:	57 1f       	adc	r21, r23
+
+000009cc <__mulhi3_skip1>:
+ 9cc:	66 0f       	add	r22, r22
+ 9ce:	77 1f       	adc	r23, r23
+ 9d0:	61 15       	cp	r22, r1
+ 9d2:	71 05       	cpc	r23, r1
+ 9d4:	21 f0       	breq	.+8      	; 0x9de <__mulhi3_exit>
+ 9d6:	96 95       	lsr	r25
+ 9d8:	87 95       	ror	r24
+ 9da:	00 97       	sbiw	r24, 0x00	; 0
+ 9dc:	99 f7       	brne	.-26     	; 0x9c4 <__mulhi3_loop>
+
+000009de <__mulhi3_exit>:
+ 9de:	95 2f       	mov	r25, r21
+ 9e0:	80 2d       	mov	r24, r0
+ 9e2:	08 95       	ret
+
+000009e4 <_exit>:
+ 9e4:	f8 94       	cli
+
+000009e6 <__stop_program>:
+ 9e6:	ff cf       	rjmp	.-2      	; 0x9e6 <__stop_program>
Index: bin/Release/HP48GX.map
===================================================================
--- bin/Release/HP48GX.map	(nonexistent)
+++ bin/Release/HP48GX.map	(working copy)
@@ -0,0 +1,536 @@
+Archive member included because of file (symbol)
+
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+                              obj\Release\main.o (__mulhi3)
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+                              c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o (exit)
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+                              obj\Release\main.o (__do_copy_data)
+c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                              obj\Release\main.o (__do_clear_bss)
+
+Allocating common symbols
+Common symbol       size              file
+
+usbTxBuf            0xb               obj\Release\usbdrv\usbdrv.o
+usbTxStatus1        0xc               obj\Release\usbdrv\usbdrv.o
+usbDeviceAddr       0x1               obj\Release\usbdrv\usbdrv.o
+usbRxToken          0x1               obj\Release\usbdrv\usbdrv.o
+usbInputBufOffset   0x1               obj\Release\usbdrv\usbdrv.o
+usbMsgPtr           0x2               obj\Release\usbdrv\usbdrv.o
+usbRxLen            0x1               obj\Release\usbdrv\usbdrv.o
+usbNewDeviceAddr    0x1               obj\Release\usbdrv\usbdrv.o
+usbCurrentTok       0x1               obj\Release\usbdrv\usbdrv.o
+usbConfiguration    0x1               obj\Release\usbdrv\usbdrv.o
+usbRxBuf            0x16              obj\Release\usbdrv\usbdrv.o
+
+Memory Configuration
+
+Name             Origin             Length             Attributes
+text             0x00000000         0x00002000         xr
+data             0x00800060         0x0000ffa0         rw !x
+eeprom           0x00810000         0x00010000         rw !x
+fuse             0x00820000         0x00000400         rw !x
+lock             0x00830000         0x00000400         rw !x
+signature        0x00840000         0x00000400         rw !x
+*default*        0x00000000         0xffffffff
+
+Linker script and memory map
+
+Address of section .data set to 0x800100
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+LOAD obj\Release\fuse.o
+LOAD obj\Release\main.o
+LOAD obj\Release\usbdrv\oddebug.o
+LOAD obj\Release\usbdrv\usbdrv.o
+LOAD obj\Release\usbdrv\usbdrvasm.o
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25\libm.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25\libc.a
+LOAD c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a
+
+.hash
+ *(.hash)
+
+.dynsym
+ *(.dynsym)
+
+.dynstr
+ *(.dynstr)
+
+.gnu.version
+ *(.gnu.version)
+
+.gnu.version_d
+ *(.gnu.version_d)
+
+.gnu.version_r
+ *(.gnu.version_r)
+
+.rel.init
+ *(.rel.init)
+
+.rela.init
+ *(.rela.init)
+
+.rel.text
+ *(.rel.text)
+ *(.rel.text.*)
+ *(.rel.gnu.linkonce.t*)
+
+.rela.text
+ *(.rela.text)
+ *(.rela.text.*)
+ *(.rela.gnu.linkonce.t*)
+
+.rel.fini
+ *(.rel.fini)
+
+.rela.fini
+ *(.rela.fini)
+
+.rel.rodata
+ *(.rel.rodata)
+ *(.rel.rodata.*)
+ *(.rel.gnu.linkonce.r*)
+
+.rela.rodata
+ *(.rela.rodata)
+ *(.rela.rodata.*)
+ *(.rela.gnu.linkonce.r*)
+
+.rel.data
+ *(.rel.data)
+ *(.rel.data.*)
+ *(.rel.gnu.linkonce.d*)
+
+.rela.data
+ *(.rela.data)
+ *(.rela.data.*)
+ *(.rela.gnu.linkonce.d*)
+
+.rel.ctors
+ *(.rel.ctors)
+
+.rela.ctors
+ *(.rela.ctors)
+
+.rel.dtors
+ *(.rel.dtors)
+
+.rela.dtors
+ *(.rela.dtors)
+
+.rel.got
+ *(.rel.got)
+
+.rela.got
+ *(.rela.got)
+
+.rel.bss
+ *(.rel.bss)
+
+.rela.bss
+ *(.rela.bss)
+
+.rel.plt
+ *(.rel.plt)
+
+.rela.plt
+ *(.rela.plt)
+
+.text           0x00000000      0x9e8
+ *(.vectors)
+ .vectors       0x00000000       0x28 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+                0x00000000                __vectors
+                0x00000000                __vector_default
+ *(.vectors)
+ *(.progmem.gcc*)
+ *(.progmem*)
+ .progmem.data  0x00000028       0x3f obj\Release\main.o
+                0x00000028                usbDescriptorHidReport
+ .progmem.data  0x00000067       0x68 obj\Release\usbdrv\usbdrv.o
+                0x0000009b                usbDescriptorDevice
+                0x00000067                usbDescriptorString0
+                0x000000ad                usbDescriptorConfiguration
+                0x0000006b                usbDescriptorStringVendor
+                0x0000008b                usbDescriptorStringDevice
+                0x000000d0                . = ALIGN (0x2)
+ *fill*         0x000000cf        0x1 00
+                0x000000d0                __trampolines_start = .
+ *(.trampolines)
+ .trampolines   0x000000d0        0x0 linker stubs
+ *(.trampolines*)
+                0x000000d0                __trampolines_end = .
+ *(.jumptables)
+ *(.jumptables*)
+ *(.lowtext)
+ *(.lowtext*)
+                0x000000d0                __ctors_start = .
+ *(.ctors)
+                0x000000d0                __ctors_end = .
+                0x000000d0                __dtors_start = .
+ *(.dtors)
+                0x000000d0                __dtors_end = .
+ SORT(*)(.ctors)
+ SORT(*)(.dtors)
+ *(.init0)
+ .init0         0x000000d0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+                0x000000d0                __init
+ *(.init0)
+ *(.init1)
+ *(.init1)
+ *(.init2)
+ .init2         0x000000d0        0xc c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ *(.init2)
+ *(.init3)
+ *(.init3)
+ *(.init4)
+ .init4         0x000000dc       0x16 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+                0x000000dc                __do_copy_data
+ .init4         0x000000f2       0x10 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                0x000000f2                __do_clear_bss
+ *(.init4)
+ *(.init5)
+ *(.init5)
+ *(.init6)
+ *(.init6)
+ *(.init7)
+ *(.init7)
+ *(.init8)
+ *(.init8)
+ *(.init9)
+ .init9         0x00000102        0x4 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ *(.init9)
+ *(.text)
+ .text          0x00000106        0x2 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+                0x00000106                __vector_12
+                0x00000106                __bad_interrupt
+                0x00000106                __vector_6
+                0x00000106                __vector_3
+                0x00000106                __vector_11
+                0x00000106                __vector_13
+                0x00000106                __vector_17
+                0x00000106                __vector_19
+                0x00000106                __vector_7
+                0x00000106                __vector_5
+                0x00000106                __vector_4
+                0x00000106                __vector_9
+                0x00000106                __vector_2
+                0x00000106                __vector_15
+                0x00000106                __vector_8
+                0x00000106                __vector_10
+                0x00000106                __vector_16
+                0x00000106                __vector_18
+ .text          0x00000108        0x0 obj\Release\fuse.o
+ .text          0x00000108      0x36a obj\Release\main.o
+                0x0000039e                Init
+                0x000002fc                OnKey
+                0x00000108                usbFunctionSetup
+                0x00000326                KeyPressed
+                0x00000172                buildReport
+                0x000003d2                main
+                0x000001a4                scanMatrix
+                0x0000017c                __vector_14
+                0x0000016e                usbFunctionWrite
+ .text          0x00000472        0x0 obj\Release\usbdrv\oddebug.o
+ .text          0x00000472      0x2a8 obj\Release\usbdrv\usbdrv.o
+                0x0000048c                usbPoll
+                0x000006d6                usbSetInterrupt
+                0x00000472                usbInit
+ .text          0x0000071a      0x2a6 obj\Release\usbdrv\usbdrvasm.o
+                0x0000074c                __vector_1
+                0x0000071a                usbCrc16
+                0x00000744                usbCrc16Append
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .text          0x000009c0        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                0x000009c0                . = ALIGN (0x2)
+ *(.text.*)
+ .text.libgcc   0x000009c0       0x24 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+                0x000009c0                __mulhi3
+ .text.libgcc   0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .text.libgcc   0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .text.libgcc   0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                0x000009e4                . = ALIGN (0x2)
+ *(.fini9)
+ .fini9         0x000009e4        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+                0x000009e4                exit
+                0x000009e4                _exit
+ *(.fini9)
+ *(.fini8)
+ *(.fini8)
+ *(.fini7)
+ *(.fini7)
+ *(.fini6)
+ *(.fini6)
+ *(.fini5)
+ *(.fini5)
+ *(.fini4)
+ *(.fini4)
+ *(.fini3)
+ *(.fini3)
+ *(.fini2)
+ *(.fini2)
+ *(.fini1)
+ *(.fini1)
+ *(.fini0)
+ .fini0         0x000009e4        0x4 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ *(.fini0)
+                0x000009e8                _etext = .
+
+.data           0x00800100       0x40 load address 0x000009e8
+                0x00800100                PROVIDE (__data_start, .)
+ *(.data)
+ .data          0x00800100        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ .data          0x00800100        0x0 obj\Release\fuse.o
+ .data          0x00800100       0x3e obj\Release\main.o
+                0x00800100                ScanCode
+ .data          0x0080013e        0x0 obj\Release\usbdrv\oddebug.o
+ .data          0x0080013e        0x2 obj\Release\usbdrv\usbdrv.o
+                0x0080013e                usbTxLen
+ .data          0x00800140        0x0 obj\Release\usbdrv\usbdrvasm.o
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .data          0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+ *(.data*)
+ *(.rodata)
+ *(.rodata*)
+ *(.gnu.linkonce.d*)
+                0x00800140                . = ALIGN (0x2)
+                0x00800140                _edata = .
+                0x00800140                PROVIDE (__data_end, .)
+
+.bss            0x00800140       0x57
+                0x00800140                PROVIDE (__bss_start, .)
+ *(.bss)
+ .bss           0x00800140        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+ .bss           0x00800140        0x0 obj\Release\fuse.o
+ .bss           0x00800140       0x20 obj\Release\main.o
+                0x00800143                keybuild
+                0x00800141                EnableKeyPressed
+                0x00800140                state
+                0x00800149                changedKeys
+                0x00800147                FAIL
+                0x00800145                OnCount
+ .bss           0x00800160        0x0 obj\Release\usbdrv\oddebug.o
+ .bss           0x00800160        0x1 obj\Release\usbdrv\usbdrv.o
+ .bss           0x00800161        0x0 obj\Release\usbdrv\usbdrvasm.o
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+ .bss           0x00800161        0x0 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+ *(.bss*)
+ *(COMMON)
+ COMMON         0x00800161       0x36 obj\Release\usbdrv\usbdrv.o
+                0x00800161                usbTxBuf
+                0x0080016c                usbTxStatus1
+                0x00800178                usbDeviceAddr
+                0x00800179                usbRxToken
+                0x0080017a                usbInputBufOffset
+                0x0080017b                usbMsgPtr
+                0x0080017d                usbRxLen
+                0x0080017e                usbNewDeviceAddr
+                0x0080017f                usbCurrentTok
+                0x00800180                usbConfiguration
+                0x00800181                usbRxBuf
+                0x00800197                PROVIDE (__bss_end, .)
+                0x000009e8                __data_load_start = LOADADDR (.data)
+                0x00000a28                __data_load_end = (__data_load_start + SIZEOF (.data))
+
+.noinit         0x00800197        0x0
+                0x00800197                PROVIDE (__noinit_start, .)
+ *(.noinit*)
+                0x00800197                PROVIDE (__noinit_end, .)
+                0x00800197                _end = .
+                0x00800197                PROVIDE (__heap_start, .)
+
+.eeprom         0x00810000        0x0
+ *(.eeprom*)
+                0x00810000                __eeprom_end = .
+
+.fuse           0x00820000        0x3
+ *(.fuse)
+ .fuse          0x00820000        0x3 obj\Release\fuse.o
+                0x00820000                __fuse
+ *(.lfuse)
+ *(.hfuse)
+ *(.efuse)
+
+.lock
+ *(.lock*)
+
+.signature
+ *(.signature*)
+
+.stab
+ *(.stab)
+
+.stabstr
+ *(.stabstr)
+
+.stab.excl
+ *(.stab.excl)
+
+.stab.exclstr
+ *(.stab.exclstr)
+
+.stab.index
+ *(.stab.index)
+
+.stab.indexstr
+ *(.stab.indexstr)
+
+.comment
+ *(.comment)
+
+.debug
+ *(.debug)
+
+.line
+ *(.line)
+
+.debug_srcinfo
+ *(.debug_srcinfo)
+
+.debug_sfnames
+ *(.debug_sfnames)
+
+.debug_aranges
+ *(.debug_aranges)
+
+.debug_pubnames
+ *(.debug_pubnames)
+
+.debug_info
+ *(.debug_info)
+ *(.gnu.linkonce.wi.*)
+
+.debug_abbrev
+ *(.debug_abbrev)
+
+.debug_line
+ *(.debug_line)
+
+.debug_frame
+ *(.debug_frame)
+
+.debug_str
+ *(.debug_str)
+
+.debug_loc
+ *(.debug_loc)
+
+.debug_macinfo
+ *(.debug_macinfo)
+OUTPUT(bin\Release\HP48GX.elf elf32-avr)
+LOAD linker stubs
+
+Cross Reference Table
+
+Symbol                                            File
+EnableKeyPressed                                  obj\Release\main.o
+FAIL                                              obj\Release\main.o
+Init                                              obj\Release\main.o
+KeyPressed                                        obj\Release\main.o
+OnCount                                           obj\Release\main.o
+OnKey                                             obj\Release\main.o
+ScanCode                                          obj\Release\main.o
+__bad_interrupt                                   c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__bss_end                                         c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+__bss_start                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+__data_end                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+__data_load_start                                 c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+__data_start                                      c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+__do_clear_bss                                    c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_clear_bss.o)
+                                                  obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+__do_copy_data                                    c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_copy_data.o)
+                                                  obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+__fuse                                            obj\Release\fuse.o
+__heap_end                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__init                                            c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__mulhi3                                          c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_mulhi3.o)
+                                                  obj\Release\main.o
+__stack                                           c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_1                                        obj\Release\usbdrv\usbdrvasm.o
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_10                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_11                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_12                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_13                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_14                                       obj\Release\main.o
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_15                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_16                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_17                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_18                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_19                                       c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_2                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_3                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_4                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_5                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_6                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_7                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_8                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_9                                        c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vector_default                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+__vectors                                         c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+_exit                                             c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+buildReport                                       obj\Release\main.o
+changedKeys                                       obj\Release\main.o
+exit                                              c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/avr25\libgcc.a(_exit.o)
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+keybuild                                          obj\Release\main.o
+main                                              obj\Release\main.o
+                                                  c:/winavr-20100110/bin/../lib/gcc/avr/4.3.3/../../../../avr/lib/avr25/crttn88.o
+scanMatrix                                        obj\Release\main.o
+state                                             obj\Release\main.o
+usbConfiguration                                  obj\Release\usbdrv\usbdrv.o
+usbCrc16                                          obj\Release\usbdrv\usbdrvasm.o
+usbCrc16Append                                    obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbCurrentTok                                     obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbDescriptorConfiguration                        obj\Release\usbdrv\usbdrv.o
+usbDescriptorDevice                               obj\Release\usbdrv\usbdrv.o
+usbDescriptorHidReport                            obj\Release\main.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbDescriptorString0                              obj\Release\usbdrv\usbdrv.o
+usbDescriptorStringDevice                         obj\Release\usbdrv\usbdrv.o
+usbDescriptorStringVendor                         obj\Release\usbdrv\usbdrv.o
+usbDeviceAddr                                     obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbFunctionSetup                                  obj\Release\main.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbFunctionWrite                                  obj\Release\main.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbInit                                           obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbInputBufOffset                                 obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbMsgPtr                                         obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbNewDeviceAddr                                  obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbPoll                                           obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbRxBuf                                          obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbRxLen                                          obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbRxToken                                        obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbSetInterrupt                                   obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
+usbTxBuf                                          obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+usbTxLen                                          obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\usbdrv\usbdrvasm.o
+usbTxStatus1                                      obj\Release\usbdrv\usbdrvasm.o
+                                                  obj\Release\usbdrv\usbdrv.o
+                                                  obj\Release\main.o
Index: bin/Release/HP48GX.sig
===================================================================
--- bin/Release/HP48GX.sig	(nonexistent)
+++ bin/Release/HP48GX.sig	(working copy)
@@ -0,0 +1 @@
+:00000001FF
Index: fuse.c
===================================================================
--- fuse.c	(nonexistent)
+++ fuse.c	(working copy)
@@ -0,0 +1,7 @@
+#include <avr/io.h>
+
+FUSES = {
+    .low = 0xEC,            //Clock Source = Ext. crystal 8-..MHz, Start-up Time = 64ms, SUT11
+    .high = 0xDF,           //Enable Serial Programming = ON
+    .extended = 0xFF        //Self Programming Enable = OFF
+};
Index: header/delay.h
===================================================================
--- header/delay.h	(nonexistent)
+++ header/delay.h	(working copy)
@@ -0,0 +1,39 @@
+/* Copyright (c) 2005 Joerg Wunsch
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+   * Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in
+     the documentation and/or other materials provided with the
+     distribution.
+
+   * Neither the name of the copyright holders nor the names of
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE. */
+
+/* $Id: delay.h,v 1.14 2005/11/05 22:23:15 joerg_wunsch Exp $ */
+
+#ifndef _AVR_DELAY_H_
+#define _AVR_DELAY_H_
+
+#warning "This file has been moved to <util/delay.h>."
+#include <util/delay.h>
+
+#endif /* _AVR_DELAY_H_ */
Index: header/io.h
===================================================================
--- header/io.h	(nonexistent)
+++ header/io.h	(working copy)
@@ -0,0 +1,420 @@
+/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
+   Copyright (c) 2007 Eric B. Weddington
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+   * Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in
+     the documentation and/or other materials provided with the
+     distribution.
+
+   * Neither the name of the copyright holders nor the names of
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE. */
+
+/* $Id: io.h,v 1.52.2.28 2009/12/20 17:02:53 arcanum Exp $ */
+
+/** \file */
+/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
+    \code #include <avr/io.h> \endcode
+
+    This header file includes the apropriate IO definitions for the
+    device that has been specified by the <tt>-mmcu=</tt> compiler
+    command-line switch.  This is done by diverting to the appropriate
+    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
+    never be included directly.  Some register names common to all
+    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
+    which is included in <tt>&lt;avr/io.h&gt;</tt>,
+    but most of the details come from the respective include file.
+
+    Note that this file always includes the following files:
+    \code
+    #include <avr/sfr_defs.h>
+    #include <avr/portpins.h>
+    #include <avr/common.h>
+    #include <avr/version.h>
+    \endcode
+    See \ref avr_sfr for more details about that header file.
+
+    Included are definitions of the IO register set and their
+    respective bit values as specified in the Atmel documentation.
+    Note that inconsistencies in naming conventions,
+    so even identical functions sometimes get different names on
+    different devices.
+
+    Also included are the specific names useable for interrupt
+    function definitions as documented
+    \ref avr_signames "here".
+
+    Finally, the following macros are defined:
+
+    - \b RAMEND
+    <br>
+    The last on-chip RAM address.
+    <br>
+    - \b XRAMEND
+    <br>
+    The last possible RAM location that is addressable. This is equal to
+    RAMEND for devices that do not allow for external RAM. For devices
+    that allow external RAM, this will be larger than RAMEND.
+    <br>
+    - \b E2END
+    <br>
+    The last EEPROM address.
+    <br>
+    - \b FLASHEND
+    <br>
+    The last byte address in the Flash program space.
+    <br>
+    - \b SPM_PAGESIZE
+    <br>
+    For devices with bootloader support, the flash pagesize
+    (in bytes) to be used for the \c SPM instruction.
+    - \b E2PAGESIZE
+    <br>
+    The size of the EEPROM page.
+
+*/
+
+#ifndef _AVR_IO_H_
+#define _AVR_IO_H_
+
+#include <avr/sfr_defs.h>
+
+#if defined (__AVR_AT94K__)
+#  include <avr/ioat94k.h>
+#elif defined (__AVR_AT43USB320__)
+#  include <avr/io43u32x.h>
+#elif defined (__AVR_AT43USB355__)
+#  include <avr/io43u35x.h>
+#elif defined (__AVR_AT76C711__)
+#  include <avr/io76c711.h>
+#elif defined (__AVR_AT86RF401__)
+#  include <avr/io86r401.h>
+#elif defined (__AVR_AT90PWM1__)
+#  include <avr/io90pwm1.h>
+#elif defined (__AVR_AT90PWM2__)
+#  include <avr/io90pwmx.h>
+#elif defined (__AVR_AT90PWM2B__)
+#  include <avr/io90pwm2b.h>
+#elif defined (__AVR_AT90PWM3__)
+#  include <avr/io90pwmx.h>
+#elif defined (__AVR_AT90PWM3B__)
+#  include <avr/io90pwm3b.h>
+#elif defined (__AVR_AT90PWM216__)
+#  include <avr/io90pwm216.h>
+#elif defined (__AVR_AT90PWM316__)
+#  include <avr/io90pwm316.h>
+#elif defined (__AVR_AT90PWM81__)
+#  include <avr/io90pwm81.h>
+#elif defined (__AVR_ATmega8U2__)
+#  include <avr/iom8u2.h>
+#elif defined (__AVR_ATmega16M1__)
+#  include <avr/iom16m1.h>
+#elif defined (__AVR_ATmega16U2__)
+#  include <avr/iom16u2.h>
+#elif defined (__AVR_ATmega16U4__)
+#  include <avr/iom16u4.h>
+#elif defined (__AVR_ATmega32C1__)
+#  include <avr/iom32c1.h>
+#elif defined (__AVR_ATmega32M1__)
+#  include <avr/iom32m1.h>
+#elif defined (__AVR_ATmega32U2__)
+#  include <avr/iom32u2.h>
+#elif defined (__AVR_ATmega32U4__)
+#  include <avr/iom32u4.h>
+#elif defined (__AVR_ATmega32U6__)
+#  include <avr/iom32u6.h>
+#elif defined (__AVR_ATmega64C1__)
+#  include <avr/iom64c1.h>
+#elif defined (__AVR_ATmega64M1__)
+#  include <avr/iom64m1.h>
+#elif defined (__AVR_ATmega128__)
+#  include <avr/iom128.h>
+#elif defined (__AVR_ATmega1280__)
+#  include <avr/iom1280.h>
+#elif defined (__AVR_ATmega1281__)
+#  include <avr/iom1281.h>
+#elif defined (__AVR_ATmega1284P__)
+#  include <avr/iom1284p.h>
+#elif defined (__AVR_ATmega128RFA1__)
+#  include <avr/iom128rfa1.h>
+#elif defined (__AVR_ATmega2560__)
+#  include <avr/iom2560.h>
+#elif defined (__AVR_ATmega2561__)
+#  include <avr/iom2561.h>
+#elif defined (__AVR_AT90CAN32__)
+#  include <avr/iocan32.h>
+#elif defined (__AVR_AT90CAN64__)
+#  include <avr/iocan64.h>
+#elif defined (__AVR_AT90CAN128__)
+#  include <avr/iocan128.h>
+#elif defined (__AVR_AT90USB82__)
+#  include <avr/iousb82.h>
+#elif defined (__AVR_AT90USB162__)
+#  include <avr/iousb162.h>
+#elif defined (__AVR_AT90USB646__)
+#  include <avr/iousb646.h>
+#elif defined (__AVR_AT90USB647__)
+#  include <avr/iousb647.h>
+#elif defined (__AVR_AT90USB1286__)
+#  include <avr/iousb1286.h>
+#elif defined (__AVR_AT90USB1287__)
+#  include <avr/iousb1287.h>
+#elif defined (__AVR_ATmega64__)
+#  include <avr/iom64.h>
+#elif defined (__AVR_ATmega640__)
+#  include <avr/iom640.h>
+#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega644A__)
+#  include <avr/iom644.h>
+#elif defined (__AVR_ATmega644P__)
+#  include <avr/iom644p.h>
+#elif defined (__AVR_ATmega644PA__)
+#  include <avr/iom644pa.h>
+#elif defined (__AVR_ATmega645__) || defined (__AVR_ATmega645A__) || defined (__AVR_ATmega645P__)
+#  include <avr/iom645.h>
+#elif defined (__AVR_ATmega6450__) || defined (__AVR_ATmega6450A__) || defined (__AVR_ATmega6450P__)
+#  include <avr/iom6450.h>
+#elif defined (__AVR_ATmega649__) || defined (__AVR_ATmega649A__)
+#  include <avr/iom649.h>
+#elif defined (__AVR_ATmega6490__) || defined (__AVR_ATmega6490A__) || defined (__AVR_ATmega6490P__)
+#  include <avr/iom6490.h>
+#elif defined (__AVR_ATmega649P__)
+#  include <avr/iom649p.h>
+#elif defined (__AVR_ATmega64HVE__)
+#  include <avr/iom64hve.h>
+#elif defined (__AVR_ATmega103__)
+#  include <avr/iom103.h>
+#elif defined (__AVR_ATmega32__)
+#  include <avr/iom32.h>
+#elif defined (__AVR_ATmega323__)
+#  include <avr/iom323.h>
+#elif defined (__AVR_ATmega324P__) || defined (__AVR_ATmega324A__)
+#  include <avr/iom324.h>
+#elif defined (__AVR_ATmega324PA__)
+#  include <avr/iom324pa.h>
+#elif defined (__AVR_ATmega325__)
+#  include <avr/iom325.h>
+#elif defined (__AVR_ATmega325P__)
+#  include <avr/iom325.h>
+#elif defined (__AVR_ATmega3250__)
+#  include <avr/iom3250.h>
+#elif defined (__AVR_ATmega3250P__)
+#  include <avr/iom3250.h>
+#elif defined (__AVR_ATmega328P__) || defined (__AVR_ATmega328__)
+#  include <avr/iom328p.h>
+#elif defined (__AVR_ATmega329__)
+#  include <avr/iom329.h>
+#elif defined (__AVR_ATmega329P__) || defined (__AVR_ATmega329PA__)
+#  include <avr/iom329.h>
+#elif defined (__AVR_ATmega3290__)
+#  include <avr/iom3290.h>
+#elif defined (__AVR_ATmega3290P__)
+#  include <avr/iom3290.h>
+#elif defined (__AVR_ATmega32HVB__)
+#  include <avr/iom32hvb.h>
+#elif defined (__AVR_ATmega406__)
+#  include <avr/iom406.h>
+#elif defined (__AVR_ATmega16__)
+#  include <avr/iom16.h>
+#elif defined (__AVR_ATmega16A__)
+#  include <avr/iom16a.h>
+#elif defined (__AVR_ATmega161__)
+#  include <avr/iom161.h>
+#elif defined (__AVR_ATmega162__)
+#  include <avr/iom162.h>
+#elif defined (__AVR_ATmega163__)
+#  include <avr/iom163.h>
+#elif defined (__AVR_ATmega164P__) || defined (__AVR_ATmega164A__)
+#  include <avr/iom164.h>
+#elif defined (__AVR_ATmega165__) || defined (__AVR_ATmega165A__)
+#  include <avr/iom165.h>
+#elif defined (__AVR_ATmega165P__)
+#  include <avr/iom165p.h>
+#elif defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
+#  include <avr/iom168.h>
+#elif defined (__AVR_ATmega168P__)
+#  include <avr/iom168p.h>
+#elif defined (__AVR_ATmega169__) || defined (__AVR_ATmega169A__)
+#  include <avr/iom169.h>
+#elif defined (__AVR_ATmega169P__)
+#  include <avr/iom169p.h>
+#elif defined (__AVR_ATmega169PA__)
+#  include <avr/iom169pa.h>
+#elif defined (__AVR_ATmega8HVA__)
+#  include <avr/iom8hva.h>
+#elif defined (__AVR_ATmega16HVA__)
+#  include <avr/iom16hva.h>
+#elif defined (__AVR_ATmega16HVA2__)
+#  include <avr/iom16hva2.h>
+#elif defined (__AVR_ATmega16HVB__)
+#  include <avr/iom16hvb.h>
+#elif defined (__AVR_ATmega8__)
+#  include <avr/iom8.h>
+#elif defined (__AVR_ATmega48__) || defined (__AVR_ATmega48A__)
+#  include <avr/iom48.h>
+#elif defined (__AVR_ATmega48P__)
+#  include <avr/iom48p.h>
+#elif defined (__AVR_ATmega88__) || defined (__AVR_ATmegaA__)
+#  include <avr/iom88.h>
+#elif defined (__AVR_ATmega88P__)
+#  include <avr/iom88p.h>
+#elif defined (__AVR_ATmega88PA__)
+#  include <avr/iom88pa.h>
+#elif defined (__AVR_ATmega8515__)
+#  include <avr/iom8515.h>
+#elif defined (__AVR_ATmega8535__)
+#  include <avr/iom8535.h>
+#elif defined (__AVR_AT90S8535__)
+#  include <avr/io8535.h>
+#elif defined (__AVR_AT90C8534__)
+#  include <avr/io8534.h>
+#elif defined (__AVR_AT90S8515__)
+#  include <avr/io8515.h>
+#elif defined (__AVR_AT90S4434__)
+#  include <avr/io4434.h>
+#elif defined (__AVR_AT90S4433__)
+#  include <avr/io4433.h>
+#elif defined (__AVR_AT90S4414__)
+#  include <avr/io4414.h>
+#elif defined (__AVR_ATtiny22__)
+#  include <avr/iotn22.h>
+#elif defined (__AVR_ATtiny26__)
+#  include <avr/iotn26.h>
+#elif defined (__AVR_AT90S2343__)
+#  include <avr/io2343.h>
+#elif defined (__AVR_AT90S2333__)
+#  include <avr/io2333.h>
+#elif defined (__AVR_AT90S2323__)
+#  include <avr/io2323.h>
+#elif defined (__AVR_AT90S2313__)
+#  include <avr/io2313.h>
+#elif defined (__AVR_ATtiny2313__)
+#  include <avr/iotn2313.h>
+#elif defined (__AVR_ATtiny2313A__)
+#  include <avr/iotn2313a.h>
+#elif defined (__AVR_ATtiny13__)
+#  include <avr/iotn13.h>
+#elif defined (__AVR_ATtiny13A__)
+#  include <avr/iotn13a.h>
+#elif defined (__AVR_ATtiny25__)
+#  include <avr/iotn25.h>
+#elif defined (__AVR_ATtiny4313__)
+#  include <avr/iotn4313.h>
+#elif defined (__AVR_ATtiny45__)
+#  include <avr/iotn45.h>
+#elif defined (__AVR_ATtiny85__)
+#  include <avr/iotn85.h>
+#elif defined (__AVR_ATtiny24__)
+#  include <avr/iotn24.h>
+#elif defined (__AVR_ATtiny24A__)
+#  include <avr/iotn24a.h>
+#elif defined (__AVR_ATtiny44__)
+#  include <avr/iotn44.h>
+#elif defined (__AVR_ATtiny44A__)
+#  include <avr/iotn44a.h>
+#elif defined (__AVR_ATtiny84__)
+#  include <avr/iotn84.h>
+#elif defined (__AVR_ATtiny261__)
+#  include <avr/iotn261.h>
+#elif defined (__AVR_ATtiny261A__)
+#  include <avr/iotn261a.h>
+#elif defined (__AVR_ATtiny461__)
+#  include <avr/iotn461.h>
+#elif defined (__AVR_ATtiny461A__)
+#  include <avr/iotn461a.h>
+#elif defined (__AVR_ATtiny861__)
+#  include <avr/iotn861.h>
+#elif defined (__AVR_ATtiny861A__)
+#  include <avr/iotn861a.h>
+#elif defined (__AVR_ATtiny43U__)
+#  include <avr/iotn43u.h>
+#elif defined (__AVR_ATtiny48__)
+#  include <avr/iotn48.h>
+#elif defined (__AVR_ATtiny88__)
+#  include <avr/iotn88.h>
+#elif defined (__AVR_ATtiny87__)
+#  include <avr/iotn87.h>
+#elif defined (__AVR_ATtiny167__)
+#  include <avr/iotn167.h>
+#elif defined (__AVR_AT90SCR100__)
+#  include <avr/io90scr100.h>
+#elif defined (__AVR_ATxmega16A4__)
+#  include <avr/iox16a4.h>
+#elif defined (__AVR_ATxmega16D4__)
+#  include <avr/iox16d4.h>
+#elif defined (__AVR_ATxmega32A4__)
+#  include <avr/iox32a4.h>
+#elif defined (__AVR_ATxmega32D4__)
+#  include <avr/iox32d4.h>
+#elif defined (__AVR_ATxmega64A1__)
+#  include <avr/iox64a1.h>
+#elif defined (__AVR_ATxmega64A3__)
+#  include <avr/iox64a3.h>
+#elif defined (__AVR_ATxmega64D3__)
+#  include <avr/iox64d3.h>
+#elif defined (__AVR_ATxmega128A1__)
+#  include <avr/iox128a1.h>
+#elif defined (__AVR_ATxmega128A3__)
+#  include <avr/iox128a3.h>
+#elif defined (__AVR_ATxmega128D3__)
+#  include <avr/iox128d3.h>
+#elif defined (__AVR_ATxmega192A3__)
+#  include <avr/iox192a3.h>
+#elif defined (__AVR_ATxmega192D3__)
+#  include <avr/iox192d3.h>
+#elif defined (__AVR_ATxmega256A3__)
+#  include <avr/iox256a3.h>
+#elif defined (__AVR_ATxmega256A3B__)
+#  include <avr/iox256a3b.h>
+#elif defined (__AVR_ATxmega256D3__)
+#  include <avr/iox256d3.h>
+#elif defined (__AVR_ATA6289__)
+#  include <avr/ioa6289.h>
+/* avr1: the following only supported for assembler programs */
+#elif defined (__AVR_ATtiny28__)
+#  include <avr/iotn28.h>
+#elif defined (__AVR_AT90S1200__)
+#  include <avr/io1200.h>
+#elif defined (__AVR_ATtiny15__)
+#  include <avr/iotn15.h>
+#elif defined (__AVR_ATtiny12__)
+#  include <avr/iotn12.h>
+#elif defined (__AVR_ATtiny11__)
+#  include <avr/iotn11.h>
+#else
+#  if !defined(__COMPILING_AVR_LIBC__)
+#    warning "device type not defined"
+#  endif
+#endif
+
+#include <avr/portpins.h>
+
+#include <avr/common.h>
+
+#include <avr/version.h>
+
+/* Include fuse.h after individual IO header files. */
+#include <avr/fuse.h>
+
+/* Include lock.h after individual IO header files. */
+#include <avr/lock.h>
+
+#endif /* _AVR_IO_H_ */
Index: header/usbconfig.h
===================================================================
--- header/usbconfig.h	(nonexistent)
+++ header/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      B
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      1
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       0
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/12000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      1
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       1
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0x42, 0x42 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0x31, 0xel /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'H', 'P', '4', '8', 'K', 'E', 'Y', 'B', 'O', 'A', 'R', D'
+#define USB_CFG_DEVICE_NAME_LEN 12
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0x03    //HID
+#define USB_CFG_INTERFACE_SUBCLASS  0x01    //Boot
+#define USB_CFG_INTERFACE_PROTOCOL  0x01    //Keyboard
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    63
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: header/delay.h
===================================================================
--- header/delay.h	(nonexistent)
+++ header/delay.h	(working copy)
@@ -0,0 +1,39 @@
+/* Copyright (c) 2005 Joerg Wunsch
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+   * Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in
+     the documentation and/or other materials provided with the
+     distribution.
+
+   * Neither the name of the copyright holders nor the names of
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE. */
+
+/* $Id: delay.h,v 1.14 2005/11/05 22:23:15 joerg_wunsch Exp $ */
+
+#ifndef _AVR_DELAY_H_
+#define _AVR_DELAY_H_
+
+#warning "This file has been moved to <util/delay.h>."
+#include <util/delay.h>
+
+#endif /* _AVR_DELAY_H_ */
Index: header/io.h
===================================================================
--- header/io.h	(nonexistent)
+++ header/io.h	(working copy)
@@ -0,0 +1,420 @@
+/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
+   Copyright (c) 2007 Eric B. Weddington
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+   * Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in
+     the documentation and/or other materials provided with the
+     distribution.
+
+   * Neither the name of the copyright holders nor the names of
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE. */
+
+/* $Id: io.h,v 1.52.2.28 2009/12/20 17:02:53 arcanum Exp $ */
+
+/** \file */
+/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
+    \code #include <avr/io.h> \endcode
+
+    This header file includes the apropriate IO definitions for the
+    device that has been specified by the <tt>-mmcu=</tt> compiler
+    command-line switch.  This is done by diverting to the appropriate
+    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
+    never be included directly.  Some register names common to all
+    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
+    which is included in <tt>&lt;avr/io.h&gt;</tt>,
+    but most of the details come from the respective include file.
+
+    Note that this file always includes the following files:
+    \code
+    #include <avr/sfr_defs.h>
+    #include <avr/portpins.h>
+    #include <avr/common.h>
+    #include <avr/version.h>
+    \endcode
+    See \ref avr_sfr for more details about that header file.
+
+    Included are definitions of the IO register set and their
+    respective bit values as specified in the Atmel documentation.
+    Note that inconsistencies in naming conventions,
+    so even identical functions sometimes get different names on
+    different devices.
+
+    Also included are the specific names useable for interrupt
+    function definitions as documented
+    \ref avr_signames "here".
+
+    Finally, the following macros are defined:
+
+    - \b RAMEND
+    <br>
+    The last on-chip RAM address.
+    <br>
+    - \b XRAMEND
+    <br>
+    The last possible RAM location that is addressable. This is equal to
+    RAMEND for devices that do not allow for external RAM. For devices
+    that allow external RAM, this will be larger than RAMEND.
+    <br>
+    - \b E2END
+    <br>
+    The last EEPROM address.
+    <br>
+    - \b FLASHEND
+    <br>
+    The last byte address in the Flash program space.
+    <br>
+    - \b SPM_PAGESIZE
+    <br>
+    For devices with bootloader support, the flash pagesize
+    (in bytes) to be used for the \c SPM instruction.
+    - \b E2PAGESIZE
+    <br>
+    The size of the EEPROM page.
+
+*/
+
+#ifndef _AVR_IO_H_
+#define _AVR_IO_H_
+
+#include <avr/sfr_defs.h>
+
+#if defined (__AVR_AT94K__)
+#  include <avr/ioat94k.h>
+#elif defined (__AVR_AT43USB320__)
+#  include <avr/io43u32x.h>
+#elif defined (__AVR_AT43USB355__)
+#  include <avr/io43u35x.h>
+#elif defined (__AVR_AT76C711__)
+#  include <avr/io76c711.h>
+#elif defined (__AVR_AT86RF401__)
+#  include <avr/io86r401.h>
+#elif defined (__AVR_AT90PWM1__)
+#  include <avr/io90pwm1.h>
+#elif defined (__AVR_AT90PWM2__)
+#  include <avr/io90pwmx.h>
+#elif defined (__AVR_AT90PWM2B__)
+#  include <avr/io90pwm2b.h>
+#elif defined (__AVR_AT90PWM3__)
+#  include <avr/io90pwmx.h>
+#elif defined (__AVR_AT90PWM3B__)
+#  include <avr/io90pwm3b.h>
+#elif defined (__AVR_AT90PWM216__)
+#  include <avr/io90pwm216.h>
+#elif defined (__AVR_AT90PWM316__)
+#  include <avr/io90pwm316.h>
+#elif defined (__AVR_AT90PWM81__)
+#  include <avr/io90pwm81.h>
+#elif defined (__AVR_ATmega8U2__)
+#  include <avr/iom8u2.h>
+#elif defined (__AVR_ATmega16M1__)
+#  include <avr/iom16m1.h>
+#elif defined (__AVR_ATmega16U2__)
+#  include <avr/iom16u2.h>
+#elif defined (__AVR_ATmega16U4__)
+#  include <avr/iom16u4.h>
+#elif defined (__AVR_ATmega32C1__)
+#  include <avr/iom32c1.h>
+#elif defined (__AVR_ATmega32M1__)
+#  include <avr/iom32m1.h>
+#elif defined (__AVR_ATmega32U2__)
+#  include <avr/iom32u2.h>
+#elif defined (__AVR_ATmega32U4__)
+#  include <avr/iom32u4.h>
+#elif defined (__AVR_ATmega32U6__)
+#  include <avr/iom32u6.h>
+#elif defined (__AVR_ATmega64C1__)
+#  include <avr/iom64c1.h>
+#elif defined (__AVR_ATmega64M1__)
+#  include <avr/iom64m1.h>
+#elif defined (__AVR_ATmega128__)
+#  include <avr/iom128.h>
+#elif defined (__AVR_ATmega1280__)
+#  include <avr/iom1280.h>
+#elif defined (__AVR_ATmega1281__)
+#  include <avr/iom1281.h>
+#elif defined (__AVR_ATmega1284P__)
+#  include <avr/iom1284p.h>
+#elif defined (__AVR_ATmega128RFA1__)
+#  include <avr/iom128rfa1.h>
+#elif defined (__AVR_ATmega2560__)
+#  include <avr/iom2560.h>
+#elif defined (__AVR_ATmega2561__)
+#  include <avr/iom2561.h>
+#elif defined (__AVR_AT90CAN32__)
+#  include <avr/iocan32.h>
+#elif defined (__AVR_AT90CAN64__)
+#  include <avr/iocan64.h>
+#elif defined (__AVR_AT90CAN128__)
+#  include <avr/iocan128.h>
+#elif defined (__AVR_AT90USB82__)
+#  include <avr/iousb82.h>
+#elif defined (__AVR_AT90USB162__)
+#  include <avr/iousb162.h>
+#elif defined (__AVR_AT90USB646__)
+#  include <avr/iousb646.h>
+#elif defined (__AVR_AT90USB647__)
+#  include <avr/iousb647.h>
+#elif defined (__AVR_AT90USB1286__)
+#  include <avr/iousb1286.h>
+#elif defined (__AVR_AT90USB1287__)
+#  include <avr/iousb1287.h>
+#elif defined (__AVR_ATmega64__)
+#  include <avr/iom64.h>
+#elif defined (__AVR_ATmega640__)
+#  include <avr/iom640.h>
+#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega644A__)
+#  include <avr/iom644.h>
+#elif defined (__AVR_ATmega644P__)
+#  include <avr/iom644p.h>
+#elif defined (__AVR_ATmega644PA__)
+#  include <avr/iom644pa.h>
+#elif defined (__AVR_ATmega645__) || defined (__AVR_ATmega645A__) || defined (__AVR_ATmega645P__)
+#  include <avr/iom645.h>
+#elif defined (__AVR_ATmega6450__) || defined (__AVR_ATmega6450A__) || defined (__AVR_ATmega6450P__)
+#  include <avr/iom6450.h>
+#elif defined (__AVR_ATmega649__) || defined (__AVR_ATmega649A__)
+#  include <avr/iom649.h>
+#elif defined (__AVR_ATmega6490__) || defined (__AVR_ATmega6490A__) || defined (__AVR_ATmega6490P__)
+#  include <avr/iom6490.h>
+#elif defined (__AVR_ATmega649P__)
+#  include <avr/iom649p.h>
+#elif defined (__AVR_ATmega64HVE__)
+#  include <avr/iom64hve.h>
+#elif defined (__AVR_ATmega103__)
+#  include <avr/iom103.h>
+#elif defined (__AVR_ATmega32__)
+#  include <avr/iom32.h>
+#elif defined (__AVR_ATmega323__)
+#  include <avr/iom323.h>
+#elif defined (__AVR_ATmega324P__) || defined (__AVR_ATmega324A__)
+#  include <avr/iom324.h>
+#elif defined (__AVR_ATmega324PA__)
+#  include <avr/iom324pa.h>
+#elif defined (__AVR_ATmega325__)
+#  include <avr/iom325.h>
+#elif defined (__AVR_ATmega325P__)
+#  include <avr/iom325.h>
+#elif defined (__AVR_ATmega3250__)
+#  include <avr/iom3250.h>
+#elif defined (__AVR_ATmega3250P__)
+#  include <avr/iom3250.h>
+#elif defined (__AVR_ATmega328P__) || defined (__AVR_ATmega328__)
+#  include <avr/iom328p.h>
+#elif defined (__AVR_ATmega329__)
+#  include <avr/iom329.h>
+#elif defined (__AVR_ATmega329P__) || defined (__AVR_ATmega329PA__)
+#  include <avr/iom329.h>
+#elif defined (__AVR_ATmega3290__)
+#  include <avr/iom3290.h>
+#elif defined (__AVR_ATmega3290P__)
+#  include <avr/iom3290.h>
+#elif defined (__AVR_ATmega32HVB__)
+#  include <avr/iom32hvb.h>
+#elif defined (__AVR_ATmega406__)
+#  include <avr/iom406.h>
+#elif defined (__AVR_ATmega16__)
+#  include <avr/iom16.h>
+#elif defined (__AVR_ATmega16A__)
+#  include <avr/iom16a.h>
+#elif defined (__AVR_ATmega161__)
+#  include <avr/iom161.h>
+#elif defined (__AVR_ATmega162__)
+#  include <avr/iom162.h>
+#elif defined (__AVR_ATmega163__)
+#  include <avr/iom163.h>
+#elif defined (__AVR_ATmega164P__) || defined (__AVR_ATmega164A__)
+#  include <avr/iom164.h>
+#elif defined (__AVR_ATmega165__) || defined (__AVR_ATmega165A__)
+#  include <avr/iom165.h>
+#elif defined (__AVR_ATmega165P__)
+#  include <avr/iom165p.h>
+#elif defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
+#  include <avr/iom168.h>
+#elif defined (__AVR_ATmega168P__)
+#  include <avr/iom168p.h>
+#elif defined (__AVR_ATmega169__) || defined (__AVR_ATmega169A__)
+#  include <avr/iom169.h>
+#elif defined (__AVR_ATmega169P__)
+#  include <avr/iom169p.h>
+#elif defined (__AVR_ATmega169PA__)
+#  include <avr/iom169pa.h>
+#elif defined (__AVR_ATmega8HVA__)
+#  include <avr/iom8hva.h>
+#elif defined (__AVR_ATmega16HVA__)
+#  include <avr/iom16hva.h>
+#elif defined (__AVR_ATmega16HVA2__)
+#  include <avr/iom16hva2.h>
+#elif defined (__AVR_ATmega16HVB__)
+#  include <avr/iom16hvb.h>
+#elif defined (__AVR_ATmega8__)
+#  include <avr/iom8.h>
+#elif defined (__AVR_ATmega48__) || defined (__AVR_ATmega48A__)
+#  include <avr/iom48.h>
+#elif defined (__AVR_ATmega48P__)
+#  include <avr/iom48p.h>
+#elif defined (__AVR_ATmega88__) || defined (__AVR_ATmegaA__)
+#  include <avr/iom88.h>
+#elif defined (__AVR_ATmega88P__)
+#  include <avr/iom88p.h>
+#elif defined (__AVR_ATmega88PA__)
+#  include <avr/iom88pa.h>
+#elif defined (__AVR_ATmega8515__)
+#  include <avr/iom8515.h>
+#elif defined (__AVR_ATmega8535__)
+#  include <avr/iom8535.h>
+#elif defined (__AVR_AT90S8535__)
+#  include <avr/io8535.h>
+#elif defined (__AVR_AT90C8534__)
+#  include <avr/io8534.h>
+#elif defined (__AVR_AT90S8515__)
+#  include <avr/io8515.h>
+#elif defined (__AVR_AT90S4434__)
+#  include <avr/io4434.h>
+#elif defined (__AVR_AT90S4433__)
+#  include <avr/io4433.h>
+#elif defined (__AVR_AT90S4414__)
+#  include <avr/io4414.h>
+#elif defined (__AVR_ATtiny22__)
+#  include <avr/iotn22.h>
+#elif defined (__AVR_ATtiny26__)
+#  include <avr/iotn26.h>
+#elif defined (__AVR_AT90S2343__)
+#  include <avr/io2343.h>
+#elif defined (__AVR_AT90S2333__)
+#  include <avr/io2333.h>
+#elif defined (__AVR_AT90S2323__)
+#  include <avr/io2323.h>
+#elif defined (__AVR_AT90S2313__)
+#  include <avr/io2313.h>
+#elif defined (__AVR_ATtiny2313__)
+#  include <avr/iotn2313.h>
+#elif defined (__AVR_ATtiny2313A__)
+#  include <avr/iotn2313a.h>
+#elif defined (__AVR_ATtiny13__)
+#  include <avr/iotn13.h>
+#elif defined (__AVR_ATtiny13A__)
+#  include <avr/iotn13a.h>
+#elif defined (__AVR_ATtiny25__)
+#  include <avr/iotn25.h>
+#elif defined (__AVR_ATtiny4313__)
+#  include <avr/iotn4313.h>
+#elif defined (__AVR_ATtiny45__)
+#  include <avr/iotn45.h>
+#elif defined (__AVR_ATtiny85__)
+#  include <avr/iotn85.h>
+#elif defined (__AVR_ATtiny24__)
+#  include <avr/iotn24.h>
+#elif defined (__AVR_ATtiny24A__)
+#  include <avr/iotn24a.h>
+#elif defined (__AVR_ATtiny44__)
+#  include <avr/iotn44.h>
+#elif defined (__AVR_ATtiny44A__)
+#  include <avr/iotn44a.h>
+#elif defined (__AVR_ATtiny84__)
+#  include <avr/iotn84.h>
+#elif defined (__AVR_ATtiny261__)
+#  include <avr/iotn261.h>
+#elif defined (__AVR_ATtiny261A__)
+#  include <avr/iotn261a.h>
+#elif defined (__AVR_ATtiny461__)
+#  include <avr/iotn461.h>
+#elif defined (__AVR_ATtiny461A__)
+#  include <avr/iotn461a.h>
+#elif defined (__AVR_ATtiny861__)
+#  include <avr/iotn861.h>
+#elif defined (__AVR_ATtiny861A__)
+#  include <avr/iotn861a.h>
+#elif defined (__AVR_ATtiny43U__)
+#  include <avr/iotn43u.h>
+#elif defined (__AVR_ATtiny48__)
+#  include <avr/iotn48.h>
+#elif defined (__AVR_ATtiny88__)
+#  include <avr/iotn88.h>
+#elif defined (__AVR_ATtiny87__)
+#  include <avr/iotn87.h>
+#elif defined (__AVR_ATtiny167__)
+#  include <avr/iotn167.h>
+#elif defined (__AVR_AT90SCR100__)
+#  include <avr/io90scr100.h>
+#elif defined (__AVR_ATxmega16A4__)
+#  include <avr/iox16a4.h>
+#elif defined (__AVR_ATxmega16D4__)
+#  include <avr/iox16d4.h>
+#elif defined (__AVR_ATxmega32A4__)
+#  include <avr/iox32a4.h>
+#elif defined (__AVR_ATxmega32D4__)
+#  include <avr/iox32d4.h>
+#elif defined (__AVR_ATxmega64A1__)
+#  include <avr/iox64a1.h>
+#elif defined (__AVR_ATxmega64A3__)
+#  include <avr/iox64a3.h>
+#elif defined (__AVR_ATxmega64D3__)
+#  include <avr/iox64d3.h>
+#elif defined (__AVR_ATxmega128A1__)
+#  include <avr/iox128a1.h>
+#elif defined (__AVR_ATxmega128A3__)
+#  include <avr/iox128a3.h>
+#elif defined (__AVR_ATxmega128D3__)
+#  include <avr/iox128d3.h>
+#elif defined (__AVR_ATxmega192A3__)
+#  include <avr/iox192a3.h>
+#elif defined (__AVR_ATxmega192D3__)
+#  include <avr/iox192d3.h>
+#elif defined (__AVR_ATxmega256A3__)
+#  include <avr/iox256a3.h>
+#elif defined (__AVR_ATxmega256A3B__)
+#  include <avr/iox256a3b.h>
+#elif defined (__AVR_ATxmega256D3__)
+#  include <avr/iox256d3.h>
+#elif defined (__AVR_ATA6289__)
+#  include <avr/ioa6289.h>
+/* avr1: the following only supported for assembler programs */
+#elif defined (__AVR_ATtiny28__)
+#  include <avr/iotn28.h>
+#elif defined (__AVR_AT90S1200__)
+#  include <avr/io1200.h>
+#elif defined (__AVR_ATtiny15__)
+#  include <avr/iotn15.h>
+#elif defined (__AVR_ATtiny12__)
+#  include <avr/iotn12.h>
+#elif defined (__AVR_ATtiny11__)
+#  include <avr/iotn11.h>
+#else
+#  if !defined(__COMPILING_AVR_LIBC__)
+#    warning "device type not defined"
+#  endif
+#endif
+
+#include <avr/portpins.h>
+
+#include <avr/common.h>
+
+#include <avr/version.h>
+
+/* Include fuse.h after individual IO header files. */
+#include <avr/fuse.h>
+
+/* Include lock.h after individual IO header files. */
+#include <avr/lock.h>
+
+#endif /* _AVR_IO_H_ */
Index: header/usbconfig.h
===================================================================
--- header/usbconfig.h	(nonexistent)
+++ header/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      B
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      1
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       0
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/12000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      1
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       1
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0x42, 0x42 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0x31, 0xel /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'H', 'P', '4', '8', 'K', 'E', 'Y', 'B', 'O', 'A', 'R', D'
+#define USB_CFG_DEVICE_NAME_LEN 12
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0x03    //HID
+#define USB_CFG_INTERFACE_SUBCLASS  0x01    //Boot
+#define USB_CFG_INTERFACE_PROTOCOL  0x01    //Keyboard
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    63
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: HP48GX.cbp
===================================================================
--- HP48GX.cbp	(nonexistent)
+++ HP48GX.cbp	(working copy)
@@ -0,0 +1,80 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="6" />
+	<Project>
+		<Option title="HP48GX" />
+		<Option pch_mode="2" />
+		<Option compiler="avr-gcc" />
+		<Build>
+			<Target title="Debug">
+				<Option output="bin/Debug/HP48GX.elf" prefix_auto="1" extension_auto="0" />
+				<Option working_dir="" />
+				<Option object_output="obj/Debug/" />
+				<Option type="5" />
+				<Option compiler="avr-gcc" />
+				<Compiler>
+					<Add option="-g" />
+				</Compiler>
+			</Target>
+			<Target title="Release">
+				<Option output="bin/Release/HP48GX.elf" prefix_auto="1" extension_auto="0" />
+				<Option working_dir="" />
+				<Option object_output="obj/Release/" />
+				<Option type="5" />
+				<Option compiler="avr-gcc" />
+				<Compiler>
+					<Add option="-Os" />
+				</Compiler>
+			</Target>
+			<Environment>
+				<Variable name="MCU" value="attiny88" />
+			</Environment>
+		</Build>
+		<Compiler>
+			<Add option="-fomit-frame-pointer" />
+			<Add option="-fexpensive-optimizations" />
+			<Add option="-Os" />
+			<Add option="-Wextra" />
+			<Add option="-Wall" />
+			<Add option="-mmcu=attiny88" />
+			<Add option="-DF_CPU=12000000UL" />
+			<Add directory="." />
+		</Compiler>
+		<Linker>
+			<Add option="-mmcu=attiny88" />
+			<Add option="-Wl,-Map=$(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).map,--cref" />
+		</Linker>
+		<ExtraCommands>
+			<Add after="avr-size --mcu=attiny88 --format=avr $(TARGET_OUTPUT_FILE)" />
+			<Add after='cmd /c &quot;avr-objdump -h -S $(TARGET_OUTPUT_FILE) &gt; $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).lss&quot;' />
+			<Add after="avr-objcopy -R .eeprom -R .fuse -R .lock -R .signature -O ihex $(TARGET_OUTPUT_FILE) $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).hex" />
+			<Add after="avr-objcopy --no-change-warnings -j .eeprom --change-section-lma .eeprom=0 -O ihex $(TARGET_OUTPUT_FILE) $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).eep" />
+			<Add after="avr-objcopy --no-change-warnings -j .lock --change-section-lma .lock=0 -O ihex $(TARGET_OUTPUT_FILE) $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).lock" />
+			<Add after="avr-objcopy --no-change-warnings -j .signature --change-section-lma .signature=0 -O ihex $(TARGET_OUTPUT_FILE) $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).sig" />
+			<Add after="avr-objcopy --no-change-warnings -j .fuse --change-section-lma .fuse=0 -O ihex $(TARGET_OUTPUT_FILE) $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).fuse" />
+			<Add after="srec_cat $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).fuse -Intel -crop 0x00 0x01 -offset  0x00 -O $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).lfs -Intel" />
+			<Add after="srec_cat $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).fuse -Intel -crop 0x01 0x02 -offset -0x01 -O $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).hfs -Intel" />
+			<Add after="srec_cat $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).fuse -Intel -crop 0x02 0x03 -offset -0x02 -O $(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).efs -Intel" />
+		</ExtraCommands>
+		<Unit filename="fuse.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="main.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="usbconfig.h" />
+		<Unit filename="usbdrv/oddebug.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="usbdrv/usbdrv.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="usbdrv/usbdrv.h" />
+		<Unit filename="usbdrv/usbdrvasm.S" />
+		<Extensions>
+			<code_completion />
+			<envvars />
+			<debugger />
+		</Extensions>
+	</Project>
+</CodeBlocks_project_file>
Index: HP48GX.cscope_file_list
===================================================================
--- HP48GX.cscope_file_list	(nonexistent)
+++ HP48GX.cscope_file_list	(working copy)
@@ -0,0 +1,3 @@
+"C:\Data\HP48GX_1\HP48GX\fuse.c"
+"C:\Data\HP48GX_1\HP48GX\usbconfig.h"
+"C:\Data\HP48GX_1\HP48GX\main.c"
Index: HP48GX.depend
===================================================================
--- HP48GX.depend	(nonexistent)
+++ HP48GX.depend	(working copy)
@@ -0,0 +1,354 @@
+# depslib dependency file v1.0
+1472127191 source:c:\data\hp48gx_1\hp48gx\fuse.c
+	<avr/io.h>
+
+1474459329 source:c:\data\hp48gx_1\hp48gx\main.c
+	<avr/io.h>
+	<util/delay.h>
+	<math.h>
+	"usbconfig.h"
+	"usbdrv/usbdrv.h"
+	<avr/wdt.h>
+	<avr/interrupt.h>
+	<stddef.h>
+	<stdint.h>
+
+1473425722 c:\data\hp48gx_1\hp48gx\usbconfig.h
+
+1472717516 source:c:\data\hp48gx_1\hp48gx\usbdrv\usbdrv.c
+	"usbportability.h"
+	"usbdrv.h"
+	"oddebug.h"
+
+1354792592 c:\data\hp48gx_1\hp48gx\usbdrv\usbportability.h
+	<ioavr.h>
+	<inavr.h>
+	<io.h>
+	<delay.h>
+	<avr/io.h>
+	<avr/pgmspace.h>
+
+1472717505 c:\data\hp48gx_1\hp48gx\usbdrv\usbdrv.h
+	"usbconfig.h"
+	"usbportability.h"
+
+1338498184 c:\data\hp48gx_1\hp48gx\usbdrv\usbconfig.h
+
+1354792592 c:\data\hp48gx_1\hp48gx\usbdrv\oddebug.h
+	"usbportability.h"
+
+1354792592 source:c:\data\hp48gx_1\hp48gx\usbdrv\oddebug.c
+	"oddebug.h"
+
+1472130791 source:c:\data\hp48gx\fuse.c
+	<avr/io.h>
+
+1354792592 source:c:\data\hp48gx\usbdrv\oddebug.c
+	"oddebug.h"
+
+1354792592 c:\data\hp48gx\usbdrv\oddebug.h
+	"usbportability.h"
+
+1354792592 c:\data\hp48gx\usbdrv\usbportability.h
+	<ioavr.h>
+	<inavr.h>
+	<io.h>
+	<delay.h>
+	<avr/io.h>
+	<avr/pgmspace.h>
+
+1354792592 source:c:\data\hp48gx\usbdrv\usbdrv.c
+	"usbdrv.h"
+	"oddebug.h"
+
+1354792592 c:\data\hp48gx\usbdrv\usbdrv.h
+	"usbconfig.h"
+	"usbportability.h"
+
+1472590750 c:\data\hp48gx\usbconfig.h
+
+1354792592 source:c:\data\hp48gx\usbdrv\usbdrvasm.s
+	"usbportability.h"
+	"usbdrv.h"
+	"usbdrvasm18-crc.inc"
+	"usbdrvasm12.inc"
+	"usbdrvasm128.inc"
+	"usbdrvasm15.inc"
+	"usbdrvasm16.inc"
+	"usbdrvasm165.inc"
+	"usbdrvasm20.inc"
+
+1354792592 c:\data\hp48gx\usbdrv\usbdrvasm18-crc.inc
+	"asmcommon.inc"
+	<stdio.h>
+
+1354792592 c:\data\hp48gx\usbdrv\asmcommon.inc
+
+1354792592 c:\data\hp48gx\usbdrv\usbdrvasm12.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx\usbdrv\usbdrvasm128.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx\usbdrv\usbdrvasm15.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx\usbdrv\usbdrvasm16.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx\usbdrv\usbdrvasm165.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx\usbdrv\usbdrvasm20.inc
+	"asmcommon.inc"
+
+1472717529 source:c:\data\hp48gx_1\hp48gx\usbdrv\usbdrvasm.s
+	"usbportability.h"
+	"usbdrv.h"
+	"usbdrvasm18-crc.inc"
+	"usbdrvasm12.inc"
+	"usbdrvasm128.inc"
+	"usbdrvasm15.inc"
+	"usbdrvasm16.inc"
+	"usbdrvasm165.inc"
+	"usbdrvasm20.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx\usbdrv\usbdrvasm18-crc.inc
+	"asmcommon.inc"
+	<stdio.h>
+
+1354792592 c:\data\hp48gx_1\hp48gx\usbdrv\asmcommon.inc
+
+1354792592 c:\data\hp48gx_1\hp48gx\usbdrv\usbdrvasm12.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx\usbdrv\usbdrvasm128.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx\usbdrv\usbdrvasm15.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx\usbdrv\usbdrvasm16.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx\usbdrv\usbdrvasm165.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx\usbdrv\usbdrvasm20.inc
+	"asmcommon.inc"
+
+1472127191 source:c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\fuse.c
+	<avr/io.h>
+
+1354792592 source:c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\oddebug.c
+	"oddebug.h"
+
+1354792592 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\oddebug.h
+	"usbportability.h"
+
+1354792592 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbportability.h
+	<ioavr.h>
+	<inavr.h>
+	<io.h>
+	<delay.h>
+	<avr/io.h>
+	<avr/pgmspace.h>
+
+1472717516 source:c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbdrv.c
+	"usbportability.h"
+	"usbdrv.h"
+	"oddebug.h"
+
+1472717505 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbdrv.h
+	"usbconfig.h"
+	"usbportability.h"
+
+1338498184 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbconfig.h
+
+1472717529 source:c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbdrvasm.s
+	"usbportability.h"
+	"usbdrv.h"
+	"usbdrvasm18-crc.inc"
+	"usbdrvasm12.inc"
+	"usbdrvasm128.inc"
+	"usbdrvasm15.inc"
+	"usbdrvasm16.inc"
+	"usbdrvasm165.inc"
+	"usbdrvasm20.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbdrvasm18-crc.inc
+	"asmcommon.inc"
+	<stdio.h>
+
+1354792592 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\asmcommon.inc
+
+1354792592 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbdrvasm12.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbdrvasm128.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbdrvasm15.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbdrvasm16.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbdrvasm165.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gx  nothing works onkey on portb\usbdrv\usbdrvasm20.inc
+	"asmcommon.inc"
+
+1472127191 source:c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\fuse.c
+	<avr/io.h>
+
+1474533783 source:c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\main.c
+	<avr/io.h>
+	<util/delay.h>
+	<math.h>
+	"usbconfig.h"
+	"usbdrv/usbdrv.h"
+	<avr/wdt.h>
+	<avr/interrupt.h>
+	<stddef.h>
+	<stdint.h>
+
+1474468778 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbconfig.h
+
+1472717505 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbdrv.h
+	"usbconfig.h"
+	"usbportability.h"
+
+1338498184 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbconfig.h
+
+1354792592 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbportability.h
+	<ioavr.h>
+	<inavr.h>
+	<io.h>
+	<delay.h>
+	<avr/io.h>
+	<avr/pgmspace.h>
+
+1354792592 source:c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\oddebug.c
+	"oddebug.h"
+
+1354792592 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\oddebug.h
+	"usbportability.h"
+
+1472717516 source:c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbdrv.c
+	"usbportability.h"
+	"usbdrv.h"
+	"oddebug.h"
+
+1472717529 source:c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbdrvasm.s
+	"usbportability.h"
+	"usbdrv.h"
+	"usbdrvasm18-crc.inc"
+	"usbdrvasm12.inc"
+	"usbdrvasm128.inc"
+	"usbdrvasm15.inc"
+	"usbdrvasm16.inc"
+	"usbdrvasm165.inc"
+	"usbdrvasm20.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbdrvasm18-crc.inc
+	"asmcommon.inc"
+	<stdio.h>
+
+1354792592 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\asmcommon.inc
+
+1354792592 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbdrvasm12.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbdrvasm128.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbdrvasm15.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbdrvasm16.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbdrvasm165.inc
+	"asmcommon.inc"
+
+1354792592 c:\data\hp48gx_1\hp48gxnothingworksonkeyonportb\usbdrv\usbdrvasm20.inc
+	"asmcommon.inc"
+
+1472123591 source:c:\data\hp48gx_1\hp48gx_allworks\fuse.c
+	<avr/io.h>
+
+1354788992 source:c:\data\hp48gx_1\hp48gx_allworks\usbdrv\oddebug.c
+	"oddebug.h"
+
+1354788992 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\oddebug.h
+	"usbportability.h"
+
+1354788992 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbportability.h
+	<ioavr.h>
+	<inavr.h>
+	<io.h>
+	<delay.h>
+	<avr/io.h>
+	<avr/pgmspace.h>
+
+1472713916 source:c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbdrv.c
+	"usbportability.h"
+	"usbdrv.h"
+	"oddebug.h"
+
+1472713905 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbdrv.h
+	"usbconfig.h"
+	"usbportability.h"
+
+1338494584 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbconfig.h
+
+1472713929 source:c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbdrvasm.s
+	"usbportability.h"
+	"usbdrv.h"
+	"usbdrvasm18-crc.inc"
+	"usbdrvasm12.inc"
+	"usbdrvasm128.inc"
+	"usbdrvasm15.inc"
+	"usbdrvasm16.inc"
+	"usbdrvasm165.inc"
+	"usbdrvasm20.inc"
+
+1354788992 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbdrvasm18-crc.inc
+	"asmcommon.inc"
+	<stdio.h>
+
+1354788992 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\asmcommon.inc
+
+1354788992 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbdrvasm12.inc
+	"asmcommon.inc"
+
+1354788992 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbdrvasm128.inc
+	"asmcommon.inc"
+
+1354788992 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbdrvasm15.inc
+	"asmcommon.inc"
+
+1354788992 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbdrvasm16.inc
+	"asmcommon.inc"
+
+1354788992 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbdrvasm165.inc
+	"asmcommon.inc"
+
+1354788992 c:\data\hp48gx_1\hp48gx_allworks\usbdrv\usbdrvasm20.inc
+	"asmcommon.inc"
+
+1478271711 source:c:\data\hp48gx_1\hp48gx_allworks\main.c
+	<avr/io.h>
+	<util/delay.h>
+	<math.h>
+	"usbconfig.h"
+	"usbdrv/usbdrv.h"
+	<avr/wdt.h>
+	<avr/interrupt.h>
+	<stddef.h>
+	<stdint.h>
+
+1474465178 c:\data\hp48gx_1\hp48gx_allworks\usbconfig.h
+
Index: HP48GX.layout
===================================================================
--- HP48GX.layout	(nonexistent)
+++ HP48GX.layout	(working copy)
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_layout_file>
+	<FileVersion major="1" minor="0" />
+	<ActiveTarget name="Release" />
+	<File name="usbdrv\usbdrv.h" open="1" top="0" tabpos="2" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="4643" topLine="558" />
+		</Cursor>
+	</File>
+	<File name="usbdrv\usbdrvasm.S" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="11670" topLine="358" />
+		</Cursor>
+	</File>
+	<File name="fuse.c" open="1" top="0" tabpos="4" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="130" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="usbdrv\usbdrv.c" open="0" top="0" tabpos="3" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="23444" topLine="491" />
+		</Cursor>
+	</File>
+	<File name="usbconfig.h" open="1" top="0" tabpos="1" split="0" active="1" splitpos="0" zoom_1="1" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="5598" topLine="93" />
+		</Cursor>
+	</File>
+	<File name="main.c" open="1" top="1" tabpos="3" split="0" active="1" splitpos="0" zoom_1="-2" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="7433" topLine="126" />
+		</Cursor>
+		<Folding>
+			<Collapse line="96" />
+		</Folding>
+	</File>
+</CodeBlocks_layout_file>
Index: main.c
===================================================================
--- main.c	(nonexistent)
+++ main.c	(working copy)
@@ -0,0 +1,337 @@
+/*---------------------------------------------------------------------------
+------------------------------HP48GX-----------------------------------------
+---------------------------------------------------------------------------*/
+
+//-------------------------------defines-----------------------------------
+#include <avr/io.h>
+#include <util/delay.h>
+#include <math.h>
+#include "usbconfig.h"
+#include "usbdrv/usbdrv.h"
+#include <avr/wdt.h>
+#include <avr/interrupt.h>
+#include <stddef.h>
+#include <stdint.h>
+
+
+#define STATE_WAIT 0
+#define STATE_SEND_KEY 1
+#define STATE_RELEASE_KEY 2
+
+#define ROWS 10
+#define DEBOUNCE_CYCLES 8
+#define TAB2HP  (60) ///F3
+//-------------------------------globale Variablen----------------------------
+
+uchar state = STATE_WAIT;
+
+typedef struct {
+	uint8_t modifier;
+	uint8_t reserved;
+	uint8_t keycode[6];
+} keyboard_report_t;
+
+static keyboard_report_t keyboard_report; // sent to PC
+static uchar idleRate; // repeat rate for keyboards
+
+static uint16_t activeRow = 0x01;
+static uint8_t activeRowIdx = 0;
+static uint8_t keyStates[ROWS] = {0};
+
+int EnableKeyPressed = 0;
+static int isrFlag = 0;
+int keybuild = 0;
+int OnCount = 0;
+int FAIL = 0;
+uint8_t changedKeys = 0;
+static uint8_t debouncing[DEBOUNCE_CYCLES][ROWS]={{0}}; //uint8_t
+PROGMEM char usbHidReportDescriptor[USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH] = {
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
+    0x09, 0x06,                    // USAGE (Keyboard)
+    0xa1, 0x01,
+    0x75, 0x01,                    //   REPORT_SIZE (1)
+    0x95, 0x08,                    //   REPORT_COUNT (8)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
+    0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)(224)
+    0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)(231)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0xFF,                    //   LOGICAL_MAXIMUM (1)
+    0x81, 0x02,                    //   INPUT (Data,Var,Abs) ; Modifier byte
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x81, 0x03,                    //   INPUT (Cnst,Var,Abs) ; Reserved byte
+    0x95, 0x05,                    //   REPORT_COUNT (5)
+    0x75, 0x01,                    //   REPORT_SIZE (1)
+    0x05, 0x08,                    //   USAGE_PAGE (LEDs)
+    0x19, 0x01,                    //   USAGE_MINIMUM (Num Lock)
+    0x29, 0xFF,                    //   USAGE_MAXIMUM (Kana)
+    0x91, 0x02,                    //   OUTPUT (Data,Var,Abs) ; LED report
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x75, 0x03,                    //   REPORT_SIZE (3)
+    0x91, 0x03,                    //   OUTPUT (Cnst,Var,Abs) ; LED report padding
+    0x95, 0x06,                    //   REPORT_COUNT (6)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0xFF,                    //   LOGICAL_MAXIMUM (101)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
+    0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))(0)
+    0x29, 0xFF,                    //   USAGE_MAXIMUM (Keyboard Application)(101)
+    0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
+    0xc0                           // END_COLLECTION
+};
+
+                    //    A5,A4,A3,A2,A1,A0
+uchar ScanCode [10][6] = {{0,5,6,7,8,9},
+              /*[y][x]*/  {0,11,12,13,14,15},
+                          {0,17,18,19,20,21},
+                          {0,23,24,25,26,27},
+                          {0,88,29,28,76,42},
+                          {43,22,36,37,38,84},
+             //             {0,0,0,0,0,0}, // unused
+                   /*225*/{225,10,33,34,35,85},
+                   /*224*/{224,4,30,31,32,86},
+                          {0,16,39,55,44,87},
+                          {41,0,0,0,0,0,}};
+
+//---------------------------------Funktionen-----------------------------------
+usbMsgLen_t usbFunctionSetup(unsigned char data[8]) {
+    usbRequest_t *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS) {
+        switch(rq->bRequest) {
+        case USBRQ_HID_GET_REPORT: // send "no keys pressed" if asked here
+            // wValue: ReportType (highbyte), ReportID (lowbyte)
+            usbMsgPtr = (void *)&keyboard_report; // we only have this one
+            keyboard_report.modifier = 0;
+            keyboard_report.keycode[0] = 0;
+            return sizeof(keyboard_report);
+		case USBRQ_HID_SET_REPORT: // if wLength == 1, should be LED state
+            return (rq->wLength.word == 1) ? USB_NO_MSG : 0;
+        case USBRQ_HID_GET_IDLE: // send idle rate to PC as required by spec
+            usbMsgPtr = &idleRate;
+            return 1;
+        case USBRQ_HID_SET_IDLE: // save idle rate as required by spec
+            idleRate = rq->wValue.bytes[1];
+            return 0;
+        }
+    }
+
+    return 0; // by default don't return any data
+}
+
+
+
+usbMsgLen_t usbFunctionWrite(uint8_t * data, uchar len)
+{
+    return 1;
+}
+
+void buildReport(uchar send_key)
+{
+	keyboard_report.modifier = 0;
+
+    keyboard_report.keycode[0] = send_key;
+
+}
+
+ISR(TIMER0_OVF_vect)
+{
+    isrFlag = 1;
+}
+void scanMatrix(void)
+{
+    if(!isrFlag)
+        return;
+    isrFlag = 0;
+    uint8_t newVal = PIND & 0xF3; /// mask data lines
+
+//    int allEqual = 1;
+//    int idx = 0;
+//    for (idx = 0 ; idx < DEBOUNCE_CYCLES-1; ++idx)
+//    {
+//        if ( newVal != debouncing[idx][activeRowIdx] )
+//            allEqual = 0;
+//        debouncing[idx][activeRowIdx] = debouncing[idx+1][activeRowIdx];
+//
+//    }
+//    if ( newVal != debouncing[idx][activeRowIdx] )
+//        allEqual = 0;
+//    debouncing[idx][activeRowIdx] = newVal;
+
+
+    uint8_t changedKeys = keyStates[activeRowIdx] ^ newVal;
+    keyStates[activeRowIdx] = newVal;
+    if(/*allEqual && */changedKeys)
+    {
+        if((~newVal&0x01) && (changedKeys&0x01))///A5
+        {
+            state = STATE_SEND_KEY;
+            keybuild = (ScanCode[activeRowIdx][0]);//A5
+        }
+         else if((~newVal&0x02) && (changedKeys&0x02)) ///A4
+        {
+            state = STATE_SEND_KEY;
+            keybuild = (ScanCode[activeRowIdx][1]);//A0
+        }
+        else if((~newVal&0x10) && (changedKeys&0x10)) ///A3
+        {
+            state = STATE_SEND_KEY;
+            keybuild = (ScanCode[activeRowIdx][2]);//A3
+        }
+        else if((~newVal&0x20) && (changedKeys&0x20)) ///A2
+        {
+            state = STATE_SEND_KEY;
+            keybuild = (ScanCode[activeRowIdx][3]);//A2
+        }
+        else if((~newVal&0x40) && (changedKeys&0x40)) ///A1
+        {
+            state = STATE_SEND_KEY;
+            keybuild = (ScanCode[activeRowIdx][4]);//A0
+        }
+        else if((~newVal&0x80) && (changedKeys&0x80)) ///A0
+        {
+            state = STATE_SEND_KEY;
+            keybuild = (ScanCode[activeRowIdx][5]);//A0
+        }
+    }
+    activeRow <<= 1;
+    activeRowIdx += 1;
+    if(activeRow == 0x40)
+    {
+        activeRow <<= 1;
+    }
+    if(activeRow == 0x400)
+    {
+        activeRow = 0x01;
+        activeRowIdx = 0;
+    }
+
+    DDRC = activeRow;
+    DDRA = ((activeRow >> 8) | 0x04);
+}
+
+void OnKey (void)
+{
+    if(state == STATE_SEND_KEY)
+        return;
+
+    int OnVal = (PINB&0x80); ///Mask PIN7
+//    int allEqual = 1;
+//    int idx = 0;
+//    for (idx = 0; idx < DEBOUNCE_CYCLES - 1; ++idx)
+//    {
+//        allEqual &= (OnVal == debouncing[idx][9]);
+//        debouncing[idx][9] = debouncing[idx+1][9];
+//
+//    }
+//    allEqual &= (OnVal == debouncing[idx][9]);
+//    debouncing[idx][9] = OnVal;
+
+    uint8_t changedKeysOn = keyStates[9] ^ OnVal;
+    keyStates[9] = OnVal;
+
+
+    if((~OnVal&0x80) /*&& (changedKeysOn&0x80)*/)///ONKEY
+    {
+        PORTB = 0b00000001;
+        EnableKeyPressed = 1;
+    }
+
+
+}
+
+void KeyPressed (void)
+{
+    if(EnableKeyPressed == 0)
+        return;
+    if((PINB&0x80)==0)
+    {
+        OnCount++;
+
+        if(OnCount == 800)///pressed and hold
+        {
+            keybuild = (TAB2HP);
+            state = STATE_SEND_KEY;
+            EnableKeyPressed = 0;
+            OnCount = 0;
+        }
+    }
+    if((OnCount < 800) && (OnCount > 600))///pressed
+    {
+        keybuild = (ScanCode[9][0]);
+        state = STATE_SEND_KEY;
+        EnableKeyPressed = 0;
+    }
+
+}
+
+void Init (void)
+{
+    PCMSK0  = 0b00000000;
+    PCMSK2  = 0b00000000;
+    PCMSK3  = 0b00000000;
+    DDRC    = 0b00000000;
+    PORTC   = 0b00000000;
+    DDRD   &= 0b00001100;
+    PORTD  &= 0b00000000;
+    DDRA    = 0b00000100;
+    PORTA   = 0b00000000;
+    TCCR1A  = 0b00000000;
+    TCCR1B  = 0b00000000;
+    TCCR1C  = 0b00000000;
+    DDRB    = 0b00000001;
+    PORTB   = 0b00000000;
+}
+//----------------------Main--------------------------------
+int main(void)
+{
+    Init();
+//-------------------------------------
+    uchar i;
+    for(i=0; i<sizeof(keyboard_report); i++) // clear report initially
+        ((uchar *)&keyboard_report)[i] = 0;
+    wdt_enable(WDTO_1S); // enable 1s watchdog timer
+    usbInit();
+    usbDeviceDisconnect(); // enforce re-enumeration
+
+    for(i = 0; i<250; i++) { // wait 500 ms
+        wdt_reset(); // keep the watchdog happy
+        _delay_ms(2);
+    }
+    usbPoll();
+    usbDeviceConnect();
+
+    cli();
+    TCCR0A = 0b00000011; //clk/8 ==> timeout 1.35ms
+    TIMSK0 = 0b00000001;
+    sei();
+
+    while(1)
+    {
+        KeyPressed();
+        OnKey();
+        scanMatrix();
+        wdt_reset(); // keep the watchdog happy
+        usbPoll();
+
+        if(usbInterruptIsReady() && state != STATE_WAIT)
+        {
+            switch(state)
+			{
+			case STATE_SEND_KEY:
+                buildReport(keybuild);
+				state = STATE_RELEASE_KEY; // release next
+				break;
+			case STATE_RELEASE_KEY:
+                buildReport(0);
+                state = STATE_WAIT; // go back to waiting
+                break;
+			default:
+                state = STATE_WAIT; // should not happen
+			}
+        }
+        usbSetInterrupt((void *)&keyboard_report, sizeof(keyboard_report)); // start sending
+    }
+
+    return 0;
+}
Index: main.c.bak
===================================================================
--- main.c.bak	(nonexistent)
+++ main.c.bak	(working copy)
@@ -0,0 +1,314 @@
+/*---------------------------------------------------------------------------
+------------------------------HP48GX-----------------------------------------
+---------------------------------------------------------------------------*/
+
+//-------------------------------defines-----------------------------------
+#include <avr/io.h>
+#include <util/delay.h>
+#include <math.h>
+#include "usbconfig.h"
+#include "usbdrv/usbdrv.h"
+#include <avr/wdt.h>
+#include <avr/interrupt.h>
+#include <stddef.h>
+
+#define PWRLED (PORTC | 0b00100000)
+#define A12OUT (PORTC & 0b00101111)
+#define A10OUT (PORTD & 0b11111101)
+#define A1IN   (PINC2)
+
+#define STATE_WAIT 0
+#define STATE_SEND_KEY 1
+#define STATE_RELEASE_KEY 2
+
+//-------------------------------globale Variablen----------------------------
+
+uchar state = STATE_WAIT;
+
+PROGMEM char usbHidReportDescriptor[USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH] = {
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
+    0x09, 0x06,                    // USAGE (Keyboard)
+    0xa1, 0x01,
+    0x75, 0x01,                    //   REPORT_SIZE (1)
+    0x95, 0x08,                    //   REPORT_COUNT (8)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
+    0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)(224)
+    0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)(231)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
+    0x81, 0x02,                    //   INPUT (Data,Var,Abs) ; Modifier byte
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x81, 0x03,                    //   INPUT (Cnst,Var,Abs) ; Reserved byte
+    0x95, 0x05,                    //   REPORT_COUNT (5)
+    0x75, 0x01,                    //   REPORT_SIZE (1)
+    0x05, 0x08,                    //   USAGE_PAGE (LEDs)
+    0x19, 0x01,                    //   USAGE_MINIMUM (Num Lock)
+    0x29, 0x05,                    //   USAGE_MAXIMUM (Kana)
+    0x91, 0x02,                    //   OUTPUT (Data,Var,Abs) ; LED report
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x75, 0x03,                    //   REPORT_SIZE (3)
+    0x91, 0x03,                    //   OUTPUT (Cnst,Var,Abs) ; LED report padding
+    0x95, 0x06,                    //   REPORT_COUNT (6)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
+    0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))(0)
+    0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)(101)
+    0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
+    0xc0                           // END_COLLECTION
+};
+
+
+uchar ScanCode [10][6] = {{0,5,6,7,8,9},
+             /*[y][x]*/  {0,11,12,13,14,15},
+                         {0,17,18,19,20,21},
+                         {0,23,24,25,26,27},
+                         {0,88,28,29,76,42},
+                         {43,22,36,37,38,84},
+                         {225,16,33,34,35,85},
+                         {224,10,30,31,32,86},
+                         {0,4,62,37,44,87},
+                         {41,0,0,0,0,0}};
+
+
+/*  enter 88
+    delete 76
+    backspace 42
+    operationen 84 - 87 /*-+
+    tab 43
+    control 224
+    shift 225
+    esc 41
+	space 44
+	f13 104*/
+
+typedef struct {
+	uint8_t modifier;
+	uint8_t reserved;
+	uint8_t keycode[6];
+} keyboard_report_t;
+
+static keyboard_report_t keyboard_report; // sent to PC
+static uchar idleRate; // repeat rate for keyboards
+
+
+usbMsgLen_t usbFunctionSetup(unsigned char data[8]) {
+    usbRequest_t *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS) {
+        switch(rq->bRequest) {
+        case USBRQ_HID_GET_REPORT: // send "no keys pressed" if asked here
+            // wValue: ReportType (highbyte), ReportID (lowbyte)
+            usbMsgPtr = (void *)&keyboard_report; // we only have this one
+            keyboard_report.modifier = 0;
+            keyboard_report.keycode[0] = 0;
+            return sizeof(keyboard_report);
+		case USBRQ_HID_SET_REPORT: // if wLength == 1, should be LED state
+            return (rq->wLength.word == 1) ? USB_NO_MSG : 0;
+        case USBRQ_HID_GET_IDLE: // send idle rate to PC as required by spec
+            usbMsgPtr = &idleRate;
+            return 1;
+        case USBRQ_HID_SET_IDLE: // save idle rate as required by spec
+            idleRate = rq->wValue.bytes[1];
+            return 0;
+        }
+    }
+
+    return 0; // by default don't return any data
+}
+
+
+
+usbMsgLen_t usbFunctionWrite(uint8_t * data, uchar len) {
+	//if (data[0] == LED_state)
+        return 1;
+    //else
+    //    LED_state = data[0];PORTD = PORTD & 0b11110111;
+	//TIMSK0 |= (1<<TOIE0); //enables Overflow Interrupt
+    //// LED state changed
+	//if(LED_state & CAPS_LOCK)
+	//	PORTB |= 1 << PB0; // LED on
+	//else
+	//	PORTB &= ~(1 << PB0); // LED off
+	//
+	//return 1; // Data read, not expecting more
+}
+void buildReport(uchar send_key) {
+	keyboard_report.modifier = 0;
+    if(send_key != 0)
+		keyboard_report.keycode[0] = send_key;
+    else
+		keyboard_report.keycode[0] = 0;
+}
+#define VBAT 3
+#define ROWS 10
+#define DEBOUNCE_CYCLES 10
+uint16_t activeRow = 0x01;
+uint8_t activeRowIdx = 0;
+uint8_t keyStates[ROWS];
+uint8_t debouncing[DEBOUNCE_CYCLES][ROWS];
+
+int isrFlag = 0;
+
+ISR(TIMER0_OVF_vect)
+{
+    isrFlag = 1;
+}
+int scanMatrix(void)
+{
+    if(!isrFlag)
+        return 0;
+    isrFlag = 0;
+
+    int idx = 0;
+    int allEqual = 1;
+
+    uint8_t newVal = PIND & 0xF3; /// mask data lines
+    for (idx = 0 ; idx < DEBOUNCE_CYCLES - 1; ++idx)
+    {
+        allEqual &= newVal == debouncing[idx][activeRowIdx];
+        debouncing[idx][activeRowIdx] = debouncing[idx+1][activeRowIdx];
+    }
+    allEqual &= newVal == debouncing[idx][activeRowIdx];
+    debouncing[idx][activeRowIdx] = newVal;
+
+    uint8_t changedKeys = keyStates[activeRowIdx] ^ newVal;
+    if(allEqual && changedKeys)
+    {
+        if(((changedKeys & 0x01)&~(keyStates[activeRowIdx]|0xFE))== 0x01 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][0]);
+            }
+        else if(((changedKeys & 0x02)&~(keyStates[activeRowIdx]|0xFD))== 0x02 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][1]);
+            }
+        else if(((changedKeys & 0x04)&~(keyStates[activeRowIdx]|0xFB))== 0x04 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][2]);
+            }
+        else if(((changedKeys & 0x08)&~(keyStates[activeRowIdx]|0xF7))== 0x08 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][3]);
+            }
+        else if(((changedKeys & 0x10)&~(keyStates[activeRowIdx]|0xEF))== 0x10 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][4]);
+            }
+        else if(((changedKeys & 0x20)&~(keyStates[activeRowIdx]|0xDF))== 0x20 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][5]);
+            }
+        keyStates[activeRowIdx] = newVal;
+    }
+
+    else
+    {
+        int ONKEY = 0;
+        for(idx = 0; idx < DEBOUNCE_CYCLES-1; ++idx)
+        {
+            ONKEY = (PINB & 0x80);
+            allEqual &= ONKEY == debouncing[idx][activeRowIdx];
+            debouncing[idx][activeRowIdx] = debouncing[idx+1][activeRowIdx];
+        }
+        allEqual &= ONKEY == debouncing[idx][activeRowIdx];
+        debouncing[idx][activeRowIdx] = ONKEY;
+        uint8_t changedONKEY = keyStates[activeRowIdx] ^ ONKEY;
+        if(allEqual && changedONKEY)
+        {
+            if(((changedONKEY & 0x80)&~(keyStates[activeRowIdx]|0x7F))== 0x80){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][0]);
+            }
+        }
+    }
+    DDRC =  ~activeRow     & 0xff;     //DDRC
+    activeRow <<= 1;
+    activeRowIdx += 1;
+    if (activeRow & (1 << ROWS))
+    {
+        activeRow = 0x01;
+        activeRowIdx = 0;
+    }
+    DDRC =  ~activeRow     & 0xff;     //DDRC
+    DDRA = (~activeRow>>8) & 0xff;     //DDRA
+
+    return 0;
+}
+int main(void)
+{
+    /*DDRC  = 0b00000000;
+    PORTC = 0b01000000;
+    DDRD  &= 0b00001100;
+    PORTD &= 0b00001100;
+    DDRA  = 0b00000000;
+    PORTA = 0b00000000;
+    DDRB  = 0b01111111;
+    PORTB = 0b01111111;*/
+
+    DDRC = 0b00110000;
+    PORTC = 0b00000000;
+
+    TCCR0A |= 0b00000011; //clk/64 ==> timeout 1.35ms
+//-------------------------------------
+    uchar report_size,i, button_release_counter = 0;
+    //cli();
+
+    for(report_size=0; report_size<sizeof(keyboard_report); report_size++) // clear report initially
+        ((uchar *)&keyboard_report)[report_size] = 0;
+
+    wdt_enable(WDTO_1S); // enable 1s watchdog timer
+
+    usbInit();
+
+    usbDeviceDisconnect(); // enforce re-enumeration
+    for(i = 0; i<250; i++) // wait 500 ms
+    {
+        wdt_reset(); // keep the watchdog happy
+        _delay_ms(2);
+    }
+    usbDeviceConnect();
+
+    sei(); // Enable interrupts after re-enumeration
+    int keybuild = 0;
+    while(1)
+    {
+     //   keybuild = scanMatrix();
+        wdt_reset(); // keep the watchdog happy
+        usbPoll();
+
+        if(!(PINC & (1<<A1IN))) { // button pressed (PB1 at ground voltage)
+			// also check if some time has elapsed since last button press
+			if(state == STATE_WAIT && button_release_counter == 255)
+				state = STATE_SEND_KEY;
+				button_release_counter = 0; // now button needs to be released a while until retrigger
+		}
+
+		if(button_release_counter < 255)
+			button_release_counter++; // increase release counter*/
+
+        if(usbInterruptIsReady() && state != STATE_WAIT)
+        {
+
+			switch(state)
+			{
+			case STATE_SEND_KEY:
+				buildReport('1');
+				state = STATE_RELEASE_KEY; // release next
+				break;
+			case STATE_RELEASE_KEY:
+				buildReport(NULL);
+				state = STATE_WAIT; // go back to waiting
+				break;
+			default:
+				state = STATE_WAIT; // should not happen
+			}
+        }
+        // start sending
+        usbSetInterrupt((void *)&keyboard_report, sizeof(keyboard_report));
+    }
+
+    return 0;
+}
Index: new_main_hp48GX.txt
===================================================================
--- new_main_hp48GX.txt	(nonexistent)
+++ new_main_hp48GX.txt	(working copy)
@@ -0,0 +1,314 @@
+/*---------------------------------------------------------------------------
+------------------------------HP48GX-----------------------------------------
+---------------------------------------------------------------------------*/
+
+//-------------------------------defines-----------------------------------
+#include <avr/io.h>
+#include <util/delay.h>
+#include <math.h>
+#include "usbconfig.h"
+#include "usbdrv/usbdrv.h"
+#include <avr/wdt.h>
+#include <avr/interrupt.h>
+#include <stddef.h>
+
+#define PWRLED (PORTC | 0b00100000)
+#define A12OUT (PORTC & 0b00101111)
+#define A10OUT (PORTD & 0b11111101)
+#define A1IN   (PINC2)
+
+#define STATE_WAIT 0
+#define STATE_SEND_KEY 1
+#define STATE_RELEASE_KEY 2
+
+//-------------------------------globale Variablen----------------------------
+
+uchar state = STATE_WAIT;
+
+PROGMEM char usbHidReportDescriptor[USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH] = {
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
+    0x09, 0x06,                    // USAGE (Keyboard)
+    0xa1, 0x01,
+    0x75, 0x01,                    //   REPORT_SIZE (1)
+    0x95, 0x08,                    //   REPORT_COUNT (8)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
+    0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)(224)
+    0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)(231)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
+    0x81, 0x02,                    //   INPUT (Data,Var,Abs) ; Modifier byte
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x81, 0x03,                    //   INPUT (Cnst,Var,Abs) ; Reserved byte
+    0x95, 0x05,                    //   REPORT_COUNT (5)
+    0x75, 0x01,                    //   REPORT_SIZE (1)
+    0x05, 0x08,                    //   USAGE_PAGE (LEDs)
+    0x19, 0x01,                    //   USAGE_MINIMUM (Num Lock)
+    0x29, 0x05,                    //   USAGE_MAXIMUM (Kana)
+    0x91, 0x02,                    //   OUTPUT (Data,Var,Abs) ; LED report
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x75, 0x03,                    //   REPORT_SIZE (3)
+    0x91, 0x03,                    //   OUTPUT (Cnst,Var,Abs) ; LED report padding
+    0x95, 0x06,                    //   REPORT_COUNT (6)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
+    0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))(0)
+    0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)(101)
+    0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
+    0xc0                           // END_COLLECTION
+};
+
+
+uchar ScanCode [10][6] = {{0,5,6,7,8,9},
+             /*[y][x]*/  {0,11,12,13,14,15},
+                         {0,17,18,19,20,21},
+                         {0,23,24,25,26,27},
+                         {0,88,28,29,76,42},
+                         {43,22,36,37,38,84},
+                         {225,16,33,34,35,85},
+                         {224,10,30,31,32,86},
+                         {0,4,62,37,44,87},
+                         {41,0,0,0,0,0}};
+
+
+/*  enter 88
+    delete 76
+    backspace 42
+    operationen 84 - 87 /*-+
+    tab 43
+    control 224
+    shift 225
+    esc 41
+	space 44
+	f13 104*/
+
+typedef struct {
+	uint8_t modifier;
+	uint8_t reserved;
+	uint8_t keycode[6];
+} keyboard_report_t;
+
+static keyboard_report_t keyboard_report; // sent to PC
+static uchar idleRate; // repeat rate for keyboards
+
+
+usbMsgLen_t usbFunctionSetup(unsigned char data[8]) {
+    usbRequest_t *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS) {
+        switch(rq->bRequest) {
+        case USBRQ_HID_GET_REPORT: // send "no keys pressed" if asked here
+            // wValue: ReportType (highbyte), ReportID (lowbyte)
+            usbMsgPtr = (void *)&keyboard_report; // we only have this one
+            keyboard_report.modifier = 0;
+            keyboard_report.keycode[0] = 0;
+            return sizeof(keyboard_report);
+		case USBRQ_HID_SET_REPORT: // if wLength == 1, should be LED state
+            return (rq->wLength.word == 1) ? USB_NO_MSG : 0;
+        case USBRQ_HID_GET_IDLE: // send idle rate to PC as required by spec
+            usbMsgPtr = &idleRate;
+            return 1;
+        case USBRQ_HID_SET_IDLE: // save idle rate as required by spec
+            idleRate = rq->wValue.bytes[1];
+            return 0;
+        }
+    }
+
+    return 0; // by default don't return any data
+}
+
+
+
+usbMsgLen_t usbFunctionWrite(uint8_t * data, uchar len) {
+	//if (data[0] == LED_state)
+        return 1;
+    //else
+    //    LED_state = data[0];PORTD = PORTD & 0b11110111;
+	//TIMSK0 |= (1<<TOIE0); //enables Overflow Interrupt
+    //// LED state changed
+	//if(LED_state & CAPS_LOCK)
+	//	PORTB |= 1 << PB0; // LED on
+	//else
+	//	PORTB &= ~(1 << PB0); // LED off
+	//
+	//return 1; // Data read, not expecting more
+}
+void buildReport(uchar send_key) {
+	keyboard_report.modifier = 0;
+    if(send_key != 0)
+		keyboard_report.keycode[0] = send_key;
+    else
+		keyboard_report.keycode[0] = 0;
+}
+#define VBAT 3
+#define ROWS 10
+#define DEBOUNCE_CYCLES 10
+uint16_t activeRow = 0x01;
+uint8_t activeRowIdx = 0;
+uint8_t keyStates[ROWS];
+uint8_t debouncing[DEBOUNCE_CYCLES][ROWS];
+
+int isrFlag = 0;
+
+ISR(TIMER0_OVF_vect)
+{
+    isrFlag = 1;
+}
+/*int scanMatrix(void)
+{
+    if(!isrFlag)
+        return 0;
+    isrFlag = 0;
+
+    int idx = 0;
+    int allEqual = 1;
+
+    uint8_t newVal = PIND & 0xF3; /// mask data lines
+    for (idx = 0 ; idx < DEBOUNCE_CYCLES - 1; ++idx)
+    {
+        allEqual &= newVal == debouncing[idx][activeRowIdx];
+        debouncing[idx][activeRowIdx] = debouncing[idx+1][activeRowIdx];
+    }
+    allEqual &= newVal == debouncing[idx][activeRowIdx];
+    debouncing[idx][activeRowIdx] = newVal;
+
+    uint8_t changedKeys = keyStates[activeRowIdx] ^ newVal;
+    if(allEqual && changedKeys)
+    {
+        if(((changedKeys & 0x01)&~(keyStates[activeRowIdx]|0xFE))== 0x01 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][0]);
+            }
+        else if(((changedKeys & 0x02)&~(keyStates[activeRowIdx]|0xFD))== 0x02 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][1]);
+            }
+        else if(((changedKeys & 0x04)&~(keyStates[activeRowIdx]|0xFB))== 0x04 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][2]);
+            }
+        else if(((changedKeys & 0x08)&~(keyStates[activeRowIdx]|0xF7))== 0x08 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][3]);
+            }
+        else if(((changedKeys & 0x10)&~(keyStates[activeRowIdx]|0xEF))== 0x10 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][4]);
+            }
+        else if(((changedKeys & 0x20)&~(keyStates[activeRowIdx]|0xDF))== 0x20 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][5]);
+            }
+        keyStates[activeRowIdx] = newVal;
+    }
+
+    else
+    {
+        int ONKEY = 0;
+        for(idx = 0; idx < DEBOUNCE_CYCLES-1; ++idx)
+        {
+            ONKEY = (PINB & 0x80);
+            allEqual &= ONKEY == debouncing[idx][activeRowIdx];
+            debouncing[idx][activeRowIdx] = debouncing[idx+1][activeRowIdx];
+        }
+        allEqual &= ONKEY == debouncing[idx][activeRowIdx];
+        debouncing[idx][activeRowIdx] = ONKEY;
+        uint8_t changedONKEY = keyStates[activeRowIdx] ^ ONKEY;
+        if(allEqual && changedONKEY)
+        {
+            if(((changedONKEY & 0x80)&~(keyStates[activeRowIdx]|0x7F))== 0x80){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][0]);
+            }
+        }
+    }
+    DDRC =  ~activeRow     & 0xff;     //DDRC
+    activeRow <<= 1;
+    activeRowIdx += 1;
+    if (activeRow & (1 << ROWS))
+    {
+        activeRow = 0x01;
+        activeRowIdx = 0;
+    }
+    DDRC =  ~activeRow     & 0xff;     //DDRC
+    DDRA = (~activeRow>>8) & 0xff;     //DDRA
+
+    return 0;
+}*/
+int main(void)
+{
+    /*DDRC  = 0b00000000;
+    PORTC = 0b01000000;
+    DDRD  &= 0b00001100;
+    PORTD &= 0b00001100;
+    DDRA  = 0b00000000;
+    PORTA = 0b00000000;
+    DDRB  = 0b01111111;
+    PORTB = 0b01111111;*/
+
+    DDRC = 0b00110000;
+    PORTC = 0b00000000;
+
+    TCCR0A |= 0b00000011; //clk/64 ==> timeout 1.35ms
+//-------------------------------------
+    uchar report_size,i, button_release_counter = 0;
+    //cli();
+
+    for(report_size=0; report_size<sizeof(keyboard_report); report_size++) // clear report initially
+        ((uchar *)&keyboard_report)[report_size] = 0;
+
+    wdt_enable(WDTO_1S); // enable 1s watchdog timer
+
+    usbInit();
+
+    usbDeviceDisconnect(); // enforce re-enumeration
+    for(i = 0; i<250; i++) // wait 500 ms
+    {
+        wdt_reset(); // keep the watchdog happy
+        _delay_ms(2);
+    }
+    usbDeviceConnect();
+
+    sei(); // Enable interrupts after re-enumeration
+    int keybuild = 0;
+    while(1)
+    {
+     //   keybuild = scanMatrix();
+        wdt_reset(); // keep the watchdog happy
+        usbPoll();
+
+        if(!(PINC & (1<<A1IN))) { // button pressed (PB1 at ground voltage)
+			// also check if some time has elapsed since last button press
+			if(state == STATE_WAIT && button_release_counter == 255)
+				state = STATE_SEND_KEY;
+				button_release_counter = 0; // now button needs to be released a while until retrigger
+		}
+
+		if(button_release_counter < 255)
+			button_release_counter++; // increase release counter*/
+
+        if(usbInterruptIsReady() && state != STATE_WAIT)
+        {
+
+			switch(state)
+			{
+			case STATE_SEND_KEY:
+				buildReport('1');
+				state = STATE_RELEASE_KEY; // release next
+				break;
+			case STATE_RELEASE_KEY:
+				buildReport(NULL);
+				state = STATE_WAIT; // go back to waiting
+				break;
+			default:
+				state = STATE_WAIT; // should not happen
+			}
+        }
+        // start sending
+        usbSetInterrupt((void *)&keyboard_report, sizeof(keyboard_report));
+    }
+
+    return 0;
+}
Index: ONKEY.txt
===================================================================
--- ONKEY.txt	(nonexistent)
+++ ONKEY.txt	(working copy)
@@ -0,0 +1,131 @@
+/*else
+    {
+        int allEqualOn = 1;
+        //DDRB |= 0b00000010;
+        uint8_t OnVal = PINB & 0x80; /// mask ONKEY
+        for (idx = 0 ; idx < DEBOUNCE_CYCLES - 1; ++idx)
+        {
+            allEqualOn &= (OnVal == debouncingOn[idx][0]);
+            debouncingOn[idx][0] = debouncingOn[idx+1][0];
+
+        }
+        allEqualOn &= (OnVal == debouncingOn[idx][0]);
+        debouncingOn[idx][0] = OnVal;
+
+
+        uint8_t changedKeyOn = keyStateOn[0] ^ OnVal;
+        if(count1 == 0)
+        {
+            changedKeyOn = 0;
+            count1++;
+        }
+        //allEqual = 1;
+        //changedKeys = 1;
+        keyStateOn[0] = OnVal; //falsche Position
+        if(allEqualOn && changedKeyOn)
+        {
+            PORTC = PWRLED;
+            if((~OnVal&0x01) && (changedOn&0x01))
+            {
+                state = STATE_SEND_KEY;
+                PORTC = PWRLED;
+
+                keybuild = (ScanCode[9][0]);//A5
+            }
+        }
+    }*/
+	
+	
+	
+	
+	#define VBAT 3
+#define ROWS 10
+#define DEBOUNCE_CYCLES 9
+uint16_t activeRow = 0x01;
+uint8_t activeRowIdx = 0;
+uint8_t keyStates[ROWS];
+uint8_t keyStateOn[1];
+uint8_t debouncing[DEBOUNCE_CYCLES][ROWS];
+uint8_t debouncingOn[DEBOUNCE_CYCLES][1];
+uint8_t changedOn = 0;
+
+int isrFlag = 0;
+int count = 0;
+int count1 = 0;
+
+    /*else if(!(PINB&0x80))
+            {
+
+            state = STATE_SEND_KEY;
+            PORTC = PWRLED;
+
+            keybuild = (ScanCode[9][0]);//A0
+            }*/
+			
+			
+			    /*else if(!(PINB&0x80))
+            {
+
+            state = STATE_SEND_KEY;
+            PORTC = PWRLED;
+
+            keybuild = (ScanCode[9][0]);//A0
+            }*/
+    /*else
+    {
+        uint8_t debouncingOn[DEBOUNCE_CYCLES][1];
+        uint8_t changedOn = 0
+        int allEqualOn = 1;
+        uint8_t keyStateOn[1];
+        //DDRB |= 0b00000010;
+        uint8_t OnVal = PINB & 0x80; /// mask ONKEY
+        for (idx = 0 ; idx < DEBOUNCE_CYCLES - 1; ++idx)
+        {
+            allEqualOn &= (OnVal == debouncingOn[idx][0]);
+            debouncingOn[idx][0] = debouncingOn[idx+1][0];
+
+        }
+        allEqualOn &= (OnVal == debouncingOn[idx][0]);
+        debouncingOn[idx][0] = OnVal;
+
+
+        uint8_t changedKeyOn = keyStateOn[0] ^ OnVal;
+        if(count1 == 0)
+        {
+            changedKeyOn = 0;
+            count1++;
+        }
+        //allEqual = 1;
+        //changedKeys = 1;
+        keyStateOn[0] = OnVal; //falsche Position
+        if(allEqualOn && changedKeyOn)
+        {
+            PORTC = PWRLED;
+            if((~OnVal&0x01) && (changedOn&0x01))
+            {
+                state = STATE_SEND_KEY;
+                PORTC = PWRLED;
+
+                keybuild = (ScanCode[9][0]);//A5
+            }
+        }
+    }*/
+	
+	
+	  else
+    {
+     if((PINB&0x80)==0)
+            {
+
+            state = STATE_SEND_KEY;
+            PORTC = PWRLED;
+
+            keybuild = (ScanCode[9][0]);//A0
+            }
+    }
+	
+	
+	DDRB  |= 0b00000010;
+    PORTB &= 0b00000000;
+	
+	
\ No newline at end of file
Index: RUN_new_MainHp48GX.txt
===================================================================
--- RUN_new_MainHp48GX.txt	(nonexistent)
+++ RUN_new_MainHp48GX.txt	(working copy)
@@ -0,0 +1,318 @@
+/*---------------------------------------------------------------------------
+------------------------------HP48GX-----------------------------------------
+---------------------------------------------------------------------------*/
+
+//-------------------------------defines-----------------------------------
+#include <avr/io.h>
+#include <util/delay.h>
+#include <math.h>
+#include "usbconfig.h"
+#include "usbdrv/usbdrv.h"
+#include <avr/wdt.h>
+#include <avr/interrupt.h>
+#include <stddef.h>
+
+#define PWRLED (PORTC | 0b00100000)
+#define A12OUT (PORTC & 0b00101111)
+#define A10OUT (PORTD & 0b11111101)
+#define A1IN   (PINC2)
+
+#define STATE_WAIT 0
+#define STATE_SEND_KEY 1
+#define STATE_RELEASE_KEY 2
+
+//-------------------------------globale Variablen----------------------------
+
+uchar state = STATE_WAIT;
+
+PROGMEM char usbHidReportDescriptor[USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH] = {
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
+    0x09, 0x06,                    // USAGE (Keyboard)
+    0xa1, 0x01,
+    0x75, 0x01,                    //   REPORT_SIZE (1)
+    0x95, 0x08,                    //   REPORT_COUNT (8)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
+    0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)(224)
+    0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)(231)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
+    0x81, 0x02,                    //   INPUT (Data,Var,Abs) ; Modifier byte
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x81, 0x03,                    //   INPUT (Cnst,Var,Abs) ; Reserved byte
+    0x95, 0x05,                    //   REPORT_COUNT (5)
+    0x75, 0x01,                    //   REPORT_SIZE (1)
+    0x05, 0x08,                    //   USAGE_PAGE (LEDs)
+    0x19, 0x01,                    //   USAGE_MINIMUM (Num Lock)
+    0x29, 0x05,                    //   USAGE_MAXIMUM (Kana)
+    0x91, 0x02,                    //   OUTPUT (Data,Var,Abs) ; LED report
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x75, 0x03,                    //   REPORT_SIZE (3)
+    0x91, 0x03,                    //   OUTPUT (Cnst,Var,Abs) ; LED report padding
+    0x95, 0x06,                    //   REPORT_COUNT (6)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
+    0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))(0)
+    0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)(101)
+    0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
+    0xc0                           // END_COLLECTION
+};
+
+
+uchar ScanCode [10][6] = {{0,5,6,7,8,9},
+             /*[y][x]*/  {0,11,12,13,14,15},
+                         {0,17,18,19,20,21},
+                         {0,23,24,25,26,27},
+                         {0,88,28,29,76,42},
+                         {43,22,36,37,38,84},
+                         {225,16,33,34,35,85},
+                         {224,10,30,31,32,86},
+                         {0,4,62,37,44,87},
+                         {41,0,0,0,0,0}};
+
+
+/*  enter 88
+    delete 76
+    backspace 42
+    operationen 84 - 87 /*-+
+    tab 43
+    control 224
+    shift 225
+    esc 41
+	space 44
+	f13 104*/
+
+typedef struct {
+	uint8_t modifier;
+	uint8_t reserved;
+	uint8_t keycode[6];
+} keyboard_report_t;
+
+static keyboard_report_t keyboard_report; // sent to PC
+static uchar idleRate; // repeat rate for keyboards
+
+usbMsgLen_t usbFunctionSetup(unsigned char data[8]) {
+    usbRequest_t *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS) {
+        switch(rq->bRequest) {
+        case USBRQ_HID_GET_REPORT: // send "no keys pressed" if asked here
+            // wValue: ReportType (highbyte), ReportID (lowbyte)
+            usbMsgPtr = (void *)&keyboard_report; // we only have this one
+            keyboard_report.modifier = 0;
+            keyboard_report.keycode[0] = 0;
+            return sizeof(keyboard_report);
+		case USBRQ_HID_SET_REPORT: // if wLength == 1, should be LED state
+            return (rq->wLength.word == 1) ? USB_NO_MSG : 0;
+        case USBRQ_HID_GET_IDLE: // send idle rate to PC as required by spec
+            usbMsgPtr = &idleRate;
+            return 1;
+        case USBRQ_HID_SET_IDLE: // save idle rate as required by spec
+            idleRate = rq->wValue.bytes[1];
+            return 0;
+        }
+    }
+
+    return 0; // by default don't return any data
+}
+
+
+
+usbMsgLen_t usbFunctionWrite(uint8_t * data, uchar len) {
+	//if (data[0] == LED_state)
+        return 1;
+    //else
+    //    LED_state = data[0];PORTD = PORTD & 0b11110111;
+	//TIMSK0 |= (1<<TOIE0); //enables Overflow Interrupt
+    //// LED state changed
+	//if(LED_state & CAPS_LOCK)
+	//	PORTB |= 1 << PB0; // LED on
+	//else
+	//	PORTB &= ~(1 << PB0); // LED off
+	//
+	//return 1; // Data read, not expecting more
+}
+void buildReport(uchar send_key) {
+	keyboard_report.modifier = 0;
+    if(send_key != 0)
+		keyboard_report.keycode[0] = send_key;
+    else
+		keyboard_report.keycode[0] = 0;
+}
+
+#define ROWS 10
+#define DEBOUNCE_CYCLES 9
+uint16_t activeRow = 0x01;
+uint8_t activeRowIdx = 0;
+uint8_t keyStates[ROWS];
+uint8_t debouncing[DEBOUNCE_CYCLES][ROWS];
+
+int isrFlag = 0;
+
+ISR(TIMER0_OVF_vect)
+{
+    isrFlag = 1;
+}
+/*int scanMatrix(void)
+{
+    if(!isrFlag)
+        return 0;
+    isrFlag = 0;
+
+    int idx = 0;
+    int allEqual = 1;
+
+    uint8_t newVal = PIND & 0xF3; /// mask data lines
+    for (idx = 0 ; idx < DEBOUNCE_CYCLES - 1; ++idx)
+    {
+        allEqual &= newVal == debouncing[idx][activeRowIdx];
+        debouncing[idx][activeRowIdx] = debouncing[idx+1][activeRowIdx];
+    }
+    allEqual &= newVal == debouncing[idx][activeRowIdx];
+    debouncing[idx][activeRowIdx] = newVal;
+
+    uint8_t changedKeys = keyStates[activeRowIdx] ^ newVal;
+    if(allEqual && changedKeys)
+    {
+        if(((changedKeys & 0x01)&~(keyStates[activeRowIdx]|0xFE))== 0x01 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][0]);
+            }
+        else if(((changedKeys & 0x02)&~(keyStates[activeRowIdx]|0xFD))== 0x02 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][1]);
+            }
+        else if(((changedKeys & 0x04)&~(keyStates[activeRowIdx]|0xFB))== 0x04 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][2]);
+            }
+        else if(((changedKeys & 0x08)&~(keyStates[activeRowIdx]|0xF7))== 0x08 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][3]);
+            }
+        else if(((changedKeys & 0x10)&~(keyStates[activeRowIdx]|0xEF))== 0x10 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][4]);
+            }
+        else if(((changedKeys & 0x20)&~(keyStates[activeRowIdx]|0xDF))== 0x20 ){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][5]);
+            }
+        keyStates[activeRowIdx] = newVal;
+    }
+
+    else
+    {
+        int ONKEY = 0;
+        for(idx = 0; idx < DEBOUNCE_CYCLES-1; ++idx)
+        {
+            ONKEY = (PINB & 0x80);
+            allEqual &= ONKEY == debouncing[idx][activeRowIdx];
+            debouncing[idx][activeRowIdx] = debouncing[idx+1][activeRowIdx];
+        }
+        allEqual &= ONKEY == debouncing[idx][activeRowIdx];
+        debouncing[idx][activeRowIdx] = ONKEY;
+        uint8_t changedONKEY = keyStates[activeRowIdx] ^ ONKEY;
+        if(allEqual && changedONKEY)
+        {
+            if(((changedONKEY & 0x80)&~(keyStates[activeRowIdx]|0x7F))== 0x80){
+            state = STATE_SEND_KEY;
+            return (ScanCode[activeRowIdx-1][0]);
+            }
+        }
+    }
+    DDRC =  ~activeRow     & 0xff;     //DDRC
+    activeRow <<= 1;
+    activeRowIdx += 1;
+    if (activeRow & (1 << ROWS))
+    {
+        activeRow = 0x01;
+        activeRowIdx = 0;
+    }
+    DDRC =  ~activeRow     & 0xff;     //DDRC
+    DDRA = (~activeRow>>8) & 0xff;     //DDRA
+
+    return 0;
+}*/
+int main(void)
+{
+    /*//DDRD = DDRD & 0b11111111;   //Ausgang
+    DDRC = 0b00110000;
+    PORTC = 0b00000000;*/
+    DDRC  = 0b00000000;
+    PORTC = 0b01000000;
+    DDRD  = 0b00000000;
+    PORTD = 0b00000000;
+    DDRA  = 0b00000000;
+    PORTA = 0b00000000;
+    DDRB  = 0b01111111;
+    PORTB = 0b01111111;
+
+
+    TCCR0A |= 0b00000011; //clk/64 ==> timeout 1.35ms
+//-------------------------------------
+    //PORTC = A12OUT;
+
+    uchar i, button_release_counter = 0;
+
+    for(i=0; i<sizeof(keyboard_report); i++) // clear report initially
+        ((uchar *)&keyboard_report)[i] = 0;
+
+    wdt_enable(WDTO_1S); // enable 1s watchdog timer
+
+    usbInit();
+
+    usbDeviceDisconnect(); // enforce re-enumeration
+    for(i = 0; i<250; i++) { // wait 500 ms
+        wdt_reset(); // keep the watchdog happy
+        _delay_ms(2);
+    }
+    usbDeviceConnect();
+
+    //TCCR1A |= (0b00001100); // timer 0 at clk/8 will generate randomness
+    //TCCR1B |= (0b01100010);
+
+    sei(); // Enable interrupts after re-enumeration
+    //int keybuild = 0;
+    while(1)
+        {
+        //keybuild = scanMatrix();
+        wdt_reset(); // keep the watchdog happy
+        usbPoll();
+
+		if(!(PINC & (1<<A1IN)))  // button pressed (PB1 at ground voltage)
+        {
+			// also check if some time has elapsed since last button press
+			if(state == STATE_WAIT && button_release_counter == 255)
+				state = STATE_SEND_KEY;
+				button_release_counter = 0; // now button needs to be released a while until retrigger
+		}
+
+		if(button_release_counter < 255)
+			button_release_counter++; // increase release counter*/
+
+        if(usbInterruptIsReady() && state != STATE_WAIT)
+        {
+
+			switch(state) {
+			case STATE_SEND_KEY:
+				buildReport('1');
+				state = STATE_RELEASE_KEY; // release nextdebouncing
+				break;
+			case STATE_RELEASE_KEY:
+				buildReport(0);
+				state = STATE_WAIT; // go back to waiting
+				break;
+			default:
+				state = STATE_WAIT; // should not happen
+			}
+        }
+        // start sending
+        usbSetInterrupt((void *)&keyboard_report, sizeof(keyboard_report));
+
+    }
+
+    return 0;
+}
Index: source/fuse.c
===================================================================
--- source/fuse.c	(nonexistent)
+++ source/fuse.c	(working copy)
@@ -0,0 +1,7 @@
+#include <avr/io.h>
+
+FUSES = {
+    .low = 0xEC,            //Clock Source = Ext. crystal 8-..MHz, Start-up Time = 64ms, SUT11
+    .high = 0xDF,           //Enable Serial Programming = ON
+    .extended = 0xFF        //Self Programming Enable = OFF
+};
Index: source/main.c
===================================================================
--- source/main.c	(nonexistent)
+++ source/main.c	(working copy)
@@ -0,0 +1,34 @@
+/*
+ */
+
+#include <avr/io.h>
+#include <util/delay.h>
+#include <math.h>
+#include <avr/iotn88.h>
+//#include <usbconfig.h>
+
+#define PWRLED (PORTD | 0b00001000)
+#define A1     (PINC0)
+
+int main(void)
+{
+
+    DDRD = DDRD | 0b00001111;   //Ausgang
+    DDRC = 0x00;
+    PORTC = 0x00;               //Eingang
+
+    while(1)
+    {
+
+      PORTD = 0b00000110;
+      if( !(PINC & ( 1<<PINC2 )))
+      {
+          PORTD = PWRLED;
+          _delay_ms(1000);
+          PORTD = PORTD & 0b11110111;
+      }
+
+    }
+
+    return 0;
+}
Index: source/fuse.c
===================================================================
--- source/fuse.c	(nonexistent)
+++ source/fuse.c	(working copy)
@@ -0,0 +1,7 @@
+#include <avr/io.h>
+
+FUSES = {
+    .low = 0xEC,            //Clock Source = Ext. crystal 8-..MHz, Start-up Time = 64ms, SUT11
+    .high = 0xDF,           //Enable Serial Programming = ON
+    .extended = 0xFF        //Self Programming Enable = OFF
+};
Index: source/main.c
===================================================================
--- source/main.c	(nonexistent)
+++ source/main.c	(working copy)
@@ -0,0 +1,34 @@
+/*
+ */
+
+#include <avr/io.h>
+#include <util/delay.h>
+#include <math.h>
+#include <avr/iotn88.h>
+//#include <usbconfig.h>
+
+#define PWRLED (PORTD | 0b00001000)
+#define A1     (PINC0)
+
+int main(void)
+{
+
+    DDRD = DDRD | 0b00001111;   //Ausgang
+    DDRC = 0x00;
+    PORTC = 0x00;               //Eingang
+
+    while(1)
+    {
+
+      PORTD = 0b00000110;
+      if( !(PINC & ( 1<<PINC2 )))
+      {
+          PORTD = PWRLED;
+          _delay_ms(1000);
+          PORTD = PORTD & 0b11110111;
+      }
+
+    }
+
+    return 0;
+}
Index: usbconfig.h
===================================================================
--- usbconfig.h	(nonexistent)
+++ usbconfig.h	(working copy)
@@ -0,0 +1,379 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ * This Revision: $Id$
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      3
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           50
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      1
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/*#define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();}
+#ifndef __ASSEMBLER__
+extern void hadUsbReset(void); // define the function for usbdrv.c
+#endif*/
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+
+
+#define  USB_CFG_VENDOR_ID       0x42, 0x42
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0x31, 0xe1
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'c', 'o', 'd', 'e', 'a', 'n', 'd', 'l', \
+								'i', 'f', 'e', '.', 'c', 'o', 'm'
+#define USB_CFG_VENDOR_NAME_LEN 15
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'H', 'P', '4', '8', 'G', 'X'
+#define USB_CFG_DEVICE_NAME_LEN 6
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0x03 // HID
+#define USB_CFG_INTERFACE_SUBCLASS  0x01 // Boot
+#define USB_CFG_INTERFACE_PROTOCOL  0x01 // Keyboard
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    63
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: usbconfig.h.bak
===================================================================
--- usbconfig.h.bak	(nonexistent)
+++ usbconfig.h.bak	(working copy)
@@ -0,0 +1,379 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ * This Revision: $Id$
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      3
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          3*/
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           50
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      1
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/*#define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();}
+#ifndef __ASSEMBLER__
+extern void hadUsbReset(void); // define the function for usbdrv.c
+#endif*/
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+
+
+#define  USB_CFG_VENDOR_ID       0x42, 0x42
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0x31, 0xe1
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'c', 'o', 'd', 'e', 'a', 'n', 'd', 'l', \
+								'i', 'f', 'e', '.', 'c', 'o', 'm'
+#define USB_CFG_VENDOR_NAME_LEN 15
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'H', 'P', '4', '8', 'G', 'X'
+#define USB_CFG_DEVICE_NAME_LEN 6
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0x03 // HID
+#define USB_CFG_INTERFACE_SUBCLASS  0x01 // Boot
+#define USB_CFG_INTERFACE_PROTOCOL  0x01 // Keyboard
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    63
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: usbdrv/Changelog.txt
===================================================================
--- usbdrv/Changelog.txt	(nonexistent)
+++ usbdrv/Changelog.txt	(working copy)
@@ -0,0 +1,329 @@
+This file documents changes in the firmware-only USB driver for atmel's AVR
+microcontrollers. New entries are always appended to the end of the file.
+Scroll down to the bottom to see the most recent changes.
+
+2005-04-01:
+  - Implemented endpoint 1 as interrupt-in endpoint.
+  - Moved all configuration options to usbconfig.h which is not part of the
+    driver.
+  - Changed interface for usbVendorSetup().
+  - Fixed compatibility with ATMega8 device.
+  - Various minor optimizations.
+
+2005-04-11:
+  - Changed interface to application: Use usbFunctionSetup(), usbFunctionRead()
+    and usbFunctionWrite() now. Added configuration options to choose which
+    of these functions to compile in.
+  - Assembler module delivers receive data non-inverted now.
+  - Made register and bit names compatible with more AVR devices.
+
+2005-05-03:
+  - Allow address of usbRxBuf on any memory page as long as the buffer does
+    not cross 256 byte page boundaries.
+  - Better device compatibility: works with Mega88 now.
+  - Code optimization in debugging module.
+  - Documentation updates.
+
+2006-01-02:
+  - Added (free) default Vendor- and Product-IDs bought from voti.nl.
+  - Added USBID-License.txt file which defines the rules for using the free
+    shared VID/PID pair.
+  - Added Readme.txt to the usbdrv directory which clarifies administrative
+    issues.
+
+2006-01-25:
+  - Added "configured state" to become more standards compliant.
+  - Added "HALT" state for interrupt endpoint.
+  - Driver passes the "USB Command Verifier" test from usb.org now.
+  - Made "serial number" a configuration option.
+  - Minor optimizations, we now recommend compiler option "-Os" for best
+    results.
+  - Added a version number to usbdrv.h
+
+2006-02-03:
+  - New configuration variable USB_BUFFER_SECTION for the memory section where
+    the USB rx buffer will go. This defaults to ".bss" if not defined. Since
+    this buffer MUST NOT cross 256 byte pages (not even touch a page at the
+    end), the user may want to pass a linker option similar to
+    "-Wl,--section-start=.mybuffer=0x800060".
+  - Provide structure for usbRequest_t.
+  - New defines for USB constants.
+  - Prepared for HID implementations.
+  - Increased data size limit for interrupt transfers to 8 bytes.
+  - New macro usbInterruptIsReady() to query interrupt buffer state.
+
+2006-02-18:
+  - Ensure that the data token which is sent as an ack to an OUT transfer is
+    always zero sized. This fixes a bug where the host reports an error after
+    sending an out transfer to the device, although all data arrived at the
+    device.
+  - Updated docs in usbdrv.h to reflect changed API in usbFunctionWrite().
+
+* Release 2006-02-20
+
+  - Give a compiler warning when compiling with debugging turned on.
+  - Added Oleg Semyonov's changes for IAR-cc compatibility.
+  - Added new (optional) functions usbDeviceConnect() and usbDeviceDisconnect()
+    (also thanks to Oleg!).
+  - Rearranged tests in usbPoll() to save a couple of instructions in the most
+    likely case that no actions are pending.
+  - We need a delay between the SET ADDRESS request until the new address
+    becomes active. This delay was handled in usbPoll() until now. Since the
+    spec says that the delay must not exceed 2ms, previous versions required
+    aggressive polling during the enumeration phase. We have now moved the
+    handling of the delay into the interrupt routine.
+  - We must not reply with NAK to a SETUP transaction. We can only achieve this
+    by making sure that the rx buffer is empty when SETUP tokens are expected.
+    We therefore don't pass zero sized data packets from the status phase of
+    a transfer to usbPoll(). This change MAY cause troubles if you rely on
+    receiving a less than 8 bytes long packet in usbFunctionWrite() to
+    identify the end of a transfer. usbFunctionWrite() will NEVER be called
+    with a zero length.
+
+* Release 2006-03-14
+
+  - Improved IAR C support: tiny memory model, more devices
+  - Added template usbconfig.h file under the name usbconfig-prototype.h
+
+* Release 2006-03-26
+
+  - Added provision for one more interrupt-in endpoint (endpoint 3).
+  - Added provision for one interrupt-out endpoint (endpoint 1).
+  - Added flowcontrol macros for USB.
+  - Added provision for custom configuration descriptor.
+  - Allow ANY two port bits for D+ and D-.
+  - Merged (optional) receive endpoint number into global usbRxToken variable.
+  - Use USB_CFG_IOPORTNAME instead of USB_CFG_IOPORT. We now construct the
+    variable name from the single port letter instead of computing the address
+    of related ports from the output-port address.
+
+* Release 2006-06-26
+
+  - Updated documentation in usbdrv.h and usbconfig-prototype.h to reflect the
+    new features.
+  - Removed "#warning" directives because IAR does not understand them. Use
+    unused static variables instead to generate a warning.
+  - Do not include <avr/io.h> when compiling with IAR.
+  - Introduced USB_CFG_DESCR_PROPS_* in usbconfig.h to configure how each
+    USB descriptor should be handled. It is now possible to provide descriptor
+    data in Flash, RAM or dynamically at runtime.
+  - STALL is now a status in usbTxLen* instead of a message. We can now conform
+    to the spec and leave the stall status pending until it is cleared.
+  - Made usbTxPacketCnt1 and usbTxPacketCnt3 public. This allows the
+    application code to reset data toggling on interrupt pipes.
+
+* Release 2006-07-18
+
+  - Added an #if !defined __ASSEMBLER__ to the warning in usbdrv.h. This fixes
+    an assembler error.
+  - usbDeviceDisconnect() takes pull-up resistor to high impedance now.
+
+* Release 2007-02-01
+
+  - Merged in some code size improvements from usbtiny (thanks to Dick
+    Streefland for these optimizations!)
+  - Special alignment requirement for usbRxBuf not required any more. Thanks
+    again to Dick Streefland for this hint!
+  - Reverted to "#warning" instead of unused static variables -- new versions
+    of IAR CC should handle this directive.
+  - Changed Open Source license to GNU GPL v2 in order to make linking against
+    other free libraries easier. We no longer require publication of the
+    circuit diagrams, but we STRONGLY encourage it. If you improve the driver
+    itself, PLEASE grant us a royalty free license to your changes for our
+    commercial license.
+
+* Release 2007-03-29
+
+  - New configuration option "USB_PUBLIC" in usbconfig.h.
+  - Set USB version number to 1.10 instead of 1.01.
+  - Code used USB_CFG_DESCR_PROPS_STRING_DEVICE and
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT inconsistently. Changed all occurrences
+    to USB_CFG_DESCR_PROPS_STRING_PRODUCT.
+  - New assembler module for 16.5 MHz RC oscillator clock with PLL in receiver
+    code.
+  - New assembler module for 16 MHz crystal.
+  - usbdrvasm.S contains common code only, clock-specific parts have been moved
+    to usbdrvasm12.S, usbdrvasm16.S and usbdrvasm165.S respectively.
+
+* Release 2007-06-25
+
+  - 16 MHz module: Do SE0 check in stuffed bits as well.
+
+* Release 2007-07-07
+
+  - Define hi8(x) for IAR compiler to limit result to 8 bits. This is necessary
+    for negative values.
+  - Added 15 MHz module contributed by V. Bosch.
+  - Interrupt vector name can now be configured. This is useful if somebody
+    wants to use a different hardware interrupt than INT0.
+
+* Release 2007-08-07
+
+  - Moved handleIn3 routine in usbdrvasm16.S so that relative jump range is
+    not exceeded.
+  - More config options: USB_RX_USER_HOOK(), USB_INITIAL_DATATOKEN,
+    USB_COUNT_SOF
+  - USB_INTR_PENDING can now be a memory address, not just I/O
+
+* Release 2007-09-19
+
+  - Split out common parts of assembler modules into separate include file
+  - Made endpoint numbers configurable so that given interface definitions
+    can be matched. See USB_CFG_EP3_NUMBER in usbconfig-prototype.h.
+  - Store endpoint number for interrupt/bulk-out so that usbFunctionWriteOut()
+    can handle any number of endpoints.
+  - Define usbDeviceConnect() and usbDeviceDisconnect() even if no
+    USB_CFG_PULLUP_IOPORTNAME is defined. Directly set D+ and D- to 0 in this
+    case.
+
+* Release 2007-12-01
+
+  - Optimize usbDeviceConnect() and usbDeviceDisconnect() for less code size
+    when USB_CFG_PULLUP_IOPORTNAME is not defined.
+
+* Release 2007-12-13
+
+  - Renamed all include-only assembler modules from *.S to *.inc so that
+    people don't add them to their project sources.
+  - Distribute leap bits in tx loop more evenly for 16 MHz module.
+  - Use "macro" and "endm" instead of ".macro" and ".endm" for IAR
+  - Avoid compiler warnings for constant expr range by casting some values in
+    USB descriptors.
+
+* Release 2008-01-21
+
+  - Fixed bug in 15 and 16 MHz module where the new address set with
+    SET_ADDRESS was already accepted at the next NAK or ACK we send, not at
+    the next data packet we send. This caused problems when the host polled
+    too fast. Thanks to Alexander Neumann for his help and patience debugging
+    this issue!
+
+* Release 2008-02-05
+
+  - Fixed bug in 16.5 MHz module where a register was used in the interrupt
+    handler before it was pushed. This bug was introduced with version
+    2007-09-19 when common parts were moved to a separate file.
+  - Optimized CRC routine (thanks to Reimar Doeffinger).
+
+* Release 2008-02-16
+
+  - Removed outdated IAR compatibility stuff (code sections).
+  - Added hook macros for USB_RESET_HOOK() and USB_SET_ADDRESS_HOOK().
+  - Added optional routine usbMeasureFrameLength() for calibration of the
+    internal RC oscillator.
+
+* Release 2008-02-28
+
+  - USB_INITIAL_DATATOKEN defaults to USBPID_DATA1 now, which means that we
+    start with sending USBPID_DATA0.
+  - Changed defaults in usbconfig-prototype.h
+  - Added free USB VID/PID pair for MIDI class devices
+  - Restructured AVR-USB as separate package, not part of PowerSwitch any more.
+
+* Release 2008-04-18
+
+  - Restructured usbdrv.c so that it is easier to read and understand.
+  - Better code optimization with gcc 4.
+  - If a second interrupt in endpoint is enabled, also add it to config
+    descriptor.
+  - Added config option for long transfers (above 254 bytes), see
+    USB_CFG_LONG_TRANSFERS in usbconfig.h.
+  - Added 20 MHz module contributed by Jeroen Benschop.
+
+* Release 2008-05-13
+
+  - Fixed bug in libs-host/hiddata.c function usbhidGetReport(): length
+    was not incremented, pointer to length was incremented instead.
+  - Added code to command line tool(s) which claims an interface. This code
+    is disabled by default, but may be necessary on newer Linux kernels.
+  - Added usbconfig.h option "USB_CFG_CHECK_DATA_TOGGLING".
+  - New header "usbportability.h" prepares ports to other development
+    environments.
+  - Long transfers (above 254 bytes) did not work when usbFunctionRead() was
+    used to supply the data. Fixed this bug. [Thanks to Alexander Neumann!]
+  - In hiddata.c (example code for sending/receiving data over HID), use
+    USB_RECIP_DEVICE instead of USB_RECIP_INTERFACE for control transfers so
+    that we need not claim the interface.
+  - in usbPoll() loop 20 times polling for RESET state instead of 10 times.
+    This accounts for the higher clock rates we now support.
+  - Added a module for 12.8 MHz RC oscillator with PLL in receiver loop.
+  - Added hook to SOF code so that oscillator can be tuned to USB frame clock.
+  - Added timeout to waitForJ loop. Helps preventing unexpected hangs.
+  - Added example code for oscillator tuning to libs-device (thanks to
+    Henrik Haftmann for the idea to this routine).
+  - Implemented option USB_CFG_SUPPRESS_INTR_CODE.
+
+* Release 2008-10-22
+
+  - Fixed libs-device/osctune.h: OSCCAL is memory address on ATMega88 and
+    similar, not offset of 0x20 needs to be added.
+  - Allow distribution under GPLv3 for those who have to link against other
+    code distributed under GPLv3.
+
+* Release 2008-11-26
+
+  - Removed libusb-win32 dependency for hid-data example in Makefile.windows.
+    It was never required and confused many people.
+  - Added extern uchar usbRxToken to usbdrv.h.
+  - Integrated a module with CRC checks at 18 MHz by Lukas Schrittwieser.
+
+* Release 2009-03-23
+
+  - Hid-mouse example used settings from hid-data example, fixed that.
+  - Renamed project to V-USB due to a trademark issue with Atmel(r).
+  - Changed CommercialLicense.txt and USBID-License.txt to make the
+    background of USB ID registration clearer.
+
+* Release 2009-04-15
+
+  - Changed CommercialLicense.txt to reflect the new range of PIDs from
+    Jason Kotzin.
+  - Removed USBID-License.txt in favor of USB-IDs-for-free.txt and
+    USB-ID-FAQ.txt
+  - Fixed a bug in the 12.8 MHz module: End Of Packet decection was made in
+    the center between bit 0 and 1 of each byte. This is where the data lines
+    are expected to change and the sampled data may therefore be nonsense.
+    We therefore check EOP ONLY if bits 0 AND 1 have both been read as 0 on D-.
+  - Fixed a bitstuffing problem in the 16 MHz module: If bit 6 was stuffed,
+    the unstuffing code in the receiver routine was 1 cycle too long. If
+    multiple bytes had the unstuffing in bit 6, the error summed up until the
+    receiver was out of sync.
+  - Included option for faster CRC routine.
+    Thanks to Slawomir Fras (BoskiDialer) for this code!
+  - Updated bits in Configuration Descriptor's bmAttributes according to
+    USB 1.1 (in particular bit 7, it is a must-be-set bit now).
+
+* Release 2009-08-22
+
+  - Moved first DBG1() after odDebugInit() in all examples.
+  - Use vector INT0_vect instead of SIG_INTERRUPT0 if defined. This makes
+    V-USB compatible with the new "p" suffix devices (e.g. ATMega328p).
+  - USB_CFG_CLOCK_KHZ setting is now required in usbconfig.h (no default any
+    more).
+  - New option USB_CFG_DRIVER_FLASH_PAGE allows boot loaders on devices with
+    more than 64 kB flash.
+  - Built-in configuration descriptor allows custom definition for second
+    endpoint now.
+
+* Release 2010-07-15
+
+  - Fixed bug in usbDriverSetup() which prevented descriptor sizes above 255
+    bytes.
+  - Avoid a compiler warning for unused parameter in usbHandleResetHook() when
+    compiler option -Wextra is enabled.
+  - Fixed wrong hex value for some IDs in USB-IDs-for-free.txt.
+  - Keep a define for USBATTR_BUSPOWER, although the flag does not exist
+    in USB 1.1 any more. Set it to 0. This is for backward compatibility.
+
+* Release 2012-01-09
+
+  - Define a separate (defined) type for usbMsgPtr so that projects using a
+    tiny memory model can define it to an 8 bit type in usbconfig.h. This
+    change also saves a couple of bytes when using a scalar 16 bit type.
+  - Inserted "const" keyword for all PROGMEM declarations because new GCC
+    requires it.
+  - Fixed problem with dependence of usbportability.h on usbconfig.h. This
+    problem occurred with IAR CC only.
+  - Prepared repository for github.com.
+
+* Release 2012-12-06
\ No newline at end of file
Index: usbdrv/CommercialLicense.txt
===================================================================
--- usbdrv/CommercialLicense.txt	(nonexistent)
+++ usbdrv/CommercialLicense.txt	(working copy)
@@ -0,0 +1,166 @@
+V-USB Driver Software License Agreement
+Version 2012-07-09
+
+THIS LICENSE AGREEMENT GRANTS YOU CERTAIN RIGHTS IN A SOFTWARE. YOU CAN
+ENTER INTO THIS AGREEMENT AND ACQUIRE THE RIGHTS OUTLINED BELOW BY PAYING
+THE AMOUNT ACCORDING TO SECTION 4 ("PAYMENT") TO OBJECTIVE DEVELOPMENT.
+
+
+1 DEFINITIONS
+
+1.1 "OBJECTIVE DEVELOPMENT" shall mean OBJECTIVE DEVELOPMENT Software GmbH,
+Grosse Schiffgasse 1A/7, 1020 Wien, AUSTRIA.
+
+1.2 "You" shall mean the Licensee.
+
+1.3 "V-USB" shall mean all files included in the package distributed under
+the name "vusb" by OBJECTIVE DEVELOPMENT (http://www.obdev.at/vusb/)
+unless otherwise noted. This includes the firmware-only USB device
+implementation for Atmel AVR microcontrollers, some simple device examples
+and host side software examples and libraries.
+
+
+2 LICENSE GRANTS
+
+2.1 Source Code. OBJECTIVE DEVELOPMENT shall furnish you with the source
+code of V-USB.
+
+2.2 Distribution and Use. OBJECTIVE DEVELOPMENT grants you the
+non-exclusive right to use, copy and distribute V-USB with your hardware
+product(s), restricted by the limitations in section 3 below.
+
+2.3 Modifications. OBJECTIVE DEVELOPMENT grants you the right to modify
+the source code and your copy of V-USB according to your needs.
+
+2.4 USB IDs. OBJECTIVE DEVELOPMENT furnishes you with one or two USB
+Product ID(s), sent to you in e-mail. These Product IDs are reserved
+exclusively for you. OBJECTIVE DEVELOPMENT has obtained USB Product ID
+ranges under the Vendor ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under the Vendor ID 8352 from
+Jason Kotzin (now flirc.tv, Inc.). Both owners of the Vendor IDs have
+obtained these IDs from the USB Implementers Forum, Inc. (www.usb.org).
+OBJECTIVE DEVELOPMENT disclaims all liability which might arise from the
+assignment of USB IDs.
+
+2.5 USB Certification. Although not part of this agreement, we want to make
+it clear that you cannot become USB certified when you use V-USB or a USB
+Product ID assigned by OBJECTIVE DEVELOPMENT. AVR microcontrollers don't
+meet the electrical specifications required by the USB specification and
+the USB Implementers Forum certifies only members who bought a Vendor ID of
+their own.
+
+
+3 LICENSE RESTRICTIONS
+
+3.1 Number of Units. Only one of the following three definitions is
+applicable. Which one is determined by the amount you pay to OBJECTIVE
+DEVELOPMENT, see section 4 ("Payment") below.
+
+Hobby License: You may use V-USB according to section 2 above in no more
+than 5 hardware units. These units must not be sold for profit.
+
+Entry Level License: You may use V-USB according to section 2 above in no
+more than 150 hardware units.
+
+Professional License: You may use V-USB according to section 2 above in
+any number of hardware units, except for large scale production ("unlimited
+fair use"). Quantities below 10,000 units are not considered large scale
+production. If your reach quantities which are obviously large scale
+production, you must pay a license fee of 0.10 EUR per unit for all units
+above 10,000.
+
+3.2 Rental. You may not rent, lease, or lend V-USB or otherwise encumber
+any copy of V-USB, or any of the rights granted herein.
+
+3.3 Transfer. You may not transfer your rights under this Agreement to
+another party without OBJECTIVE DEVELOPMENT's prior written consent. If
+such consent is obtained, you may permanently transfer this License to
+another party. The recipient of such transfer must agree to all terms and
+conditions of this Agreement.
+
+3.4 Reservation of Rights. OBJECTIVE DEVELOPMENT retains all rights not
+expressly granted.
+
+3.5 Non-Exclusive Rights. Your license rights under this Agreement are
+non-exclusive.
+
+3.6 Third Party Rights. This Agreement cannot grant you rights controlled
+by third parties. In particular, you are not allowed to use the USB logo or
+other trademarks owned by the USB Implementers Forum, Inc. without their
+consent. Since such consent depends on USB certification, it should be
+noted that V-USB will not pass certification because it does not
+implement checksum verification and the microcontroller ports do not meet
+the electrical specifications.
+
+
+4 PAYMENT
+
+The payment amount depends on the variation of this agreement (according to
+section 3.1) into which you want to enter. Concrete prices are listed on
+OBJECTIVE DEVELOPMENT's web site, usually at
+http://www.obdev.at/vusb/license.html. You agree to pay the amount listed
+there to OBJECTIVE DEVELOPMENT or OBJECTIVE DEVELOPMENT's payment processor
+or reseller.
+
+
+5 COPYRIGHT AND OWNERSHIP
+
+V-USB is protected by copyright laws and international copyright
+treaties, as well as other intellectual property laws and treaties. V-USB
+is licensed, not sold.
+
+
+6 TERM AND TERMINATION
+
+6.1 Term. This Agreement shall continue indefinitely. However, OBJECTIVE
+DEVELOPMENT may terminate this Agreement and revoke the granted license and
+USB-IDs if you fail to comply with any of its terms and conditions.
+
+6.2 Survival of Terms. All provisions regarding secrecy, confidentiality
+and limitation of liability shall survive termination of this agreement.
+
+
+7 DISCLAIMER OF WARRANTY AND LIABILITY
+
+LIMITED WARRANTY. V-USB IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
+KIND. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, OBJECTIVE
+DEVELOPMENT AND ITS SUPPLIERS HEREBY DISCLAIM ALL WARRANTIES, EITHER
+EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND
+NON-INFRINGEMENT, WITH REGARD TO V-USB, AND THE PROVISION OF OR FAILURE
+TO PROVIDE SUPPORT SERVICES. THIS LIMITED WARRANTY GIVES YOU SPECIFIC LEGAL
+RIGHTS. YOU MAY HAVE OTHERS, WHICH VARY FROM STATE/JURISDICTION TO
+STATE/JURISDICTION.
+
+LIMITATION OF LIABILITY. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW,
+IN NO EVENT SHALL OBJECTIVE DEVELOPMENT OR ITS SUPPLIERS BE LIABLE FOR ANY
+SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER
+(INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
+BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY
+LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE V-USB OR THE
+PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES, EVEN IF OBJECTIVE
+DEVELOPMENT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY
+CASE, OBJECTIVE DEVELOPMENT'S ENTIRE LIABILITY UNDER ANY PROVISION OF THIS
+AGREEMENT SHALL BE LIMITED TO THE AMOUNT ACTUALLY PAID BY YOU FOR V-USB.
+
+
+8 MISCELLANEOUS TERMS
+
+8.1 Marketing. OBJECTIVE DEVELOPMENT has the right to mention for marketing
+purposes that you entered into this agreement.
+
+8.2 Entire Agreement. This document represents the entire agreement between
+OBJECTIVE DEVELOPMENT and you. It may only be modified in writing signed by
+an authorized representative of both, OBJECTIVE DEVELOPMENT and you.
+
+8.3 Severability. In case a provision of these terms and conditions should
+be or become partly or entirely invalid, ineffective, or not executable,
+the validity of all other provisions shall not be affected.
+
+8.4 Applicable Law. This agreement is governed by the laws of the Republic
+of Austria.
+
+8.5 Responsible Courts. The responsible courts in Vienna/Austria will have
+exclusive jurisdiction regarding all disputes in connection with this
+agreement.
+
Index: usbdrv/License.txt
===================================================================
--- usbdrv/License.txt	(nonexistent)
+++ usbdrv/License.txt	(working copy)
@@ -0,0 +1,361 @@
+OBJECTIVE DEVELOPMENT GmbH's V-USB driver software is distributed under the
+terms and conditions of the GNU GPL version 2 or the GNU GPL version 3. It is
+your choice whether you apply the terms of version 2 or version 3. The full
+text of GPLv2 is included below. In addition to the requirements in the GPL,
+we STRONGLY ENCOURAGE you to do the following:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: usbdrv/Readme.txt
===================================================================
--- usbdrv/Readme.txt	(nonexistent)
+++ usbdrv/Readme.txt	(working copy)
@@ -0,0 +1,172 @@
+This is the Readme file to Objective Development's firmware-only USB driver
+for Atmel AVR microcontrollers. For more information please visit
+http://www.obdev.at/vusb/
+
+This directory contains the USB firmware only. Copy it as-is to your own
+project and add all .c and .S files to your project (these files are marked
+with an asterisk in the list below). Then copy usbconfig-prototype.h as
+usbconfig.h to your project and edit it according to your configuration.
+
+
+TECHNICAL DOCUMENTATION
+=======================
+The technical documentation (API) for the firmware driver is contained in the
+file "usbdrv.h". Please read all of it carefully! Configuration options are
+documented in "usbconfig-prototype.h".
+
+The driver consists of the following files:
+  Readme.txt ............. The file you are currently reading.
+  Changelog.txt .......... Release notes for all versions of the driver.
+  usbdrv.h ............... Driver interface definitions and technical docs.
+* usbdrv.c ............... High level language part of the driver. Link this
+                           module to your code!
+* usbdrvasm.S ............ Assembler part of the driver. This module is mostly
+                           a stub and includes one of the usbdrvasm*.S files
+                           depending on processor clock. Link this module to
+                           your code!
+  usbdrvasm*.inc ......... Assembler routines for particular clock frequencies.
+                           Included by usbdrvasm.S, don't link it directly!
+  asmcommon.inc .......... Common assembler routines. Included by
+                           usbdrvasm*.inc, don't link it directly!
+  usbconfig-prototype.h .. Prototype for your own usbdrv.h file.
+* oddebug.c .............. Debug functions. Only used when DEBUG_LEVEL is
+                           defined to a value greater than 0. Link this module
+                           to your code!
+  oddebug.h .............. Interface definitions of the debug module.
+  usbportability.h ....... Header with compiler-dependent stuff.
+  usbdrvasm.asm .......... Compatibility stub for IAR-C-compiler. Use this
+                           module instead of usbdrvasm.S when you assembler
+                           with IAR's tools.
+  License.txt ............ Open Source license for this driver.
+  CommercialLicense.txt .. Optional commercial license for this driver.
+  USB-ID-FAQ.txt ......... General infos about USB Product- and Vendor-IDs.
+  USB-IDs-for-free.txt ... List and terms of use for free shared PIDs.
+
+(*) ... These files should be linked to your project.
+
+
+CPU CORE CLOCK FREQUENCY
+========================
+We supply assembler modules for clock frequencies of 12 MHz, 12.8 MHz, 15 MHz,
+16 MHz, 16.5 MHz 18 MHz and 20 MHz. Other clock rates are not supported. The
+actual clock rate must be configured in usbconfig.h.
+
+12 MHz Clock
+This is the traditional clock rate of V-USB because it's the lowest clock
+rate where the timing constraints of the USB spec can be met.
+
+15 MHz Clock
+Similar to 12 MHz, but some NOPs inserted. On the other hand, the higher clock
+rate allows for some loops which make the resulting code size somewhat smaller
+than the 12 MHz version.
+
+16 MHz Clock
+This clock rate has been added for users of the Arduino board and other
+ready-made boards which come with a fixed 16 MHz crystal. It's also an option
+if you need the slightly higher clock rate for performance reasons. Since
+16 MHz is not divisible by the USB low speed bit clock of 1.5 MHz, the code
+is somewhat tricky and has to insert a leap cycle every third byte.
+
+12.8 MHz and 16.5 MHz Clock
+The assembler modules for these clock rates differ from the other modules
+because they have been built for an RC oscillator with only 1% precision. The
+receiver code inserts leap cycles to compensate for clock deviations. 1% is
+also the precision which can be achieved by calibrating the internal RC
+oscillator of the AVR. Please note that only AVRs with internal 64 MHz PLL
+oscillator can reach 16.5 MHz with the RC oscillator. This includes the very
+popular ATTiny25, ATTiny45, ATTiny85 series as well as the ATTiny26. Almost
+all AVRs can reach 12.8 MHz, although this is outside the specified range.
+
+See the EasyLogger example at http://www.obdev.at/vusb/easylogger.html for
+code which calibrates the RC oscillator based on the USB frame clock.
+
+18 MHz Clock
+This module is closer to the USB specification because it performs an on the
+fly CRC check for incoming packets. Packets with invalid checksum are
+discarded as required by the spec. If you also implement checks for data
+PID toggling on application level (see option USB_CFG_CHECK_DATA_TOGGLING
+in usbconfig.h for more info), this ensures data integrity. Due to the CRC
+tables and alignment requirements, this code is bigger than modules for other
+clock rates. To activate this module, you must define USB_CFG_CHECK_CRC to 1
+and USB_CFG_CLOCK_KHZ to 18000 in usbconfig.h.
+
+20 MHz Clock
+This module is for people who won't do it with less than the maximum. Since
+20 MHz is not divisible by the USB low speed bit clock of 1.5 MHz, the code
+uses similar tricks as the 16 MHz module to insert leap cycles.
+
+
+USB IDENTIFIERS
+===============
+Every USB device needs a vendor- and a product-identifier (VID and PID). VIDs
+are obtained from usb.org for a price of 1,500 USD. Once you have a VID, you
+can assign PIDs at will.
+
+Since an entry level cost of 1,500 USD is too high for most small companies
+and hobbyists, we provide some VID/PID pairs for free. See the file
+USB-IDs-for-free.txt for details.
+
+Objective Development also has some license offerings which include product
+IDs. See http://www.obdev.at/vusb/ for details.
+
+
+DEVELOPMENT SYSTEM
+==================
+This driver has been developed and optimized for the GNU compiler version 3
+and 4. We recommend that you use the GNU compiler suite because it is freely
+available. V-USB has also been ported to the IAR compiler and assembler. It
+has been tested with IAR 4.10B/W32 and 4.12A/W32 on an ATmega8 with the
+"small" and "tiny" memory model. Not every release is tested with IAR CC and
+the driver may therefore fail to compile with IAR. Please note that gcc is
+more efficient for usbdrv.c because this module has been deliberately
+optimized for gcc.
+
+Gcc version 3 produces smaller code than version 4 due to new optimizing
+capabilities which don't always improve things on 8 bit CPUs. The code size
+generated by gcc 4 can be reduced with the compiler options
+-fno-move-loop-invariants, -fno-tree-scev-cprop and
+-fno-inline-small-functions in addition to -Os. On devices with more than
+8k of flash memory, we also recommend the linker option --relax (written as
+-Wl,--relax for gcc) to convert absolute calls into relative where possible.
+
+For more information about optimizing options see:
+
+    http://www.tty1.net/blog/2008-04-29-avr-gcc-optimisations_en.html
+
+These optimizations are good for gcc 4.x. Version 3.x of gcc does not support
+most of these options and produces good code anyway.
+
+
+USING V-USB FOR FREE
+====================
+The AVR firmware driver is published under the GNU General Public License
+Version 2 (GPL2) and the GNU General Public License Version 3 (GPL3). It is
+your choice whether you apply the terms of version 2 or version 3.
+
+If you decide for the free GPL2 or GPL3, we STRONGLY ENCOURAGE you to do the
+following things IN ADDITION to the obligations from the GPL:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+If you don't have a web site, you can publish the project in obdev's
+documentation wiki at
+http://www.obdev.at/goto.php?t=vusb-wiki&p=hosted-projects.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+COMMERCIAL LICENSES FOR V-USB
+=============================
+If you don't want to publish your source code under the terms of the GPL,
+you can simply pay money for V-USB. As an additional benefit you get
+USB PIDs for free, reserved exclusively to you. See the file
+"CommercialLicense.txt" for details.
+
Index: usbdrv/USB-ID-FAQ.txt
===================================================================
--- usbdrv/USB-ID-FAQ.txt	(nonexistent)
+++ usbdrv/USB-ID-FAQ.txt	(working copy)
@@ -0,0 +1,149 @@
+Version 2012-07-09
+
+==========================
+WHY DO WE NEED THESE IDs?
+==========================
+
+USB is more than a low level protocol for data transport. It also defines a
+common set of requests which must be understood by all devices. And as part
+of these common requests, the specification defines data structures, the
+USB Descriptors, which are used to describe the properties of the device.
+
+From the perspective of an operating system, it is therefore possible to find
+out basic properties of a device (such as e.g. the manufacturer and the name
+of the device) without a device-specific driver. This is essential because
+the operating system can choose a driver to load based on this information
+(Plug-And-Play).
+
+Among the most important properties in the Device Descriptor are the USB
+Vendor- and Product-ID. Both are 16 bit integers. The most simple form of
+driver matching is based on these IDs. The driver announces the Vendor- and
+Product-IDs of the devices it can handle and the operating system loads the
+appropriate driver when the device is connected.
+
+It is obvious that this technique only works if the pair Vendor- plus
+Product-ID is unique: Only devices which require the same driver can have the
+same pair of IDs.
+
+
+=====================================================
+HOW DOES THE USB STANDARD ENSURE THAT IDs ARE UNIQUE?
+=====================================================
+
+Since it is so important that USB IDs are unique, the USB Implementers Forum,
+Inc. (usb.org) needs a way to enforce this legally. It is not forbidden by
+law to build a device and assign it any random numbers as IDs. Usb.org
+therefore needs an agreement to regulate the use of USB IDs. The agreement
+binds only parties who agreed to it, of course. Everybody else is free to use
+any numbers for their IDs.
+
+So how can usb.org ensure that every manufacturer of USB devices enters into
+an agreement with them? They do it via trademark licensing. Usb.org has
+registered the trademark "USB", all associated logos and related terms. If
+you want to put an USB logo on your product or claim that it is USB
+compliant, you must license these trademarks from usb.org. And this is where
+you enter into an agreement. See the "USB-IF Trademark License Agreement and
+Usage Guidelines for the USB-IF Logo" at
+http://www.usb.org/developers/logo_license/.
+
+Licensing the USB trademarks requires that you buy a USB Vendor-ID from
+usb.org (one-time fee of ca. 2,000 USD), that you become a member of usb.org
+(yearly fee of ca. 4,000 USD) and that you meet all the technical
+specifications from the USB spec.
+
+This means that most hobbyists and small companies will never be able to
+become USB compliant, just because membership is so expensive. And you can't
+be compliant with a driver based on V-USB anyway, because the AVR's port pins
+don't meet the electrical specifications for USB. So, in principle, all
+hobbyists and small companies are free to choose any random numbers for their
+IDs. They have nothing to lose...
+
+There is one exception worth noting, though: If you use a sub-component which
+implements USB, the vendor of the sub-components may guarantee USB
+compliance. This might apply to some or all of FTDI's solutions.
+
+
+=======================================================================
+WHY SHOULD YOU OBTAIN USB IDs EVEN IF YOU DON'T LICENSE USB TRADEMARKS?
+=======================================================================
+
+You have learned in the previous section that you are free to choose any
+numbers for your IDs anyway. So why not do exactly this? There is still the
+technical issue. If you choose IDs which are already in use by somebody else,
+operating systems will load the wrong drivers and your device won't work.
+Even if you choose IDs which are not currently in use, they may be in use in
+the next version of the operating system or even after an automatic update.
+
+So what you need is a pair of Vendor- and Product-IDs for which you have the
+guarantee that no USB compliant product uses them. This implies that no
+operating system will ever ship with drivers responsible for these IDs.
+
+
+==============================================
+HOW DOES OBJECTIVE DEVELOPMENT HANDLE USB IDs?
+==============================================
+
+Objective Development gives away pairs of USB-IDs with their V-USB licenses.
+In order to ensure that these IDs are unique, Objective Development has an
+agreement with the company/person who has bought the USB Vendor-ID from
+usb.org. This agreement ensures that a range of USB Product-IDs is reserved
+for assignment by Objective Development and that the owner of the Vendor-ID
+won't give it to anybody else.
+
+This means that you have to trust three parties to ensure uniqueness of
+your IDs:
+
+  - Objective Development, that they don't give the same PID to more than
+    one person.
+  - The owner of the Vendor-ID that they don't assign PIDs from the range
+    assigned to Objective Development to anybody else.
+  - Usb.org that they don't assign the same Vendor-ID a second time.
+
+
+==================================
+WHO IS THE OWNER OF THE VENDOR-ID?
+==================================
+
+Objective Development has obtained ranges of USB Product-IDs under two
+Vendor-IDs: Under Vendor-ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under Vendor-ID 8352 from Jason
+Kotzin (now flirc.tv, Inc.). Both VID owners have received their Vendor-ID
+directly from usb.org.
+
+
+=========================================================================
+CAN I USE USB-IDs FROM OBJECTIVE DEVELOPMENT WITH OTHER DRIVERS/HARDWARE?
+=========================================================================
+
+The short answer is: Yes. All you get is a guarantee that the IDs are never
+assigned to anybody else. What more do you need?
+
+
+============================
+WHAT ABOUT SHARED ID PAIRS?
+============================
+
+Objective Development has reserved some PID/VID pairs for shared use. You
+have no guarantee of uniqueness for them, except that no USB compliant device
+uses them. In order to avoid technical problems, we must ensure that all
+devices with the same pair of IDs use the same driver on kernel level. For
+details, see the file USB-IDs-for-free.txt.
+
+
+======================================================
+I HAVE HEARD THAT SUB-LICENSING OF USB-IDs IS ILLEGAL?
+======================================================
+
+A 16 bit integer number cannot be protected by copyright laws. It is not
+sufficiently complex. And since none of the parties involved entered into the
+USB-IF Trademark License Agreement, we are not bound by this agreement. So
+there is no reason why it should be illegal to sub-license USB-IDs.
+
+
+=============================================
+WHO IS LIABLE IF THERE ARE INCOMPATIBILITIES?
+=============================================
+
+Objective Development disclaims all liabilities which might arise from the
+assignment of IDs. If you guarantee product features to your customers
+without proper disclaimer, YOU are liable for that.
Index: usbdrv/USB-IDs-for-free.txt
===================================================================
--- usbdrv/USB-IDs-for-free.txt	(nonexistent)
+++ usbdrv/USB-IDs-for-free.txt	(working copy)
@@ -0,0 +1,154 @@
+Version 2009-08-22
+
+===========================
+FREE USB-IDs FOR SHARED USE
+===========================
+
+Objective Development has reserved a set of USB Product-IDs for use according
+to the guidelines outlined below. For more information about the concept of
+USB IDs please see the file USB-ID-FAQ.txt. Objective Development guarantees
+that the IDs listed below are not used by any USB compliant devices.
+
+
+====================
+MECHANISM OF SHARING
+====================
+
+From a technical point of view, two different devices can share the same USB
+Vendor- and Product-ID if they require the same driver on operating system
+level. We make use of this fact by assigning separate IDs for various device
+classes. On application layer, devices must be distinguished by their textual
+name or serial number. We offer separate sets of IDs for discrimination by
+textual name and for serial number.
+
+Examples for shared use of USB IDs are included with V-USB in the "examples"
+subdirectory.
+
+
+======================================
+IDs FOR DISCRIMINATION BY TEXTUAL NAME
+======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the manufacturer
+and product identification. The manufacturer identification MUST be available
+at least in USB language 0x0409 (English/US).
+
+(2) The textual manufacturer identification MUST contain either an Internet
+domain name (e.g. "mycompany.com") registered and owned by you, or an e-mail
+address under your control (e.g. "myname@gmx.net"). You can embed the domain
+name or e-mail address in any string you like, e.g.  "Objective Development
+http://www.obdev.at/vusb/".
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(4) You may choose any string for the textual product identification, as long
+as this string is unique within the scope of your textual manufacturer
+identification.
+
+(5) Application side device look-up MUST be based on the textual manufacturer
+and product identification in addition to VID/PID matching. The driver
+matching MUST be a comparison of the entire strings, NOT a sub-string match.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+Table if IDs for discrimination by textual name:
+
+PID dec (hex) | VID dec (hex) | Description of use
+==============+===============+============================================
+1500 (0x05dc) | 5824 (0x16c0) | For Vendor Class devices with libusb
+--------------+---------------+--------------------------------------------
+1503 (0x05df) | 5824 (0x16c0) | For generic HID class devices (which are
+              |               | NOT mice, keyboards or joysticks)
+--------------+---------------+--------------------------------------------
+1505 (0x05e1) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+--------------+---------------+--------------------------------------------
+1508 (0x05e4) | 5824 (0x16c0) | For MIDI class devices
+--------------+---------------+--------------------------------------------
+
+Note that Windows caches the textual product- and vendor-description for
+mice, keyboards and joysticks. Name-bsed discrimination is therefore not
+recommended for these device classes.
+
+
+=======================================
+IDs FOR DISCRIMINATION BY SERIAL NUMBER
+=======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the serial
+number, unless ONLY the operating system's default class driver is used.
+The serial number string MUST be available at least in USB language 0x0409
+(English/US).
+
+(2) The serial number MUST start with either an Internet domain name (e.g.
+"mycompany.com") registered and owned by you, or an e-mail address under your
+control (e.g. "myname@gmx.net"), both terminated with a colon (":") character.
+You MAY append any string you like for further discrimination of your devices.
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(5) Application side device look-up MUST be based on the serial number string
+in addition to VID/PID matching. The matching must start at the first
+character of the serial number string and include the colon character
+terminating your domain or e-mail address. It MAY stop anywhere after that.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+(7) If ONLY the operating system's default class driver is used, e.g. for
+mice, keyboards, joysticks, CDC or MIDI devices and no discrimination by an
+application is needed, the serial number may be omitted.
+
+
+Table if IDs for discrimination by serial number string:
+
+PID dec (hex)  | VID dec (hex) | Description of use
+===============+===============+===========================================
+10200 (0x27d8) | 5824 (0x16c0) | For Vendor Class devices with libusb
+---------------+---------------+-------------------------------------------
+10201 (0x27d9) | 5824 (0x16c0) | For generic HID class devices (which are
+               |               | NOT mice, keyboards or joysticks)
+---------------+---------------+-------------------------------------------
+10202 (0x27da) | 5824 (0x16c0) | For USB Mice
+---------------+---------------+-------------------------------------------
+10203 (0x27db) | 5824 (0x16c0) | For USB Keyboards
+---------------+---------------+-------------------------------------------
+10204 (0x27dc) | 5824 (0x16c0) | For USB Joysticks
+---------------+---------------+-------------------------------------------
+10205 (0x27dd) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+---------------+---------------+-------------------------------------------
+10206 (0x27de) | 5824 (0x16c0) | For MIDI class devices
+---------------+---------------+-------------------------------------------
+
+
+=================
+ORIGIN OF USB-IDs
+=================
+
+OBJECTIVE DEVELOPMENT Software GmbH has obtained all VID/PID pairs listed
+here from Wouter van Ooijen (see www.voti.nl) for exclusive disposition.
+Wouter van Ooijen has obtained the VID from the USB Implementers Forum, Inc.
+(see www.usb.org). The VID is registered for the company name "Van Ooijen
+Technische Informatica".
+
+
+==========
+DISCLAIMER
+==========
+
+OBJECTIVE DEVELOPMENT Software GmbH disclaims all liability for any
+problems which are caused by the shared use of these VID/PID pairs.
Index: usbdrv/asmcommon.inc
===================================================================
--- usbdrv/asmcommon.inc	(nonexistent)
+++ usbdrv/asmcommon.inc	(working copy)
@@ -0,0 +1,187 @@
+/* Name: asmcommon.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-11-05
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file contains assembler code which is shared among the USB driver
+implementations for different CPU cocks. Since the code must be inserted
+in the middle of the module, it's split out into this file and #included.
+
+Jump destinations called from outside:
+    sofError: Called when no start sequence was found.
+    se0: Called when a package has been successfully received.
+    overflow: Called when receive buffer overflows.
+    doReturn: Called after sending data.
+
+Outside jump destinations used by this module:
+    waitForJ: Called to receive an already arriving packet.
+    sendAckAndReti:
+    sendNakAndReti:
+    sendCntAndReti:
+    usbSendAndReti:
+
+The following macros must be defined before this file is included:
+    .macro POP_STANDARD
+    .endm
+    .macro POP_RETI
+    .endm
+*/
+
+#define token   x1
+
+overflow:
+    ldi     x2, 1<<USB_INTR_PENDING_BIT
+    USB_STORE_PENDING(x2)       ; clear any pending interrupts
+ignorePacket:
+    clr     token
+    rjmp    storeTokenAndReturn
+
+;----------------------------------------------------------------------------
+; Processing of received packet (numbers in brackets are cycles after center of SE0)
+;----------------------------------------------------------------------------
+;This is the only non-error exit point for the software receiver loop
+;we don't check any CRCs here because there is no time left.
+se0:
+    subi    cnt, USB_BUFSIZE    ;[5]
+    neg     cnt                 ;[6]
+    sub     YL, cnt             ;[7]
+    sbci    YH, 0               ;[8]
+    ldi     x2, 1<<USB_INTR_PENDING_BIT ;[9]
+    USB_STORE_PENDING(x2)       ;[10] clear pending intr and check flag later. SE0 should be over.
+    ld      token, y            ;[11]
+    cpi     token, USBPID_DATA0 ;[13]
+    breq    handleData          ;[14]
+    cpi     token, USBPID_DATA1 ;[15]
+    breq    handleData          ;[16]
+    lds     shift, usbDeviceAddr;[17]
+    ldd     x2, y+1             ;[19] ADDR and 1 bit endpoint number
+    lsl     x2                  ;[21] shift out 1 bit endpoint number
+    cpse    x2, shift           ;[22]
+    rjmp    ignorePacket        ;[23]
+/* only compute endpoint number in x3 if required later */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT || USB_CFG_IMPLEMENT_FN_WRITEOUT
+    ldd     x3, y+2             ;[24] endpoint number + crc
+    rol     x3                  ;[26] shift in LSB of endpoint
+#endif
+    cpi     token, USBPID_IN    ;[27]
+    breq    handleIn            ;[28]
+    cpi     token, USBPID_SETUP ;[29]
+    breq    handleSetupOrOut    ;[30]
+    cpi     token, USBPID_OUT   ;[31]
+    brne    ignorePacket        ;[32] must be ack, nak or whatever
+;   rjmp    handleSetupOrOut    ; fallthrough
+
+;Setup and Out are followed by a data packet two bit times (16 cycles) after
+;the end of SE0. The sync code allows up to 40 cycles delay from the start of
+;the sync pattern until the first bit is sampled. That's a total of 56 cycles.
+handleSetupOrOut:               ;[32]
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT   /* if we have data for endpoint != 0, set usbCurrentTok to address */
+    andi    x3, 0xf             ;[32]
+    breq    storeTokenAndReturn ;[33]
+    mov     token, x3           ;[34] indicate that this is endpoint x OUT
+#endif
+storeTokenAndReturn:
+    sts     usbCurrentTok, token;[35]
+doReturn:
+    POP_STANDARD                ;[37] 12...16 cycles
+    USB_LOAD_PENDING(YL)        ;[49]
+    sbrc    YL, USB_INTR_PENDING_BIT;[50] check whether data is already arriving
+    rjmp    waitForJ            ;[51] save the pops and pushes -- a new interrupt is already pending
+sofError:
+    POP_RETI                    ;macro call
+    reti
+
+handleData:
+#if USB_CFG_CHECK_CRC
+    CRC_CLEANUP_AND_CHECK       ; jumps to ignorePacket if CRC error
+#endif
+    lds     shift, usbCurrentTok;[18]
+    tst     shift               ;[20]
+    breq    doReturn            ;[21]
+    lds     x2, usbRxLen        ;[22]
+    tst     x2                  ;[24]
+    brne    sendNakAndReti      ;[25]
+; 2006-03-11: The following two lines fix a problem where the device was not
+; recognized if usbPoll() was called less frequently than once every 4 ms.
+    cpi     cnt, 4              ;[26] zero sized data packets are status phase only -- ignore and ack
+    brmi    sendAckAndReti      ;[27] keep rx buffer clean -- we must not NAK next SETUP
+#if USB_CFG_CHECK_DATA_TOGGLING
+    sts     usbCurrentDataToken, token  ; store for checking by C code
+#endif
+    sts     usbRxLen, cnt       ;[28] store received data, swap buffers
+    sts     usbRxToken, shift   ;[30]
+    lds     x2, usbInputBufOffset;[32] swap buffers
+    ldi     cnt, USB_BUFSIZE    ;[34]
+    sub     cnt, x2             ;[35]
+    sts     usbInputBufOffset, cnt;[36] buffers now swapped
+    rjmp    sendAckAndReti      ;[38] 40 + 17 = 57 until SOP
+
+handleIn:
+;We don't send any data as long as the C code has not processed the current
+;input data and potentially updated the output data. That's more efficient
+;in terms of code size than clearing the tx buffers when a packet is received.
+    lds     x1, usbRxLen        ;[30]
+    cpi     x1, 1               ;[32] negative values are flow control, 0 means "buffer free"
+    brge    sendNakAndReti      ;[33] unprocessed input packet?
+    ldi     x1, USBPID_NAK      ;[34] prepare value for usbTxLen
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+    andi    x3, 0xf             ;[35] x3 contains endpoint
+#if USB_CFG_SUPPRESS_INTR_CODE
+    brne    sendNakAndReti      ;[36]
+#else
+    brne    handleIn1           ;[36]
+#endif
+#endif
+    lds     cnt, usbTxLen       ;[37]
+    sbrc    cnt, 4              ;[39] all handshake tokens have bit 4 set
+    rjmp    sendCntAndReti      ;[40] 42 + 16 = 58 until SOP
+    sts     usbTxLen, x1        ;[41] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf)   ;[43]
+    ldi     YH, hi8(usbTxBuf)   ;[44]
+    rjmp    usbSendAndReti      ;[45] 57 + 12 = 59 until SOP
+
+; Comment about when to set usbTxLen to USBPID_NAK:
+; We should set it back when we receive the ACK from the host. This would
+; be simple to implement: One static variable which stores whether the last
+; tx was for endpoint 0 or 1 and a compare in the receiver to distinguish the
+; ACK. However, we set it back immediately when we send the package,
+; assuming that no error occurs and the host sends an ACK. We save one byte
+; RAM this way and avoid potential problems with endless retries. The rest of
+; the driver assumes error-free transfers anyway.
+
+#if !USB_CFG_SUPPRESS_INTR_CODE && USB_CFG_HAVE_INTRIN_ENDPOINT /* placed here due to relative jump range */
+handleIn1:                      ;[38]
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+; 2006-06-10 as suggested by O.Tamura: support second INTR IN / BULK IN endpoint
+    cpi     x3, USB_CFG_EP3_NUMBER;[38]
+    breq    handleIn3           ;[39]
+#endif
+    lds     cnt, usbTxLen1      ;[40]
+    sbrc    cnt, 4              ;[42] all handshake tokens have bit 4 set
+    rjmp    sendCntAndReti      ;[43] 47 + 16 = 63 until SOP
+    sts     usbTxLen1, x1       ;[44] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf1)  ;[46]
+    ldi     YH, hi8(usbTxBuf1)  ;[47]
+    rjmp    usbSendAndReti      ;[48] 50 + 12 = 62 until SOP
+
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+handleIn3:
+    lds     cnt, usbTxLen3      ;[41]
+    sbrc    cnt, 4              ;[43]
+    rjmp    sendCntAndReti      ;[44] 49 + 16 = 65 until SOP
+    sts     usbTxLen3, x1       ;[45] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf3)  ;[47]
+    ldi     YH, hi8(usbTxBuf3)  ;[48]
+    rjmp    usbSendAndReti      ;[49] 51 + 12 = 63 until SOP
+#endif
+#endif
Index: usbdrv/oddebug.c
===================================================================
--- usbdrv/oddebug.c	(nonexistent)
+++ usbdrv/oddebug.c	(working copy)
@@ -0,0 +1,49 @@
+/* Name: oddebug.c
+ * Project: AVR library
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-01-16
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include "oddebug.h"
+
+#if DEBUG_LEVEL > 0
+
+#warning "Never compile production devices with debugging enabled"
+
+static void uartPutc(char c)
+{
+    while(!(ODDBG_USR & (1 << ODDBG_UDRE)));    /* wait for data register empty */
+    ODDBG_UDR = c;
+}
+
+static uchar    hexAscii(uchar h)
+{
+    h &= 0xf;
+    if(h >= 10)
+        h += 'a' - (uchar)10 - '0';
+    h += '0';
+    return h;
+}
+
+static void printHex(uchar c)
+{
+    uartPutc(hexAscii(c >> 4));
+    uartPutc(hexAscii(c));
+}
+
+void    odDebug(uchar prefix, uchar *data, uchar len)
+{
+    printHex(prefix);
+    uartPutc(':');
+    while(len--){
+        uartPutc(' ');
+        printHex(*data++);
+    }
+    uartPutc('\r');
+    uartPutc('\n');
+}
+
+#endif
Index: usbdrv/oddebug.h
===================================================================
--- usbdrv/oddebug.h	(nonexistent)
+++ usbdrv/oddebug.h	(working copy)
@@ -0,0 +1,122 @@
+/* Name: oddebug.h
+ * Project: AVR library
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-01-16
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __oddebug_h_included__
+#define __oddebug_h_included__
+
+/*
+General Description:
+This module implements a function for debug logs on the serial line of the
+AVR microcontroller. Debugging can be configured with the define
+'DEBUG_LEVEL'. If this macro is not defined or defined to 0, all debugging
+calls are no-ops. If it is 1, DBG1 logs will appear, but not DBG2. If it is
+2, DBG1 and DBG2 logs will be printed.
+
+A debug log consists of a label ('prefix') to indicate which debug log created
+the output and a memory block to dump in hex ('data' and 'len').
+*/
+
+
+#ifndef F_CPU
+#   define  F_CPU   12000000    /* 12 MHz */
+#endif
+
+/* make sure we have the UART defines: */
+#include "usbportability.h"
+
+#ifndef uchar
+#   define  uchar   unsigned char
+#endif
+
+#if DEBUG_LEVEL > 0 && !(defined TXEN || defined TXEN0) /* no UART in device */
+#   warning "Debugging disabled because device has no UART"
+#   undef   DEBUG_LEVEL
+#endif
+
+#ifndef DEBUG_LEVEL
+#   define  DEBUG_LEVEL 0
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#if DEBUG_LEVEL > 0
+#   define  DBG1(prefix, data, len) odDebug(prefix, data, len)
+#else
+#   define  DBG1(prefix, data, len)
+#endif
+
+#if DEBUG_LEVEL > 1
+#   define  DBG2(prefix, data, len) odDebug(prefix, data, len)
+#else
+#   define  DBG2(prefix, data, len)
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#if DEBUG_LEVEL > 0
+extern void odDebug(uchar prefix, uchar *data, uchar len);
+
+/* Try to find our control registers; ATMEL likes to rename these */
+
+#if defined UBRR
+#   define  ODDBG_UBRR  UBRR
+#elif defined UBRRL
+#   define  ODDBG_UBRR  UBRRL
+#elif defined UBRR0
+#   define  ODDBG_UBRR  UBRR0
+#elif defined UBRR0L
+#   define  ODDBG_UBRR  UBRR0L
+#endif
+
+#if defined UCR
+#   define  ODDBG_UCR   UCR
+#elif defined UCSRB
+#   define  ODDBG_UCR   UCSRB
+#elif defined UCSR0B
+#   define  ODDBG_UCR   UCSR0B
+#endif
+
+#if defined TXEN
+#   define  ODDBG_TXEN  TXEN
+#else
+#   define  ODDBG_TXEN  TXEN0
+#endif
+
+#if defined USR
+#   define  ODDBG_USR   USR
+#elif defined UCSRA
+#   define  ODDBG_USR   UCSRA
+#elif defined UCSR0A
+#   define  ODDBG_USR   UCSR0A
+#endif
+
+#if defined UDRE
+#   define  ODDBG_UDRE  UDRE
+#else
+#   define  ODDBG_UDRE  UDRE0
+#endif
+
+#if defined UDR
+#   define  ODDBG_UDR   UDR
+#elif defined UDR0
+#   define  ODDBG_UDR   UDR0
+#endif
+
+static inline void  odDebugInit(void)
+{
+    ODDBG_UCR |= (1<<ODDBG_TXEN);
+    ODDBG_UBRR = F_CPU / (19200 * 16L) - 1;
+}
+#else
+#   define odDebugInit()
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#endif /* __oddebug_h_included__ */
Index: usbdrv/usbconfig-prototype.h
===================================================================
--- usbdrv/usbconfig-prototype.h	(nonexistent)
+++ usbdrv/usbconfig-prototype.h	(working copy)
@@ -0,0 +1,384 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
++ To create your own usbconfig.h file, copy this file to your project's
++ firmware source directory) and rename it to "usbconfig.h".
++ Then edit it accordingly.
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    0
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           100
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdc, 0x05 /* = 0x05dc = 1500 */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'T', 'e', 'm', 'p', 'l', 'a', 't', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 8
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: usbdrv/usbconfig.h
===================================================================
--- usbdrv/usbconfig.h	(nonexistent)
+++ usbdrv/usbconfig.h	(working copy)
@@ -0,0 +1,377 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ * This Revision: $Id$
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      3
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           50
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      1
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/*#define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();}
+#ifndef __ASSEMBLER__
+extern void hadUsbReset(void); // define the function for usbdrv.c
+#endif*/
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0x42, 0x42
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0x31, 0xe1
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'c', 'o', 'd', 'e', 'a', 'n', 'd', 'l', \
+								'i', 'f', 'e', '.', 'c', 'o', 'm'
+#define USB_CFG_VENDOR_NAME_LEN 15
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'P', 'a', 's', 's', 'g', 'e', 'n'
+#define USB_CFG_DEVICE_NAME_LEN 7
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0x03 // HID
+#define USB_CFG_INTERFACE_SUBCLASS  0x01 // Boot
+#define USB_CFG_INTERFACE_PROTOCOL  0x01 // Keyboard
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    63
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: usbdrv/usbconfig3.h
===================================================================
--- usbdrv/usbconfig3.h	(nonexistent)
+++ usbdrv/usbconfig3.h	(working copy)
@@ -0,0 +1,259 @@
+/* Name: usbconfig.h
+ * Project: AVR USB driver
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-23
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)
+ * This Revision: $Id: usbconfig.h 537 2008-02-28 21:13:01Z cs $
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      B
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      1
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0!
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in MHz. Legal values are 12000, 16000 or 16500.
+ * The 16.5 MHz version of the code requires no crystal, it tolerates +/- 1%
+ * deviation from the nominal frequency. All other rates require a precision
+ * of 2000 ppm and thus a crystal!
+ * Default if not specified: 12 MHz
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint 1.
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 1 and an interrupt-in
+ * endpoint 3. You must also enable endpoint 1 above.
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           50
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoint 1.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to endpoint 1.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#ifndef __ASSEMBLER__
+extern void hadUsbReset(void);
+#endif
+#define USB_RESET_HOOK(isReset)             if(!isReset){hadUsbReset();}
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   1
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0x42, 0x42
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you use obdev's free shared
+ * VID/PID pair. Be sure to read USBID-License.txt for rules!
+ * This template uses obdev's shared VID/PID pair for HIDs: 0x16c0/0x5df.
+ * Use this VID/PID pair ONLY if you understand the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0x31, 0xe1
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you use obdev's free shared VID/PID pair. Be sure to read the rules in
+ * USBID-License.txt!
+ * This template uses obdev's shared VID/PID pair for HIDs: 0x16c0/0x5df.
+ * Use this VID/PID pair ONLY if you understand the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'c', 'o', 'd', 'e', 'a', 'n', 'd', 'l', \
+								'i', 'f', 'e', '.', 'c', 'o', 'm'
+#define USB_CFG_VENDOR_NAME_LEN 15
+
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USBID-License.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'E', 'a', 's', 'y', 'L', 'o', 'g', 'g', 'e', 'r'
+#define USB_CFG_DEVICE_NAME_LEN 10
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USBID-License.txt before you assign a name if you
+ * use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ */
+#define USB_CFG_INTERFACE_CLASS     3   /* HID */
+#define USB_CFG_INTERFACE_SUBCLASS  0   /* no boot interface */
+#define USB_CFG_INTERFACE_PROTOCOL  0   /* no protocol */
+/* See USB specification if you want to conform to an existing device class or
+ * protocol.
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    35  /* total length of report descriptor */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * Since this template defines a HID device, it must also specify a HID
+ * report descriptor length. You must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor().
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+
+#endif /* __usbconfig_h_included__ */
Index: usbdrv/usbdrv.c
===================================================================
--- usbdrv/usbdrv.c	(nonexistent)
+++ usbdrv/usbdrv.c	(working copy)
@@ -0,0 +1,628 @@
+/* Name: usbdrv.c
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ * This Revision: $Id$
+ */
+
+#include "usbportability.h"
+#include "usbdrv.h"
+#include "oddebug.h"
+
+/*
+General Description:
+This module implements the C-part of the USB driver. See usbdrv.h for a
+documentation of the entire driver.
+*/
+
+/* ------------------------------------------------------------------------- */
+
+/* raw USB registers / interface to assembler code: */
+uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
+uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
+uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
+uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
+uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but not used */
+volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow control */
+uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 0 */
+uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
+volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handshake token */
+uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains handshake token */
+#if USB_COUNT_SOF
+volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+usbTxStatus_t  usbTxStatus1;
+#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
+usbTxStatus_t  usbTxStatus3;
+#   endif
+#endif
+#if USB_CFG_CHECK_DATA_TOGGLING
+uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
+#endif
+
+/* USB status registers / not shared with asm code */
+uchar               *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
+static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
+static uchar        usbMsgFlags;    /* flag values see below */
+
+#define USB_FLG_MSGPTR_IS_ROM   (1<<6)
+#define USB_FLG_USE_USER_RW     (1<<7)
+
+/*
+optimizing hints:
+- do not post/pre inc/dec integer values in operations
+- assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
+- use narrow scope for variables which should be in X/Y/Z register
+- assign char sized expressions to variables to force 8 bit arithmetics
+*/
+
+/* -------------------------- String Descriptors --------------------------- */
+
+#if USB_CFG_DESCR_PROPS_STRINGS == 0
+
+#if USB_CFG_DESCR_PROPS_STRING_0 == 0
+#undef USB_CFG_DESCR_PROPS_STRING_0
+#define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
+PROGMEM char usbDescriptorString0[] = { /* language descriptor */
+    4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
+    3,          /* descriptor type */
+    0x09, 0x04, /* language index (0x0409 = US-English) */
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_VENDOR
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
+PROGMEM int  usbDescriptorStringVendor[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
+    USB_CFG_VENDOR_NAME
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
+PROGMEM int  usbDescriptorStringDevice[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
+    USB_CFG_DEVICE_NAME
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
+PROGMEM int usbDescriptorStringSerialNumber[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
+    USB_CFG_SERIAL_NUMBER
+};
+#endif
+
+#endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
+
+/* --------------------------- Device Descriptor --------------------------- */
+
+#if USB_CFG_DESCR_PROPS_DEVICE == 0
+#undef USB_CFG_DESCR_PROPS_DEVICE
+#define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
+PROGMEM char usbDescriptorDevice[] = {    /* USB device descriptor */
+    18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
+    USBDESCR_DEVICE,        /* descriptor type */
+    0x10, 0x01,             /* USB version supported */
+    USB_CFG_DEVICE_CLASS,
+    USB_CFG_DEVICE_SUBCLASS,
+    0,                      /* protocol */
+    8,                      /* max packet size */
+    /* the following two casts affect the first byte of the constant only, but
+     * that's sufficient to avoid a warning with the default values.
+     */
+    (char)USB_CFG_VENDOR_ID,/* 2 bytes */
+    (char)USB_CFG_DEVICE_ID,/* 2 bytes */
+    USB_CFG_DEVICE_VERSION, /* 2 bytes */
+    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
+    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
+    1,          /* number of configurations */
+};
+#endif
+
+/* ----------------------- Configuration Descriptor ------------------------ */
+
+#if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
+#undef USB_CFG_DESCR_PROPS_HID
+#define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
+#endif
+
+#if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
+#undef USB_CFG_DESCR_PROPS_CONFIGURATION
+#define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
+PROGMEM char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
+    9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
+    USBDESCR_CONFIG,    /* descriptor type */
+    18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
+                (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
+                /* total length of data returned (including inlined descriptors) */
+    1,          /* number of interfaces in this configuration */
+    1,          /* index of this configuration */
+    0,          /* configuration name string index */
+#if USB_CFG_IS_SELF_POWERED
+    (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
+#else
+    (1 << 7),                           /* attributes */
+#endif
+    USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
+/* interface descriptor follows inline: */
+    9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
+    USBDESCR_INTERFACE, /* descriptor type */
+    0,          /* index of this interface */
+    0,          /* alternate setting for this interface */
+    USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of endpoint descriptors to follow */
+    USB_CFG_INTERFACE_CLASS,
+    USB_CFG_INTERFACE_SUBCLASS,
+    USB_CFG_INTERFACE_PROTOCOL,
+    0,          /* string index for interface */
+#if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
+    9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
+    USBDESCR_HID,   /* descriptor type: HID */
+    0x01, 0x01, /* BCD representation of HID version */
+    0x00,       /* target country code */
+    0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
+    0x22,       /* descriptor type: report */
+    USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)0x81, /* IN endpoint number 1 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+};
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+static inline void  usbResetDataToggling(void)
+{
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
+#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
+    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
+#   endif
+#endif
+}
+
+static inline void  usbResetStall(void)
+{
+#if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
+        usbTxLen1 = USBPID_NAK;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+        usbTxLen3 = USBPID_NAK;
+#endif
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+#if !USB_CFG_SUPPRESS_INTR_CODE
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
+{
+uchar   *p;
+char    i;
+
+#if USB_CFG_IMPLEMENT_HALT
+    if(usbTxLen1 == USBPID_STALL)
+        return;
+#endif
+    if(txStatus->len & 0x10){   /* packet buffer was empty */
+        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
+    }else{
+        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
+    }
+    p = txStatus->buffer + 1;
+    i = len;
+    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
+        *p++ = *data++;
+    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
+    usbCrc16Append(&txStatus->buffer[1], len);
+    txStatus->len = len + 4;    /* len must be given including sync byte */
+    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
+}
+
+USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
+{
+    usbGenericSetInterrupt(data, len, &usbTxStatus1);
+}
+#endif
+
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
+{
+    usbGenericSetInterrupt(data, len, &usbTxStatus3);
+}
+#endif
+#endif /* USB_CFG_SUPPRESS_INTR_CODE */
+
+/* ------------------ utilities for code following below ------------------- */
+
+/* Use defines for the switch statement so that we can choose between an
+ * if()else if() and a switch/case based implementation. switch() is more
+ * efficient for a LARGE set of sequential choices, if() is better in all other
+ * cases.
+ */
+#if USB_CFG_USE_SWITCH_STATEMENT
+#   define SWITCH_START(cmd)       switch(cmd){{
+#   define SWITCH_CASE(value)      }break; case (value):{
+#   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
+#   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
+#   define SWITCH_DEFAULT          }break; default:{
+#   define SWITCH_END              }}
+#else
+#   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
+#   define SWITCH_CASE(value)      }else if(_cmd == (value)){
+#   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
+#   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
+#   define SWITCH_DEFAULT          }else{
+#   define SWITCH_END              }}
+#endif
+
+#ifndef USB_RX_USER_HOOK
+#define USB_RX_USER_HOOK(data, len)
+#endif
+#ifndef USB_SET_ADDRESS_HOOK
+#define USB_SET_ADDRESS_HOOK()
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+/* We use if() instead of #if in the macro below because #if can't be used
+ * in macros and the compiler optimizes constant conditions anyway.
+ * This may cause problems with undefined symbols if compiled without
+ * optimizing!
+ */
+#define GET_DESCRIPTOR(cfgProp, staticName)         \
+    if(cfgProp){                                    \
+        if((cfgProp) & USB_PROP_IS_RAM)             \
+            flags = 0;                              \
+        if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
+            len = usbFunctionDescriptor(rq);        \
+        }else{                                      \
+            len = USB_PROP_LENGTH(cfgProp);         \
+            usbMsgPtr = (uchar *)(staticName);      \
+        }                                           \
+    }
+
+/* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
+ * internally for all types of descriptors.
+ */
+static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
+{
+usbMsgLen_t len = 0;
+uchar       flags = USB_FLG_MSGPTR_IS_ROM;
+
+    SWITCH_START(rq->wValue.bytes[1])
+    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
+    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
+    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
+#if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
+        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
+            flags = 0;
+        len = usbFunctionDescriptor(rq);
+#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
+        SWITCH_START(rq->wValue.bytes[0])
+        SWITCH_CASE(0)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
+        SWITCH_CASE(1)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
+        SWITCH_CASE(2)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
+        SWITCH_CASE(3)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumber)
+        SWITCH_DEFAULT
+            if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
+                len = usbFunctionDescriptor(rq);
+            }
+        SWITCH_END
+#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
+#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
+    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
+    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
+#endif
+    SWITCH_DEFAULT
+        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
+            len = usbFunctionDescriptor(rq);
+        }
+    SWITCH_END
+    usbMsgFlags = flags;
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
+ * standard requests instead of class and custom requests.
+ */
+static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
+{
+usbMsgLen_t len = 0;
+uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
+uchar   value = rq->wValue.bytes[0];
+#if USB_CFG_IMPLEMENT_HALT
+uchar   index = rq->wIndex.bytes[0];
+#endif
+
+    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
+    SWITCH_START(rq->bRequest)
+    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
+        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */
+        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
+            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
+#if USB_CFG_IMPLEMENT_HALT
+        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
+            dataPtr[0] = usbTxLen1 == USBPID_STALL;
+#endif
+        dataPtr[1] = 0;
+        len = 2;
+#if USB_CFG_IMPLEMENT_HALT
+    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
+        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
+            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
+            usbResetDataToggling();
+        }
+#endif
+    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
+        usbNewDeviceAddr = value;
+        USB_SET_ADDRESS_HOOK();
+    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
+        len = usbDriverDescriptor(rq);
+        goto skipMsgPtrAssignment;
+    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
+        dataPtr = &usbConfiguration;  /* send current configuration value */
+        len = 1;
+    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
+        usbConfiguration = value;
+        usbResetStall();
+    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
+        len = 1;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
+        usbResetDataToggling();
+        usbResetStall();
+#endif
+    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
+        /* Should we add an optional hook here? */
+    SWITCH_END
+    usbMsgPtr = dataPtr;
+skipMsgPtrAssignment:
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbProcessRx() is called for every message received by the interrupt
+ * routine. It distinguishes between SETUP and DATA packets and processes
+ * them accordingly.
+ */
+static inline void usbProcessRx(uchar *data, uchar len)
+{
+usbRequest_t    *rq = (void *)data;
+
+/* usbRxToken can be:
+ * 0x2d 00101101 (USBPID_SETUP for setup data)
+ * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
+ * 0...0x0f for OUT on endpoint X
+ */
+    DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
+    USB_RX_USER_HOOK(data, len)
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
+        usbFunctionWriteOut(data, len);
+        return;
+    }
+#endif
+    if(usbRxToken == (uchar)USBPID_SETUP){
+        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
+            return;
+        usbMsgLen_t replyLen;
+        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
+        usbTxLen = USBPID_NAK;              /* abort pending transmit */
+        usbMsgFlags = 0;
+        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
+        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
+            replyLen = usbFunctionSetup(data);
+        }else{
+            replyLen = usbDriverSetup(rq);
+        }
+#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
+        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
+            /* do some conditioning on replyLen, but on IN transfers only */
+            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
+                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
+                    replyLen = rq->wLength.bytes[0];
+                }else{
+                    replyLen = rq->wLength.word;
+                }
+            }
+            usbMsgFlags = USB_FLG_USE_USER_RW;
+        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
+#endif
+        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
+            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
+                replyLen = rq->wLength.bytes[0];
+        }else{
+            if(replyLen > rq->wLength.word)     /* limit length to max */
+                replyLen = rq->wLength.word;
+        }
+        usbMsgLen = replyLen;
+    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
+#if USB_CFG_IMPLEMENT_FN_WRITE
+        if(usbMsgFlags & USB_FLG_USE_USER_RW){
+            uchar rval = usbFunctionWrite(data, len);
+            if(rval == 0xff){   /* an error occurred */
+                usbTxLen = USBPID_STALL;
+            }else if(rval != 0){    /* This was the final package */
+                usbMsgLen = 0;  /* answer with a zero-sized data packet */
+            }
+        }
+#endif
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* This function is similar to usbFunctionRead(), but it's also called for
+ * data handled automatically by the driver (e.g. descriptor reads).
+ */
+static uchar usbDeviceRead(uchar *data, uchar len)
+{
+    if(len > 0){    /* don't bother app with 0 sized reads */
+#if USB_CFG_IMPLEMENT_FN_READ
+        if(usbMsgFlags & USB_FLG_USE_USER_RW){
+            len = usbFunctionRead(data, len);
+        }else
+#endif
+        {
+            uchar i = len, *r = usbMsgPtr;
+            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
+                do{
+                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
+                    *data++ = c;
+                    r++;
+                }while(--i);
+            }else{  /* RAM data */
+                do{
+                    *data++ = *r++;
+                }while(--i);
+            }
+            usbMsgPtr = r;
+        }
+    }
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbBuildTxBlock() is called when we have data to transmit and the
+ * interrupt routine's transmit buffer is empty.
+ */
+static inline void usbBuildTxBlock(void)
+{
+usbMsgLen_t wantLen;
+uchar       len;
+
+    wantLen = usbMsgLen;
+    if(wantLen > 8)
+        wantLen = 8;
+    usbMsgLen -= wantLen;
+    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
+    len = usbDeviceRead(usbTxBuf + 1, wantLen);
+    if(len <= 8){           /* valid data packet */
+        usbCrc16Append(&usbTxBuf[1], len);
+        len += 4;           /* length including sync byte */
+        if(len < 12)        /* a partial package identifies end of message */
+            usbMsgLen = USB_NO_MSG;
+    }else{
+        len = USBPID_STALL;   /* stall the endpoint */
+        usbMsgLen = USB_NO_MSG;
+    }
+    usbTxLen = len;
+    DBG2(0x20, usbTxBuf, len-1);
+}
+
+/* ------------------------------------------------------------------------- */
+
+static inline void usbHandleResetHook(uchar notResetState)
+{
+#ifdef USB_RESET_HOOK
+static uchar    wasReset;
+uchar           isReset = !notResetState;
+
+    if(wasReset != isReset){
+        USB_RESET_HOOK(isReset);
+        wasReset = isReset;
+    }
+#else
+    notResetState = notResetState;  // avoid compiler warning
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+USB_PUBLIC void usbPoll(void)
+{
+schar   len;
+uchar   i;
+
+    len = usbRxLen - 3;
+    if(len >= 0){
+/* We could check CRC16 here -- but ACK has already been sent anyway. If you
+ * need data integrity checks with this driver, check the CRC in your app
+ * code and report errors back to the host. Since the ACK was already sent,
+ * retries must be handled on application level.
+ * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
+ */
+        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
+#if USB_CFG_HAVE_FLOWCONTROL
+        if(usbRxLen > 0)    /* only mark as available if not inactivated */
+            usbRxLen = 0;
+#else
+        usbRxLen = 0;       /* mark rx buffer as available */
+#endif
+    }
+    if(usbTxLen & 0x10){    /* transmit system idle */
+        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
+            usbBuildTxBlock();
+        }
+    }
+    for(i = 20; i > 0; i--){
+        uchar usbLineStatus = USBIN & USBMASK;
+        if(usbLineStatus != 0)  /* SE0 has ended */
+            goto isNotReset;
+    }
+    /* RESET condition, called multiple times during reset */
+    usbNewDeviceAddr = 0;
+    usbDeviceAddr = 0;
+    usbResetStall();
+    DBG1(0xff, 0, 0);
+isNotReset:
+    usbHandleResetHook(i);
+}
+
+/* ------------------------------------------------------------------------- */
+
+USB_PUBLIC void usbInit(void)
+{
+#if USB_INTR_CFG_SET != 0
+    USB_INTR_CFG |= USB_INTR_CFG_SET;
+#endif
+#if USB_INTR_CFG_CLR != 0
+    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
+#endif
+    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
+    usbResetDataToggling();
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    usbTxLen1 = USBPID_NAK;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+    usbTxLen3 = USBPID_NAK;
+#endif
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
Index: usbdrv/usbdrv.h
===================================================================
--- usbdrv/usbdrv.h	(nonexistent)
+++ usbdrv/usbdrv.h	(working copy)
@@ -0,0 +1,736 @@
+/* Name: usbdrv.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ * This Revision: $Id$
+ */
+
+#ifndef __usbdrv_h_included__
+#define __usbdrv_h_included__
+#include "usbconfig.h"
+#include "usbportability.h"
+
+/*
+Hardware Prerequisites:
+=======================
+USB lines D+ and D- MUST be wired to the same I/O port. We recommend that D+
+triggers the interrupt (best achieved by using INT0 for D+), but it is also
+possible to trigger the interrupt from D-. If D- is used, interrupts are also
+triggered by SOF packets. D- requires a pull-up of 1.5k to +3.5V (and the
+device must be powered at 3.5V) to identify as low-speed USB device. A
+pull-down or pull-up of 1M SHOULD be connected from D+ to +3.5V to prevent
+interference when no USB master is connected. If you use Zener diodes to limit
+the voltage on D+ and D-, you MUST use a pull-down resistor, not a pull-up.
+We use D+ as interrupt source and not D- because it does not trigger on
+keep-alive and RESET states. If you want to count keep-alive events with
+USB_COUNT_SOF, you MUST use D- as an interrupt source.
+
+As a compile time option, the 1.5k pull-up resistor on D- can be made
+switchable to allow the device to disconnect at will. See the definition of
+usbDeviceConnect() and usbDeviceDisconnect() further down in this file.
+
+Please adapt the values in usbconfig.h according to your hardware!
+
+The device MUST be clocked at exactly 12 MHz, 15 MHz, 16 MHz or 20 MHz
+or at 12.8 MHz resp. 16.5 MHz +/- 1%. See usbconfig-prototype.h for details.
+
+
+Limitations:
+============
+Robustness with respect to communication errors:
+The driver assumes error-free communication. It DOES check for errors in
+the PID, but does NOT check bit stuffing errors, SE0 in middle of a byte,
+token CRC (5 bit) and data CRC (16 bit). CRC checks can not be performed due
+to timing constraints: We must start sending a reply within 7 bit times.
+Bit stuffing and misplaced SE0 would have to be checked in real-time, but CPU
+performance does not permit that. The driver does not check Data0/Data1
+toggling, but application software can implement the check.
+
+Input characteristics:
+Since no differential receiver circuit is used, electrical interference
+robustness may suffer. The driver samples only one of the data lines with
+an ordinary I/O pin's input characteristics. However, since this is only a
+low speed USB implementation and the specification allows for 8 times the
+bit rate over the same hardware, we should be on the safe side. Even the spec
+requires detection of asymmetric states at high bit rate for SE0 detection.
+
+Number of endpoints:
+The driver supports the following endpoints:
+
+- Endpoint 0, the default control endpoint.
+- Any number of interrupt- or bulk-out endpoints. The data is sent to
+  usbFunctionWriteOut() and USB_CFG_IMPLEMENT_FN_WRITEOUT must be defined
+  to 1 to activate this feature. The endpoint number can be found in the
+  global variable 'usbRxToken'.
+- One default interrupt- or bulk-in endpoint. This endpoint is used for
+  interrupt- or bulk-in transfers which are not handled by any other endpoint.
+  You must define USB_CFG_HAVE_INTRIN_ENDPOINT in order to activate this
+  feature and call usbSetInterrupt() to send interrupt/bulk data.
+- One additional interrupt- or bulk-in endpoint. This was endpoint 3 in
+  previous versions of this driver but can now be configured to any endpoint
+  number. You must define USB_CFG_HAVE_INTRIN_ENDPOINT3 in order to activate
+  this feature and call usbSetInterrupt3() to send interrupt/bulk data. The
+  endpoint number can be set with USB_CFG_EP3_NUMBER.
+
+Please note that the USB standard forbids bulk endpoints for low speed devices!
+Most operating systems allow them anyway, but the AVR will spend 90% of the CPU
+time in the USB interrupt polling for bulk data.
+
+Maximum data payload:
+Data payload of control in and out transfers may be up to 254 bytes. In order
+to accept payload data of out transfers, you need to implement
+'usbFunctionWrite()'.
+
+USB Suspend Mode supply current:
+The USB standard limits power consumption to 500uA when the bus is in suspend
+mode. This is not a problem for self-powered devices since they don't need
+bus power anyway. Bus-powered devices can achieve this only by putting the
+CPU in sleep mode. The driver does not implement suspend handling by itself.
+However, the application may implement activity monitoring and wakeup from
+sleep. The host sends regular SE0 states on the bus to keep it active. These
+SE0 states can be detected by using D- as the interrupt source. Define
+USB_COUNT_SOF to 1 and use the global variable usbSofCount to check for bus
+activity.
+
+Operation without an USB master:
+The driver behaves neutral without connection to an USB master if D- reads
+as 1. To avoid spurious interrupts, we recommend a high impedance (e.g. 1M)
+pull-down or pull-up resistor on D+ (interrupt). If Zener diodes are used,
+use a pull-down. If D- becomes statically 0, the driver may block in the
+interrupt routine.
+
+Interrupt latency:
+The application must ensure that the USB interrupt is not disabled for more
+than 25 cycles (this is for 12 MHz, faster clocks allow longer latency).
+This implies that all interrupt routines must either have the "ISR_NOBLOCK"
+attribute set (see "avr/interrupt.h") or be written in assembler with "sei"
+as the first instruction.
+
+Maximum interrupt duration / CPU cycle consumption:
+The driver handles all USB communication during the interrupt service
+routine. The routine will not return before an entire USB message is received
+and the reply is sent. This may be up to ca. 1200 cycles @ 12 MHz (= 100us) if
+the host conforms to the standard. The driver will consume CPU cycles for all
+USB messages, even if they address another (low-speed) device on the same bus.
+
+*/
+
+/* ------------------------------------------------------------------------- */
+/* --------------------------- Module Interface ---------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#define USBDRV_VERSION  20120109
+/* This define uniquely identifies a driver version. It is a decimal number
+ * constructed from the driver's release date in the form YYYYMMDD. If the
+ * driver's behavior or interface changes, you can use this constant to
+ * distinguish versions. If it is not defined, the driver's release date is
+ * older than 2006-01-25.
+ */
+
+
+#ifndef USB_PUBLIC
+#define USB_PUBLIC
+#endif
+/* USB_PUBLIC is used as declaration attribute for all functions exported by
+ * the USB driver. The default is no attribute (see above). You may define it
+ * to static either in usbconfig.h or from the command line if you include
+ * usbdrv.c instead of linking against it. Including the C module of the driver
+ * directly in your code saves a couple of bytes in flash memory.
+ */
+
+#ifndef __ASSEMBLER__
+#ifndef uchar
+#define uchar   unsigned char
+#endif
+#ifndef schar
+#define schar   signed char
+#endif
+/* shortcuts for well defined 8 bit integer types */
+
+#if USB_CFG_LONG_TRANSFERS  /* if more than 254 bytes transfer size required */
+#   define usbMsgLen_t unsigned
+#else
+#   define usbMsgLen_t uchar
+#endif
+/* usbMsgLen_t is the data type used for transfer lengths. By default, it is
+ * defined to uchar, allowing a maximum of 254 bytes (255 is reserved for
+ * USB_NO_MSG below). If the usbconfig.h defines USB_CFG_LONG_TRANSFERS to 1,
+ * a 16 bit data type is used, allowing up to 16384 bytes (the rest is used
+ * for flags in the descriptor configuration).
+ */
+#define USB_NO_MSG  ((usbMsgLen_t)-1)   /* constant meaning "no message" */
+
+struct usbRequest;  /* forward declaration */
+
+USB_PUBLIC void usbInit(void);
+/* This function must be called before interrupts are enabled and the main
+ * loop is entered. We exepct that the PORT and DDR bits for D+ and D- have
+ * not been changed from their default status (which is 0). If you have changed
+ * them, set both back to 0 (configure them as input with no internal pull-up).
+ */
+USB_PUBLIC void usbPoll(void);
+/* This function must be called at regular intervals from the main loop.
+ * Maximum delay between calls is somewhat less than 50ms (USB timeout for
+ * accepting a Setup message). Otherwise the device will not be recognized.
+ * Please note that debug outputs through the UART take ~ 0.5ms per byte
+ * at 19200 bps.
+ */
+extern uchar *usbMsgPtr;
+/* This variable may be used to pass transmit data to the driver from the
+ * implementation of usbFunctionWrite(). It is also used internally by the
+ * driver for standard control requests.
+ */
+USB_PUBLIC usbMsgLen_t usbFunctionSetup(uchar data[8]);
+/* This function is called when the driver receives a SETUP transaction from
+ * the host which is not answered by the driver itself (in practice: class and
+ * vendor requests). All control transfers start with a SETUP transaction where
+ * the host communicates the parameters of the following (optional) data
+ * transfer. The SETUP data is available in the 'data' parameter which can
+ * (and should) be casted to 'usbRequest_t *' for a more user-friendly access
+ * to parameters.
+ *
+ * If the SETUP indicates a control-in transfer, you should provide the
+ * requested data to the driver. There are two ways to transfer this data:
+ * (1) Set the global pointer 'usbMsgPtr' to the base of the static RAM data
+ * block and return the length of the data in 'usbFunctionSetup()'. The driver
+ * will handle the rest. Or (2) return USB_NO_MSG in 'usbFunctionSetup()'. The
+ * driver will then call 'usbFunctionRead()' when data is needed. See the
+ * documentation for usbFunctionRead() for details.
+ *
+ * If the SETUP indicates a control-out transfer, the only way to receive the
+ * data from the host is through the 'usbFunctionWrite()' call. If you
+ * implement this function, you must return USB_NO_MSG in 'usbFunctionSetup()'
+ * to indicate that 'usbFunctionWrite()' should be used. See the documentation
+ * of this function for more information. If you just want to ignore the data
+ * sent by the host, return 0 in 'usbFunctionSetup()'.
+ *
+ * Note that calls to the functions usbFunctionRead() and usbFunctionWrite()
+ * are only done if enabled by the configuration in usbconfig.h.
+ */
+USB_PUBLIC usbMsgLen_t usbFunctionDescriptor(struct usbRequest *rq);
+/* You need to implement this function ONLY if you provide USB descriptors at
+ * runtime (which is an expert feature). It is very similar to
+ * usbFunctionSetup() above, but it is called only to request USB descriptor
+ * data. See the documentation of usbFunctionSetup() above for more info.
+ */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len);
+/* This function sets the message which will be sent during the next interrupt
+ * IN transfer. The message is copied to an internal buffer and must not exceed
+ * a length of 8 bytes. The message may be 0 bytes long just to indicate the
+ * interrupt status to the host.
+ * If you need to transfer more bytes, use a control read after the interrupt.
+ */
+#define usbInterruptIsReady()   (usbTxLen1 & 0x10)
+/* This macro indicates whether the last interrupt message has already been
+ * sent. If you set a new interrupt message before the old was sent, the
+ * message already buffered will be lost.
+ */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len);
+#define usbInterruptIsReady3()   (usbTxLen3 & 0x10)
+/* Same as above for endpoint 3 */
+#endif
+#endif /* USB_CFG_HAVE_INTRIN_ENDPOINT */
+#if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    /* simplified interface for backward compatibility */
+#define usbHidReportDescriptor  usbDescriptorHidReport
+/* should be declared as: PROGMEM char usbHidReportDescriptor[]; */
+/* If you implement an HID device, you need to provide a report descriptor.
+ * The HID report descriptor syntax is a bit complex. If you understand how
+ * report descriptors are constructed, we recommend that you use the HID
+ * Descriptor Tool from usb.org, see http://www.usb.org/developers/hidpage/.
+ * Otherwise you should probably start with a working example.
+ */
+#endif  /* USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH */
+#if USB_CFG_IMPLEMENT_FN_WRITE
+USB_PUBLIC uchar usbFunctionWrite(uchar *data, uchar len);
+/* This function is called by the driver to provide a control transfer's
+ * payload data (control-out). It is called in chunks of up to 8 bytes. The
+ * total count provided in the current control transfer can be obtained from
+ * the 'length' property in the setup data. If an error occurred during
+ * processing, return 0xff (== -1). The driver will answer the entire transfer
+ * with a STALL token in this case. If you have received the entire payload
+ * successfully, return 1. If you expect more data, return 0. If you don't
+ * know whether the host will send more data (you should know, the total is
+ * provided in the usbFunctionSetup() call!), return 1.
+ * NOTE: If you return 0xff for STALL, 'usbFunctionWrite()' may still be called
+ * for the remaining data. You must continue to return 0xff for STALL in these
+ * calls.
+ * In order to get usbFunctionWrite() called, define USB_CFG_IMPLEMENT_FN_WRITE
+ * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_WRITE */
+#if USB_CFG_IMPLEMENT_FN_READ
+USB_PUBLIC uchar usbFunctionRead(uchar *data, uchar len);
+/* This function is called by the driver to ask the application for a control
+ * transfer's payload data (control-in). It is called in chunks of up to 8
+ * bytes each. You should copy the data to the location given by 'data' and
+ * return the actual number of bytes copied. If you return less than requested,
+ * the control-in transfer is terminated. If you return 0xff, the driver aborts
+ * the transfer with a STALL token.
+ * In order to get usbFunctionRead() called, define USB_CFG_IMPLEMENT_FN_READ
+ * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_READ */
+
+extern uchar usbRxToken;    /* may be used in usbFunctionWriteOut() below */
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+USB_PUBLIC void usbFunctionWriteOut(uchar *data, uchar len);
+/* This function is called by the driver when data is received on an interrupt-
+ * or bulk-out endpoint. The endpoint number can be found in the global
+ * variable usbRxToken. You must define USB_CFG_IMPLEMENT_FN_WRITEOUT to 1 in
+ * usbconfig.h to get this function called.
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_WRITEOUT */
+#ifdef USB_CFG_PULLUP_IOPORTNAME
+#define usbDeviceConnect()      ((USB_PULLUP_DDR |= (1<<USB_CFG_PULLUP_BIT)), \
+                                  (USB_PULLUP_OUT |= (1<<USB_CFG_PULLUP_BIT)))
+#define usbDeviceDisconnect()   ((USB_PULLUP_DDR &= ~(1<<USB_CFG_PULLUP_BIT)), \
+                                  (USB_PULLUP_OUT &= ~(1<<USB_CFG_PULLUP_BIT)))
+#else /* USB_CFG_PULLUP_IOPORTNAME */
+#define usbDeviceConnect()      (USBDDR &= ~(1<<USBMINUS))
+#define usbDeviceDisconnect()   (USBDDR |= (1<<USBMINUS))
+#endif /* USB_CFG_PULLUP_IOPORTNAME */
+/* The macros usbDeviceConnect() and usbDeviceDisconnect() (intended to look
+ * like a function) connect resp. disconnect the device from the host's USB.
+ * If the constants USB_CFG_PULLUP_IOPORT and USB_CFG_PULLUP_BIT are defined
+ * in usbconfig.h, a disconnect consists of removing the pull-up resisitor
+ * from D-, otherwise the disconnect is done by brute-force pulling D- to GND.
+ * This does not conform to the spec, but it works.
+ * Please note that the USB interrupt must be disabled while the device is
+ * in disconnected state, or the interrupt handler will hang! You can either
+ * turn off the USB interrupt selectively with
+ *     USB_INTR_ENABLE &= ~(1 << USB_INTR_ENABLE_BIT)
+ * or use cli() to disable interrupts globally.
+ */
+extern unsigned usbCrc16(unsigned data, uchar len);
+#define usbCrc16(data, len) usbCrc16((unsigned)(data), len)
+/* This function calculates the binary complement of the data CRC used in
+ * USB data packets. The value is used to build raw transmit packets.
+ * You may want to use this function for data checksums or to verify received
+ * data. We enforce 16 bit calling conventions for compatibility with IAR's
+ * tiny memory model.
+ */
+extern unsigned usbCrc16Append(unsigned data, uchar len);
+#define usbCrc16Append(data, len)    usbCrc16Append((unsigned)(data), len)
+/* This function is equivalent to usbCrc16() above, except that it appends
+ * the 2 bytes CRC (lowbyte first) in the 'data' buffer after reading 'len'
+ * bytes.
+ */
+#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
+extern unsigned usbMeasureFrameLength(void);
+/* This function MUST be called IMMEDIATELY AFTER USB reset and measures 1/7 of
+ * the number of CPU cycles during one USB frame minus one low speed bit
+ * length. In other words: return value = 1499 * (F_CPU / 10.5 MHz)
+ * Since this is a busy wait, you MUST disable all interrupts with cli() before
+ * calling this function.
+ * This can be used to calibrate the AVR's RC oscillator.
+ */
+#endif
+extern uchar    usbConfiguration;
+/* This value contains the current configuration set by the host. The driver
+ * allows setting and querying of this variable with the USB SET_CONFIGURATION
+ * and GET_CONFIGURATION requests, but does not use it otherwise.
+ * You may want to reflect the "configured" status with a LED on the device or
+ * switch on high power parts of the circuit only if the device is configured.
+ */
+#if USB_COUNT_SOF
+extern volatile uchar   usbSofCount;
+/* This variable is incremented on every SOF packet. It is only available if
+ * the macro USB_COUNT_SOF is defined to a value != 0.
+ */
+#endif
+#if USB_CFG_CHECK_DATA_TOGGLING
+extern uchar    usbCurrentDataToken;
+/* This variable can be checked in usbFunctionWrite() and usbFunctionWriteOut()
+ * to ignore duplicate packets.
+ */
+#endif
+
+#define USB_STRING_DESCRIPTOR_HEADER(stringLength) ((2*(stringLength)+2) | (3<<8))
+/* This macro builds a descriptor header for a string descriptor given the
+ * string's length. See usbdrv.c for an example how to use it.
+ */
+#if USB_CFG_HAVE_FLOWCONTROL
+extern volatile schar   usbRxLen;
+#define usbDisableAllRequests()     usbRxLen = -1
+/* Must be called from usbFunctionWrite(). This macro disables all data input
+ * from the USB interface. Requests from the host are answered with a NAK
+ * while they are disabled.
+ */
+#define usbEnableAllRequests()      usbRxLen = 0
+/* May only be called if requests are disabled. This macro enables input from
+ * the USB interface after it has been disabled with usbDisableAllRequests().
+ */
+#define usbAllRequestsAreDisabled() (usbRxLen < 0)
+/* Use this macro to find out whether requests are disabled. It may be needed
+ * to ensure that usbEnableAllRequests() is never called when requests are
+ * enabled.
+ */
+#endif
+
+#define USB_SET_DATATOKEN1(token)   usbTxBuf1[0] = token
+#define USB_SET_DATATOKEN3(token)   usbTxBuf3[0] = token
+/* These two macros can be used by application software to reset data toggling
+ * for interrupt-in endpoints 1 and 3. Since the token is toggled BEFORE
+ * sending data, you must set the opposite value of the token which should come
+ * first.
+ */
+
+#endif  /* __ASSEMBLER__ */
+
+
+/* ------------------------------------------------------------------------- */
+/* ----------------- Definitions for Descriptor Properties ----------------- */
+/* ------------------------------------------------------------------------- */
+/* This is advanced stuff. See usbconfig-prototype.h for more information
+ * about the various methods to define USB descriptors. If you do nothing,
+ * the default descriptors will be used.
+ */
+#define USB_PROP_IS_DYNAMIC     (1 << 14)
+/* If this property is set for a descriptor, usbFunctionDescriptor() will be
+ * used to obtain the particular descriptor. Data directly returned via
+ * usbMsgPtr are FLASH data by default, combine (OR) with USB_PROP_IS_RAM to
+ * return RAM data.
+ */
+#define USB_PROP_IS_RAM         (1 << 15)
+/* If this property is set for a descriptor, the data is read from RAM
+ * memory instead of Flash. The property is used for all methods to provide
+ * external descriptors.
+ */
+#define USB_PROP_LENGTH(len)    ((len) & 0x3fff)
+/* If a static external descriptor is used, this is the total length of the
+ * descriptor in bytes.
+ */
+
+/* all descriptors which may have properties: */
+#ifndef USB_CFG_DESCR_PROPS_DEVICE
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_CONFIGURATION
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRINGS
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_VENDOR
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_PRODUCT
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_HID
+#define USB_CFG_DESCR_PROPS_HID                     0
+#endif
+#if !(USB_CFG_DESCR_PROPS_HID_REPORT)
+#   undef USB_CFG_DESCR_PROPS_HID_REPORT
+#   if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH /* do some backward compatibility tricks */
+#       define USB_CFG_DESCR_PROPS_HID_REPORT       USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH
+#   else
+#       define USB_CFG_DESCR_PROPS_HID_REPORT       0
+#   endif
+#endif
+#ifndef USB_CFG_DESCR_PROPS_UNKNOWN
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+#endif
+
+/* ------------------ forward declaration of descriptors ------------------- */
+/* If you use external static descriptors, they must be stored in global
+ * arrays as declared below:
+ */
+#ifndef __ASSEMBLER__
+extern
+#if !(USB_CFG_DESCR_PROPS_DEVICE & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+char usbDescriptorDevice[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_CONFIGURATION & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+char usbDescriptorConfiguration[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_HID_REPORT & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+char usbDescriptorHidReport[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_0 & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+char usbDescriptorString0[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_VENDOR & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+int usbDescriptorStringVendor[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_PRODUCT & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+int usbDescriptorStringDevice[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+int usbDescriptorStringSerialNumber[];
+
+#endif /* __ASSEMBLER__ */
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------ General Purpose Macros ------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#define USB_CONCAT(a, b)            a ## b
+#define USB_CONCAT_EXPANDED(a, b)   USB_CONCAT(a, b)
+
+#define USB_OUTPORT(name)           USB_CONCAT(PORT, name)
+#define USB_INPORT(name)            USB_CONCAT(PIN, name)
+#define USB_DDRPORT(name)           USB_CONCAT(DDR, name)
+/* The double-define trick above lets us concatenate strings which are
+ * defined by macros.
+ */
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------- Constant definitions -------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#if !defined __ASSEMBLER__ && (!defined USB_CFG_VENDOR_ID || !defined USB_CFG_DEVICE_ID)
+#warning "You should define USB_CFG_VENDOR_ID and USB_CFG_DEVICE_ID in usbconfig.h"
+/* If the user has not defined IDs, we default to obdev's free IDs.
+ * See USB-IDs-for-free.txt for details.
+ */
+#endif
+
+/* make sure we have a VID and PID defined, byte order is lowbyte, highbyte */
+#ifndef USB_CFG_VENDOR_ID
+#   define  USB_CFG_VENDOR_ID   0xc0, 0x16  /* = 0x16c0 = 5824 = voti.nl */
+#endif
+
+#ifndef USB_CFG_DEVICE_ID
+#   if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH
+#       define USB_CFG_DEVICE_ID    0xdf, 0x05  /* = 0x5df = 1503, shared PID for HIDs */
+#   elif USB_CFG_INTERFACE_CLASS == 2
+#       define USB_CFG_DEVICE_ID    0xe1, 0x05  /* = 0x5e1 = 1505, shared PID for CDC Modems */
+#   else
+#       define USB_CFG_DEVICE_ID    0xdc, 0x05  /* = 0x5dc = 1500, obdev's free PID */
+#   endif
+#endif
+
+/* Derive Output, Input and DataDirection ports from port names */
+#ifndef USB_CFG_IOPORTNAME
+#error "You must define USB_CFG_IOPORTNAME in usbconfig.h, see usbconfig-prototype.h"
+#endif
+
+#define USBOUT          USB_OUTPORT(USB_CFG_IOPORTNAME)
+#define USB_PULLUP_OUT  USB_OUTPORT(USB_CFG_PULLUP_IOPORTNAME)
+#define USBIN           USB_INPORT(USB_CFG_IOPORTNAME)
+#define USBDDR          USB_DDRPORT(USB_CFG_IOPORTNAME)
+#define USB_PULLUP_DDR  USB_DDRPORT(USB_CFG_PULLUP_IOPORTNAME)
+
+#define USBMINUS    USB_CFG_DMINUS_BIT
+#define USBPLUS     USB_CFG_DPLUS_BIT
+#define USBIDLE     (1<<USB_CFG_DMINUS_BIT) /* value representing J state */
+#define USBMASK     ((1<<USB_CFG_DPLUS_BIT) | (1<<USB_CFG_DMINUS_BIT))  /* mask for USB I/O bits */
+
+/* defines for backward compatibility with older driver versions: */
+#define USB_CFG_IOPORT          USB_OUTPORT(USB_CFG_IOPORTNAME)
+#ifdef USB_CFG_PULLUP_IOPORTNAME
+#define USB_CFG_PULLUP_IOPORT   USB_OUTPORT(USB_CFG_PULLUP_IOPORTNAME)
+#endif
+
+#ifndef USB_CFG_EP3_NUMBER  /* if not defined in usbconfig.h */
+#define USB_CFG_EP3_NUMBER  3
+#endif
+
+#ifndef USB_CFG_HAVE_INTRIN_ENDPOINT3
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+#endif
+
+#define USB_BUFSIZE     11  /* PID, 8 bytes data, 2 bytes CRC */
+
+/* ----- Try to find registers and bits responsible for ext interrupt 0 ----- */
+
+#ifndef USB_INTR_CFG    /* allow user to override our default */
+#   if defined  EICRA
+#       define USB_INTR_CFG EICRA
+#   else
+#       define USB_INTR_CFG MCUCR
+#   endif
+#endif
+#ifndef USB_INTR_CFG_SET    /* allow user to override our default */
+#   if defined(USB_COUNT_SOF) || defined(USB_SOF_HOOK)
+#       define USB_INTR_CFG_SET (1 << ISC01)                    /* cfg for falling edge */
+        /* If any SOF logic is used, the interrupt must be wired to D- where
+         * we better trigger on falling edge
+         */
+#   else
+#       define USB_INTR_CFG_SET ((1 << ISC00) | (1 << ISC01))   /* cfg for rising edge */
+#   endif
+#endif
+#ifndef USB_INTR_CFG_CLR    /* allow user to override our default */
+#   define USB_INTR_CFG_CLR 0    /* no bits to clear */
+#endif
+
+#ifndef USB_INTR_ENABLE     /* allow user to override our default */
+#   if defined GIMSK
+#       define USB_INTR_ENABLE  GIMSK
+#   elif defined EIMSK
+#       define USB_INTR_ENABLE  EIMSK
+#   else
+#       define USB_INTR_ENABLE  GICR
+#   endif
+#endif
+#ifndef USB_INTR_ENABLE_BIT /* allow user to override our default */
+#   define USB_INTR_ENABLE_BIT  INT0
+#endif
+
+#ifndef USB_INTR_PENDING    /* allow user to override our default */
+#   if defined  EIFR
+#       define USB_INTR_PENDING EIFR
+#   else
+#       define USB_INTR_PENDING GIFR
+#   endif
+#endif
+#ifndef USB_INTR_PENDING_BIT    /* allow user to override our default */
+#   define USB_INTR_PENDING_BIT INTF0
+#endif
+
+/*
+The defines above don't work for the following chips
+at90c8534: no ISC0?, no PORTB, can't find a data sheet
+at86rf401: no PORTB, no MCUCR etc, low clock rate
+atmega103: no ISC0? (maybe omission in header, can't find data sheet)
+atmega603: not defined in avr-libc
+at43usb320, at43usb355, at76c711: have USB anyway
+at94k: is different...
+
+at90s1200, attiny11, attiny12, attiny15, attiny28: these have no RAM
+*/
+
+/* ------------------------------------------------------------------------- */
+/* ----------------- USB Specification Constants and Types ----------------- */
+/* ------------------------------------------------------------------------- */
+
+/* USB Token values */
+#define USBPID_SETUP    0x2d
+#define USBPID_OUT      0xe1
+#define USBPID_IN       0x69
+#define USBPID_DATA0    0xc3
+#define USBPID_DATA1    0x4b
+
+#define USBPID_ACK      0xd2
+#define USBPID_NAK      0x5a
+#define USBPID_STALL    0x1e
+
+#ifndef USB_INITIAL_DATATOKEN
+#define USB_INITIAL_DATATOKEN   USBPID_DATA1
+#endif
+
+#ifndef __ASSEMBLER__
+
+typedef struct usbTxStatus{
+    volatile uchar   len;
+    uchar   buffer[USB_BUFSIZE];
+}usbTxStatus_t;
+
+extern usbTxStatus_t   usbTxStatus1, usbTxStatus3;
+#define usbTxLen1   usbTxStatus1.len
+#define usbTxBuf1   usbTxStatus1.buffer
+#define usbTxLen3   usbTxStatus3.len
+#define usbTxBuf3   usbTxStatus3.buffer
+
+
+typedef union usbWord{
+    unsigned    word;
+    uchar       bytes[2];
+}usbWord_t;
+
+typedef struct usbRequest{
+    uchar       bmRequestType;
+    uchar       bRequest;
+    usbWord_t   wValue;
+    usbWord_t   wIndex;
+    usbWord_t   wLength;
+}usbRequest_t;
+/* This structure matches the 8 byte setup request */
+#endif
+
+/* bmRequestType field in USB setup:
+ * d t t r r r r r, where
+ * d ..... direction: 0=host->device, 1=device->host
+ * t ..... type: 0=standard, 1=class, 2=vendor, 3=reserved
+ * r ..... recipient: 0=device, 1=interface, 2=endpoint, 3=other
+ */
+
+/* USB setup recipient values */
+#define USBRQ_RCPT_MASK         0x1f
+#define USBRQ_RCPT_DEVICE       0
+#define USBRQ_RCPT_INTERFACE    1
+#define USBRQ_RCPT_ENDPOINT     2
+
+/* USB request type values */
+#define USBRQ_TYPE_MASK         0x60
+#define USBRQ_TYPE_STANDARD     (0<<5)
+#define USBRQ_TYPE_CLASS        (1<<5)
+#define USBRQ_TYPE_VENDOR       (2<<5)
+
+/* USB direction values: */
+#define USBRQ_DIR_MASK              0x80
+#define USBRQ_DIR_HOST_TO_DEVICE    (0<<7)
+#define USBRQ_DIR_DEVICE_TO_HOST    (1<<7)
+
+/* USB Standard Requests */
+#define USBRQ_GET_STATUS        0
+#define USBRQ_CLEAR_FEATURE     1
+#define USBRQ_SET_FEATURE       3
+#define USBRQ_SET_ADDRESS       5
+#define USBRQ_GET_DESCRIPTOR    6
+#define USBRQ_SET_DESCRIPTOR    7
+#define USBRQ_GET_CONFIGURATION 8
+#define USBRQ_SET_CONFIGURATION 9
+#define USBRQ_GET_INTERFACE     10
+#define USBRQ_SET_INTERFACE     11
+#define USBRQ_SYNCH_FRAME       12
+
+/* USB descriptor constants */
+#define USBDESCR_DEVICE         1
+#define USBDESCR_CONFIG         2
+#define USBDESCR_STRING         3
+#define USBDESCR_INTERFACE      4
+#define USBDESCR_ENDPOINT       5
+#define USBDESCR_HID            0x21
+#define USBDESCR_HID_REPORT     0x22
+#define USBDESCR_HID_PHYS       0x23
+
+//#define USBATTR_BUSPOWER        0x80  // USB 1.1 does not define this value any more
+#define USBATTR_BUSPOWER        0
+#define USBATTR_SELFPOWER       0x40
+#define USBATTR_REMOTEWAKE      0x20
+
+/* USB HID Requests */
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_GET_IDLE      0x02
+#define USBRQ_HID_GET_PROTOCOL  0x03
+#define USBRQ_HID_SET_REPORT    0x09
+#define USBRQ_HID_SET_IDLE      0x0a
+#define USBRQ_HID_SET_PROTOCOL  0x0b
+
+/* ------------------------------------------------------------------------- */
+
+#endif /* __usbdrv_h_included__ */
Index: usbdrv/usbdrvasm.S
===================================================================
--- usbdrv/usbdrvasm.S	(nonexistent)
+++ usbdrv/usbdrvasm.S	(working copy)
@@ -0,0 +1,393 @@
+/* Name: usbdrvasm.S
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-13
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ * Revision: $Id$
+ */
+
+/*
+General Description:
+This module is the assembler part of the USB driver. This file contains
+general code (preprocessor acrobatics and CRC computation) and then includes
+the file appropriate for the given clock rate.
+*/
+
+#define __SFR_OFFSET 0      /* used by avr-libc's register definitions */
+#include "usbportability.h"
+#include "usbdrv.h"         /* for common defs */
+
+/* register names */
+#define x1      r16
+#define x2      r17
+#define shift   r18
+#define cnt     r19
+#define x3      r20
+#define x4      r21
+#define x5		r22
+#define bitcnt  x5
+#define phase   x4
+#define leap    x4
+
+/* Some assembler dependent definitions and declarations: */
+
+#ifdef __IAR_SYSTEMS_ASM__
+    extern  usbRxBuf, usbDeviceAddr, usbNewDeviceAddr, usbInputBufOffset
+    extern  usbCurrentTok, usbRxLen, usbRxToken, usbTxLen
+    extern  usbTxBuf, usbTxStatus1, usbTxStatus3
+#   if USB_COUNT_SOF
+        extern usbSofCount
+#   endif
+    public  usbCrc16
+    public  usbCrc16Append
+
+    COMMON  INTVEC
+#   ifndef USB_INTR_VECTOR
+        ORG     INT0_vect
+#   else /* USB_INTR_VECTOR */
+        ORG     USB_INTR_VECTOR
+#       undef   USB_INTR_VECTOR
+#   endif /* USB_INTR_VECTOR */
+#   define  USB_INTR_VECTOR usbInterruptHandler
+    rjmp    USB_INTR_VECTOR
+    RSEG    CODE
+
+#else /* __IAR_SYSTEMS_ASM__ */
+
+#   ifndef USB_INTR_VECTOR /* default to hardware interrupt INT0 */
+#       ifdef INT0_vect
+#           define USB_INTR_VECTOR  INT0_vect       // this is the "new" define for the vector
+#       else
+#           define USB_INTR_VECTOR  SIG_INTERRUPT0  // this is the "old" vector
+#       endif
+#   endif
+    .text
+    .global USB_INTR_VECTOR
+    .type   USB_INTR_VECTOR, @function
+    .global usbCrc16
+    .global usbCrc16Append
+#endif /* __IAR_SYSTEMS_ASM__ */
+
+
+#if USB_INTR_PENDING < 0x40 /* This is an I/O address, use in and out */
+#   define  USB_LOAD_PENDING(reg)   in reg, USB_INTR_PENDING
+#   define  USB_STORE_PENDING(reg)  out USB_INTR_PENDING, reg
+#else   /* It's a memory address, use lds and sts */
+#   define  USB_LOAD_PENDING(reg)   lds reg, USB_INTR_PENDING
+#   define  USB_STORE_PENDING(reg)  sts USB_INTR_PENDING, reg
+#endif
+
+#define usbTxLen1   usbTxStatus1
+#define usbTxBuf1   (usbTxStatus1 + 1)
+#define usbTxLen3   usbTxStatus3
+#define usbTxBuf3   (usbTxStatus3 + 1)
+
+
+;----------------------------------------------------------------------------
+; Utility functions
+;----------------------------------------------------------------------------
+
+#ifdef __IAR_SYSTEMS_ASM__
+/* Register assignments for usbCrc16 on IAR cc */
+/* Calling conventions on IAR:
+ * First parameter passed in r16/r17, second in r18/r19 and so on.
+ * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+ * Result is passed in r16/r17
+ * In case of the "tiny" memory model, pointers are only 8 bit with no
+ * padding. We therefore pass argument 1 as "16 bit unsigned".
+ */
+RTMODEL "__rt_version", "3"
+/* The line above will generate an error if cc calling conventions change.
+ * The value "3" above is valid for IAR 4.10B/W32
+ */
+#   define argLen   r18 /* argument 2 */
+#   define argPtrL  r16 /* argument 1 */
+#   define argPtrH  r17 /* argument 1 */
+
+#   define resCrcL  r16 /* result */
+#   define resCrcH  r17 /* result */
+
+#   define ptrL     ZL
+#   define ptrH     ZH
+#   define ptr      Z
+#   define byte     r22
+#   define bitCnt   r19
+#   define polyL    r20
+#   define polyH    r21
+#   define scratch  r23
+
+#else  /* __IAR_SYSTEMS_ASM__ */
+/* Register assignments for usbCrc16 on gcc */
+/* Calling conventions on gcc:
+ * First parameter passed in r24/r25, second in r22/23 and so on.
+ * Callee must preserve r1-r17, r28/r29
+ * Result is passed in r24/r25
+ */
+#   define argLen   r22 /* argument 2 */
+#   define argPtrL  r24 /* argument 1 */
+#   define argPtrH  r25 /* argument 1 */
+
+#   define resCrcL  r24 /* result */
+#   define resCrcH  r25 /* result */
+
+#   define ptrL     XL
+#   define ptrH     XH
+#   define ptr      x
+#   define byte     r18
+#   define bitCnt   r19
+#   define polyL    r20
+#   define polyH    r21
+#   define scratch  r23
+
+#endif
+
+#if USB_USE_FAST_CRC
+
+; This implementation is faster, but has bigger code size
+; Thanks to Slawomir Fras (BoskiDialer) for this code!
+; It implements the following C pseudo-code:
+; unsigned table(unsigned char x)
+; {
+; unsigned    value;
+;
+;     value = (unsigned)x << 6;
+;     value ^= (unsigned)x << 7;
+;     if(parity(x))
+;         value ^= 0xc001;
+;     return value;
+; }
+; unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen)
+; {
+; unsigned crc = 0xffff;
+;
+;     while(argLen--)
+;         crc = table(lo8(crc) ^ *argPtr++) ^ hi8(crc);
+;     return ~crc;
+; }
+
+; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+;   argPtr  r24+25 / r16+r17
+;   argLen  r22 / r18
+; temp variables:
+;   byte    r18 / r22
+;   scratch r23
+;   resCrc  r24+r25 / r16+r17
+;   ptr     X / Z
+usbCrc16:
+    mov     ptrL, argPtrL
+    mov     ptrH, argPtrH
+    ldi     resCrcL, 0xFF
+    ldi     resCrcH, 0xFF
+    rjmp    usbCrc16LoopTest
+usbCrc16ByteLoop:
+    ld      byte, ptr+
+    eor     resCrcL, byte   ; resCrcL is now 'x' in table()
+    mov     byte, resCrcL   ; compute parity of 'x'
+    swap    byte
+    eor     byte, resCrcL
+    mov     scratch, byte
+    lsr     byte
+    lsr     byte
+    eor     byte, scratch
+    inc     byte
+    lsr     byte
+    andi    byte, 1         ; byte is now parity(x)
+    mov     scratch, resCrcL
+    mov     resCrcL, resCrcH
+    eor     resCrcL, byte   ; low byte of if(parity(x)) value ^= 0xc001;
+    neg     byte
+    andi    byte, 0xc0
+    mov     resCrcH, byte   ; high byte of if(parity(x)) value ^= 0xc001;
+    clr     byte
+    lsr     scratch
+    ror     byte
+    eor     resCrcH, scratch
+    eor     resCrcL, byte
+    lsr     scratch
+    ror     byte
+    eor     resCrcH, scratch
+    eor     resCrcL, byte
+usbCrc16LoopTest:
+    subi    argLen, 1
+    brsh    usbCrc16ByteLoop
+    com     resCrcL
+    com     resCrcH
+    ret
+
+#else   /* USB_USE_FAST_CRC */
+
+; This implementation is slower, but has less code size
+;
+; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+;   argPtr  r24+25 / r16+r17
+;   argLen  r22 / r18
+; temp variables:
+;   byte    r18 / r22
+;   bitCnt  r19
+;   poly    r20+r21
+;   scratch r23
+;   resCrc  r24+r25 / r16+r17
+;   ptr     X / Z
+usbCrc16:
+    mov     ptrL, argPtrL
+    mov     ptrH, argPtrH
+    ldi     resCrcL, 0
+    ldi     resCrcH, 0
+    ldi     polyL, lo8(0xa001)
+    ldi     polyH, hi8(0xa001)
+    com     argLen      ; argLen = -argLen - 1: modified loop to ensure that carry is set
+    ldi     bitCnt, 0   ; loop counter with starnd condition = end condition
+    rjmp    usbCrcLoopEntry
+usbCrcByteLoop:
+    ld      byte, ptr+
+    eor     resCrcL, byte
+usbCrcBitLoop:
+    ror     resCrcH     ; carry is always set here (see brcs jumps to here)
+    ror     resCrcL
+    brcs    usbCrcNoXor
+    eor     resCrcL, polyL
+    eor     resCrcH, polyH
+usbCrcNoXor:
+    subi    bitCnt, 224 ; (8 * 224) % 256 = 0; this loop iterates 8 times
+    brcs    usbCrcBitLoop
+usbCrcLoopEntry:
+    subi    argLen, -1
+    brcs    usbCrcByteLoop
+usbCrcReady:
+    ret
+; Thanks to Reimar Doeffinger for optimizing this CRC routine!
+
+#endif /* USB_USE_FAST_CRC */
+
+; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
+usbCrc16Append:
+    rcall   usbCrc16
+    st      ptr+, resCrcL
+    st      ptr+, resCrcH
+    ret
+
+#undef argLen
+#undef argPtrL
+#undef argPtrH
+#undef resCrcL
+#undef resCrcH
+#undef ptrL
+#undef ptrH
+#undef ptr
+#undef byte
+#undef bitCnt
+#undef polyL
+#undef polyH
+#undef scratch
+
+
+#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
+#ifdef __IAR_SYSTEMS_ASM__
+/* Register assignments for usbMeasureFrameLength on IAR cc */
+/* Calling conventions on IAR:
+ * First parameter passed in r16/r17, second in r18/r19 and so on.
+ * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+ * Result is passed in r16/r17
+ * In case of the "tiny" memory model, pointers are only 8 bit with no
+ * padding. We therefore pass argument 1 as "16 bit unsigned".
+ */
+#   define resL     r16
+#   define resH     r17
+#   define cnt16L   r30
+#   define cnt16H   r31
+#   define cntH     r18
+
+#else  /* __IAR_SYSTEMS_ASM__ */
+/* Register assignments for usbMeasureFrameLength on gcc */
+/* Calling conventions on gcc:
+ * First parameter passed in r24/r25, second in r22/23 and so on.
+ * Callee must preserve r1-r17, r28/r29
+ * Result is passed in r24/r25
+ */
+#   define resL     r24
+#   define resH     r25
+#   define cnt16L   r24
+#   define cnt16H   r25
+#   define cntH     r26
+#endif
+#   define cnt16    cnt16L
+
+; extern unsigned usbMeasurePacketLength(void);
+; returns time between two idle strobes in multiples of 7 CPU clocks
+.global usbMeasureFrameLength
+usbMeasureFrameLength:
+    ldi     cntH, 6         ; wait ~ 10 ms for D- == 0
+    clr     cnt16L
+    clr     cnt16H
+usbMFTime16:
+    dec     cntH
+    breq    usbMFTimeout
+usbMFWaitStrobe:            ; first wait for D- == 0 (idle strobe)
+    sbiw    cnt16, 1        ;[0] [6]
+    breq    usbMFTime16     ;[2]
+    sbic    USBIN, USBMINUS ;[3]
+    rjmp    usbMFWaitStrobe ;[4]
+usbMFWaitIdle:              ; then wait until idle again
+    sbis    USBIN, USBMINUS ;1 wait for D- == 1
+    rjmp    usbMFWaitIdle   ;2
+    ldi     cnt16L, 1       ;1 represents cycles so far
+    clr     cnt16H          ;1
+usbMFWaitLoop:
+    in      cntH, USBIN     ;[0] [7]
+    adiw    cnt16, 1        ;[1]
+    breq    usbMFTimeout    ;[3]
+    andi    cntH, USBMASK   ;[4]
+    brne    usbMFWaitLoop   ;[5]
+usbMFTimeout:
+#if resL != cnt16L
+    mov     resL, cnt16L
+    mov     resH, cnt16H
+#endif
+    ret
+
+#undef resL
+#undef resH
+#undef cnt16
+#undef cnt16L
+#undef cnt16H
+#undef cntH
+
+#endif  /* USB_CFG_HAVE_MEASURE_FRAME_LENGTH */
+
+;----------------------------------------------------------------------------
+; Now include the clock rate specific code
+;----------------------------------------------------------------------------
+
+#ifndef USB_CFG_CLOCK_KHZ
+#   ifdef F_CPU
+#       define USB_CFG_CLOCK_KHZ (F_CPU/1000)
+#   else
+#       error "USB_CFG_CLOCK_KHZ not defined in usbconfig.h and no F_CPU set!"
+#   endif
+#endif
+
+#if USB_CFG_CHECK_CRC   /* separate dispatcher for CRC type modules */
+#   if USB_CFG_CLOCK_KHZ == 18000
+#       include "usbdrvasm18-crc.inc"
+#   else
+#       error "USB_CFG_CLOCK_KHZ is not one of the supported crc-rates!"
+#   endif
+#else   /* USB_CFG_CHECK_CRC */
+#   if USB_CFG_CLOCK_KHZ == 12000
+#       include "usbdrvasm12.inc"
+#   elif USB_CFG_CLOCK_KHZ == 12800
+#       include "usbdrvasm128.inc"
+#   elif USB_CFG_CLOCK_KHZ == 15000
+#       include "usbdrvasm15.inc"
+#   elif USB_CFG_CLOCK_KHZ == 16000
+#       include "usbdrvasm16.inc"
+#   elif USB_CFG_CLOCK_KHZ == 16500
+#       include "usbdrvasm165.inc"
+#   elif USB_CFG_CLOCK_KHZ == 20000
+#       include "usbdrvasm20.inc"
+#   else
+#       error "USB_CFG_CLOCK_KHZ is not one of the supported non-crc-rates!"
+#   endif
+#endif /* USB_CFG_CHECK_CRC */
Index: usbdrv/usbdrvasm.asm
===================================================================
--- usbdrv/usbdrvasm.asm	(nonexistent)
+++ usbdrv/usbdrvasm.asm	(working copy)
@@ -0,0 +1,20 @@
+/* Name: usbdrvasm.asm
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-03-01
+ * Tabsize: 4
+ * Copyright: (c) 2006 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The IAR compiler/assembler system prefers assembler files with file extension
+".asm". We simply provide this file as an alias for usbdrvasm.S.
+
+Thanks to Oleg Semyonov for his help with the IAR tools port!
+*/
+
+#include "usbdrvasm.S"
+
+end
Index: usbdrv/usbdrvasm12.inc
===================================================================
--- usbdrv/usbdrvasm12.inc	(nonexistent)
+++ usbdrv/usbdrvasm12.inc	(working copy)
@@ -0,0 +1,392 @@
+/* Name: usbdrvasm12.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 12 MHz version of the asssembler part of the USB driver. It
+requires a 12 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+
+
+Timing constraints according to spec (in bit times):
+timing subject                                      min max    CPUcycles
+---------------------------------------------------------------------------
+EOP of OUT/SETUP to sync pattern of DATA0 (both rx) 2   16     16-128
+EOP of IN to sync pattern of DATA0 (rx, then tx)    2   7.5    16-60
+DATAx (rx) to ACK/NAK/STALL (tx)                    2   7.5    16-60
+*/
+
+;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
+;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
+;max allowable interrupt latency: 34 cycles -> max 25 cycles interrupt disable
+;max stack usage: [ret(2), YL, SREG, YH, shift, x1, x2, x3, cnt, x4] = 11 bytes
+;Numbers in brackets are maximum cycles since SOF.
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt
+    push    YL              ;2 [35] push only what is necessary to sync with edge ASAP
+    in      YL, SREG        ;1 [37]
+    push    YL              ;2 [39]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    YH                  ;2 [2]
+    lds     YL, usbInputBufOffset;2 [4]
+    clr     YH                  ;1 [5]
+    subi    YL, lo8(-(usbRxBuf));1 [6]
+    sbci    YH, hi8(-(usbRxBuf));1 [7]
+
+    sbis    USBIN, USBMINUS ;1 [8] we want two bits K [sample 1 cycle too early]
+    rjmp    haveTwoBitsK    ;2 [10]
+    pop     YH              ;2 [11] undo the push from before
+    rjmp    waitForK        ;2 [13] this was not the end of sync, retry
+haveTwoBitsK:
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+    push    shift           ;2 [16]
+    push    x1              ;2 [12]
+    push    x2              ;2 [14]
+
+    in      x1, USBIN       ;1 [17] <-- sample bit 0
+    ldi     shift, 0xff     ;1 [18]
+    bst     x1, USBMINUS    ;1 [19]
+    bld     shift, 0        ;1 [20]
+    push    x3              ;2 [22]
+    push    cnt             ;2 [24]
+    
+    in      x2, USBIN       ;1 [25] <-- sample bit 1
+    ser     x3              ;1 [26] [inserted init instruction]
+    eor     x1, x2          ;1 [27]
+    bst     x1, USBMINUS    ;1 [28]
+    bld     shift, 1        ;1 [29]
+    ldi     cnt, USB_BUFSIZE;1 [30] [inserted init instruction]
+    rjmp    rxbit2          ;2 [32]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+
+unstuff0:               ;1 (branch taken)
+    andi    x3, ~0x01   ;1 [15]
+    mov     x1, x2      ;1 [16] x2 contains last sampled (stuffed) bit
+    in      x2, USBIN   ;1 [17] <-- sample bit 1 again
+    ori     shift, 0x01 ;1 [18]
+    rjmp    didUnstuff0 ;2 [20]
+
+unstuff1:               ;1 (branch taken)
+    mov     x2, x1      ;1 [21] x1 contains last sampled (stuffed) bit
+    andi    x3, ~0x02   ;1 [22]
+    ori     shift, 0x02 ;1 [23]
+    nop                 ;1 [24]
+    in      x1, USBIN   ;1 [25] <-- sample bit 2 again
+    rjmp    didUnstuff1 ;2 [27]
+
+unstuff2:               ;1 (branch taken)
+    andi    x3, ~0x04   ;1 [29]
+    ori     shift, 0x04 ;1 [30]
+    mov     x1, x2      ;1 [31] x2 contains last sampled (stuffed) bit
+    nop                 ;1 [32]
+    in      x2, USBIN   ;1 [33] <-- sample bit 3
+    rjmp    didUnstuff2 ;2 [35]
+
+unstuff3:               ;1 (branch taken)
+    in      x2, USBIN   ;1 [34] <-- sample stuffed bit 3 [one cycle too late]
+    andi    x3, ~0x08   ;1 [35]
+    ori     shift, 0x08 ;1 [36]
+    rjmp    didUnstuff3 ;2 [38]
+
+unstuff4:               ;1 (branch taken)
+    andi    x3, ~0x10   ;1 [40]
+    in      x1, USBIN   ;1 [41] <-- sample stuffed bit 4
+    ori     shift, 0x10 ;1 [42]
+    rjmp    didUnstuff4 ;2 [44]
+
+unstuff5:               ;1 (branch taken)
+    andi    x3, ~0x20   ;1 [48]
+    in      x2, USBIN   ;1 [49] <-- sample stuffed bit 5
+    ori     shift, 0x20 ;1 [50]
+    rjmp    didUnstuff5 ;2 [52]
+
+unstuff6:               ;1 (branch taken)
+    andi    x3, ~0x40   ;1 [56]
+    in      x1, USBIN   ;1 [57] <-- sample stuffed bit 6
+    ori     shift, 0x40 ;1 [58]
+    rjmp    didUnstuff6 ;2 [60]
+
+; extra jobs done during bit interval:
+; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs]
+; bit 1:    se0 check
+; bit 2:    overflow check
+; bit 3:    recovery from delay [bit 0 tasks took too long]
+; bit 4:    none
+; bit 5:    none
+; bit 6:    none
+; bit 7:    jump, eor
+rxLoop:
+    eor     x3, shift   ;1 [0] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    in      x1, USBIN   ;1 [1] <-- sample bit 0
+    st      y+, x3      ;2 [3] store data
+    ser     x3          ;1 [4]
+    nop                 ;1 [5]
+    eor     x2, x1      ;1 [6]
+    bst     x2, USBMINUS;1 [7]
+    bld     shift, 0    ;1 [8]
+    in      x2, USBIN   ;1 [9] <-- sample bit 1 (or possibly bit 0 stuffed)
+    andi    x2, USBMASK ;1 [10]
+    breq    se0         ;1 [11] SE0 check for bit 1
+    andi    shift, 0xf9 ;1 [12]
+didUnstuff0:
+    breq    unstuff0    ;1 [13]
+    eor     x1, x2      ;1 [14]
+    bst     x1, USBMINUS;1 [15]
+    bld     shift, 1    ;1 [16]
+rxbit2:
+    in      x1, USBIN   ;1 [17] <-- sample bit 2 (or possibly bit 1 stuffed)
+    andi    shift, 0xf3 ;1 [18]
+    breq    unstuff1    ;1 [19] do remaining work for bit 1
+didUnstuff1:
+    subi    cnt, 1      ;1 [20]
+    brcs    overflow    ;1 [21] loop control
+    eor     x2, x1      ;1 [22]
+    bst     x2, USBMINUS;1 [23]
+    bld     shift, 2    ;1 [24]
+    in      x2, USBIN   ;1 [25] <-- sample bit 3 (or possibly bit 2 stuffed)
+    andi    shift, 0xe7 ;1 [26]
+    breq    unstuff2    ;1 [27]
+didUnstuff2:
+    eor     x1, x2      ;1 [28]
+    bst     x1, USBMINUS;1 [29]
+    bld     shift, 3    ;1 [30]
+didUnstuff3:
+    andi    shift, 0xcf ;1 [31]
+    breq    unstuff3    ;1 [32]
+    in      x1, USBIN   ;1 [33] <-- sample bit 4
+    eor     x2, x1      ;1 [34]
+    bst     x2, USBMINUS;1 [35]
+    bld     shift, 4    ;1 [36]
+didUnstuff4:
+    andi    shift, 0x9f ;1 [37]
+    breq    unstuff4    ;1 [38]
+    nop2                ;2 [40]
+    in      x2, USBIN   ;1 [41] <-- sample bit 5
+    eor     x1, x2      ;1 [42]
+    bst     x1, USBMINUS;1 [43]
+    bld     shift, 5    ;1 [44]
+didUnstuff5:
+    andi    shift, 0x3f ;1 [45]
+    breq    unstuff5    ;1 [46]
+    nop2                ;2 [48]
+    in      x1, USBIN   ;1 [49] <-- sample bit 6
+    eor     x2, x1      ;1 [50]
+    bst     x2, USBMINUS;1 [51]
+    bld     shift, 6    ;1 [52]
+didUnstuff6:
+    cpi     shift, 0x02 ;1 [53]
+    brlo    unstuff6    ;1 [54]
+    nop2                ;2 [56]
+    in      x2, USBIN   ;1 [57] <-- sample bit 7
+    eor     x1, x2      ;1 [58]
+    bst     x1, USBMINUS;1 [59]
+    bld     shift, 7    ;1 [60]
+didUnstuff7:
+    cpi     shift, 0x04 ;1 [61]
+    brsh    rxLoop      ;2 [63] loop control
+unstuff7:
+    andi    x3, ~0x80   ;1 [63]
+    ori     shift, 0x80 ;1 [64]
+    in      x2, USBIN   ;1 [65] <-- sample stuffed bit 7
+    nop                 ;1 [66]
+    rjmp    didUnstuff7 ;2 [68]
+
+macro POP_STANDARD ; 12 cycles
+    pop     cnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;----------------------------------------------------------------------------
+; Transmitting data
+;----------------------------------------------------------------------------
+
+txByteLoop:
+txBitloop:
+stuffN1Delay:                   ;     [03]
+    ror     shift               ;[-5] [11] [59]
+    brcc    doExorN1            ;[-4]      [60]
+    subi    x4, 1               ;[-3]
+    brne    commonN1            ;[-2]
+    lsl     shift               ;[-1] compensate ror after rjmp stuffDelay
+    nop                         ;[00] stuffing consists of just waiting 8 cycles
+    rjmp    stuffN1Delay        ;[01] after ror, C bit is reliably clear
+
+sendNakAndReti:                 ;0 [-19] 19 cycles until SOP
+    ldi     x3, USBPID_NAK      ;1 [-18]
+    rjmp    usbSendX3           ;2 [-16]
+sendAckAndReti:                 ;0 [-19] 19 cycles until SOP
+    ldi     x3, USBPID_ACK      ;1 [-18]
+    rjmp    usbSendX3           ;2 [-16]
+sendCntAndReti:                 ;0 [-17] 17 cycles until SOP
+    mov     x3, cnt             ;1 [-16]
+usbSendX3:                      ;0 [-16]
+    ldi     YL, 20              ;1 [-15] 'x3' is R20
+    ldi     YH, 0               ;1 [-14]
+    ldi     cnt, 2              ;1 [-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
+; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
+; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte
+;uses: x1...x2, x4, shift, cnt, Y [x1 = mirror USBOUT, x2 = USBMASK, x4 = bitstuff cnt]
+;Numbers in brackets are time since first bit of sync pattern is sent (start of instruction)
+usbSendAndReti:
+    in      x2, USBDDR          ;[-12] 12 cycles until SOP
+    ori     x2, USBMASK         ;[-11]
+    sbi     USBOUT, USBMINUS    ;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    out     USBDDR, x2          ;[-8] <--- acquire bus
+    in      x1, USBOUT          ;[-7] port mirror for tx loop
+    ldi     shift, 0x40         ;[-6] sync byte is first byte sent (we enter loop after ror)
+    ldi     x2, USBMASK         ;[-5]
+    push    x4                  ;[-4]
+doExorN1:
+    eor     x1, x2              ;[-2] [06] [62]
+    ldi     x4, 6               ;[-1] [07] [63]
+commonN1:
+stuffN2Delay:
+    out     USBOUT, x1          ;[00] [08] [64] <--- set bit
+    ror     shift               ;[01]
+    brcc    doExorN2            ;[02]
+    subi    x4, 1               ;[03]
+    brne    commonN2            ;[04]
+    lsl     shift               ;[05] compensate ror after rjmp stuffDelay
+    rjmp    stuffN2Delay        ;[06] after ror, C bit is reliably clear
+doExorN2:
+    eor     x1, x2              ;[04] [12]
+    ldi     x4, 6               ;[05] [13]
+commonN2:
+    nop                         ;[06] [14]
+    subi    cnt, 171            ;[07] [15] trick: (3 * 171) & 0xff = 1
+    out     USBOUT, x1          ;[08] [16] <--- set bit
+    brcs    txBitloop           ;[09]      [25] [41]
+
+stuff6Delay:
+    ror     shift               ;[42] [50]
+    brcc    doExor6             ;[43]
+    subi    x4, 1               ;[44]
+    brne    common6             ;[45]
+    lsl     shift               ;[46] compensate ror after rjmp stuffDelay
+    nop                         ;[47] stuffing consists of just waiting 8 cycles
+    rjmp    stuff6Delay         ;[48] after ror, C bit is reliably clear
+doExor6:
+    eor     x1, x2              ;[45] [53]
+    ldi     x4, 6               ;[46]
+common6:
+stuff7Delay:
+    ror     shift               ;[47] [55]
+    out     USBOUT, x1          ;[48] <--- set bit
+    brcc    doExor7             ;[49]
+    subi    x4, 1               ;[50]
+    brne    common7             ;[51]
+    lsl     shift               ;[52] compensate ror after rjmp stuffDelay
+    rjmp    stuff7Delay         ;[53] after ror, C bit is reliably clear
+doExor7:
+    eor     x1, x2              ;[51] [59]
+    ldi     x4, 6               ;[52]
+common7:
+    ld      shift, y+           ;[53]
+    tst     cnt                 ;[55]
+    out     USBOUT, x1          ;[56] <--- set bit
+    brne    txByteLoop          ;[57]
+
+;make SE0:
+    cbr     x1, USBMASK         ;[58] prepare SE0 [spec says EOP may be 15 to 18 cycles]
+    lds     x2, usbNewDeviceAddr;[59]
+    lsl     x2                  ;[61] we compare with left shifted address
+    subi    YL, 2 + 20          ;[62] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0               ;[63]
+    out     USBOUT, x1          ;[00] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign      ;[01]
+    sts     usbDeviceAddr, x2   ; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[03] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)       ;[04]
+    ori     x1, USBIDLE         ;[05]
+    in      x2, USBDDR          ;[06]
+    cbr     x2, USBMASK         ;[07] set both pins to input
+    mov     x3, x1              ;[08]
+    cbr     x3, USBMASK         ;[09] configure no pullup on both pins
+    pop     x4                  ;[10]
+    nop2                        ;[12]
+    nop2                        ;[14]
+    out     USBOUT, x1          ;[16] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2          ;[17] <-- release bus now
+    out     USBOUT, x3          ;[18] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: usbdrv/usbdrvasm128.inc
===================================================================
--- usbdrv/usbdrvasm128.inc	(nonexistent)
+++ usbdrv/usbdrvasm128.inc	(working copy)
@@ -0,0 +1,749 @@
+/* Name: usbdrvasm128.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-10-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 12.8 MHz version of the USB driver. It is intended for use
+with the internal RC oscillator. Although 12.8 MHz is outside the guaranteed
+calibration range of the oscillator, almost all AVRs can reach this frequency.
+This version contains a phase locked loop in the receiver routine to cope with
+slight clock rate deviations of up to +/- 1%.
+
+See usbdrv.h for a description of the entire driver.
+
+LIMITATIONS
+===========
+Although it may seem very handy to save the crystal and use the internal
+RC oscillator of the CPU, this method (and this module) has some serious
+limitations:
+(1) The guaranteed calibration range of the oscillator is only 8.1 MHz.
+They typical range is 14.5 MHz and most AVRs can actually reach this rate.
+(2) Writing EEPROM and Flash may be unreliable (short data lifetime) since
+the write procedure is timed from the RC oscillator.
+(3) End Of Packet detection (SE0) should be in bit 1, bit it is only checked
+if bits 0 and 1 both read as 0 on D- and D+ read as 0 in the middle. This may
+cause problems with old hubs which delay SE0 by up to one cycle.
+(4) Code size is much larger than that of the other modules.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+
+Implementation notes:
+======================
+min frequency: 67 cycles for 8 bit -> 12.5625 MHz
+max frequency: 69.286 cycles for 8 bit -> 12.99 MHz
+nominal frequency: 12.77 MHz ( = sqrt(min * max))
+
+sampling positions: (next even number in range [+/- 0.5])
+cycle index range: 0 ... 66
+bits:
+.5, 8.875, 17.25, 25.625, 34, 42.375, 50.75, 59.125
+[0/1], [9], [17], [25/+26], [34], [+42/43], [51], [59]
+
+bit number:     0   1   2   3   4   5   6   7
+spare cycles    1   2   1   2   1   1   1   0
+
+operations to perform:      duration cycle
+                            ----------------
+    eor     fix, shift          1 -> 00
+    andi    phase, USBMASK      1 -> 08
+    breq    se0                 1 -> 16 (moved to 11)
+    st      y+, data            2 -> 24, 25
+    mov     data, fix           1 -> 33
+    ser     data                1 -> 41
+    subi    cnt, 1              1 -> 49
+    brcs    overflow            1 -> 50
+
+layout of samples and operations:
+[##] = sample bit
+<##> = sample phase
+*##* = operation
+
+0:  *00* [01]  02   03   04  <05>  06   07
+1:  *08* [09]  10   11   12  <13>  14   15  *16*
+2:  [17]  18   19   20  <21>  22   23
+3:  *24* *25* [26]  27   28   29  <30>  31   32
+4:  *33* [34]  35   36   37  <38>  39   40
+5:  *41* [42]  43   44   45  <46>  47   48
+6:  *49* *50* [51]  52   53   54  <55>  56   57   58
+7:  [59]  60   61   62  <63>  64   65   66
+*****************************************************************************/
+
+/* we prefer positive expressions (do if condition) instead of negative
+ * (skip if condition), therefore use defines for skip instructions:
+ */
+#define ifioclr sbis
+#define ifioset sbic
+#define ifrclr  sbrs
+#define ifrset  sbrc
+
+/* The registers "fix" and "data" swap their meaning during the loop. Use
+ * defines to keep their name constant.
+ */
+#define fix     x2
+#define data    x1
+#undef phase        /* phase has a default definition to x4 */
+#define phase   x3
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt, r0
+    push    YL              ;2 push only what is necessary to sync with edge ASAP
+    in      YL, SREG        ;1
+    push    YL              ;2
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS ;[0]
+    rjmp    foundK          ;[1]
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+
+foundK:
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    YH                  ;[2]
+    lds     YL, usbInputBufOffset;[4]
+    clr     YH                  ;[6]
+    subi    YL, lo8(-(usbRxBuf));[7]
+    sbci    YH, hi8(-(usbRxBuf));[8]
+
+    sbis    USBIN, USBMINUS     ;[9] we want two bits K [we want to sample at 8 + 4 - 1.5 = 10.5]
+    rjmp    haveTwoBitsK        ;[10]
+    pop     YH                  ;[11] undo the push from before
+    rjmp    waitForK            ;[13] this was not the end of sync, retry
+haveTwoBitsK:
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+#define fix     x2
+#define data    x1
+
+    push    shift               ;[12]
+    push    x1                  ;[14]
+    push    x2                  ;[16]
+    ldi     shift, 0x80         ;[18] prevent bit-unstuffing but init low bits to 0
+    ifioset USBIN, USBMINUS     ;[19] [01] <--- bit 0 [10.5 + 8 = 18.5]
+    ori     shift, 1<<0         ;[02]
+    push    x3                  ;[03]
+    push    cnt                 ;[05]
+    push    r0                  ;[07]
+    ifioset USBIN, USBMINUS     ;[09] <--- bit 1
+    ori     shift, 1<<1         ;[10]
+    ser     fix                 ;[11]
+    ldi     cnt, USB_BUFSIZE    ;[12]
+    mov     data, shift         ;[13]
+    lsl     shift               ;[14]
+    nop2                        ;[15]
+    ifioset USBIN, USBMINUS     ;[17] <--- bit 2
+    ori     data, 3<<2          ;[18] store in bit 2 AND bit 3
+    eor     shift, data         ;[19] do nrzi decoding
+    andi    data, 1<<3          ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    brne    jumpToEntryAfterSet ;[22] if USBMINS at bit 3 was 1
+    nop                         ;[23]
+    rjmp    entryAfterClr       ;[24]
+jumpToEntryAfterSet:
+    rjmp    entryAfterSet       ;[24]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+#undef  fix
+#define  fix    x1
+#undef  data
+#define data    x2
+
+bit7IsSet:
+    ifrclr  phase, USBMINUS     ;[62] check phase only if D- changed
+    lpm                         ;[63]
+    in      phase, USBIN        ;[64] <- phase (one cycle too late)
+    ori     shift, 1 << 7       ;[65]
+    nop                         ;[66]
+;;;;rjmp    bit0AfterSet        ; -> [00] == [67] moved block up to save jump
+bit0AfterSet:
+    eor     fix, shift          ;[00]
+#undef  fix
+#define fix     x2
+#undef  data
+#define data    x1  /* we now have result in data, fix is reset to 0xff */
+    ifioclr USBIN, USBMINUS     ;[01] <--- sample 0
+    rjmp    bit0IsClr           ;[02]
+    andi    shift, ~(7 << 0)    ;[03]
+    breq    unstuff0s           ;[04]
+    in      phase, USBIN        ;[05] <- phase
+    rjmp    bit1AfterSet        ;[06]
+unstuff0s:
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    andi    fix, ~(1 << 0)      ;[07]
+    ifioclr USBIN, USBMINUS     ;[00]
+    ifioset USBIN, USBPLUS      ;[01]
+    rjmp    bit0IsClr           ;[02] executed if first expr false or second true
+se0AndStore:                    ; executed only if both bits 0
+    st      y+, x1              ;[15/17] cycles after start of byte
+    rjmp    se0                 ;[17/19]
+
+bit0IsClr:
+    ifrset  phase, USBMINUS     ;[04] check phase only if D- changed
+    lpm                         ;[05]
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    ori     shift, 1 << 0       ;[07]
+bit1AfterClr:
+    andi    phase, USBMASK      ;[08]
+    ifioset USBIN, USBMINUS     ;[09] <--- sample 1
+    rjmp    bit1IsSet           ;[10]
+    breq    se0AndStore         ;[11] if D- was 0 in bits 0 AND 1 and D+ was 0 in between, we have SE0
+    andi    shift, ~(7 << 1)    ;[12]
+    in      phase, USBIN        ;[13] <- phase
+    breq    unstuff1c           ;[14]
+    rjmp    bit2AfterClr        ;[15]
+unstuff1c:
+    andi    fix, ~(1 << 1)      ;[16]
+    nop2                        ;[08]
+    nop2                        ;[10]
+bit1IsSet:
+    ifrclr  phase, USBMINUS     ;[12] check phase only if D- changed
+    lpm                         ;[13]
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    ori     shift, 1 << 1       ;[15]
+    nop                         ;[16]
+bit2AfterSet:
+    ifioclr USBIN, USBMINUS     ;[17] <--- sample 2
+    rjmp    bit2IsClr           ;[18]
+    andi    shift, ~(7 << 2)    ;[19]
+    breq    unstuff2s           ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    rjmp    bit3AfterSet        ;[22]
+unstuff2s:
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    andi    fix, ~(1 << 2)      ;[23]
+    nop2                        ;[16]
+    nop2                        ;[18]
+bit2IsClr:
+    ifrset  phase, USBMINUS     ;[20] check phase only if D- changed
+    lpm                         ;[21]
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    ori     shift, 1 << 2       ;[23]
+bit3AfterClr:
+    st      y+, data            ;[24]
+entryAfterClr:
+    ifioset USBIN, USBMINUS     ;[26] <--- sample 3
+    rjmp    bit3IsSet           ;[27]
+    andi    shift, ~(7 << 3)    ;[28]
+    breq    unstuff3c           ;[29]
+    in      phase, USBIN        ;[30] <- phase
+    rjmp    bit4AfterClr        ;[31]
+unstuff3c:
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    andi    fix, ~(1 << 3)      ;[32]
+    nop2                        ;[25]
+    nop2                        ;[27]
+bit3IsSet:
+    ifrclr  phase, USBMINUS     ;[29] check phase only if D- changed
+    lpm                         ;[30]
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    ori     shift, 1 << 3       ;[32]
+bit4AfterSet:
+    mov     data, fix           ;[33] undo this move by swapping defines
+#undef  fix
+#define fix     x1
+#undef  data
+#define data    x2
+    ifioclr USBIN, USBMINUS     ;[34] <--- sample 4
+    rjmp    bit4IsClr           ;[35]
+    andi    shift, ~(7 << 4)    ;[36]
+    breq    unstuff4s           ;[37]
+    in      phase, USBIN        ;[38] <- phase
+    rjmp    bit5AfterSet        ;[39]
+unstuff4s:
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    andi    fix, ~(1 << 4)      ;[40]
+    nop2                        ;[33]
+    nop2                        ;[35]
+bit4IsClr:
+    ifrset  phase, USBMINUS     ;[37] check phase only if D- changed
+    lpm                         ;[38]
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    ori     shift, 1 << 4       ;[40]
+bit5AfterClr:
+    ser     data                ;[41]
+    ifioset USBIN, USBMINUS     ;[42] <--- sample 5
+    rjmp    bit5IsSet           ;[43]
+    andi    shift, ~(7 << 5)    ;[44]
+    breq    unstuff5c           ;[45]
+    in      phase, USBIN        ;[46] <- phase
+    rjmp    bit6AfterClr        ;[47]
+unstuff5c:
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    andi    fix, ~(1 << 5)      ;[48]
+    nop2                        ;[41]
+    nop2                        ;[43]
+bit5IsSet:
+    ifrclr  phase, USBMINUS     ;[45] check phase only if D- changed
+    lpm                         ;[46]
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    ori     shift, 1 << 5       ;[48]
+bit6AfterSet:
+    subi    cnt, 1              ;[49]
+    brcs    jumpToOverflow      ;[50]
+    ifioclr USBIN, USBMINUS     ;[51] <--- sample 6
+    rjmp    bit6IsClr           ;[52]
+    andi    shift, ~(3 << 6)    ;[53]
+    cpi     shift, 2            ;[54]
+    in      phase, USBIN        ;[55] <- phase
+    brlt    unstuff6s           ;[56]
+    rjmp    bit7AfterSet        ;[57]
+
+jumpToOverflow:
+    rjmp    overflow
+
+unstuff6s:
+    andi    fix, ~(1 << 6)      ;[50]
+    lpm                         ;[51]
+bit6IsClr:
+    ifrset  phase, USBMINUS     ;[54] check phase only if D- changed
+    lpm                         ;[55]
+    in      phase, USBIN        ;[56] <- phase (one cycle too late)
+    ori     shift, 1 << 6       ;[57]
+    nop                         ;[58]
+bit7AfterClr:
+    ifioset USBIN, USBMINUS     ;[59] <--- sample 7
+    rjmp    bit7IsSet           ;[60]
+    andi    shift, ~(1 << 7)    ;[61]
+    cpi     shift, 4            ;[62]
+    in      phase, USBIN        ;[63] <- phase
+    brlt    unstuff7c           ;[64]
+    rjmp    bit0AfterClr        ;[65] -> [00] == [67]
+unstuff7c:
+    andi    fix, ~(1 << 7)      ;[58]
+    nop                         ;[59]
+    rjmp    bit7IsSet           ;[60]
+
+bit7IsClr:
+    ifrset  phase, USBMINUS     ;[62] check phase only if D- changed
+    lpm                         ;[63]
+    in      phase, USBIN        ;[64] <- phase (one cycle too late)
+    ori     shift, 1 << 7       ;[65]
+    nop                         ;[66]
+;;;;rjmp    bit0AfterClr        ; -> [00] == [67] moved block up to save jump
+bit0AfterClr:
+    eor     fix, shift          ;[00]
+#undef  fix
+#define fix     x2
+#undef  data
+#define data    x1  /* we now have result in data, fix is reset to 0xff */
+    ifioset USBIN, USBMINUS     ;[01] <--- sample 0
+    rjmp    bit0IsSet           ;[02]
+    andi    shift, ~(7 << 0)    ;[03]
+    breq    unstuff0c           ;[04]
+    in      phase, USBIN        ;[05] <- phase
+    rjmp    bit1AfterClr        ;[06]
+unstuff0c:
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    andi    fix, ~(1 << 0)      ;[07]
+    ifioclr USBIN, USBMINUS     ;[00]
+    ifioset USBIN, USBPLUS      ;[01]
+    rjmp    bit0IsSet           ;[02] executed if first expr false or second true
+    rjmp    se0AndStore         ;[03] executed only if both bits 0
+bit0IsSet:
+    ifrclr  phase, USBMINUS     ;[04] check phase only if D- changed
+    lpm                         ;[05]
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    ori     shift, 1 << 0       ;[07]
+bit1AfterSet:
+    andi    shift, ~(7 << 1)    ;[08] compensated by "ori shift, 1<<1" if bit1IsClr
+    ifioclr USBIN, USBMINUS     ;[09] <--- sample 1
+    rjmp    bit1IsClr           ;[10]
+    breq    unstuff1s           ;[11]
+    nop2                        ;[12] do not check for SE0 if bit 0 was 1
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    rjmp    bit2AfterSet        ;[15]
+unstuff1s:
+    in      phase, USBIN        ;[13] <- phase
+    andi    fix, ~(1 << 1)      ;[14]
+    lpm                         ;[07]
+    nop2                        ;[10]
+bit1IsClr:
+    ifrset  phase, USBMINUS     ;[12] check phase only if D- changed
+    lpm                         ;[13]
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    ori     shift, 1 << 1       ;[15]
+    nop                         ;[16]
+bit2AfterClr:
+    ifioset USBIN, USBMINUS     ;[17] <--- sample 2
+    rjmp    bit2IsSet           ;[18]
+    andi    shift, ~(7 << 2)    ;[19]
+    breq    unstuff2c           ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    rjmp    bit3AfterClr        ;[22]
+unstuff2c:
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    andi    fix, ~(1 << 2)      ;[23]
+    nop2                        ;[16]
+    nop2                        ;[18]
+bit2IsSet:
+    ifrclr  phase, USBMINUS     ;[20] check phase only if D- changed
+    lpm                         ;[21]
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    ori     shift, 1 << 2       ;[23]
+bit3AfterSet:
+    st      y+, data            ;[24]
+entryAfterSet:
+    ifioclr USBIN, USBMINUS     ;[26] <--- sample 3
+    rjmp    bit3IsClr           ;[27]
+    andi    shift, ~(7 << 3)    ;[28]
+    breq    unstuff3s           ;[29]
+    in      phase, USBIN        ;[30] <- phase
+    rjmp    bit4AfterSet        ;[31]
+unstuff3s:
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    andi    fix, ~(1 << 3)      ;[32]
+    nop2                        ;[25]
+    nop2                        ;[27]
+bit3IsClr:
+    ifrset  phase, USBMINUS     ;[29] check phase only if D- changed
+    lpm                         ;[30]
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    ori     shift, 1 << 3       ;[32]
+bit4AfterClr:
+    mov     data, fix           ;[33] undo this move by swapping defines
+#undef  fix
+#define fix     x1
+#undef  data
+#define data    x2
+    ifioset USBIN, USBMINUS     ;[34] <--- sample 4
+    rjmp    bit4IsSet           ;[35]
+    andi    shift, ~(7 << 4)    ;[36]
+    breq    unstuff4c           ;[37]
+    in      phase, USBIN        ;[38] <- phase
+    rjmp    bit5AfterClr        ;[39]
+unstuff4c:
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    andi    fix, ~(1 << 4)      ;[40]
+    nop2                        ;[33]
+    nop2                        ;[35]
+bit4IsSet:
+    ifrclr  phase, USBMINUS     ;[37] check phase only if D- changed
+    lpm                         ;[38]
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    ori     shift, 1 << 4       ;[40]
+bit5AfterSet:
+    ser     data                ;[41]
+    ifioclr USBIN, USBMINUS     ;[42] <--- sample 5
+    rjmp    bit5IsClr           ;[43]
+    andi    shift, ~(7 << 5)    ;[44]
+    breq    unstuff5s           ;[45]
+    in      phase, USBIN        ;[46] <- phase
+    rjmp    bit6AfterSet        ;[47]
+unstuff5s:
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    andi    fix, ~(1 << 5)      ;[48]
+    nop2                        ;[41]
+    nop2                        ;[43]
+bit5IsClr:
+    ifrset  phase, USBMINUS     ;[45] check phase only if D- changed
+    lpm                         ;[46]
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    ori     shift, 1 << 5       ;[48]
+bit6AfterClr:
+    subi    cnt, 1              ;[49]
+    brcs    overflow            ;[50]
+    ifioset USBIN, USBMINUS     ;[51] <--- sample 6
+    rjmp    bit6IsSet           ;[52]
+    andi    shift, ~(3 << 6)    ;[53]
+    cpi     shift, 2            ;[54]
+    in      phase, USBIN        ;[55] <- phase
+    brlt    unstuff6c           ;[56]
+    rjmp    bit7AfterClr        ;[57]
+unstuff6c:
+    andi    fix, ~(1 << 6)      ;[50]
+    lpm                         ;[51]
+bit6IsSet:
+    ifrclr  phase, USBMINUS     ;[54] check phase only if D- changed
+    lpm                         ;[55]
+    in      phase, USBIN        ;[56] <- phase (one cycle too late)
+    ori     shift, 1 << 6       ;[57]
+bit7AfterSet:
+    ifioclr USBIN, USBMINUS     ;[59] <--- sample 7
+    rjmp    bit7IsClr           ;[60]
+    andi    shift, ~(1 << 7)    ;[61]
+    cpi     shift, 4            ;[62]
+    in      phase, USBIN        ;[63] <- phase
+    brlt    unstuff7s           ;[64]
+    rjmp    bit0AfterSet        ;[65] -> [00] == [67]
+unstuff7s:
+    andi    fix, ~(1 << 7)      ;[58]
+    nop                         ;[59]
+    rjmp    bit7IsClr           ;[60]
+
+macro POP_STANDARD ; 14 cycles
+    pop     r0
+    pop     cnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;----------------------------------------------------------------------------
+; Transmitting data
+;----------------------------------------------------------------------------
+
+txByteLoop:
+txBitloop:
+stuffN1Delay:                   ;     [03]
+    ror     shift               ;[-5] [11] [63]
+    brcc    doExorN1            ;[-4]      [64]
+    subi    x3, 1               ;[-3]
+    brne    commonN1            ;[-2]
+    lsl     shift               ;[-1] compensate ror after rjmp stuffDelay
+    nop                         ;[00] stuffing consists of just waiting 8 cycles
+    rjmp    stuffN1Delay        ;[01] after ror, C bit is reliably clear
+
+sendNakAndReti:
+    ldi     cnt, USBPID_NAK ;[-19]
+    rjmp    sendCntAndReti  ;[-18]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     r0, cnt         ;[-16]
+    ldi     YL, 0           ;[-15] R0 address is 0
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
+; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
+; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte
+;uses: x1...x3, shift, cnt, Y [x1 = mirror USBOUT, x2 = USBMASK, x3 = bitstuff cnt]
+;Numbers in brackets are time since first bit of sync pattern is sent (start of instruction)
+usbSendAndReti:
+    in      x2, USBDDR          ;[-10] 10 cycles until SOP
+    ori     x2, USBMASK         ;[-9]
+    sbi     USBOUT, USBMINUS    ;[-8] prepare idle state; D+ and D- must have been 0 (no pullups)
+    out     USBDDR, x2          ;[-6] <--- acquire bus
+    in      x1, USBOUT          ;[-5] port mirror for tx loop
+    ldi     shift, 0x40         ;[-4] sync byte is first byte sent (we enter loop after ror)
+    ldi     x2, USBMASK         ;[-3]
+doExorN1:
+    eor     x1, x2              ;[-2] [06] [62]
+    ldi     x3, 6               ;[-1] [07] [63]
+commonN1:
+stuffN2Delay:
+    out     USBOUT, x1          ;[00] [08] [64] <--- set bit
+    ror     shift               ;[01]
+    brcc    doExorN2            ;[02]
+    subi    x3, 1               ;[03]
+    brne    commonN2            ;[04]
+    lsl     shift               ;[05] compensate ror after rjmp stuffDelay
+    rjmp    stuffN2Delay        ;[06] after ror, C bit is reliably clear
+doExorN2:
+    eor     x1, x2              ;[04] [12]
+    ldi     x3, 6               ;[05] [13]
+commonN2:
+    nop2                        ;[06] [14]
+    subi    cnt, 171            ;[08] [16] trick: (3 * 171) & 0xff = 1
+    out     USBOUT, x1          ;[09] [17] <--- set bit
+    brcs    txBitloop           ;[10]      [27] [44]
+
+stuff6Delay:
+    ror     shift               ;[45] [53]
+    brcc    doExor6             ;[46]
+    subi    x3, 1               ;[47]
+    brne    common6             ;[48]
+    lsl     shift               ;[49] compensate ror after rjmp stuffDelay
+    nop                         ;[50] stuffing consists of just waiting 8 cycles
+    rjmp    stuff6Delay         ;[51] after ror, C bit is reliably clear
+doExor6:
+    eor     x1, x2              ;[48] [56]
+    ldi     x3, 6               ;[49]
+common6:
+stuff7Delay:
+    ror     shift               ;[50] [58]
+    out     USBOUT, x1          ;[51] <--- set bit
+    brcc    doExor7             ;[52]
+    subi    x3, 1               ;[53]
+    brne    common7             ;[54]
+    lsl     shift               ;[55] compensate ror after rjmp stuffDelay
+    rjmp    stuff7Delay         ;[56] after ror, C bit is reliably clear
+doExor7:
+    eor     x1, x2              ;[54] [62]
+    ldi     x3, 6               ;[55]
+common7:
+    ld      shift, y+           ;[56]
+    nop                         ;[58]
+    tst     cnt                 ;[59]
+    out     USBOUT, x1          ;[60] [00]<--- set bit
+    brne    txByteLoop          ;[61] [01]
+;make SE0:
+    cbr     x1, USBMASK         ;[02] prepare SE0 [spec says EOP may be 15 to 18 cycles]
+    lds     x2, usbNewDeviceAddr;[03]
+    lsl     x2                  ;[05] we compare with left shifted address
+    subi    YL, 2 + 0           ;[06] Only assign address on data packets, not ACK/NAK in r0
+    sbci    YH, 0               ;[07]
+    out     USBOUT, x1          ;[00] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign      ;[01]
+    sts     usbDeviceAddr, x2   ; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[03] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)       ;[04]
+    ori     x1, USBIDLE         ;[05]
+    in      x2, USBDDR          ;[06]
+    cbr     x2, USBMASK         ;[07] set both pins to input
+    mov     x3, x1              ;[08]
+    cbr     x3, USBMASK         ;[09] configure no pullup on both pins
+    lpm                         ;[10]
+    lpm                         ;[13]
+    out     USBOUT, x1          ;[16] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2          ;[17] <-- release bus now
+    out     USBOUT, x3          ;[18] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
+
+
+/*****************************************************************************
+The following PHP script generates a code skeleton for the receiver routine:
+
+<?php
+
+function printCmdBuffer($thisBit)
+{
+global $cycle;
+
+    $nextBit = ($thisBit + 1) % 8;
+    $s = ob_get_contents();
+    ob_end_clean();
+    $s = str_replace("#", $thisBit, $s);
+    $s = str_replace("@", $nextBit, $s);
+    $lines = explode("\n", $s);
+    for($i = 0; $i < count($lines); $i++){
+        $s = $lines[$i];
+        if(ereg("\\[([0-9-][0-9])\\]", $s, $regs)){
+            $c = $cycle + (int)$regs[1];
+            $s = ereg_replace("\\[[0-9-][0-9]\\]", sprintf("[%02d]", $c), $s);
+        }
+        if(strlen($s) > 0)
+            echo "$s\n";
+    }
+}
+
+function printBit($isAfterSet, $bitNum)
+{
+    ob_start();
+    if($isAfterSet){
+?>
+    ifioclr USBIN, USBMINUS     ;[00] <--- sample
+    rjmp    bit#IsClr           ;[01]
+    andi    shift, ~(7 << #)    ;[02]
+    breq    unstuff#s           ;[03]
+    in      phase, USBIN        ;[04] <- phase
+    rjmp    bit@AfterSet        ;[05]
+unstuff#s:
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    andi    fix, ~(1 << #)      ;[06]
+    nop2                        ;[-1]
+    nop2                        ;[01]
+bit#IsClr:
+    ifrset  phase, USBMINUS     ;[03] check phase only if D- changed
+    lpm                         ;[04]
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    ori     shift, 1 << #       ;[06]
+<?php
+    }else{
+?>
+    ifioset USBIN, USBMINUS     ;[00] <--- sample
+    rjmp    bit#IsSet           ;[01]
+    andi    shift, ~(7 << #)    ;[02]
+    breq    unstuff#c           ;[03]
+    in      phase, USBIN        ;[04] <- phase
+    rjmp    bit@AfterClr        ;[05]
+unstuff#c:
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    andi    fix, ~(1 << #)      ;[06]
+    nop2                        ;[-1]
+    nop2                        ;[01]
+bit#IsSet:
+    ifrclr  phase, USBMINUS     ;[03] check phase only if D- changed
+    lpm                         ;[04]
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    ori     shift, 1 << #       ;[06]
+<?php
+    }
+    printCmdBuffer($bitNum);
+}
+
+$bitStartCycles = array(1, 9, 17, 26, 34, 42, 51, 59);
+for($i = 0; $i < 16; $i++){
+    $bit = $i % 8;
+    $emitClrCode = ($i + (int)($i / 8)) % 2;
+    $cycle = $bitStartCycles[$bit];
+    if($emitClrCode){
+        printf("bit%dAfterClr:\n", $bit);
+    }else{
+        printf("bit%dAfterSet:\n", $bit);
+    }
+    ob_start();
+    echo "    *****                       ;[-1]\n";
+    printCmdBuffer($bit);
+    printBit(!$emitClrCode, $bit);
+    if($i == 7)
+        echo "\n";
+}
+
+?>
+*****************************************************************************/
Index: usbdrv/usbdrvasm15.inc
===================================================================
--- usbdrv/usbdrvasm15.inc	(nonexistent)
+++ usbdrv/usbdrvasm15.inc	(working copy)
@@ -0,0 +1,422 @@
+/* Name: usbdrvasm15.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: contributed by V. Bosch
+ * Creation Date: 2007-08-06
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 15 MHz version of the asssembler part of the USB driver. It
+requires a 15 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 15 MHz -> 10.0 cycles per bit, 80.0 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+;----------------------------------------------------------------------------
+; order of registers pushed: 
+;	YL, SREG [sofError] YH, shift, x1, x2, x3, bitcnt, cnt, x4
+;----------------------------------------------------------------------------
+USB_INTR_VECTOR:              
+    push    YL                   ;2 	push only what is necessary to sync with edge ASAP
+    in      YL, SREG             ;1 
+    push    YL                   ;2 
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;
+;   sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;   sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+;-------------------------------------------------------------------------------
+; The following code results in a sampling window of < 1/4 bit 
+;	which meets the spec.
+;-------------------------------------------------------------------------------
+waitForK:			 ;- 
+    sbis    USBIN, USBMINUS      ;1 [00] <-- sample
+    rjmp    foundK               ;2 [01]
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+;------------------------------------------------------------------------------
+; {3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for 
+;	center sampling] 
+; 	we have 1 bit time for setup purposes, then sample again. 
+;	Numbers in brackets are cycles from center of first sync (double K) 
+;	bit after the instruction
+;------------------------------------------------------------------------------
+foundK:                          ;- [02]
+    lds     YL, usbInputBufOffset;2 [03+04]	tx loop
+    push    YH                   ;2 [05+06]
+    clr     YH                   ;1 [07]
+    subi    YL, lo8(-(usbRxBuf)) ;1 [08] 	[rx loop init]
+    sbci    YH, hi8(-(usbRxBuf)) ;1 [09] 	[rx loop init]
+    push    shift                ;2 [10+11]
+    ser	    shift		 ;1 [12]
+    sbis    USBIN, USBMINUS      ;1 [-1] [13] <--sample:we want two bits K (sample 1 cycle too early)
+    rjmp    haveTwoBitsK         ;2 [00] [14]
+    pop     shift                ;2 	 [15+16] undo the push from before
+    pop     YH 			 ;2 	 [17+18] undo the push from before
+    rjmp    waitForK             ;2 	 [19+20] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 20 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:			;- [01]
+    push    x1              	;2 [02+03]
+    push    x2              	;2 [04+05]
+    push    x3              	;2 [06+07]
+    push    bitcnt              ;2 [08+09]	
+    in      x1, USBIN       	;1 [00] [10] <-- sample bit 0
+    bst     x1, USBMINUS    	;1 [01]
+    bld     shift, 0        	;1 [02]
+    push    cnt             	;2 [03+04]
+    ldi     cnt, USB_BUFSIZE	;1 [05] 
+    push    x4              	;2 [06+07] tx loop
+    rjmp    rxLoop          	;2 [08]
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+unstuff0:               	;- [07] (branch taken)
+    andi    x3, ~0x01   	;1 [08]
+    mov     x1, x2      	;1 [09] x2 contains last sampled (stuffed) bit
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 1 again
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 1 
+    ori     shift, 0x01 	;1 [03] 0b00000001
+    nop				;1 [04]
+    rjmp    didUnstuff0 	;2 [05]
+;-----------------------------------------------------
+unstuff1:               	;- [05] (branch taken)
+    mov     x2, x1      	;1 [06] x1 contains last sampled (stuffed) bit
+    andi    x3, ~0x02   	;1 [07]
+    ori     shift, 0x02 	;1 [08] 0b00000010
+    nop                 	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 2 again
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 2 
+    rjmp    didUnstuff1 	;2 [03]
+;-----------------------------------------------------
+unstuff2:               	;- [05] (branch taken)
+    andi    x3, ~0x04   	;1 [06]
+    ori     shift, 0x04 	;1 [07] 0b00000100
+    mov     x1, x2      	;1 [08] x2 contains last sampled (stuffed) bit
+    nop                 	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 3
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 3 
+    rjmp    didUnstuff2 	;2 [03]
+;-----------------------------------------------------
+unstuff3:               	;- [00] [10]  (branch taken)
+    in      x2, USBIN   	;1 [01] [11] <-- sample stuffed bit 3 one cycle too late
+    andi    x2, USBMASK 	;1 [02]
+    breq    se0Hop         	;1 [03] SE0 check for stuffed bit 3 
+    andi    x3, ~0x08   	;1 [04]
+    ori     shift, 0x08 	;1 [05] 0b00001000
+    rjmp    didUnstuff3 	;2 [06]
+;----------------------------------------------------------------------------
+; extra jobs done during bit interval:
+;
+; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs], 
+; 		overflow check, jump to the head of rxLoop
+; bit 1:    SE0 check
+; bit 2:    SE0 check, recovery from delay [bit 0 tasks took too long]
+; bit 3:    SE0 check, recovery from delay [bit 0 tasks took too long]
+; bit 4:    SE0 check, none
+; bit 5:    SE0 check, none
+; bit 6:    SE0 check, none
+; bit 7:    SE0 check, reconstruct: x3 is 0 at bit locations we changed, 1 at others
+;----------------------------------------------------------------------------
+rxLoop:				;- [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 1 (or possibly bit 0 stuffed)
+    andi    x2, USBMASK 	;1 [01]
+    brne    SkipSe0Hop		;1 [02]
+se0Hop:				;- [02]
+    rjmp    se0         	;2 [03] SE0 check for bit 1 
+SkipSe0Hop:			;- [03]
+    ser     x3          	;1 [04]
+    andi    shift, 0xf9 	;1 [05] 0b11111001
+    breq    unstuff0    	;1 [06]
+didUnstuff0:			;- [06]
+    eor     x1, x2      	;1 [07]
+    bst     x1, USBMINUS	;1 [08]
+    bld     shift, 1    	;1 [09] 
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 2 (or possibly bit 1 stuffed)
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 2 
+    andi    shift, 0xf3 	;1 [03] 0b11110011
+    breq    unstuff1    	;1 [04] do remaining work for bit 1
+didUnstuff1:			;- [04]
+    eor     x2, x1      	;1 [05]
+    bst     x2, USBMINUS	;1 [06]
+    bld     shift, 2    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 3 (or possibly bit 2 stuffed)
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 3 
+    andi    shift, 0xe7 	;1 [03] 0b11100111
+    breq    unstuff2    	;1 [04]
+didUnstuff2:			;- [04]
+    eor     x1, x2      	;1 [05]
+    bst     x1, USBMINUS	;1 [06]
+    bld     shift, 3    	;1 [07]
+didUnstuff3:			;- [07]
+    andi    shift, 0xcf 	;1 [08] 0b11001111
+    breq    unstuff3    	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 4
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 4
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 4    	;1 [05]
+didUnstuff4:			;- [05]
+    andi    shift, 0x9f 	;1 [06] 0b10011111
+    breq    unstuff4    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 5
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 5
+    eor     x1, x2      	;1 [03]
+    bst     x1, USBMINUS	;1 [04]
+    bld     shift, 5    	;1 [05]
+didUnstuff5:			;- [05]
+    andi    shift, 0x3f 	;1 [06] 0b00111111
+    breq    unstuff5    	;1 [07]
+    nop2			;2 [08+09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 6
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 6
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 6   	 	;1 [05]
+didUnstuff6:			;- [05]
+    cpi     shift, 0x02 	;1 [06] 0b00000010
+    brlo    unstuff6    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 7
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 7
+    eor     x1, x2      	;1 [03]
+    bst     x1, USBMINUS	;1 [04]
+    bld     shift, 7    	;1 [05]
+didUnstuff7:			;- [05] 
+    cpi     shift, 0x04 	;1 [06] 0b00000100
+    brlo    unstuff7		;1 [07]
+    eor     x3, shift   	;1 [08] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    nop				;1 [09]
+    in      x1, USBIN   	;1 [00]	[10] <-- sample bit 0
+    st      y+, x3      	;2 [01+02] store data
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 0    	;1 [05]
+    subi    cnt, 1		;1 [06]
+    brcs    overflow	;1 [07]
+    rjmp    rxLoop		;2 [08]
+;-----------------------------------------------------
+unstuff4:               	;- [08] 
+    andi    x3, ~0x10   	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample stuffed bit 4
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 4
+    ori     shift, 0x10 	;1 [03]
+    rjmp    didUnstuff4 	;2 [04]
+;-----------------------------------------------------
+unstuff5:               	;- [08] 
+    ori     shift, 0x20 	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample stuffed bit 5
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 5
+    andi    x3, ~0x20   	;1 [03]
+    rjmp    didUnstuff5		;2 [04]
+;-----------------------------------------------------
+unstuff6:               	;- [08] 
+    andi    x3, ~0x40   	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample stuffed bit 6
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 6
+    ori     shift, 0x40 	;1 [03]
+    rjmp    didUnstuff6 	;2 [04]
+;-----------------------------------------------------
+unstuff7:			;- [08]
+    andi    x3, ~0x80   	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample stuffed bit 7
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 7
+    ori     shift, 0x80 	;1 [03]
+    rjmp    didUnstuff7 	;2 [04]
+    
+macro POP_STANDARD ; 16 cycles
+    pop     x4    
+    pop     cnt
+    pop     bitcnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;---------------------------------------------------------------------------
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+;---------------------------------------------------------------------------
+bitstuffN:		    	;- [04]
+    eor     x1, x4          	;1 [05]
+    clr	    x2			;1 [06]
+    nop				;1 [07]
+    rjmp    didStuffN       	;1 [08]
+;---------------------------------------------------------------------------    
+bitstuff6:		    	;- [04]
+    eor     x1, x4          	;1 [05]
+    clr	    x2			;1 [06]
+    rjmp    didStuff6       	;1 [07]
+;---------------------------------------------------------------------------
+bitstuff7:		    	;- [02]
+    eor     x1, x4          	;1 [03]
+    clr	    x2			;1 [06]
+    nop			    	;1 [05]
+    rjmp    didStuff7       	;1 [06]
+;---------------------------------------------------------------------------
+sendNakAndReti:			;- [-19]
+    ldi     x3, USBPID_NAK  	;1 [-18]
+    rjmp    sendX3AndReti   	;1 [-17]
+;---------------------------------------------------------------------------
+sendAckAndReti:			;- [-17]
+    ldi     cnt, USBPID_ACK 	;1 [-16]
+sendCntAndReti:			;- [-16]
+    mov     x3, cnt         	;1 [-15]
+sendX3AndReti:			;- [-15]
+    ldi     YL, 20          	;1 [-14] x3==r20 address is 20
+    ldi     YH, 0           	;1 [-13]
+    ldi     cnt, 2          	;1 [-12]
+;   rjmp    usbSendAndReti      fallthrough
+;---------------------------------------------------------------------------
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We need not to match the transfer rate exactly because the spec demands 
+;only 1.5% precision anyway.
+usbSendAndReti:             	;- [-13] 13 cycles until SOP
+    in      x2, USBDDR      	;1 [-12]
+    ori     x2, USBMASK     	;1 [-11]
+    sbi     USBOUT, USBMINUS	;2 [-09-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      	;1 [-08] port mirror for tx loop
+    out     USBDDR, x2      	;1 [-07] <- acquire bus
+	; need not init x2 (bitstuff history) because sync starts with 0 
+    ldi     x4, USBMASK     	;1 [-06] 	exor mask
+    ldi     shift, 0x80     	;1 [-05] 	sync byte is first byte sent
+    ldi     bitcnt, 6    	;1 [-04] 
+txBitLoop:		    	;- [-04] [06]
+    sbrs    shift, 0        	;1 [-03] [07]
+    eor     x1, x4          	;1 [-02] [08] 
+    ror     shift           	;1 [-01] [09]  
+didStuffN:		    	;-       [09]
+    out     USBOUT, x1      	;1 [00]  [10] <-- out N
+    ror     x2              	;1 [01]
+    cpi     x2, 0xfc        	;1 [02]
+    brcc    bitstuffN       	;1 [03]
+    dec     bitcnt          	;1 [04]
+    brne    txBitLoop       	;1 [05]
+    sbrs    shift, 0        	;1 [06]
+    eor     x1, x4          	;1 [07]
+    ror     shift           	;1 [08]
+didStuff6:			;- [08]
+    nop				;1 [09]
+    out     USBOUT, x1      	;1 [00] [10] <-- out 6
+    ror     x2              	;1 [01] 
+    cpi     x2, 0xfc        	;1 [02]
+    brcc    bitstuff6       	;1 [03]
+    sbrs    shift, 0        	;1 [04]
+    eor     x1, x4          	;1 [05]
+    ror     shift           	;1 [06]
+    ror     x2              	;1 [07]
+didStuff7:			;- [07]
+    ldi     bitcnt, 6    	;1 [08]
+    cpi     x2, 0xfc        	;1 [09]
+    out     USBOUT, x1      	;1 [00] [10] <-- out 7
+    brcc    bitstuff7       	;1 [01]
+    ld      shift, y+       	;2 [02+03]
+    dec     cnt             	;1 [04]
+    brne    txBitLoop      	;1 [05]
+makeSE0:
+    cbr     x1, USBMASK     	;1 [06] 	prepare SE0 [spec says EOP may be 19 to 23 cycles]
+    lds     x2, usbNewDeviceAddr;2 [07+08]
+    lsl     x2                  ;1 [09] we compare with left shifted address
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    out     USBOUT, x1      	;1 [00] [10] <-- out SE0-- from now 2 bits==20 cycl. until bus idle
+    subi    YL, 20 + 2          ;1 [01] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           	;1 [02]
+    breq    skipAddrAssign  	;1 [03]
+    sts     usbDeviceAddr, x2	;2 [04+05] if not skipped: SE0 is one cycle longer
+;----------------------------------------------------------------------------
+;end of usbDeviceAddress transfer
+skipAddrAssign:				;- [03/04]
+    ldi     x2, 1<<USB_INTR_PENDING_BIT	;1 [05] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)           ;1 [06]
+    ori     x1, USBIDLE     		;1 [07]
+    in      x2, USBDDR      		;1 [08]
+    cbr     x2, USBMASK     		;1 [09] set both pins to input
+    mov     x3, x1          		;1 [10]
+    cbr     x3, USBMASK     		;1 [11] configure no pullup on both pins
+    ldi     x4, 3           		;1 [12]
+se0Delay:				;- [12] [15] 
+    dec     x4              		;1 [13] [16] 
+    brne    se0Delay        		;1 [14] [17] 
+    nop2				;2      [18+19]
+    out     USBOUT, x1      		;1      [20] <--out J (idle) -- end of SE0 (EOP sig.)
+    out     USBDDR, x2      		;1      [21] <--release bus now
+    out     USBOUT, x3      		;1      [22] <--ensure no pull-up resistors are active
+    rjmp    doReturn			;1	[23]
+;---------------------------------------------------------------------------
Index: usbdrv/usbdrvasm16.inc
===================================================================
--- usbdrv/usbdrvasm16.inc	(nonexistent)
+++ usbdrv/usbdrvasm16.inc	(working copy)
@@ -0,0 +1,345 @@
+/* Name: usbdrvasm16.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-15
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 16 MHz version of the asssembler part of the USB driver. It
+requires a 16 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 16 MHz -> 10.6666666 cycles per bit, 85.333333333 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-25] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-23]
+    push    YL                  ;[-22]
+    push    YH                  ;[-20]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-15]
+    rjmp    foundK              ;[-14]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-12]
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    bitcnt              ;[-12]
+;   [---]                       ;[-11]
+    lds     YL, usbInputBufOffset;[-10]
+;   [---]                       ;[-9]
+    clr     YH                  ;[-8]
+    subi    YL, lo8(-(usbRxBuf));[-7] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-6] [rx loop init]
+    push    shift               ;[-5]
+;   [---]                       ;[-4]
+    ldi     bitcnt, 0x55        ;[-3] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-2] we want two bits K (sample 2 cycles too early)
+    rjmp    haveTwoBitsK        ;[-1]
+    pop     shift               ;[0] undo the push from before
+    pop     bitcnt              ;[2] undo the push from before
+    rjmp    waitForK            ;[4] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 21 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1              ;[1]
+    push    x2              ;[3]
+    push    x3              ;[5]
+    ldi     shift, 0        ;[7]
+    ldi     x3, 1<<4        ;[8] [rx loop init] first sample is inverse bit, compensate that
+    push    x4              ;[9] == leap
+
+    in      x1, USBIN       ;[11] <-- sample bit 0
+    andi    x1, USBMASK     ;[12]
+    bst     x1, USBMINUS    ;[13]
+    bld     shift, 7        ;[14]
+    push    cnt             ;[15]
+    ldi     leap, 0         ;[17] [rx loop init]
+    ldi     cnt, USB_BUFSIZE;[18] [rx loop init]
+    rjmp    rxbit1          ;[19] arrives at [21]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+
+; duration of unstuffing code should be 10.66666667 cycles. We adjust "leap"
+; accordingly to approximate this value in the long run.
+
+unstuff6:
+    andi    x2, USBMASK ;[03]
+    ori     x3, 1<<6    ;[04] will not be shifted any more
+    andi    shift, ~0x80;[05]
+    mov     x1, x2      ;[06] sampled bit 7 is actually re-sampled bit 6
+    subi    leap, -1    ;[07] total duration = 11 bits -> subtract 1/3
+    rjmp    didUnstuff6 ;[08]
+
+unstuff7:
+    ori     x3, 1<<7    ;[09] will not be shifted any more
+    in      x2, USBIN   ;[00] [10]  re-sample bit 7
+    andi    x2, USBMASK ;[01]
+    andi    shift, ~0x80;[02]
+    subi    leap, 2     ;[03] total duration = 10 bits -> add 1/3
+    rjmp    didUnstuff7 ;[04]
+
+unstuffEven:
+    ori     x3, 1<<6    ;[09] will be shifted right 6 times for bit 0
+    in      x1, USBIN   ;[00] [10]
+    andi    shift, ~0x80;[01]
+    andi    x1, USBMASK ;[02]
+    breq    se0         ;[03]
+    subi    leap, -1    ;[04] total duration = 11 bits -> subtract 1/3
+    nop2                ;[05]
+    rjmp    didUnstuffE ;[06]
+
+unstuffOdd:
+    ori     x3, 1<<5    ;[09] will be shifted right 4 times for bit 1
+    in      x2, USBIN   ;[00] [10]
+    andi    shift, ~0x80;[01]
+    andi    x2, USBMASK ;[02]
+    breq    se0         ;[03]
+    subi    leap, -1    ;[04] total duration = 11 bits -> subtract 1/3
+    nop2                ;[05]
+    rjmp    didUnstuffO ;[06]
+
+rxByteLoop:
+    andi    x1, USBMASK ;[03]
+    eor     x2, x1      ;[04]
+    subi    leap, 1     ;[05]
+    brpl    skipLeap    ;[06]
+    subi    leap, -3    ;1 one leap cycle every 3rd byte -> 85 + 1/3 cycles per byte
+    nop                 ;1
+skipLeap:
+    subi    x2, 1       ;[08]
+    ror     shift       ;[09]
+didUnstuff6:
+    cpi     shift, 0xfc ;[10]
+    in      x2, USBIN   ;[00] [11] <-- sample bit 7
+    brcc    unstuff6    ;[01]
+    andi    x2, USBMASK ;[02]
+    eor     x1, x2      ;[03]
+    subi    x1, 1       ;[04]
+    ror     shift       ;[05]
+didUnstuff7:
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuff7    ;[07]
+    eor     x3, shift   ;[08] reconstruct: x3 is 1 at bit locations we changed, 0 at others
+    st      y+, x3      ;[09] store data
+rxBitLoop:
+    in      x1, USBIN   ;[00] [11] <-- sample bit 0/2/4
+    andi    x1, USBMASK ;[01]
+    eor     x2, x1      ;[02]
+    andi    x3, 0x3f    ;[03] topmost two bits reserved for 6 and 7
+    subi    x2, 1       ;[04]
+    ror     shift       ;[05]
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuffEven ;[07]
+didUnstuffE:
+    lsr     x3          ;[08]
+    lsr     x3          ;[09]
+rxbit1:
+    in      x2, USBIN   ;[00] [10] <-- sample bit 1/3/5
+    andi    x2, USBMASK ;[01]
+    breq    se0         ;[02]
+    eor     x1, x2      ;[03]
+    subi    x1, 1       ;[04]
+    ror     shift       ;[05]
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuffOdd  ;[07]
+didUnstuffO:
+    subi    bitcnt, 0xab;[08] == addi 0x55, 0x55 = 0x100/3
+    brcs    rxBitLoop   ;[09]
+
+    subi    cnt, 1      ;[10]
+    in      x1, USBIN   ;[00] [11] <-- sample bit 6
+    brcc    rxByteLoop  ;[01]
+    rjmp    overflow
+
+macro POP_STANDARD ; 14 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     bitcnt
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+
+bitstuffN:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6]
+    nop2                    ;[7]
+    nop                     ;[9]
+    out     USBOUT, x1      ;[10] <-- out
+    rjmp    didStuffN       ;[0]
+    
+bitstuff6:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6] Carry is zero due to brcc
+    rol     shift           ;[7] compensate for ror shift at branch destination
+    rjmp    didStuff6       ;[8]
+
+bitstuff7:
+    ldi     x2, 0           ;[2] Carry is zero due to brcc
+    rjmp    didStuff7       ;[3]
+
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We don't match the transfer rate exactly (don't insert leap cycles every third
+;byte) because the spec demands only 1.5% precision anyway.
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x35    ;[-4] [6] binary 0011 0101
+txBitLoop:
+    sbrs    shift, 0        ;[-3] [7]
+    eor     x1, x4          ;[-2] [8]
+    out     USBOUT, x1      ;[-1] [9] <-- out N
+    ror     shift           ;[0] [10]
+    ror     x2              ;[1]
+didStuffN:
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuffN       ;[3]
+    lsr     bitcnt          ;[4]
+    brcc    txBitLoop       ;[5]
+    brne    txBitLoop       ;[6]
+
+    sbrs    shift, 0        ;[7]
+    eor     x1, x4          ;[8]
+didStuff6:
+    out     USBOUT, x1      ;[-1] [9] <-- out 6
+    ror     shift           ;[0] [10]
+    ror     x2              ;[1]
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuff6       ;[3]
+    ror     shift           ;[4]
+didStuff7:
+    ror     x2              ;[5]
+    sbrs    x2, 7           ;[6]
+    eor     x1, x4          ;[7]
+    nop                     ;[8]
+    cpi     x2, 0xfc        ;[9]
+    out     USBOUT, x1      ;[-1][10] <-- out 7
+    brcc    bitstuff7       ;[0] [11]
+    ld      shift, y+       ;[1]
+    dec     cnt             ;[3]
+    brne    txByteLoop      ;[4]
+;make SE0:
+    cbr     x1, USBMASK     ;[5] prepare SE0 [spec says EOP may be 21 to 25 cycles]
+    lds     x2, usbNewDeviceAddr;[6]
+    lsl     x2              ;[8] we compare with left shifted address
+    subi    YL, 20 + 2      ;[9] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[10]
+    out     USBOUT, x1      ;[11] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[0]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[2] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[3]
+    ori     x1, USBIDLE     ;[4]
+    in      x2, USBDDR      ;[5]
+    cbr     x2, USBMASK     ;[6] set both pins to input
+    mov     x3, x1          ;[7]
+    cbr     x3, USBMASK     ;[8] configure no pullup on both pins
+    ldi     x4, 4           ;[9]
+se0Delay:
+    dec     x4              ;[10] [13] [16] [19]
+    brne    se0Delay        ;[11] [14] [17] [20]
+    out     USBOUT, x1      ;[21] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[22] <-- release bus now
+    out     USBOUT, x3      ;[23] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: usbdrv/usbdrvasm165.inc
===================================================================
--- usbdrv/usbdrvasm165.inc	(nonexistent)
+++ usbdrv/usbdrvasm165.inc	(working copy)
@@ -0,0 +1,452 @@
+/* Name: usbdrvasm165.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-04-22
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 16.5 MHz version of the USB driver. It is intended for the
+ATTiny45 and similar controllers running on 16.5 MHz internal RC oscillator.
+This version contains a phase locked loop in the receiver routine to cope with
+slight clock rate deviations of up to +/- 1%.
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
+;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
+;max allowable interrupt latency: 59 cycles -> max 52 cycles interrupt disable
+;max stack usage: [ret(2), r0, SREG, YL, YH, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 16.5 MHz -> 11 cycles per bit
+; 16.3125 MHz < F_CPU < 16.6875 MHz (+/- 1.1%)
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], r0, YH, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-23] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-21]
+    push    YL                  ;[-20]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-15]
+    rjmp    foundK              ;[-14]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-12]
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    r0                  ;[-12]
+;   [---]                       ;[-11]
+    push    YH                  ;[-10]
+;   [---]                       ;[-9]
+    lds     YL, usbInputBufOffset;[-8]
+;   [---]                       ;[-7]
+    clr     YH                  ;[-6]
+    subi    YL, lo8(-(usbRxBuf));[-5] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-4] [rx loop init]
+    mov     r0, x2              ;[-3] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-2] we want two bits K (sample 2 cycles too early)
+    rjmp    haveTwoBitsK        ;[-1]
+    pop     YH                  ;[0] undo the pushes from before
+    pop     r0                  ;[2]
+    rjmp    waitForK            ;[4] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 22 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:               ;[1]
+    push    shift           ;[1]
+    push    x1              ;[3]
+    push    x2              ;[5]
+    push    x3              ;[7]
+    ldi     shift, 0xff     ;[9] [rx loop init]
+    ori     x3, 0xff        ;[10] [rx loop init] == ser x3, clear zero flag
+
+    in      x1, USBIN       ;[11] <-- sample bit 0
+    bst     x1, USBMINUS    ;[12]
+    bld     shift, 0        ;[13]
+    push    x4              ;[14] == phase
+;   [---]                   ;[15]
+    push    cnt             ;[16]
+;   [---]                   ;[17]
+    ldi     phase, 0        ;[18] [rx loop init]
+    ldi     cnt, USB_BUFSIZE;[19] [rx loop init]
+    rjmp    rxbit1          ;[20]
+;   [---]                   ;[21]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+/*
+byte oriented operations done during loop:
+bit 0: store data
+bit 1: SE0 check
+bit 2: overflow check
+bit 3: catch up
+bit 4: rjmp to achieve conditional jump range
+bit 5: PLL
+bit 6: catch up
+bit 7: jump, fixup bitstuff
+; 87 [+ 2] cycles
+------------------------------------------------------------------
+*/
+continueWithBit5:
+    in      x2, USBIN       ;[055] <-- bit 5
+    eor     r0, x2          ;[056]
+    or      phase, r0       ;[057]
+    sbrc    phase, USBMINUS ;[058]
+    lpm                     ;[059] optional nop3; modifies r0
+    in      phase, USBIN    ;[060] <-- phase
+    eor     x1, x2          ;[061]
+    bst     x1, USBMINUS    ;[062]
+    bld     shift, 5        ;[063]
+    andi    shift, 0x3f     ;[064]
+    in      x1, USBIN       ;[065] <-- bit 6
+    breq    unstuff5        ;[066] *** unstuff escape
+    eor     phase, x1       ;[067]
+    eor     x2, x1          ;[068]
+    bst     x2, USBMINUS    ;[069]
+    bld     shift, 6        ;[070]
+didUnstuff6:                ;[   ]
+    in      r0, USBIN       ;[071] <-- phase
+    cpi     shift, 0x02     ;[072]
+    brlo    unstuff6        ;[073] *** unstuff escape
+didUnstuff5:                ;[   ]
+    nop2                    ;[074]
+;   [---]                   ;[075]
+    in      x2, USBIN       ;[076] <-- bit 7
+    eor     x1, x2          ;[077]
+    bst     x1, USBMINUS    ;[078]
+    bld     shift, 7        ;[079]
+didUnstuff7:                ;[   ]
+    eor     r0, x2          ;[080]
+    or      phase, r0       ;[081]
+    in      r0, USBIN       ;[082] <-- phase
+    cpi     shift, 0x04     ;[083]
+    brsh    rxLoop          ;[084]
+;   [---]                   ;[085]
+unstuff7:                   ;[   ]
+    andi    x3, ~0x80       ;[085]
+    ori     shift, 0x80     ;[086]
+    in      x2, USBIN       ;[087] <-- sample stuffed bit 7
+    nop                     ;[088]
+    rjmp    didUnstuff7     ;[089]
+;   [---]                   ;[090]
+                            ;[080]
+
+unstuff5:                   ;[067]
+    eor     phase, x1       ;[068]
+    andi    x3, ~0x20       ;[069]
+    ori     shift, 0x20     ;[070]
+    in      r0, USBIN       ;[071] <-- phase
+    mov     x2, x1          ;[072]
+    nop                     ;[073]
+    nop2                    ;[074]
+;   [---]                   ;[075]
+    in      x1, USBIN       ;[076] <-- bit 6
+    eor     r0, x1          ;[077]
+    or      phase, r0       ;[078]
+    eor     x2, x1          ;[079]
+    bst     x2, USBMINUS    ;[080]
+    bld     shift, 6        ;[081] no need to check bitstuffing, we just had one
+    in      r0, USBIN       ;[082] <-- phase
+    rjmp    didUnstuff5     ;[083]
+;   [---]                   ;[084]
+                            ;[074]
+
+unstuff6:                   ;[074]
+    andi    x3, ~0x40       ;[075]
+    in      x1, USBIN       ;[076] <-- bit 6 again
+    ori     shift, 0x40     ;[077]
+    nop2                    ;[078]
+;   [---]                   ;[079]
+    rjmp    didUnstuff6     ;[080]
+;   [---]                   ;[081]
+                            ;[071]
+
+unstuff0:                   ;[013]
+    eor     r0, x2          ;[014]
+    or      phase, r0       ;[015]
+    andi    x2, USBMASK     ;[016] check for SE0
+    in      r0, USBIN       ;[017] <-- phase
+    breq    didUnstuff0     ;[018] direct jump to se0 would be too long
+    andi    x3, ~0x01       ;[019]
+    ori     shift, 0x01     ;[020]
+    mov     x1, x2          ;[021] mov existing sample
+    in      x2, USBIN       ;[022] <-- bit 1 again
+    rjmp    didUnstuff0     ;[023]
+;   [---]                   ;[024]
+                            ;[014]
+
+unstuff1:                   ;[024]
+    eor     r0, x1          ;[025]
+    or      phase, r0       ;[026]
+    andi    x3, ~0x02       ;[027]
+    in      r0, USBIN       ;[028] <-- phase
+    ori     shift, 0x02     ;[029]
+    mov     x2, x1          ;[030]
+    rjmp    didUnstuff1     ;[031]
+;   [---]                   ;[032]
+                            ;[022]
+
+unstuff2:                   ;[035]
+    eor     r0, x2          ;[036]
+    or      phase, r0       ;[037]
+    andi    x3, ~0x04       ;[038]
+    in      r0, USBIN       ;[039] <-- phase
+    ori     shift, 0x04     ;[040]
+    mov     x1, x2          ;[041]
+    rjmp    didUnstuff2     ;[042]
+;   [---]                   ;[043]
+                            ;[033]
+
+unstuff3:                   ;[043]
+    in      x2, USBIN       ;[044] <-- bit 3 again
+    eor     r0, x2          ;[045]
+    or      phase, r0       ;[046]
+    andi    x3, ~0x08       ;[047]
+    ori     shift, 0x08     ;[048]
+    nop                     ;[049]
+    in      r0, USBIN       ;[050] <-- phase
+    rjmp    didUnstuff3     ;[051]
+;   [---]                   ;[052]
+                            ;[042]
+
+unstuff4:                   ;[053]
+    andi    x3, ~0x10       ;[054]
+    in      x1, USBIN       ;[055] <-- bit 4 again
+    ori     shift, 0x10     ;[056]
+    rjmp    didUnstuff4     ;[057]
+;   [---]                   ;[058]
+                            ;[048]
+
+rxLoop:                     ;[085]
+    eor     x3, shift       ;[086] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    in      x1, USBIN       ;[000] <-- bit 0
+    st      y+, x3          ;[001]
+;   [---]                   ;[002]
+    eor     r0, x1          ;[003]
+    or      phase, r0       ;[004]
+    eor     x2, x1          ;[005]
+    in      r0, USBIN       ;[006] <-- phase
+    ser     x3              ;[007]
+    bst     x2, USBMINUS    ;[008]
+    bld     shift, 0        ;[009]
+    andi    shift, 0xf9     ;[010]
+rxbit1:                     ;[   ]
+    in      x2, USBIN       ;[011] <-- bit 1
+    breq    unstuff0        ;[012] *** unstuff escape
+    andi    x2, USBMASK     ;[013] SE0 check for bit 1
+didUnstuff0:                ;[   ] Z only set if we detected SE0 in bitstuff
+    breq    se0             ;[014]
+    eor     r0, x2          ;[015]
+    or      phase, r0       ;[016]
+    in      r0, USBIN       ;[017] <-- phase
+    eor     x1, x2          ;[018]
+    bst     x1, USBMINUS    ;[019]
+    bld     shift, 1        ;[020]
+    andi    shift, 0xf3     ;[021]
+didUnstuff1:                ;[   ]
+    in      x1, USBIN       ;[022] <-- bit 2
+    breq    unstuff1        ;[023] *** unstuff escape
+    eor     r0, x1          ;[024]
+    or      phase, r0       ;[025]
+    subi    cnt, 1          ;[026] overflow check
+    brcs    overflow        ;[027]
+    in      r0, USBIN       ;[028] <-- phase
+    eor     x2, x1          ;[029]
+    bst     x2, USBMINUS    ;[030]
+    bld     shift, 2        ;[031]
+    andi    shift, 0xe7     ;[032]
+didUnstuff2:                ;[   ]
+    in      x2, USBIN       ;[033] <-- bit 3
+    breq    unstuff2        ;[034] *** unstuff escape
+    eor     r0, x2          ;[035]
+    or      phase, r0       ;[036]
+    eor     x1, x2          ;[037]
+    bst     x1, USBMINUS    ;[038]
+    in      r0, USBIN       ;[039] <-- phase
+    bld     shift, 3        ;[040]
+    andi    shift, 0xcf     ;[041]
+didUnstuff3:                ;[   ]
+    breq    unstuff3        ;[042] *** unstuff escape
+    nop                     ;[043]
+    in      x1, USBIN       ;[044] <-- bit 4
+    eor     x2, x1          ;[045]
+    bst     x2, USBMINUS    ;[046]
+    bld     shift, 4        ;[047]
+didUnstuff4:                ;[   ]
+    eor     r0, x1          ;[048]
+    or      phase, r0       ;[049]
+    in      r0, USBIN       ;[050] <-- phase
+    andi    shift, 0x9f     ;[051]
+    breq    unstuff4        ;[052] *** unstuff escape
+    rjmp    continueWithBit5;[053]
+;   [---]                   ;[054]
+
+macro POP_STANDARD ; 16 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    pop     r0
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+
+bitstuff7:
+    eor     x1, x4          ;[4]
+    ldi     x2, 0           ;[5]
+    nop2                    ;[6] C is zero (brcc)
+    rjmp    didStuff7       ;[8]
+
+bitstuffN:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6]
+    lpm                     ;[7] 3 cycle NOP, modifies r0
+    out     USBOUT, x1      ;[10] <-- out
+    rjmp    didStuffN       ;[0]
+
+#define bitStatus   x3
+
+sendNakAndReti:
+    ldi     cnt, USBPID_NAK ;[-19]
+    rjmp    sendCntAndReti  ;[-18]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     r0, cnt         ;[-16]
+    ldi     YL, 0           ;[-15] R0 address is 0
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+    ldi     bitStatus, 0xff ;[-4] init bit loop counter, works for up to 12 bytes
+byteloop:
+bitloop:
+    sbrs    shift, 0        ;[8] [-3]
+    eor     x1, x4          ;[9] [-2]
+    out     USBOUT, x1      ;[10] [-1] <-- out
+    ror     shift           ;[0]
+    ror     x2              ;[1]
+didStuffN:
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuffN       ;[3]
+    nop                     ;[4]
+    subi    bitStatus, 37   ;[5] 256 / 7 ~=~ 37
+    brcc    bitloop         ;[6] when we leave the loop, bitStatus has almost the initial value
+    sbrs    shift, 0        ;[7]
+    eor     x1, x4          ;[8]
+    ror     shift           ;[9]
+didStuff7:
+    out     USBOUT, x1      ;[10] <-- out
+    ror     x2              ;[0]
+    cpi     x2, 0xfc        ;[1]
+    brcc    bitstuff7       ;[2]
+    ld      shift, y+       ;[3]
+    dec     cnt             ;[5]
+    brne    byteloop        ;[6]
+;make SE0:
+    cbr     x1, USBMASK     ;[7] prepare SE0 [spec says EOP may be 21 to 25 cycles]
+    lds     x2, usbNewDeviceAddr;[8]
+    lsl     x2              ;[10] we compare with left shifted address
+    out     USBOUT, x1      ;[11] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    subi    YL, 2           ;[0] Only assign address on data packets, not ACK/NAK in r0
+    sbci    YH, 0           ;[1]
+    breq    skipAddrAssign  ;[2]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[5]
+    ori     x1, USBIDLE     ;[6]
+    in      x2, USBDDR      ;[7]
+    cbr     x2, USBMASK     ;[8] set both pins to input
+    mov     x3, x1          ;[9]
+    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
+    ldi     x4, 4           ;[11]
+se0Delay:
+    dec     x4              ;[12] [15] [18] [21]
+    brne    se0Delay        ;[13] [16] [19] [22]
+    out     USBOUT, x1      ;[23] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[24] <-- release bus now
+    out     USBOUT, x3      ;[25] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
Index: usbdrv/usbdrvasm18-crc.inc
===================================================================
--- usbdrv/usbdrvasm18-crc.inc	(nonexistent)
+++ usbdrv/usbdrvasm18-crc.inc	(working copy)
@@ -0,0 +1,706 @@
+/* Name: usbdrvasm18.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Lukas Schrittwieser (based on 20 MHz usbdrvasm20.inc by Jeroen Benschop)
+ * Creation Date: 2009-01-20
+ * Tabsize: 4
+ * Copyright: (c) 2008 by Lukas Schrittwieser and OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 18 MHz version of the asssembler part of the USB driver. It
+requires a 18 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+
+;max stack usage: [ret(2), YL, SREG, YH, [sofError], bitcnt(x5), shift, x1, x2, x3, x4, cnt, ZL, ZH] = 14 bytes
+;nominal frequency: 18 MHz -> 12 cycles per bit
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+;register use in receive loop to receive the data bytes:
+; shift assembles the byte currently being received
+; x1 holds the D+ and D- line state
+; x2 holds the previous line state
+; cnt holds the number of bytes left in the receive buffer
+; x3 holds the higher crc byte (see algorithm below)
+; x4 is used as temporary register for the crc algorithm
+; x5 is used for unstuffing: when unstuffing the last received bit is inverted in shift (to prevent further
+;    unstuffing calls. In the same time the corresponding bit in x5 is cleared to mark the bit as beening iverted
+; zl lower crc value and crc table index
+; zh used for crc table accesses
+
+;--------------------------------------------------------------------------------------------------------------
+; CRC mods:
+;  table driven crc checker, Z points to table in prog space
+;   ZL is the lower crc byte, x3 is the higher crc byte
+;	x4 is used as temp register to store different results
+;	the initialization of the crc register is not 0xFFFF but 0xFE54. This is because during the receipt of the
+;	first data byte an virtual zero data byte is added to the crc register, this results in the correct initial
+;	value of 0xFFFF at beginning of the second data byte before the first data byte is added to the crc.
+;	The magic number 0xFE54 results form the crc table: At tabH[0x54] = 0xFF = crcH (required) and
+;	tabL[0x54] = 0x01  ->  crcL = 0x01 xor 0xFE = 0xFF
+;  bitcnt is renamed to x5 and is used for unstuffing purposes, the unstuffing works like in the 12MHz version
+;--------------------------------------------------------------------------------------------------------------
+; CRC algorithm:
+;	The crc register is formed by x3 (higher byte) and ZL (lower byte). The algorithm uses a 'reversed' form
+;	i.e. that it takes the least significant bit first and shifts to the right. So in fact the highest order
+;	bit seen from the polynomial devision point of view is the lsb of ZL. (If this sounds strange to you i
+;	propose a research on CRC :-) )
+;	Each data byte received is xored to ZL, the lower crc byte. This byte now builds the crc
+;	table index. Next the new high byte is loaded from the table and stored in x4 until we have space in x3
+;	(its destination).
+;	Afterwards the lower table is loaded from the table and stored in ZL (the old index is overwritten as
+;	we don't need it anymore. In fact this is a right shift by 8 bits.) Now the old crc high value is xored
+;	to ZL, this is the second shift of the old crc value. Now x4 (the temp reg) is moved to x3 and the crc
+; 	calculation is done.
+;	Prior to the first byte the two CRC register have to be initialized to 0xFFFF (as defined in usb spec)
+;	however the crc engine also runs during the receipt of the first byte, therefore x3 and zl are initialized
+;	to a magic number which results in a crc value of 0xFFFF after the first complete byte.
+;
+;	This algorithm is split into the extra cycles of the different bits:
+;	bit7:	XOR the received byte to ZL
+;	bit5:	load the new high byte to x4
+;	bit6:	load the lower xor byte from the table, xor zl and x3, store result in zl (=the new crc low value)
+;			move x4 (the new high byte) to x3, the crc value is ready
+;
+
+
+macro POP_STANDARD ; 18 cycles
+    pop		ZH
+    pop		ZL
+	pop     cnt
+    pop     x5
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     x4
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+macro CRC_CLEANUP_AND_CHECK
+	; the last byte has already been xored with the lower crc byte, we have to do the table lookup and xor
+	; x3 is the higher crc byte, zl the lower one
+	ldi		ZH, hi8(usbCrcTableHigh);[+1] get the new high byte from the table
+	lpm		x2, Z				;[+2][+3][+4]
+	ldi		ZH, hi8(usbCrcTableLow);[+5] get the new low xor byte from the table
+	lpm		ZL, Z				;[+6][+7][+8]
+	eor		ZL, x3				;[+7] xor the old high byte with the value from the table, x2:ZL now holds the crc value
+	cpi		ZL, 0x01			;[+8] if the crc is ok we have a fixed remainder value of 0xb001 in x2:ZL (see usb spec)
+	brne	ignorePacket		;[+9] detected a crc fault -> paket is ignored and retransmitted by the host
+	cpi		x2, 0xb0			;[+10]
+	brne	ignorePacket		;[+11] detected a crc fault -> paket is ignored and retransmitted by the host
+    endm
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG, YH, [sofError], x4, shift, x1, x2, x3, x5, cnt, ZL, ZH
+    push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-26]
+    push    YL                  ;[-25]
+    push    YH                  ;[-23]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-17]
+    rjmp    foundK              ;[-16]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-15]
+;{3, 5} after falling D- edge, average delay: 4 cycles
+;bit0 should be at 30  (2.5 bits) for center sampling. Currently at 4 so 26 cylces till bit 0 sample
+;use 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    x4                  ;[-14]
+;   [---]                       ;[-13]
+    lds     YL, usbInputBufOffset;[-12] used to toggle the two usb receive buffers
+;   [---]                       ;[-11]
+    clr     YH                  ;[-10]
+    subi    YL, lo8(-(usbRxBuf));[-9] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-8] [rx loop init]
+    push    shift               ;[-7]
+;   [---]                       ;[-6]
+    ldi		shift, 0x80			;[-5] the last bit is the end of byte marker for the pid receiver loop
+    clc			      	      	;[-4] the carry has to be clear for receipt of pid bit 0
+    sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
+    rjmp    haveTwoBitsK        ;[-2]
+    pop     shift               ;[-1] undo the push from before
+    pop     x4                  ;[1]
+    rjmp    waitForK            ;[3] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 24 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1                  ;[0]
+    push    x2                  ;[2]
+    push    x3                  ;[4] crc high byte
+    ldi     x2, 1<<USBPLUS      ;[6] [rx loop init] current line state is K state. D+=="1", D-=="0"
+    push    x5                  ;[7]
+    push    cnt                 ;[9]
+    ldi     cnt, USB_BUFSIZE    ;[11]
+
+
+;--------------------------------------------------------------------------------------------------------------
+; receives the pid byte
+; there is no real unstuffing algorithm implemented here as a stuffing bit is impossible in the pid byte.
+; That's because the last four bits of the byte are the inverted of the first four bits. If we detect a
+; unstuffing condition something went wrong and abort
+; shift has to be initialized to 0x80
+;--------------------------------------------------------------------------------------------------------------
+
+; pid bit 0 - used for even more register saving (we need the z pointer)
+	in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    eor		x2, x1				;[2] generate inverted of actual bit
+	sbrc	x2, USBMINUS		;[3] if the bit is set we received a zero
+	sec							;[4]
+	ror		shift				;[5] we perform no unstuffing check here as this is the first bit
+	mov		x2, x1				;[6]
+	push	ZL					;[7]
+								;[8]
+	push	ZH					;[9]
+								;[10]
+	ldi		x3, 0xFE			;[11] x3 is the high order crc value
+
+
+bitloopPid:						
+	in      x1, USBIN           ;[0] sample line state
+   	andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    breq    nse0                ;[2] both lines are low so handle se0	
+	eor		x2, x1				;[3] generate inverted of actual bit
+	sbrc	x2, USBMINUS		;[4] set the carry if we received a zero
+	sec							;[5]
+	ror		shift				;[6]
+	ldi		ZL, 0x54			;[7] ZL is the low order crc value
+	ser		x4					;[8] the is no bit stuffing check here as the pid bit can't be stuffed. if so
+								; some error occured. In this case the paket is discarded later on anyway.
+	mov		x2, x1				;[9] prepare for the next cycle
+	brcc	bitloopPid			;[10] while 0s drop out of shift we get the next bit
+	eor		x4, shift			;[11] invert all bits in shift and store result in x4
+
+;--------------------------------------------------------------------------------------------------------------
+; receives data bytes and calculates the crc
+; the last USBIN state has to be in x2
+; this is only the first half, due to branch distanc limitations the second half of the loop is near the end
+; of this asm file
+;--------------------------------------------------------------------------------------------------------------
+
+rxDataStart:
+    in      x1, USBIN           ;[0] sample line state (note: a se0 check is not useful due to bit dribbling)
+    ser		x5					;[1] prepare the unstuff marker register
+    eor		x2, x1             	;[2] generates the inverted of the actual bit
+    bst		x2, USBMINUS       	;[3] copy the bit from x2
+    bld		shift, 0	        ;[4] and store it in shift
+    mov		x2, shift	     	;[5] make a copy of shift for unstuffing check
+    andi	x2, 0xF9	      	;[6] mask the last six bits, if we got six zeros (which are six ones in fact)
+    breq	unstuff0	      	;[7] then Z is set now and we branch to the unstuffing handler
+didunstuff0:
+	subi    cnt, 1         		;[8] cannot use dec because it doesn't affect the carry flag
+    brcs    nOverflow    		;[9] Too many bytes received. Ignore packet							
+    st		Y+, x4				;[10] store the last received byte
+								;[11] st needs two cycles
+
+; bit1							
+	in		x2, USBIN			;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0 during bit 0
+    breq	nse0				;[2]
+    andi	x2, USBMASK			;[3] check se0 during bit 1
+    breq	nse0				;[4]
+	eor		x1, x2				;[5]
+    bst		x1, USBMINUS		;[6]
+    bld 	shift, 1	 		;[7]
+    mov		x1, shift			;[8]
+    andi	x1, 0xF3			;[9]
+    breq	unstuff1			;[10]
+didunstuff1:
+	nop							;[11]	
+
+; bit2
+	in      x1, USBIN           ;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0 (as there is nothing else to do here
+	breq	nOverflow	 		;[2]
+    eor		x2, x1              ;[3] generates the inverted of the actual bit
+    bst		x2, USBMINUS		;[4]
+    bld		shift, 2			;[5] store the bit
+    mov		x2, shift			;[6]
+    andi	x2, 0xE7			;[7] if we have six zeros here (which means six 1 in the stream)
+    breq	unstuff2			;[8] the next bit is a stuffing bit
+didunstuff2:
+	nop2						;[9]
+								;[10]
+	nop							;[11]					
+					
+; bit3							
+	in		x2, USBIN			;[0] sample line state
+    andi	x2, USBMASK			;[1] check for se0
+    breq	nOverflow           ;[2]
+    eor		x1, x2				;[3]
+    bst		x1, USBMINUS		;[4]
+    bld 	shift, 3	 		;[5]
+    mov		x1, shift			;[6]
+    andi	x1, 0xCF			;[7]
+    breq	unstuff3			;[8]
+didunstuff3:
+	nop							;[9]
+	rjmp 	rxDataBit4			;[10]
+								;[11]				
+
+; the avr branch instructions allow an offset of +63 insturction only, so we need this
+; 'local copy' of se0
+nse0:		
+	rjmp	se0					;[4]
+								;[5]
+; the same same as for se0 is needed for overflow and StuffErr
+nOverflow:
+stuffErr:
+	rjmp	overflow
+
+
+unstuff0:						;[8] this is the branch delay of breq unstuffX
+	andi	x1, USBMASK			;[9] do an se0 check here (if the last crc byte ends with 5 one's we might end up here
+	breq	didunstuff0			;[10] event tough the message is complete -> jump back and store the byte
+	ori		shift, 0x01			;[11] invert the last received bit to prevent furhter unstuffing
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	andi	x5, 0xFE			;[1] mark this bit as inverted (will be corrected before storing shift)
+	eor		x1, x2				;[2] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[3] mask the interesting bits
+	breq	stuffErr			;[4] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[5] the next bit expects the last state to be in x1
+	rjmp 	didunstuff0			;[6]
+								;[7] jump delay of rjmp didunstuffX	
+
+unstuff1:						;[11] this is the jump delay of breq unstuffX
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	ori		shift, 0x02			;[1] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xFD			;[2] mark this bit as inverted (will be corrected before storing shift)
+	eor		x2, x1				;[3] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[4] mask the interesting bits
+	breq	stuffErr			;[5] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[6] the next bit expects the last state to be in x2
+	nop2						;[7]
+								;[8]
+	rjmp 	didunstuff1			;[9]
+								;[10] jump delay of rjmp didunstuffX		
+
+unstuff2:						;[9] this is the jump delay of breq unstuffX
+	ori		shift, 0x04			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xFB			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff2			;[7]
+								;[8] jump delay of rjmp didunstuffX	
+
+unstuff3:						;[9] this is the jump delay of breq unstuffX
+	ori		shift, 0x08			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xF7			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff3			;[7]
+								;[8] jump delay of rjmp didunstuffX			
+
+
+
+; the include has to be here due to branch distance restirctions
+#define __USE_CRC__
+#include "asmcommon.inc"
+
+	
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+; 7.5 bit times is 90 cycles. ...there is plenty of time
+
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-6] <- acquire bus
+	ldi		x2, 0			;[-6] init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-5] exor mask
+    ldi     shift, 0x80     ;[-4] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x40    ;[-3]=[9]     binary 01000000
+txBitLoop:					; the loop sends the first 7 bits of the byte
+    sbrs    shift, 0        ;[-2]=[10] if we have to send a 1 don't change the line state
+    eor     x1, x4          ;[-1]=[11]
+    out     USBOUT, x1      ;[0]
+    ror     shift           ;[1]
+    ror     x2              ;[2] transfers the last sent bit to the stuffing history
+didStuffN:
+    nop	                    ;[3]
+    nop                     ;[4]
+    cpi     x2, 0xfc        ;[5] if we sent six consecutive ones
+    brcc    bitstuffN       ;[6]
+    lsr     bitcnt          ;[7]
+    brne    txBitLoop       ;[8] restart the loop while the 1 is still in the bitcount
+
+; transmit bit 7
+    sbrs    shift, 0        ;[9]
+    eor     x1, x4          ;[10]
+didStuff7:
+    ror     shift           ;[11]
+	out     USBOUT, x1      ;[0] transfer bit 7 to the pins
+    ror     x2              ;[1] move the bit into the stuffing history	
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuff7       ;[3]
+    ld      shift, y+       ;[4] get next byte to transmit
+    dec     cnt             ;[5] decrement byte counter
+    brne    txByteLoop      ;[7] if we have more bytes start next one
+    						;[8] branch delay
+    						
+;make SE0:
+    cbr     x1, USBMASK     ;[8] 		prepare SE0 [spec says EOP may be 25 to 30 cycles]
+    lds     x2, usbNewDeviceAddr;[9]
+    lsl     x2              ;[11] 		we compare with left shifted address
+    out     USBOUT, x1      ;[0] 		<-- out SE0 -- from now 2 bits = 24 cycles until bus idle
+    subi    YL, 20 + 2      ;[1] 		Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[2]
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[3]
+    sts     usbDeviceAddr, x2		; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[5] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[6]
+    ori     x1, USBIDLE     ;[7]
+    in      x2, USBDDR      ;[8]
+    cbr     x2, USBMASK     ;[9] set both pins to input
+    mov     x3, x1          ;[10]
+    cbr     x3, USBMASK     ;[11] configure no pullup on both pins
+    ldi     x4, 4           ;[12]
+se0Delay:
+    dec     x4              ;[13] [16] [19] [22]
+    brne    se0Delay        ;[14] [17] [20] [23]
+    out     USBOUT, x1      ;[24] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[25] <-- release bus now
+    out     USBOUT, x3      ;[26] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
+bitstuffN:
+    eor     x1, x4          ;[8] generate a zero
+    ldi     x2, 0           ;[9] reset the bit stuffing history
+    nop2                    ;[10]
+    out     USBOUT, x1      ;[0] <-- send the stuffing bit
+    rjmp    didStuffN       ;[1]
+
+bitstuff7:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6] reset bit stuffing history
+    clc						;[7] fill a zero into the shift register
+    rol     shift           ;[8] compensate for ror shift at branch destination
+    rjmp    didStuff7       ;[9]
+    						;[10] jump delay
+
+;--------------------------------------------------------------------------------------------------------------
+; receives data bytes and calculates the crc
+; second half of the data byte receiver loop
+; most parts of the crc algorithm are here
+;--------------------------------------------------------------------------------------------------------------
+
+nOverflow2:
+	rjmp overflow
+
+rxDataBit4:
+	in      x1, USBIN           ;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0
+    breq	nOverflow2			;[2]
+    eor		x2, x1              ;[3]
+    bst		x2, USBMINUS		;[4]
+    bld		shift, 4			;[5]
+    mov		x2, shift			;[6]
+    andi	x2, 0x9F			;[7]
+    breq	unstuff4			;[8]
+didunstuff4:
+	nop2						;[9][10]
+	nop							;[11]
+
+; bit5							
+	in		x2, USBIN			;[0] sample line state
+    ldi		ZH, hi8(usbCrcTableHigh);[1] use the table for the higher byte
+    eor		x1, x2				;[2]
+    bst		x1, USBMINUS		;[3]
+    bld 	shift, 5	 		;[4]
+    mov		x1, shift			;[5]
+    andi	x1, 0x3F			;[6]
+    breq	unstuff5			;[7]
+didunstuff5:
+	lpm		x4, Z				;[8] load the higher crc xor-byte and store it for later use
+								;[9] lpm needs 3 cycles
+								;[10]			
+	ldi		ZH, hi8(usbCrcTableLow);[11] load the lower crc xor byte adress
+
+; bit6	    					
+	in      x1, USBIN           ;[0] sample line state
+    eor		x2, x1              ;[1]
+    bst		x2, USBMINUS		;[2]
+    bld		shift, 6			;[3]
+    mov		x2, shift			;[4]
+    andi	x2, 0x7E			;[5]
+    breq	unstuff6			;[6]
+didunstuff6:
+	lpm		ZL, Z				;[7] load the lower xor crc byte
+								;[8] lpm needs 3 cycles
+	    						;[9]
+	eor		ZL, x3				;[10] xor the old high crc byte with the low xor-byte
+	mov		x3, x4				;[11] move the new high order crc value from temp to its destination
+			
+; bit7							
+	in		x2, USBIN			;[0] sample line state
+    eor		x1, x2				;[1]
+    bst		x1, USBMINUS		;[2]
+    bld 	shift, 7	 		;[3] now shift holds the complete but inverted data byte
+    mov		x1, shift			;[4]
+    andi	x1, 0xFC			;[5]
+    breq	unstuff7			;[6]
+didunstuff7:
+	eor		x5, shift			;[7] x5 marks all bits which have not been inverted by the unstuffing subs
+	mov		x4, x5				;[8] keep a copy of the data byte it will be stored during next bit0
+	eor		ZL, x4				;[9] feed the actual byte into the crc algorithm
+	rjmp	rxDataStart			;[10] next byte
+								;[11] during the reception of the next byte this one will be fed int the crc algorithm
+
+unstuff4:						;[9] this is the jump delay of rjmp unstuffX
+	ori		shift, 0x10			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xEF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff4			;[7]
+								;[8] jump delay of rjmp didunstuffX	
+
+unstuff5:						;[8] this is the jump delay of rjmp unstuffX
+	nop							;[9]
+	ori		shift, 0x20			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xDF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	nop							;[5]
+	rjmp 	didunstuff5			;[6]
+								;[7] jump delay of rjmp didunstuffX													
+
+unstuff6:						;[7] this is the jump delay of rjmp unstuffX
+	nop2						;[8]
+								;[9]
+	ori		shift, 0x40			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xBF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	rjmp 	didunstuff6			;[5]
+								;[6] jump delay of rjmp didunstuffX	
+
+unstuff7:						;[7] this is the jump delay of rjmp unstuffX
+	nop							;[8]
+	nop							;[9]
+	ori		shift, 0x80			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0x7F			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	rjmp 	didunstuff7			;[5]
+								;[6] jump delay of rjmp didunstuff7
+
+; local copy of the stuffErr desitnation for the second half of the receiver loop
+stuffErr2:
+	rjmp	stuffErr
+
+;--------------------------------------------------------------------------------------------------------------
+; The crc table follows. It has to be aligned to enable a fast loading of the needed bytes.
+; There are two tables of 256 entries each, the low and the high byte table.
+; Table values were generated with the following C code:
+/*
+#include <stdio.h>
+int main (int argc, char **argv)
+{
+	int i, j;
+	for (i=0; i<512; i++){
+		unsigned short crc = i & 0xff;
+		for(j=0; j<8; j++) crc = (crc >> 1) ^ ((crc & 1) ? 0xa001 : 0);
+		if((i & 7) == 0) printf("\n.byte ");
+		printf("0x%02x, ", (i > 0xff ? (crc >> 8) : crc) & 0xff);
+		if(i == 255) printf("\n");
+	}
+	return 0;
+}
+
+// Use the following algorithm to compute CRC values:
+ushort computeCrc(uchar *msg, uchar msgLen)
+{
+    uchar i;
+	ushort crc = 0xffff;
+	for(i = 0; i < msgLen; i++)
+		crc = usbCrcTable16[lo8(crc) ^ msg[i]] ^ hi8(crc);
+    return crc;
+}
+*/
+
+.balign 256
+usbCrcTableLow:	
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+
+; .balign 256
+usbCrcTableHigh:
+.byte 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2
+.byte 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04
+.byte 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E
+.byte 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8
+.byte 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A
+.byte 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC
+.byte 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6
+.byte 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10
+.byte 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32
+.byte 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4
+.byte 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE
+.byte 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38
+.byte 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA
+.byte 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C
+.byte 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26
+.byte 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0
+.byte 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62
+.byte 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4
+.byte 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE
+.byte 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68
+.byte 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA
+.byte 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C
+.byte 0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76
+.byte 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0
+.byte 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92
+.byte 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54
+.byte 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E
+.byte 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98
+.byte 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A
+.byte 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C
+.byte 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86
+.byte 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40	
+
Index: usbdrv/usbdrvasm20.inc
===================================================================
--- usbdrv/usbdrvasm20.inc	(nonexistent)
+++ usbdrv/usbdrvasm20.inc	(working copy)
@@ -0,0 +1,359 @@
+/* Name: usbdrvasm20.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Jeroen Benschop
+ * Based on usbdrvasm16.inc from Christian Starkjohann
+ * Creation Date: 2008-03-05
+ * Tabsize: 4
+ * Copyright: (c) 2008 by Jeroen Benschop and OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 20 MHz version of the asssembler part of the USB driver. It
+requires a 20 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+#define leap2   x3
+#ifdef __IAR_SYSTEMS_ASM__
+#define nextInst    $+2
+#else
+#define nextInst    .+0
+#endif
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 20 MHz -> 13.333333 cycles per bit, 106.666667 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+;register use in receive loop:
+; shift assembles the byte currently being received
+; x1 holds the D+ and D- line state
+; x2 holds the previous line state
+; x4 (leap)  is used to add a leap cycle once every three bytes received
+; X3 (leap2) is used to add a leap cycle once every three stuff bits received
+; bitcnt is used to determine when a stuff bit is due
+; cnt holds the number of bytes left in the receive buffer
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-26]
+    push    YL                  ;[-25]
+    push    YH                  ;[-23]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-19]
+    rjmp    foundK              ;[-18]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-16]
+;{3, 5} after falling D- edge, average delay: 4 cycles
+;bit0 should be at 34 for center sampling. Currently at 4 so 30 cylces till bit 0 sample
+;use 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    bitcnt              ;[-16]
+;   [---]                       ;[-15]
+    lds     YL, usbInputBufOffset;[-14]
+;   [---]                       ;[-13]
+    clr     YH                  ;[-12]
+    subi    YL, lo8(-(usbRxBuf));[-11] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-10] [rx loop init]
+    push    shift               ;[-9]
+;   [---]                       ;[-8]
+    ldi     shift,0x40          ;[-7] set msb to "1" so processing bit7 can be detected
+    nop2                        ;[-6]
+;   [---]                       ;[-5]
+    ldi     bitcnt, 5           ;[-4] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
+    rjmp    haveTwoBitsK        ;[-2]
+    pop     shift               ;[-1] undo the push from before
+    pop     bitcnt              ;[1] 
+    rjmp    waitForK            ;[3] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 27 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1                  ;[0]
+    push    x2                  ;[2]
+    push    x3                  ;[4] (leap2)
+    ldi     leap2, 0x55         ;[6] add leap cycle on 2nd,5th,8th,... stuff bit
+    push    x4                  ;[7] == leap
+    ldi     leap, 0x55          ;[9] skip leap cycle on 2nd,5th,8th,... byte received
+    push    cnt                 ;[10]
+    ldi     cnt, USB_BUFSIZE    ;[12] [rx loop init]
+    ldi     x2, 1<<USBPLUS      ;[13] current line state is K state. D+=="1", D-=="0"
+bit0:       
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    rjmp    handleBit           ;[2] make bit0 14 cycles long
+
+;----------------------------------------------------------------------------
+; Process bit7. However, bit 6 still may need unstuffing.
+;----------------------------------------------------------------------------
+
+b6checkUnstuff:
+    dec     bitcnt              ;[9]
+    breq    unstuff6            ;[10]
+bit7:
+    subi    cnt, 1              ;[11] cannot use dec becaus it does not affect the carry flag
+    brcs    overflow            ;[12] Too many bytes received. Ignore packet
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    cpse    x1, x2              ;[2] when previous line state equals current line state, handle "1"
+    rjmp    b7handle0           ;[3] when line state differs, handle "0"
+    sec                         ;[4]
+    ror     shift               ;[5] shift "1" into the data
+    st      y+, shift           ;[6] store the data into the buffer
+    ldi     shift, 0x40         ;[7] reset data for receiving the next byte
+    subi    leap, 0x55          ;[9] trick to introduce a leap cycle every 3 bytes
+    brcc    nextInst            ;[10 or 11] it will fail after 85 bytes. However low speed can only receive 11
+    dec     bitcnt              ;[11 or 12]
+    brne    bit0                ;[12 or 13]
+    ldi     x1, 1               ;[13 or 14] unstuffing bit 7
+    in      bitcnt, USBIN       ;[0] sample stuff bit
+    rjmp    unstuff             ;[1]
+
+b7handle0:
+    mov     x2,x1               ;[5] Set x2 to current line state
+    ldi     bitcnt, 6           ;[6]
+    lsr     shift               ;[7] shift "0" into the data
+    st      y+, shift           ;[8] store data into the buffer
+    ldi     shift, 0x40         ;[10] reset data for receiving the next byte
+    subi    leap, 0x55          ;[11] trick to introduce a leap cycle every 3 bytes
+    brcs    bit0                ;[12] it will fail after 85 bytes. However low speed can only receive 11
+    rjmp    bit0                ;[13]
+
+
+;----------------------------------------------------------------------------
+; Handle unstuff
+; x1==0xFF indicate unstuffing bit6
+;----------------------------------------------------------------------------
+
+unstuff6:
+    ldi     x1,0xFF             ;[12] indicate unstuffing bit 6
+    in      bitcnt, USBIN       ;[0]  sample stuff bit
+    nop                         ;[1]  fix timing
+unstuff:                        ;b0-5  b6   b7
+    mov     x2,bitcnt           ;[3]  [2]  [3]  Set x2 to match line state
+    subi    leap2, 0x55         ;[4]  [3]  [4]  delay loop
+    brcs    nextInst            ;[5]  [4]  [5]  add one cycle every three stuff bits
+    sbci    leap2,0             ;[6]  [5]  [6]
+    ldi     bitcnt,6            ;[7]  [6]  [7]  reset bit stuff counter
+    andi    x2, USBMASK         ;[8]  [7]  [8] only keep D+ and D-
+    cpi     x1,0                ;[9]  [8]  [9]
+    brmi    bit7                ;[10] [9]  [10] finished unstuffing bit6 When x1<0
+    breq    bitloop             ;[11] ---  [11] finished unstuffing bit0-5 when x1=0
+    nop                         ;---  ---  [12]
+    in      x1, USBIN           ;---  ---  [0] sample line state for bit0
+    andi    x1, USBMASK         ;---  ---  [1] filter only D+ and D- bits
+    rjmp    handleBit           ;---  ---  [2] make bit0 14 cycles long
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+bitloop:
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    breq    se0                 ;[2] both lines are low so handle se0
+handleBit:
+    cpse    x1, x2              ;[3] when previous line state equals current line state, handle "1"
+    rjmp    handle0             ;[4] when line state differs, handle "0"
+    sec                         ;[5]
+    ror     shift               ;[6] shift "1" into the data
+    brcs    b6checkUnstuff      ;[7] When after shift C is set, next bit is bit7
+    nop2                        ;[8]
+    dec     bitcnt              ;[10]
+    brne    bitloop             ;[11]
+    ldi     x1,0                ;[12] indicate unstuff for bit other than bit6 or bit7
+    in      bitcnt, USBIN       ;[0] sample stuff bit
+    rjmp    unstuff             ;[1]
+
+handle0:
+    mov     x2, x1              ;[6] Set x2 to current line state
+    ldi     bitcnt, 6           ;[7] reset unstuff counter. 
+    lsr     shift               ;[8] shift "0" into the data
+    brcs    bit7                ;[9] When after shift C is set, next bit is bit7
+    nop                         ;[10]
+    rjmp    bitloop             ;[11] 
+    
+;----------------------------------------------------------------------------
+; End of receive loop. Now start handling EOP
+;----------------------------------------------------------------------------
+
+macro POP_STANDARD ; 14 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     bitcnt
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+
+
+#include "asmcommon.inc"
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+; 7.5 bit times is 100 cycles. This implementation arrives a bit later at se0
+; then specified in the include file but there is plenty of time
+
+bitstuffN:
+    eor     x1, x4          ;[8]
+    ldi     x2, 0           ;[9]
+    nop2                    ;[10]
+    out     USBOUT, x1      ;[12] <-- out
+    rjmp    didStuffN       ;[0]
+    
+bitstuff7:
+    eor     x1, x4          ;[6]
+    ldi     x2, 0           ;[7] Carry is zero due to brcc
+    rol     shift           ;[8] compensate for ror shift at branch destination
+    nop2                    ;[9]
+    rjmp    didStuff7       ;[11]
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We don't match the transfer rate exactly (don't insert leap cycles every third
+;byte) because the spec demands only 1.5% precision anyway.
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x49    ;[-4]        [10] binary 01001001
+txBitLoop:
+    sbrs    shift, 0        ;[-3] [10]   [11]
+    eor     x1, x4          ;[-2] [11]   [12]
+    out     USBOUT, x1      ;[-1] [12]   [13]   <-- out N
+    ror     shift           ;[0]  [13]   [14]
+    ror     x2              ;[1]
+didStuffN:
+    nop2                    ;[2]
+    nop                     ;[4]
+    cpi     x2, 0xfc        ;[5]
+    brcc    bitstuffN       ;[6]
+    lsr     bitcnt          ;[7]
+    brcc    txBitLoop       ;[8]
+    brne    txBitLoop       ;[9]
+
+    sbrs    shift, 0        ;[10]
+    eor     x1, x4          ;[11]
+didStuff7:
+    out     USBOUT, x1      ;[-1] [13] <-- out 7
+    ror     shift           ;[0] [14]
+    ror     x2              ;[1]
+    nop                     ;[2]
+    cpi     x2, 0xfc        ;[3]
+    brcc    bitstuff7       ;[4]
+    ld      shift, y+       ;[5]
+    dec     cnt             ;[7]
+    brne    txByteLoop      ;[8]
+;make SE0:
+    cbr     x1, USBMASK     ;[9] prepare SE0 [spec says EOP may be 25 to 30 cycles]
+    lds     x2, usbNewDeviceAddr;[10]
+    lsl     x2              ;[12] we compare with left shifted address
+    out     USBOUT, x1      ;[13] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+    subi    YL, 20 + 2      ;[0] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[1]
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[2]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[5]
+    ori     x1, USBIDLE     ;[6]
+    in      x2, USBDDR      ;[7]
+    cbr     x2, USBMASK     ;[8] set both pins to input
+    mov     x3, x1          ;[9]
+    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
+    ldi     x4, 5           ;[11]
+se0Delay:
+    dec     x4              ;[12] [15] [18] [21] [24]
+    brne    se0Delay        ;[13] [16] [19] [22] [25]
+    out     USBOUT, x1      ;[26] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[27] <-- release bus now
+    out     USBOUT, x3      ;[28] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: usbdrv/usbportability.h
===================================================================
--- usbdrv/usbportability.h	(nonexistent)
+++ usbdrv/usbportability.h	(working copy)
@@ -0,0 +1,143 @@
+/* Name: usbportability.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-06-17
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This header is intended to contain all (or at least most of) the compiler
+and library dependent stuff. The C code is written for avr-gcc and avr-libc.
+The API of other development environments is converted to gcc's and avr-libc's
+API by means of defines.
+
+This header also contains all system includes since they depend on the
+development environment.
+
+Thanks to Oleg Semyonov for his help with the IAR tools port!
+*/
+
+#ifndef __usbportability_h_INCLUDED__
+#define __usbportability_h_INCLUDED__
+
+/* We check explicitly for IAR and CodeVision. Default is avr-gcc/avr-libc. */
+
+/* ------------------------------------------------------------------------- */
+#if defined __IAR_SYSTEMS_ICC__ || defined __IAR_SYSTEMS_ASM__  /* check for IAR */
+/* ------------------------------------------------------------------------- */
+
+#ifndef ENABLE_BIT_DEFINITIONS
+#   define ENABLE_BIT_DEFINITIONS	1   /* Enable bit definitions */
+#endif
+
+/* Include IAR headers */
+#include <ioavr.h>
+#ifndef __IAR_SYSTEMS_ASM__
+#   include <inavr.h>
+#endif
+
+#define __attribute__(arg)  /* not supported on IAR */
+
+#ifdef __IAR_SYSTEMS_ASM__
+#   define __ASSEMBLER__    /* IAR does not define standard macro for asm */
+#endif
+
+#ifdef __HAS_ELPM__
+#   define PROGMEM __farflash
+#else
+#   define PROGMEM __flash
+#endif
+
+#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+
+/* The following definitions are not needed by the driver, but may be of some
+ * help if you port a gcc based project to IAR.
+ */
+#define cli()       __disable_interrupt()
+#define sei()       __enable_interrupt()
+#define wdt_reset() __watchdog_reset()
+#define _BV(x)      (1 << (x))
+
+/* assembler compatibility macros */
+#define nop2    rjmp    $+2 /* jump to next instruction */
+#define XL      r26
+#define XH      r27
+#define YL      r28
+#define YH      r29
+#define ZL      r30
+#define ZH      r31
+#define lo8(x)  LOW(x)
+#define hi8(x)  (((x)>>8) & 0xff)   /* not HIGH to allow XLINK to make a proper range check */
+
+/* Depending on the device you use, you may get problems with the way usbdrv.h
+ * handles the differences between devices. Since IAR does not use #defines
+ * for MCU registers, we can't check for the existence of a particular
+ * register with an #ifdef. If the autodetection mechanism fails, include
+ * definitions for the required USB_INTR_* macros in your usbconfig.h. See
+ * usbconfig-prototype.h and usbdrv.h for details.
+ */
+
+/* ------------------------------------------------------------------------- */
+#elif __CODEVISIONAVR__ /* check for CodeVision AVR */
+/* ------------------------------------------------------------------------- */
+/* This port is not working (yet) */
+
+/* #define F_CPU   _MCU_CLOCK_FREQUENCY_    seems to be defined automatically */
+
+#include <io.h>
+#include <delay.h>
+
+#define __attribute__(arg)  /* not supported on IAR */
+
+#define PROGMEM                 __flash
+#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+
+#ifndef __ASSEMBLER__
+static inline void  cli(void)
+{
+    #asm("cli");
+}
+static inline void  sei(void)
+{
+    #asm("sei");
+}
+#endif
+#define _delay_ms(t)    delay_ms(t)
+#define _BV(x)          (1 << (x))
+#define USB_CFG_USE_SWITCH_STATEMENT 1  /* macro for if() cascase fails for unknown reason */
+
+#define macro   .macro
+#define endm    .endmacro
+#define nop2    rjmp    .+0 /* jump to next instruction */
+
+/* ------------------------------------------------------------------------- */
+#else   /* default development environment is avr-gcc/avr-libc */
+/* ------------------------------------------------------------------------- */
+
+#include <avr/io.h>
+#ifdef __ASSEMBLER__
+#   define _VECTOR(N)   __vector_ ## N   /* io.h does not define this for asm */
+#else
+#   include <avr/pgmspace.h>
+#endif
+
+#if USB_CFG_DRIVER_FLASH_PAGE
+#   define USB_READ_FLASH(addr)    pgm_read_byte_far(((long)USB_CFG_DRIVER_FLASH_PAGE << 16) | (long)(addr))
+#else
+#   define USB_READ_FLASH(addr)    pgm_read_byte(addr)
+#endif
+
+#define macro   .macro
+#define endm    .endm
+#define nop2    rjmp    .+0 /* jump to next instruction */
+
+#endif  /* development environment */
+
+/* for conveniecne, ensure that PRG_RDB exists */
+#ifndef PRG_RDB
+#   define PRG_RDB(addr)    USB_READ_FLASH(addr)
+#endif
+#endif  /* __usbportability_h_INCLUDED__ */
Index: usbdrv/asmcommon.inc
===================================================================
--- usbdrv/asmcommon.inc	(nonexistent)
+++ usbdrv/asmcommon.inc	(working copy)
@@ -0,0 +1,187 @@
+/* Name: asmcommon.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-11-05
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file contains assembler code which is shared among the USB driver
+implementations for different CPU cocks. Since the code must be inserted
+in the middle of the module, it's split out into this file and #included.
+
+Jump destinations called from outside:
+    sofError: Called when no start sequence was found.
+    se0: Called when a package has been successfully received.
+    overflow: Called when receive buffer overflows.
+    doReturn: Called after sending data.
+
+Outside jump destinations used by this module:
+    waitForJ: Called to receive an already arriving packet.
+    sendAckAndReti:
+    sendNakAndReti:
+    sendCntAndReti:
+    usbSendAndReti:
+
+The following macros must be defined before this file is included:
+    .macro POP_STANDARD
+    .endm
+    .macro POP_RETI
+    .endm
+*/
+
+#define token   x1
+
+overflow:
+    ldi     x2, 1<<USB_INTR_PENDING_BIT
+    USB_STORE_PENDING(x2)       ; clear any pending interrupts
+ignorePacket:
+    clr     token
+    rjmp    storeTokenAndReturn
+
+;----------------------------------------------------------------------------
+; Processing of received packet (numbers in brackets are cycles after center of SE0)
+;----------------------------------------------------------------------------
+;This is the only non-error exit point for the software receiver loop
+;we don't check any CRCs here because there is no time left.
+se0:
+    subi    cnt, USB_BUFSIZE    ;[5]
+    neg     cnt                 ;[6]
+    sub     YL, cnt             ;[7]
+    sbci    YH, 0               ;[8]
+    ldi     x2, 1<<USB_INTR_PENDING_BIT ;[9]
+    USB_STORE_PENDING(x2)       ;[10] clear pending intr and check flag later. SE0 should be over.
+    ld      token, y            ;[11]
+    cpi     token, USBPID_DATA0 ;[13]
+    breq    handleData          ;[14]
+    cpi     token, USBPID_DATA1 ;[15]
+    breq    handleData          ;[16]
+    lds     shift, usbDeviceAddr;[17]
+    ldd     x2, y+1             ;[19] ADDR and 1 bit endpoint number
+    lsl     x2                  ;[21] shift out 1 bit endpoint number
+    cpse    x2, shift           ;[22]
+    rjmp    ignorePacket        ;[23]
+/* only compute endpoint number in x3 if required later */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT || USB_CFG_IMPLEMENT_FN_WRITEOUT
+    ldd     x3, y+2             ;[24] endpoint number + crc
+    rol     x3                  ;[26] shift in LSB of endpoint
+#endif
+    cpi     token, USBPID_IN    ;[27]
+    breq    handleIn            ;[28]
+    cpi     token, USBPID_SETUP ;[29]
+    breq    handleSetupOrOut    ;[30]
+    cpi     token, USBPID_OUT   ;[31]
+    brne    ignorePacket        ;[32] must be ack, nak or whatever
+;   rjmp    handleSetupOrOut    ; fallthrough
+
+;Setup and Out are followed by a data packet two bit times (16 cycles) after
+;the end of SE0. The sync code allows up to 40 cycles delay from the start of
+;the sync pattern until the first bit is sampled. That's a total of 56 cycles.
+handleSetupOrOut:               ;[32]
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT   /* if we have data for endpoint != 0, set usbCurrentTok to address */
+    andi    x3, 0xf             ;[32]
+    breq    storeTokenAndReturn ;[33]
+    mov     token, x3           ;[34] indicate that this is endpoint x OUT
+#endif
+storeTokenAndReturn:
+    sts     usbCurrentTok, token;[35]
+doReturn:
+    POP_STANDARD                ;[37] 12...16 cycles
+    USB_LOAD_PENDING(YL)        ;[49]
+    sbrc    YL, USB_INTR_PENDING_BIT;[50] check whether data is already arriving
+    rjmp    waitForJ            ;[51] save the pops and pushes -- a new interrupt is already pending
+sofError:
+    POP_RETI                    ;macro call
+    reti
+
+handleData:
+#if USB_CFG_CHECK_CRC
+    CRC_CLEANUP_AND_CHECK       ; jumps to ignorePacket if CRC error
+#endif
+    lds     shift, usbCurrentTok;[18]
+    tst     shift               ;[20]
+    breq    doReturn            ;[21]
+    lds     x2, usbRxLen        ;[22]
+    tst     x2                  ;[24]
+    brne    sendNakAndReti      ;[25]
+; 2006-03-11: The following two lines fix a problem where the device was not
+; recognized if usbPoll() was called less frequently than once every 4 ms.
+    cpi     cnt, 4              ;[26] zero sized data packets are status phase only -- ignore and ack
+    brmi    sendAckAndReti      ;[27] keep rx buffer clean -- we must not NAK next SETUP
+#if USB_CFG_CHECK_DATA_TOGGLING
+    sts     usbCurrentDataToken, token  ; store for checking by C code
+#endif
+    sts     usbRxLen, cnt       ;[28] store received data, swap buffers
+    sts     usbRxToken, shift   ;[30]
+    lds     x2, usbInputBufOffset;[32] swap buffers
+    ldi     cnt, USB_BUFSIZE    ;[34]
+    sub     cnt, x2             ;[35]
+    sts     usbInputBufOffset, cnt;[36] buffers now swapped
+    rjmp    sendAckAndReti      ;[38] 40 + 17 = 57 until SOP
+
+handleIn:
+;We don't send any data as long as the C code has not processed the current
+;input data and potentially updated the output data. That's more efficient
+;in terms of code size than clearing the tx buffers when a packet is received.
+    lds     x1, usbRxLen        ;[30]
+    cpi     x1, 1               ;[32] negative values are flow control, 0 means "buffer free"
+    brge    sendNakAndReti      ;[33] unprocessed input packet?
+    ldi     x1, USBPID_NAK      ;[34] prepare value for usbTxLen
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+    andi    x3, 0xf             ;[35] x3 contains endpoint
+#if USB_CFG_SUPPRESS_INTR_CODE
+    brne    sendNakAndReti      ;[36]
+#else
+    brne    handleIn1           ;[36]
+#endif
+#endif
+    lds     cnt, usbTxLen       ;[37]
+    sbrc    cnt, 4              ;[39] all handshake tokens have bit 4 set
+    rjmp    sendCntAndReti      ;[40] 42 + 16 = 58 until SOP
+    sts     usbTxLen, x1        ;[41] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf)   ;[43]
+    ldi     YH, hi8(usbTxBuf)   ;[44]
+    rjmp    usbSendAndReti      ;[45] 57 + 12 = 59 until SOP
+
+; Comment about when to set usbTxLen to USBPID_NAK:
+; We should set it back when we receive the ACK from the host. This would
+; be simple to implement: One static variable which stores whether the last
+; tx was for endpoint 0 or 1 and a compare in the receiver to distinguish the
+; ACK. However, we set it back immediately when we send the package,
+; assuming that no error occurs and the host sends an ACK. We save one byte
+; RAM this way and avoid potential problems with endless retries. The rest of
+; the driver assumes error-free transfers anyway.
+
+#if !USB_CFG_SUPPRESS_INTR_CODE && USB_CFG_HAVE_INTRIN_ENDPOINT /* placed here due to relative jump range */
+handleIn1:                      ;[38]
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+; 2006-06-10 as suggested by O.Tamura: support second INTR IN / BULK IN endpoint
+    cpi     x3, USB_CFG_EP3_NUMBER;[38]
+    breq    handleIn3           ;[39]
+#endif
+    lds     cnt, usbTxLen1      ;[40]
+    sbrc    cnt, 4              ;[42] all handshake tokens have bit 4 set
+    rjmp    sendCntAndReti      ;[43] 47 + 16 = 63 until SOP
+    sts     usbTxLen1, x1       ;[44] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf1)  ;[46]
+    ldi     YH, hi8(usbTxBuf1)  ;[47]
+    rjmp    usbSendAndReti      ;[48] 50 + 12 = 62 until SOP
+
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+handleIn3:
+    lds     cnt, usbTxLen3      ;[41]
+    sbrc    cnt, 4              ;[43]
+    rjmp    sendCntAndReti      ;[44] 49 + 16 = 65 until SOP
+    sts     usbTxLen3, x1       ;[45] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf3)  ;[47]
+    ldi     YH, hi8(usbTxBuf3)  ;[48]
+    rjmp    usbSendAndReti      ;[49] 51 + 12 = 63 until SOP
+#endif
+#endif
Index: usbdrv/Changelog.txt
===================================================================
--- usbdrv/Changelog.txt	(nonexistent)
+++ usbdrv/Changelog.txt	(working copy)
@@ -0,0 +1,329 @@
+This file documents changes in the firmware-only USB driver for atmel's AVR
+microcontrollers. New entries are always appended to the end of the file.
+Scroll down to the bottom to see the most recent changes.
+
+2005-04-01:
+  - Implemented endpoint 1 as interrupt-in endpoint.
+  - Moved all configuration options to usbconfig.h which is not part of the
+    driver.
+  - Changed interface for usbVendorSetup().
+  - Fixed compatibility with ATMega8 device.
+  - Various minor optimizations.
+
+2005-04-11:
+  - Changed interface to application: Use usbFunctionSetup(), usbFunctionRead()
+    and usbFunctionWrite() now. Added configuration options to choose which
+    of these functions to compile in.
+  - Assembler module delivers receive data non-inverted now.
+  - Made register and bit names compatible with more AVR devices.
+
+2005-05-03:
+  - Allow address of usbRxBuf on any memory page as long as the buffer does
+    not cross 256 byte page boundaries.
+  - Better device compatibility: works with Mega88 now.
+  - Code optimization in debugging module.
+  - Documentation updates.
+
+2006-01-02:
+  - Added (free) default Vendor- and Product-IDs bought from voti.nl.
+  - Added USBID-License.txt file which defines the rules for using the free
+    shared VID/PID pair.
+  - Added Readme.txt to the usbdrv directory which clarifies administrative
+    issues.
+
+2006-01-25:
+  - Added "configured state" to become more standards compliant.
+  - Added "HALT" state for interrupt endpoint.
+  - Driver passes the "USB Command Verifier" test from usb.org now.
+  - Made "serial number" a configuration option.
+  - Minor optimizations, we now recommend compiler option "-Os" for best
+    results.
+  - Added a version number to usbdrv.h
+
+2006-02-03:
+  - New configuration variable USB_BUFFER_SECTION for the memory section where
+    the USB rx buffer will go. This defaults to ".bss" if not defined. Since
+    this buffer MUST NOT cross 256 byte pages (not even touch a page at the
+    end), the user may want to pass a linker option similar to
+    "-Wl,--section-start=.mybuffer=0x800060".
+  - Provide structure for usbRequest_t.
+  - New defines for USB constants.
+  - Prepared for HID implementations.
+  - Increased data size limit for interrupt transfers to 8 bytes.
+  - New macro usbInterruptIsReady() to query interrupt buffer state.
+
+2006-02-18:
+  - Ensure that the data token which is sent as an ack to an OUT transfer is
+    always zero sized. This fixes a bug where the host reports an error after
+    sending an out transfer to the device, although all data arrived at the
+    device.
+  - Updated docs in usbdrv.h to reflect changed API in usbFunctionWrite().
+
+* Release 2006-02-20
+
+  - Give a compiler warning when compiling with debugging turned on.
+  - Added Oleg Semyonov's changes for IAR-cc compatibility.
+  - Added new (optional) functions usbDeviceConnect() and usbDeviceDisconnect()
+    (also thanks to Oleg!).
+  - Rearranged tests in usbPoll() to save a couple of instructions in the most
+    likely case that no actions are pending.
+  - We need a delay between the SET ADDRESS request until the new address
+    becomes active. This delay was handled in usbPoll() until now. Since the
+    spec says that the delay must not exceed 2ms, previous versions required
+    aggressive polling during the enumeration phase. We have now moved the
+    handling of the delay into the interrupt routine.
+  - We must not reply with NAK to a SETUP transaction. We can only achieve this
+    by making sure that the rx buffer is empty when SETUP tokens are expected.
+    We therefore don't pass zero sized data packets from the status phase of
+    a transfer to usbPoll(). This change MAY cause troubles if you rely on
+    receiving a less than 8 bytes long packet in usbFunctionWrite() to
+    identify the end of a transfer. usbFunctionWrite() will NEVER be called
+    with a zero length.
+
+* Release 2006-03-14
+
+  - Improved IAR C support: tiny memory model, more devices
+  - Added template usbconfig.h file under the name usbconfig-prototype.h
+
+* Release 2006-03-26
+
+  - Added provision for one more interrupt-in endpoint (endpoint 3).
+  - Added provision for one interrupt-out endpoint (endpoint 1).
+  - Added flowcontrol macros for USB.
+  - Added provision for custom configuration descriptor.
+  - Allow ANY two port bits for D+ and D-.
+  - Merged (optional) receive endpoint number into global usbRxToken variable.
+  - Use USB_CFG_IOPORTNAME instead of USB_CFG_IOPORT. We now construct the
+    variable name from the single port letter instead of computing the address
+    of related ports from the output-port address.
+
+* Release 2006-06-26
+
+  - Updated documentation in usbdrv.h and usbconfig-prototype.h to reflect the
+    new features.
+  - Removed "#warning" directives because IAR does not understand them. Use
+    unused static variables instead to generate a warning.
+  - Do not include <avr/io.h> when compiling with IAR.
+  - Introduced USB_CFG_DESCR_PROPS_* in usbconfig.h to configure how each
+    USB descriptor should be handled. It is now possible to provide descriptor
+    data in Flash, RAM or dynamically at runtime.
+  - STALL is now a status in usbTxLen* instead of a message. We can now conform
+    to the spec and leave the stall status pending until it is cleared.
+  - Made usbTxPacketCnt1 and usbTxPacketCnt3 public. This allows the
+    application code to reset data toggling on interrupt pipes.
+
+* Release 2006-07-18
+
+  - Added an #if !defined __ASSEMBLER__ to the warning in usbdrv.h. This fixes
+    an assembler error.
+  - usbDeviceDisconnect() takes pull-up resistor to high impedance now.
+
+* Release 2007-02-01
+
+  - Merged in some code size improvements from usbtiny (thanks to Dick
+    Streefland for these optimizations!)
+  - Special alignment requirement for usbRxBuf not required any more. Thanks
+    again to Dick Streefland for this hint!
+  - Reverted to "#warning" instead of unused static variables -- new versions
+    of IAR CC should handle this directive.
+  - Changed Open Source license to GNU GPL v2 in order to make linking against
+    other free libraries easier. We no longer require publication of the
+    circuit diagrams, but we STRONGLY encourage it. If you improve the driver
+    itself, PLEASE grant us a royalty free license to your changes for our
+    commercial license.
+
+* Release 2007-03-29
+
+  - New configuration option "USB_PUBLIC" in usbconfig.h.
+  - Set USB version number to 1.10 instead of 1.01.
+  - Code used USB_CFG_DESCR_PROPS_STRING_DEVICE and
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT inconsistently. Changed all occurrences
+    to USB_CFG_DESCR_PROPS_STRING_PRODUCT.
+  - New assembler module for 16.5 MHz RC oscillator clock with PLL in receiver
+    code.
+  - New assembler module for 16 MHz crystal.
+  - usbdrvasm.S contains common code only, clock-specific parts have been moved
+    to usbdrvasm12.S, usbdrvasm16.S and usbdrvasm165.S respectively.
+
+* Release 2007-06-25
+
+  - 16 MHz module: Do SE0 check in stuffed bits as well.
+
+* Release 2007-07-07
+
+  - Define hi8(x) for IAR compiler to limit result to 8 bits. This is necessary
+    for negative values.
+  - Added 15 MHz module contributed by V. Bosch.
+  - Interrupt vector name can now be configured. This is useful if somebody
+    wants to use a different hardware interrupt than INT0.
+
+* Release 2007-08-07
+
+  - Moved handleIn3 routine in usbdrvasm16.S so that relative jump range is
+    not exceeded.
+  - More config options: USB_RX_USER_HOOK(), USB_INITIAL_DATATOKEN,
+    USB_COUNT_SOF
+  - USB_INTR_PENDING can now be a memory address, not just I/O
+
+* Release 2007-09-19
+
+  - Split out common parts of assembler modules into separate include file
+  - Made endpoint numbers configurable so that given interface definitions
+    can be matched. See USB_CFG_EP3_NUMBER in usbconfig-prototype.h.
+  - Store endpoint number for interrupt/bulk-out so that usbFunctionWriteOut()
+    can handle any number of endpoints.
+  - Define usbDeviceConnect() and usbDeviceDisconnect() even if no
+    USB_CFG_PULLUP_IOPORTNAME is defined. Directly set D+ and D- to 0 in this
+    case.
+
+* Release 2007-12-01
+
+  - Optimize usbDeviceConnect() and usbDeviceDisconnect() for less code size
+    when USB_CFG_PULLUP_IOPORTNAME is not defined.
+
+* Release 2007-12-13
+
+  - Renamed all include-only assembler modules from *.S to *.inc so that
+    people don't add them to their project sources.
+  - Distribute leap bits in tx loop more evenly for 16 MHz module.
+  - Use "macro" and "endm" instead of ".macro" and ".endm" for IAR
+  - Avoid compiler warnings for constant expr range by casting some values in
+    USB descriptors.
+
+* Release 2008-01-21
+
+  - Fixed bug in 15 and 16 MHz module where the new address set with
+    SET_ADDRESS was already accepted at the next NAK or ACK we send, not at
+    the next data packet we send. This caused problems when the host polled
+    too fast. Thanks to Alexander Neumann for his help and patience debugging
+    this issue!
+
+* Release 2008-02-05
+
+  - Fixed bug in 16.5 MHz module where a register was used in the interrupt
+    handler before it was pushed. This bug was introduced with version
+    2007-09-19 when common parts were moved to a separate file.
+  - Optimized CRC routine (thanks to Reimar Doeffinger).
+
+* Release 2008-02-16
+
+  - Removed outdated IAR compatibility stuff (code sections).
+  - Added hook macros for USB_RESET_HOOK() and USB_SET_ADDRESS_HOOK().
+  - Added optional routine usbMeasureFrameLength() for calibration of the
+    internal RC oscillator.
+
+* Release 2008-02-28
+
+  - USB_INITIAL_DATATOKEN defaults to USBPID_DATA1 now, which means that we
+    start with sending USBPID_DATA0.
+  - Changed defaults in usbconfig-prototype.h
+  - Added free USB VID/PID pair for MIDI class devices
+  - Restructured AVR-USB as separate package, not part of PowerSwitch any more.
+
+* Release 2008-04-18
+
+  - Restructured usbdrv.c so that it is easier to read and understand.
+  - Better code optimization with gcc 4.
+  - If a second interrupt in endpoint is enabled, also add it to config
+    descriptor.
+  - Added config option for long transfers (above 254 bytes), see
+    USB_CFG_LONG_TRANSFERS in usbconfig.h.
+  - Added 20 MHz module contributed by Jeroen Benschop.
+
+* Release 2008-05-13
+
+  - Fixed bug in libs-host/hiddata.c function usbhidGetReport(): length
+    was not incremented, pointer to length was incremented instead.
+  - Added code to command line tool(s) which claims an interface. This code
+    is disabled by default, but may be necessary on newer Linux kernels.
+  - Added usbconfig.h option "USB_CFG_CHECK_DATA_TOGGLING".
+  - New header "usbportability.h" prepares ports to other development
+    environments.
+  - Long transfers (above 254 bytes) did not work when usbFunctionRead() was
+    used to supply the data. Fixed this bug. [Thanks to Alexander Neumann!]
+  - In hiddata.c (example code for sending/receiving data over HID), use
+    USB_RECIP_DEVICE instead of USB_RECIP_INTERFACE for control transfers so
+    that we need not claim the interface.
+  - in usbPoll() loop 20 times polling for RESET state instead of 10 times.
+    This accounts for the higher clock rates we now support.
+  - Added a module for 12.8 MHz RC oscillator with PLL in receiver loop.
+  - Added hook to SOF code so that oscillator can be tuned to USB frame clock.
+  - Added timeout to waitForJ loop. Helps preventing unexpected hangs.
+  - Added example code for oscillator tuning to libs-device (thanks to
+    Henrik Haftmann for the idea to this routine).
+  - Implemented option USB_CFG_SUPPRESS_INTR_CODE.
+
+* Release 2008-10-22
+
+  - Fixed libs-device/osctune.h: OSCCAL is memory address on ATMega88 and
+    similar, not offset of 0x20 needs to be added.
+  - Allow distribution under GPLv3 for those who have to link against other
+    code distributed under GPLv3.
+
+* Release 2008-11-26
+
+  - Removed libusb-win32 dependency for hid-data example in Makefile.windows.
+    It was never required and confused many people.
+  - Added extern uchar usbRxToken to usbdrv.h.
+  - Integrated a module with CRC checks at 18 MHz by Lukas Schrittwieser.
+
+* Release 2009-03-23
+
+  - Hid-mouse example used settings from hid-data example, fixed that.
+  - Renamed project to V-USB due to a trademark issue with Atmel(r).
+  - Changed CommercialLicense.txt and USBID-License.txt to make the
+    background of USB ID registration clearer.
+
+* Release 2009-04-15
+
+  - Changed CommercialLicense.txt to reflect the new range of PIDs from
+    Jason Kotzin.
+  - Removed USBID-License.txt in favor of USB-IDs-for-free.txt and
+    USB-ID-FAQ.txt
+  - Fixed a bug in the 12.8 MHz module: End Of Packet decection was made in
+    the center between bit 0 and 1 of each byte. This is where the data lines
+    are expected to change and the sampled data may therefore be nonsense.
+    We therefore check EOP ONLY if bits 0 AND 1 have both been read as 0 on D-.
+  - Fixed a bitstuffing problem in the 16 MHz module: If bit 6 was stuffed,
+    the unstuffing code in the receiver routine was 1 cycle too long. If
+    multiple bytes had the unstuffing in bit 6, the error summed up until the
+    receiver was out of sync.
+  - Included option for faster CRC routine.
+    Thanks to Slawomir Fras (BoskiDialer) for this code!
+  - Updated bits in Configuration Descriptor's bmAttributes according to
+    USB 1.1 (in particular bit 7, it is a must-be-set bit now).
+
+* Release 2009-08-22
+
+  - Moved first DBG1() after odDebugInit() in all examples.
+  - Use vector INT0_vect instead of SIG_INTERRUPT0 if defined. This makes
+    V-USB compatible with the new "p" suffix devices (e.g. ATMega328p).
+  - USB_CFG_CLOCK_KHZ setting is now required in usbconfig.h (no default any
+    more).
+  - New option USB_CFG_DRIVER_FLASH_PAGE allows boot loaders on devices with
+    more than 64 kB flash.
+  - Built-in configuration descriptor allows custom definition for second
+    endpoint now.
+
+* Release 2010-07-15
+
+  - Fixed bug in usbDriverSetup() which prevented descriptor sizes above 255
+    bytes.
+  - Avoid a compiler warning for unused parameter in usbHandleResetHook() when
+    compiler option -Wextra is enabled.
+  - Fixed wrong hex value for some IDs in USB-IDs-for-free.txt.
+  - Keep a define for USBATTR_BUSPOWER, although the flag does not exist
+    in USB 1.1 any more. Set it to 0. This is for backward compatibility.
+
+* Release 2012-01-09
+
+  - Define a separate (defined) type for usbMsgPtr so that projects using a
+    tiny memory model can define it to an 8 bit type in usbconfig.h. This
+    change also saves a couple of bytes when using a scalar 16 bit type.
+  - Inserted "const" keyword for all PROGMEM declarations because new GCC
+    requires it.
+  - Fixed problem with dependence of usbportability.h on usbconfig.h. This
+    problem occurred with IAR CC only.
+  - Prepared repository for github.com.
+
+* Release 2012-12-06
\ No newline at end of file
Index: usbdrv/CommercialLicense.txt
===================================================================
--- usbdrv/CommercialLicense.txt	(nonexistent)
+++ usbdrv/CommercialLicense.txt	(working copy)
@@ -0,0 +1,166 @@
+V-USB Driver Software License Agreement
+Version 2012-07-09
+
+THIS LICENSE AGREEMENT GRANTS YOU CERTAIN RIGHTS IN A SOFTWARE. YOU CAN
+ENTER INTO THIS AGREEMENT AND ACQUIRE THE RIGHTS OUTLINED BELOW BY PAYING
+THE AMOUNT ACCORDING TO SECTION 4 ("PAYMENT") TO OBJECTIVE DEVELOPMENT.
+
+
+1 DEFINITIONS
+
+1.1 "OBJECTIVE DEVELOPMENT" shall mean OBJECTIVE DEVELOPMENT Software GmbH,
+Grosse Schiffgasse 1A/7, 1020 Wien, AUSTRIA.
+
+1.2 "You" shall mean the Licensee.
+
+1.3 "V-USB" shall mean all files included in the package distributed under
+the name "vusb" by OBJECTIVE DEVELOPMENT (http://www.obdev.at/vusb/)
+unless otherwise noted. This includes the firmware-only USB device
+implementation for Atmel AVR microcontrollers, some simple device examples
+and host side software examples and libraries.
+
+
+2 LICENSE GRANTS
+
+2.1 Source Code. OBJECTIVE DEVELOPMENT shall furnish you with the source
+code of V-USB.
+
+2.2 Distribution and Use. OBJECTIVE DEVELOPMENT grants you the
+non-exclusive right to use, copy and distribute V-USB with your hardware
+product(s), restricted by the limitations in section 3 below.
+
+2.3 Modifications. OBJECTIVE DEVELOPMENT grants you the right to modify
+the source code and your copy of V-USB according to your needs.
+
+2.4 USB IDs. OBJECTIVE DEVELOPMENT furnishes you with one or two USB
+Product ID(s), sent to you in e-mail. These Product IDs are reserved
+exclusively for you. OBJECTIVE DEVELOPMENT has obtained USB Product ID
+ranges under the Vendor ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under the Vendor ID 8352 from
+Jason Kotzin (now flirc.tv, Inc.). Both owners of the Vendor IDs have
+obtained these IDs from the USB Implementers Forum, Inc. (www.usb.org).
+OBJECTIVE DEVELOPMENT disclaims all liability which might arise from the
+assignment of USB IDs.
+
+2.5 USB Certification. Although not part of this agreement, we want to make
+it clear that you cannot become USB certified when you use V-USB or a USB
+Product ID assigned by OBJECTIVE DEVELOPMENT. AVR microcontrollers don't
+meet the electrical specifications required by the USB specification and
+the USB Implementers Forum certifies only members who bought a Vendor ID of
+their own.
+
+
+3 LICENSE RESTRICTIONS
+
+3.1 Number of Units. Only one of the following three definitions is
+applicable. Which one is determined by the amount you pay to OBJECTIVE
+DEVELOPMENT, see section 4 ("Payment") below.
+
+Hobby License: You may use V-USB according to section 2 above in no more
+than 5 hardware units. These units must not be sold for profit.
+
+Entry Level License: You may use V-USB according to section 2 above in no
+more than 150 hardware units.
+
+Professional License: You may use V-USB according to section 2 above in
+any number of hardware units, except for large scale production ("unlimited
+fair use"). Quantities below 10,000 units are not considered large scale
+production. If your reach quantities which are obviously large scale
+production, you must pay a license fee of 0.10 EUR per unit for all units
+above 10,000.
+
+3.2 Rental. You may not rent, lease, or lend V-USB or otherwise encumber
+any copy of V-USB, or any of the rights granted herein.
+
+3.3 Transfer. You may not transfer your rights under this Agreement to
+another party without OBJECTIVE DEVELOPMENT's prior written consent. If
+such consent is obtained, you may permanently transfer this License to
+another party. The recipient of such transfer must agree to all terms and
+conditions of this Agreement.
+
+3.4 Reservation of Rights. OBJECTIVE DEVELOPMENT retains all rights not
+expressly granted.
+
+3.5 Non-Exclusive Rights. Your license rights under this Agreement are
+non-exclusive.
+
+3.6 Third Party Rights. This Agreement cannot grant you rights controlled
+by third parties. In particular, you are not allowed to use the USB logo or
+other trademarks owned by the USB Implementers Forum, Inc. without their
+consent. Since such consent depends on USB certification, it should be
+noted that V-USB will not pass certification because it does not
+implement checksum verification and the microcontroller ports do not meet
+the electrical specifications.
+
+
+4 PAYMENT
+
+The payment amount depends on the variation of this agreement (according to
+section 3.1) into which you want to enter. Concrete prices are listed on
+OBJECTIVE DEVELOPMENT's web site, usually at
+http://www.obdev.at/vusb/license.html. You agree to pay the amount listed
+there to OBJECTIVE DEVELOPMENT or OBJECTIVE DEVELOPMENT's payment processor
+or reseller.
+
+
+5 COPYRIGHT AND OWNERSHIP
+
+V-USB is protected by copyright laws and international copyright
+treaties, as well as other intellectual property laws and treaties. V-USB
+is licensed, not sold.
+
+
+6 TERM AND TERMINATION
+
+6.1 Term. This Agreement shall continue indefinitely. However, OBJECTIVE
+DEVELOPMENT may terminate this Agreement and revoke the granted license and
+USB-IDs if you fail to comply with any of its terms and conditions.
+
+6.2 Survival of Terms. All provisions regarding secrecy, confidentiality
+and limitation of liability shall survive termination of this agreement.
+
+
+7 DISCLAIMER OF WARRANTY AND LIABILITY
+
+LIMITED WARRANTY. V-USB IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
+KIND. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, OBJECTIVE
+DEVELOPMENT AND ITS SUPPLIERS HEREBY DISCLAIM ALL WARRANTIES, EITHER
+EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND
+NON-INFRINGEMENT, WITH REGARD TO V-USB, AND THE PROVISION OF OR FAILURE
+TO PROVIDE SUPPORT SERVICES. THIS LIMITED WARRANTY GIVES YOU SPECIFIC LEGAL
+RIGHTS. YOU MAY HAVE OTHERS, WHICH VARY FROM STATE/JURISDICTION TO
+STATE/JURISDICTION.
+
+LIMITATION OF LIABILITY. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW,
+IN NO EVENT SHALL OBJECTIVE DEVELOPMENT OR ITS SUPPLIERS BE LIABLE FOR ANY
+SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER
+(INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
+BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY
+LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE V-USB OR THE
+PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES, EVEN IF OBJECTIVE
+DEVELOPMENT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY
+CASE, OBJECTIVE DEVELOPMENT'S ENTIRE LIABILITY UNDER ANY PROVISION OF THIS
+AGREEMENT SHALL BE LIMITED TO THE AMOUNT ACTUALLY PAID BY YOU FOR V-USB.
+
+
+8 MISCELLANEOUS TERMS
+
+8.1 Marketing. OBJECTIVE DEVELOPMENT has the right to mention for marketing
+purposes that you entered into this agreement.
+
+8.2 Entire Agreement. This document represents the entire agreement between
+OBJECTIVE DEVELOPMENT and you. It may only be modified in writing signed by
+an authorized representative of both, OBJECTIVE DEVELOPMENT and you.
+
+8.3 Severability. In case a provision of these terms and conditions should
+be or become partly or entirely invalid, ineffective, or not executable,
+the validity of all other provisions shall not be affected.
+
+8.4 Applicable Law. This agreement is governed by the laws of the Republic
+of Austria.
+
+8.5 Responsible Courts. The responsible courts in Vienna/Austria will have
+exclusive jurisdiction regarding all disputes in connection with this
+agreement.
+
Index: usbdrv/License.txt
===================================================================
--- usbdrv/License.txt	(nonexistent)
+++ usbdrv/License.txt	(working copy)
@@ -0,0 +1,361 @@
+OBJECTIVE DEVELOPMENT GmbH's V-USB driver software is distributed under the
+terms and conditions of the GNU GPL version 2 or the GNU GPL version 3. It is
+your choice whether you apply the terms of version 2 or version 3. The full
+text of GPLv2 is included below. In addition to the requirements in the GPL,
+we STRONGLY ENCOURAGE you to do the following:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: usbdrv/oddebug.c
===================================================================
--- usbdrv/oddebug.c	(nonexistent)
+++ usbdrv/oddebug.c	(working copy)
@@ -0,0 +1,49 @@
+/* Name: oddebug.c
+ * Project: AVR library
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-01-16
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include "oddebug.h"
+
+#if DEBUG_LEVEL > 0
+
+#warning "Never compile production devices with debugging enabled"
+
+static void uartPutc(char c)
+{
+    while(!(ODDBG_USR & (1 << ODDBG_UDRE)));    /* wait for data register empty */
+    ODDBG_UDR = c;
+}
+
+static uchar    hexAscii(uchar h)
+{
+    h &= 0xf;
+    if(h >= 10)
+        h += 'a' - (uchar)10 - '0';
+    h += '0';
+    return h;
+}
+
+static void printHex(uchar c)
+{
+    uartPutc(hexAscii(c >> 4));
+    uartPutc(hexAscii(c));
+}
+
+void    odDebug(uchar prefix, uchar *data, uchar len)
+{
+    printHex(prefix);
+    uartPutc(':');
+    while(len--){
+        uartPutc(' ');
+        printHex(*data++);
+    }
+    uartPutc('\r');
+    uartPutc('\n');
+}
+
+#endif
Index: usbdrv/oddebug.h
===================================================================
--- usbdrv/oddebug.h	(nonexistent)
+++ usbdrv/oddebug.h	(working copy)
@@ -0,0 +1,122 @@
+/* Name: oddebug.h
+ * Project: AVR library
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-01-16
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __oddebug_h_included__
+#define __oddebug_h_included__
+
+/*
+General Description:
+This module implements a function for debug logs on the serial line of the
+AVR microcontroller. Debugging can be configured with the define
+'DEBUG_LEVEL'. If this macro is not defined or defined to 0, all debugging
+calls are no-ops. If it is 1, DBG1 logs will appear, but not DBG2. If it is
+2, DBG1 and DBG2 logs will be printed.
+
+A debug log consists of a label ('prefix') to indicate which debug log created
+the output and a memory block to dump in hex ('data' and 'len').
+*/
+
+
+#ifndef F_CPU
+#   define  F_CPU   12000000    /* 12 MHz */
+#endif
+
+/* make sure we have the UART defines: */
+#include "usbportability.h"
+
+#ifndef uchar
+#   define  uchar   unsigned char
+#endif
+
+#if DEBUG_LEVEL > 0 && !(defined TXEN || defined TXEN0) /* no UART in device */
+#   warning "Debugging disabled because device has no UART"
+#   undef   DEBUG_LEVEL
+#endif
+
+#ifndef DEBUG_LEVEL
+#   define  DEBUG_LEVEL 0
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#if DEBUG_LEVEL > 0
+#   define  DBG1(prefix, data, len) odDebug(prefix, data, len)
+#else
+#   define  DBG1(prefix, data, len)
+#endif
+
+#if DEBUG_LEVEL > 1
+#   define  DBG2(prefix, data, len) odDebug(prefix, data, len)
+#else
+#   define  DBG2(prefix, data, len)
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#if DEBUG_LEVEL > 0
+extern void odDebug(uchar prefix, uchar *data, uchar len);
+
+/* Try to find our control registers; ATMEL likes to rename these */
+
+#if defined UBRR
+#   define  ODDBG_UBRR  UBRR
+#elif defined UBRRL
+#   define  ODDBG_UBRR  UBRRL
+#elif defined UBRR0
+#   define  ODDBG_UBRR  UBRR0
+#elif defined UBRR0L
+#   define  ODDBG_UBRR  UBRR0L
+#endif
+
+#if defined UCR
+#   define  ODDBG_UCR   UCR
+#elif defined UCSRB
+#   define  ODDBG_UCR   UCSRB
+#elif defined UCSR0B
+#   define  ODDBG_UCR   UCSR0B
+#endif
+
+#if defined TXEN
+#   define  ODDBG_TXEN  TXEN
+#else
+#   define  ODDBG_TXEN  TXEN0
+#endif
+
+#if defined USR
+#   define  ODDBG_USR   USR
+#elif defined UCSRA
+#   define  ODDBG_USR   UCSRA
+#elif defined UCSR0A
+#   define  ODDBG_USR   UCSR0A
+#endif
+
+#if defined UDRE
+#   define  ODDBG_UDRE  UDRE
+#else
+#   define  ODDBG_UDRE  UDRE0
+#endif
+
+#if defined UDR
+#   define  ODDBG_UDR   UDR
+#elif defined UDR0
+#   define  ODDBG_UDR   UDR0
+#endif
+
+static inline void  odDebugInit(void)
+{
+    ODDBG_UCR |= (1<<ODDBG_TXEN);
+    ODDBG_UBRR = F_CPU / (19200 * 16L) - 1;
+}
+#else
+#   define odDebugInit()
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#endif /* __oddebug_h_included__ */
Index: usbdrv/Readme.txt
===================================================================
--- usbdrv/Readme.txt	(nonexistent)
+++ usbdrv/Readme.txt	(working copy)
@@ -0,0 +1,172 @@
+This is the Readme file to Objective Development's firmware-only USB driver
+for Atmel AVR microcontrollers. For more information please visit
+http://www.obdev.at/vusb/
+
+This directory contains the USB firmware only. Copy it as-is to your own
+project and add all .c and .S files to your project (these files are marked
+with an asterisk in the list below). Then copy usbconfig-prototype.h as
+usbconfig.h to your project and edit it according to your configuration.
+
+
+TECHNICAL DOCUMENTATION
+=======================
+The technical documentation (API) for the firmware driver is contained in the
+file "usbdrv.h". Please read all of it carefully! Configuration options are
+documented in "usbconfig-prototype.h".
+
+The driver consists of the following files:
+  Readme.txt ............. The file you are currently reading.
+  Changelog.txt .......... Release notes for all versions of the driver.
+  usbdrv.h ............... Driver interface definitions and technical docs.
+* usbdrv.c ............... High level language part of the driver. Link this
+                           module to your code!
+* usbdrvasm.S ............ Assembler part of the driver. This module is mostly
+                           a stub and includes one of the usbdrvasm*.S files
+                           depending on processor clock. Link this module to
+                           your code!
+  usbdrvasm*.inc ......... Assembler routines for particular clock frequencies.
+                           Included by usbdrvasm.S, don't link it directly!
+  asmcommon.inc .......... Common assembler routines. Included by
+                           usbdrvasm*.inc, don't link it directly!
+  usbconfig-prototype.h .. Prototype for your own usbdrv.h file.
+* oddebug.c .............. Debug functions. Only used when DEBUG_LEVEL is
+                           defined to a value greater than 0. Link this module
+                           to your code!
+  oddebug.h .............. Interface definitions of the debug module.
+  usbportability.h ....... Header with compiler-dependent stuff.
+  usbdrvasm.asm .......... Compatibility stub for IAR-C-compiler. Use this
+                           module instead of usbdrvasm.S when you assembler
+                           with IAR's tools.
+  License.txt ............ Open Source license for this driver.
+  CommercialLicense.txt .. Optional commercial license for this driver.
+  USB-ID-FAQ.txt ......... General infos about USB Product- and Vendor-IDs.
+  USB-IDs-for-free.txt ... List and terms of use for free shared PIDs.
+
+(*) ... These files should be linked to your project.
+
+
+CPU CORE CLOCK FREQUENCY
+========================
+We supply assembler modules for clock frequencies of 12 MHz, 12.8 MHz, 15 MHz,
+16 MHz, 16.5 MHz 18 MHz and 20 MHz. Other clock rates are not supported. The
+actual clock rate must be configured in usbconfig.h.
+
+12 MHz Clock
+This is the traditional clock rate of V-USB because it's the lowest clock
+rate where the timing constraints of the USB spec can be met.
+
+15 MHz Clock
+Similar to 12 MHz, but some NOPs inserted. On the other hand, the higher clock
+rate allows for some loops which make the resulting code size somewhat smaller
+than the 12 MHz version.
+
+16 MHz Clock
+This clock rate has been added for users of the Arduino board and other
+ready-made boards which come with a fixed 16 MHz crystal. It's also an option
+if you need the slightly higher clock rate for performance reasons. Since
+16 MHz is not divisible by the USB low speed bit clock of 1.5 MHz, the code
+is somewhat tricky and has to insert a leap cycle every third byte.
+
+12.8 MHz and 16.5 MHz Clock
+The assembler modules for these clock rates differ from the other modules
+because they have been built for an RC oscillator with only 1% precision. The
+receiver code inserts leap cycles to compensate for clock deviations. 1% is
+also the precision which can be achieved by calibrating the internal RC
+oscillator of the AVR. Please note that only AVRs with internal 64 MHz PLL
+oscillator can reach 16.5 MHz with the RC oscillator. This includes the very
+popular ATTiny25, ATTiny45, ATTiny85 series as well as the ATTiny26. Almost
+all AVRs can reach 12.8 MHz, although this is outside the specified range.
+
+See the EasyLogger example at http://www.obdev.at/vusb/easylogger.html for
+code which calibrates the RC oscillator based on the USB frame clock.
+
+18 MHz Clock
+This module is closer to the USB specification because it performs an on the
+fly CRC check for incoming packets. Packets with invalid checksum are
+discarded as required by the spec. If you also implement checks for data
+PID toggling on application level (see option USB_CFG_CHECK_DATA_TOGGLING
+in usbconfig.h for more info), this ensures data integrity. Due to the CRC
+tables and alignment requirements, this code is bigger than modules for other
+clock rates. To activate this module, you must define USB_CFG_CHECK_CRC to 1
+and USB_CFG_CLOCK_KHZ to 18000 in usbconfig.h.
+
+20 MHz Clock
+This module is for people who won't do it with less than the maximum. Since
+20 MHz is not divisible by the USB low speed bit clock of 1.5 MHz, the code
+uses similar tricks as the 16 MHz module to insert leap cycles.
+
+
+USB IDENTIFIERS
+===============
+Every USB device needs a vendor- and a product-identifier (VID and PID). VIDs
+are obtained from usb.org for a price of 1,500 USD. Once you have a VID, you
+can assign PIDs at will.
+
+Since an entry level cost of 1,500 USD is too high for most small companies
+and hobbyists, we provide some VID/PID pairs for free. See the file
+USB-IDs-for-free.txt for details.
+
+Objective Development also has some license offerings which include product
+IDs. See http://www.obdev.at/vusb/ for details.
+
+
+DEVELOPMENT SYSTEM
+==================
+This driver has been developed and optimized for the GNU compiler version 3
+and 4. We recommend that you use the GNU compiler suite because it is freely
+available. V-USB has also been ported to the IAR compiler and assembler. It
+has been tested with IAR 4.10B/W32 and 4.12A/W32 on an ATmega8 with the
+"small" and "tiny" memory model. Not every release is tested with IAR CC and
+the driver may therefore fail to compile with IAR. Please note that gcc is
+more efficient for usbdrv.c because this module has been deliberately
+optimized for gcc.
+
+Gcc version 3 produces smaller code than version 4 due to new optimizing
+capabilities which don't always improve things on 8 bit CPUs. The code size
+generated by gcc 4 can be reduced with the compiler options
+-fno-move-loop-invariants, -fno-tree-scev-cprop and
+-fno-inline-small-functions in addition to -Os. On devices with more than
+8k of flash memory, we also recommend the linker option --relax (written as
+-Wl,--relax for gcc) to convert absolute calls into relative where possible.
+
+For more information about optimizing options see:
+
+    http://www.tty1.net/blog/2008-04-29-avr-gcc-optimisations_en.html
+
+These optimizations are good for gcc 4.x. Version 3.x of gcc does not support
+most of these options and produces good code anyway.
+
+
+USING V-USB FOR FREE
+====================
+The AVR firmware driver is published under the GNU General Public License
+Version 2 (GPL2) and the GNU General Public License Version 3 (GPL3). It is
+your choice whether you apply the terms of version 2 or version 3.
+
+If you decide for the free GPL2 or GPL3, we STRONGLY ENCOURAGE you to do the
+following things IN ADDITION to the obligations from the GPL:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+If you don't have a web site, you can publish the project in obdev's
+documentation wiki at
+http://www.obdev.at/goto.php?t=vusb-wiki&p=hosted-projects.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+COMMERCIAL LICENSES FOR V-USB
+=============================
+If you don't want to publish your source code under the terms of the GPL,
+you can simply pay money for V-USB. As an additional benefit you get
+USB PIDs for free, reserved exclusively to you. See the file
+"CommercialLicense.txt" for details.
+
Index: usbdrv/USB-ID-FAQ.txt
===================================================================
--- usbdrv/USB-ID-FAQ.txt	(nonexistent)
+++ usbdrv/USB-ID-FAQ.txt	(working copy)
@@ -0,0 +1,149 @@
+Version 2012-07-09
+
+==========================
+WHY DO WE NEED THESE IDs?
+==========================
+
+USB is more than a low level protocol for data transport. It also defines a
+common set of requests which must be understood by all devices. And as part
+of these common requests, the specification defines data structures, the
+USB Descriptors, which are used to describe the properties of the device.
+
+From the perspective of an operating system, it is therefore possible to find
+out basic properties of a device (such as e.g. the manufacturer and the name
+of the device) without a device-specific driver. This is essential because
+the operating system can choose a driver to load based on this information
+(Plug-And-Play).
+
+Among the most important properties in the Device Descriptor are the USB
+Vendor- and Product-ID. Both are 16 bit integers. The most simple form of
+driver matching is based on these IDs. The driver announces the Vendor- and
+Product-IDs of the devices it can handle and the operating system loads the
+appropriate driver when the device is connected.
+
+It is obvious that this technique only works if the pair Vendor- plus
+Product-ID is unique: Only devices which require the same driver can have the
+same pair of IDs.
+
+
+=====================================================
+HOW DOES THE USB STANDARD ENSURE THAT IDs ARE UNIQUE?
+=====================================================
+
+Since it is so important that USB IDs are unique, the USB Implementers Forum,
+Inc. (usb.org) needs a way to enforce this legally. It is not forbidden by
+law to build a device and assign it any random numbers as IDs. Usb.org
+therefore needs an agreement to regulate the use of USB IDs. The agreement
+binds only parties who agreed to it, of course. Everybody else is free to use
+any numbers for their IDs.
+
+So how can usb.org ensure that every manufacturer of USB devices enters into
+an agreement with them? They do it via trademark licensing. Usb.org has
+registered the trademark "USB", all associated logos and related terms. If
+you want to put an USB logo on your product or claim that it is USB
+compliant, you must license these trademarks from usb.org. And this is where
+you enter into an agreement. See the "USB-IF Trademark License Agreement and
+Usage Guidelines for the USB-IF Logo" at
+http://www.usb.org/developers/logo_license/.
+
+Licensing the USB trademarks requires that you buy a USB Vendor-ID from
+usb.org (one-time fee of ca. 2,000 USD), that you become a member of usb.org
+(yearly fee of ca. 4,000 USD) and that you meet all the technical
+specifications from the USB spec.
+
+This means that most hobbyists and small companies will never be able to
+become USB compliant, just because membership is so expensive. And you can't
+be compliant with a driver based on V-USB anyway, because the AVR's port pins
+don't meet the electrical specifications for USB. So, in principle, all
+hobbyists and small companies are free to choose any random numbers for their
+IDs. They have nothing to lose...
+
+There is one exception worth noting, though: If you use a sub-component which
+implements USB, the vendor of the sub-components may guarantee USB
+compliance. This might apply to some or all of FTDI's solutions.
+
+
+=======================================================================
+WHY SHOULD YOU OBTAIN USB IDs EVEN IF YOU DON'T LICENSE USB TRADEMARKS?
+=======================================================================
+
+You have learned in the previous section that you are free to choose any
+numbers for your IDs anyway. So why not do exactly this? There is still the
+technical issue. If you choose IDs which are already in use by somebody else,
+operating systems will load the wrong drivers and your device won't work.
+Even if you choose IDs which are not currently in use, they may be in use in
+the next version of the operating system or even after an automatic update.
+
+So what you need is a pair of Vendor- and Product-IDs for which you have the
+guarantee that no USB compliant product uses them. This implies that no
+operating system will ever ship with drivers responsible for these IDs.
+
+
+==============================================
+HOW DOES OBJECTIVE DEVELOPMENT HANDLE USB IDs?
+==============================================
+
+Objective Development gives away pairs of USB-IDs with their V-USB licenses.
+In order to ensure that these IDs are unique, Objective Development has an
+agreement with the company/person who has bought the USB Vendor-ID from
+usb.org. This agreement ensures that a range of USB Product-IDs is reserved
+for assignment by Objective Development and that the owner of the Vendor-ID
+won't give it to anybody else.
+
+This means that you have to trust three parties to ensure uniqueness of
+your IDs:
+
+  - Objective Development, that they don't give the same PID to more than
+    one person.
+  - The owner of the Vendor-ID that they don't assign PIDs from the range
+    assigned to Objective Development to anybody else.
+  - Usb.org that they don't assign the same Vendor-ID a second time.
+
+
+==================================
+WHO IS THE OWNER OF THE VENDOR-ID?
+==================================
+
+Objective Development has obtained ranges of USB Product-IDs under two
+Vendor-IDs: Under Vendor-ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under Vendor-ID 8352 from Jason
+Kotzin (now flirc.tv, Inc.). Both VID owners have received their Vendor-ID
+directly from usb.org.
+
+
+=========================================================================
+CAN I USE USB-IDs FROM OBJECTIVE DEVELOPMENT WITH OTHER DRIVERS/HARDWARE?
+=========================================================================
+
+The short answer is: Yes. All you get is a guarantee that the IDs are never
+assigned to anybody else. What more do you need?
+
+
+============================
+WHAT ABOUT SHARED ID PAIRS?
+============================
+
+Objective Development has reserved some PID/VID pairs for shared use. You
+have no guarantee of uniqueness for them, except that no USB compliant device
+uses them. In order to avoid technical problems, we must ensure that all
+devices with the same pair of IDs use the same driver on kernel level. For
+details, see the file USB-IDs-for-free.txt.
+
+
+======================================================
+I HAVE HEARD THAT SUB-LICENSING OF USB-IDs IS ILLEGAL?
+======================================================
+
+A 16 bit integer number cannot be protected by copyright laws. It is not
+sufficiently complex. And since none of the parties involved entered into the
+USB-IF Trademark License Agreement, we are not bound by this agreement. So
+there is no reason why it should be illegal to sub-license USB-IDs.
+
+
+=============================================
+WHO IS LIABLE IF THERE ARE INCOMPATIBILITIES?
+=============================================
+
+Objective Development disclaims all liabilities which might arise from the
+assignment of IDs. If you guarantee product features to your customers
+without proper disclaimer, YOU are liable for that.
Index: usbdrv/USB-IDs-for-free.txt
===================================================================
--- usbdrv/USB-IDs-for-free.txt	(nonexistent)
+++ usbdrv/USB-IDs-for-free.txt	(working copy)
@@ -0,0 +1,154 @@
+Version 2009-08-22
+
+===========================
+FREE USB-IDs FOR SHARED USE
+===========================
+
+Objective Development has reserved a set of USB Product-IDs for use according
+to the guidelines outlined below. For more information about the concept of
+USB IDs please see the file USB-ID-FAQ.txt. Objective Development guarantees
+that the IDs listed below are not used by any USB compliant devices.
+
+
+====================
+MECHANISM OF SHARING
+====================
+
+From a technical point of view, two different devices can share the same USB
+Vendor- and Product-ID if they require the same driver on operating system
+level. We make use of this fact by assigning separate IDs for various device
+classes. On application layer, devices must be distinguished by their textual
+name or serial number. We offer separate sets of IDs for discrimination by
+textual name and for serial number.
+
+Examples for shared use of USB IDs are included with V-USB in the "examples"
+subdirectory.
+
+
+======================================
+IDs FOR DISCRIMINATION BY TEXTUAL NAME
+======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the manufacturer
+and product identification. The manufacturer identification MUST be available
+at least in USB language 0x0409 (English/US).
+
+(2) The textual manufacturer identification MUST contain either an Internet
+domain name (e.g. "mycompany.com") registered and owned by you, or an e-mail
+address under your control (e.g. "myname@gmx.net"). You can embed the domain
+name or e-mail address in any string you like, e.g.  "Objective Development
+http://www.obdev.at/vusb/".
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(4) You may choose any string for the textual product identification, as long
+as this string is unique within the scope of your textual manufacturer
+identification.
+
+(5) Application side device look-up MUST be based on the textual manufacturer
+and product identification in addition to VID/PID matching. The driver
+matching MUST be a comparison of the entire strings, NOT a sub-string match.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+Table if IDs for discrimination by textual name:
+
+PID dec (hex) | VID dec (hex) | Description of use
+==============+===============+============================================
+1500 (0x05dc) | 5824 (0x16c0) | For Vendor Class devices with libusb
+--------------+---------------+--------------------------------------------
+1503 (0x05df) | 5824 (0x16c0) | For generic HID class devices (which are
+              |               | NOT mice, keyboards or joysticks)
+--------------+---------------+--------------------------------------------
+1505 (0x05e1) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+--------------+---------------+--------------------------------------------
+1508 (0x05e4) | 5824 (0x16c0) | For MIDI class devices
+--------------+---------------+--------------------------------------------
+
+Note that Windows caches the textual product- and vendor-description for
+mice, keyboards and joysticks. Name-bsed discrimination is therefore not
+recommended for these device classes.
+
+
+=======================================
+IDs FOR DISCRIMINATION BY SERIAL NUMBER
+=======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the serial
+number, unless ONLY the operating system's default class driver is used.
+The serial number string MUST be available at least in USB language 0x0409
+(English/US).
+
+(2) The serial number MUST start with either an Internet domain name (e.g.
+"mycompany.com") registered and owned by you, or an e-mail address under your
+control (e.g. "myname@gmx.net"), both terminated with a colon (":") character.
+You MAY append any string you like for further discrimination of your devices.
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(5) Application side device look-up MUST be based on the serial number string
+in addition to VID/PID matching. The matching must start at the first
+character of the serial number string and include the colon character
+terminating your domain or e-mail address. It MAY stop anywhere after that.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+(7) If ONLY the operating system's default class driver is used, e.g. for
+mice, keyboards, joysticks, CDC or MIDI devices and no discrimination by an
+application is needed, the serial number may be omitted.
+
+
+Table if IDs for discrimination by serial number string:
+
+PID dec (hex)  | VID dec (hex) | Description of use
+===============+===============+===========================================
+10200 (0x27d8) | 5824 (0x16c0) | For Vendor Class devices with libusb
+---------------+---------------+-------------------------------------------
+10201 (0x27d9) | 5824 (0x16c0) | For generic HID class devices (which are
+               |               | NOT mice, keyboards or joysticks)
+---------------+---------------+-------------------------------------------
+10202 (0x27da) | 5824 (0x16c0) | For USB Mice
+---------------+---------------+-------------------------------------------
+10203 (0x27db) | 5824 (0x16c0) | For USB Keyboards
+---------------+---------------+-------------------------------------------
+10204 (0x27dc) | 5824 (0x16c0) | For USB Joysticks
+---------------+---------------+-------------------------------------------
+10205 (0x27dd) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+---------------+---------------+-------------------------------------------
+10206 (0x27de) | 5824 (0x16c0) | For MIDI class devices
+---------------+---------------+-------------------------------------------
+
+
+=================
+ORIGIN OF USB-IDs
+=================
+
+OBJECTIVE DEVELOPMENT Software GmbH has obtained all VID/PID pairs listed
+here from Wouter van Ooijen (see www.voti.nl) for exclusive disposition.
+Wouter van Ooijen has obtained the VID from the USB Implementers Forum, Inc.
+(see www.usb.org). The VID is registered for the company name "Van Ooijen
+Technische Informatica".
+
+
+==========
+DISCLAIMER
+==========
+
+OBJECTIVE DEVELOPMENT Software GmbH disclaims all liability for any
+problems which are caused by the shared use of these VID/PID pairs.
Index: usbdrv/usbconfig-prototype.h
===================================================================
--- usbdrv/usbconfig-prototype.h	(nonexistent)
+++ usbdrv/usbconfig-prototype.h	(working copy)
@@ -0,0 +1,384 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
++ To create your own usbconfig.h file, copy this file to your project's
++ firmware source directory) and rename it to "usbconfig.h".
++ Then edit it accordingly.
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    0
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           100
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdc, 0x05 /* = 0x05dc = 1500 */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'T', 'e', 'm', 'p', 'l', 'a', 't', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 8
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: usbdrv/usbconfig.h
===================================================================
--- usbdrv/usbconfig.h	(nonexistent)
+++ usbdrv/usbconfig.h	(working copy)
@@ -0,0 +1,377 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ * This Revision: $Id$
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      3
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           50
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      1
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/*#define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();}
+#ifndef __ASSEMBLER__
+extern void hadUsbReset(void); // define the function for usbdrv.c
+#endif*/
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0x42, 0x42
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0x31, 0xe1
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'c', 'o', 'd', 'e', 'a', 'n', 'd', 'l', \
+								'i', 'f', 'e', '.', 'c', 'o', 'm'
+#define USB_CFG_VENDOR_NAME_LEN 15
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'P', 'a', 's', 's', 'g', 'e', 'n'
+#define USB_CFG_DEVICE_NAME_LEN 7
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0x03 // HID
+#define USB_CFG_INTERFACE_SUBCLASS  0x01 // Boot
+#define USB_CFG_INTERFACE_PROTOCOL  0x01 // Keyboard
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    63
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: usbdrv/usbconfig3.h
===================================================================
--- usbdrv/usbconfig3.h	(nonexistent)
+++ usbdrv/usbconfig3.h	(working copy)
@@ -0,0 +1,259 @@
+/* Name: usbconfig.h
+ * Project: AVR USB driver
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-23
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)
+ * This Revision: $Id: usbconfig.h 537 2008-02-28 21:13:01Z cs $
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      B
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      1
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0!
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in MHz. Legal values are 12000, 16000 or 16500.
+ * The 16.5 MHz version of the code requires no crystal, it tolerates +/- 1%
+ * deviation from the nominal frequency. All other rates require a precision
+ * of 2000 ppm and thus a crystal!
+ * Default if not specified: 12 MHz
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint 1.
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 1 and an interrupt-in
+ * endpoint 3. You must also enable endpoint 1 above.
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           50
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoint 1.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to endpoint 1.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#ifndef __ASSEMBLER__
+extern void hadUsbReset(void);
+#endif
+#define USB_RESET_HOOK(isReset)             if(!isReset){hadUsbReset();}
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   1
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0x42, 0x42
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you use obdev's free shared
+ * VID/PID pair. Be sure to read USBID-License.txt for rules!
+ * This template uses obdev's shared VID/PID pair for HIDs: 0x16c0/0x5df.
+ * Use this VID/PID pair ONLY if you understand the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0x31, 0xe1
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you use obdev's free shared VID/PID pair. Be sure to read the rules in
+ * USBID-License.txt!
+ * This template uses obdev's shared VID/PID pair for HIDs: 0x16c0/0x5df.
+ * Use this VID/PID pair ONLY if you understand the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'c', 'o', 'd', 'e', 'a', 'n', 'd', 'l', \
+								'i', 'f', 'e', '.', 'c', 'o', 'm'
+#define USB_CFG_VENDOR_NAME_LEN 15
+
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USBID-License.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'E', 'a', 's', 'y', 'L', 'o', 'g', 'g', 'e', 'r'
+#define USB_CFG_DEVICE_NAME_LEN 10
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USBID-License.txt before you assign a name if you
+ * use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ */
+#define USB_CFG_INTERFACE_CLASS     3   /* HID */
+#define USB_CFG_INTERFACE_SUBCLASS  0   /* no boot interface */
+#define USB_CFG_INTERFACE_PROTOCOL  0   /* no protocol */
+/* See USB specification if you want to conform to an existing device class or
+ * protocol.
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    35  /* total length of report descriptor */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * Since this template defines a HID device, it must also specify a HID
+ * report descriptor length. You must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor().
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+
+#endif /* __usbconfig_h_included__ */
Index: usbdrv/usbdrv.c
===================================================================
--- usbdrv/usbdrv.c	(nonexistent)
+++ usbdrv/usbdrv.c	(working copy)
@@ -0,0 +1,628 @@
+/* Name: usbdrv.c
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ * This Revision: $Id$
+ */
+
+#include "usbportability.h"
+#include "usbdrv.h"
+#include "oddebug.h"
+
+/*
+General Description:
+This module implements the C-part of the USB driver. See usbdrv.h for a
+documentation of the entire driver.
+*/
+
+/* ------------------------------------------------------------------------- */
+
+/* raw USB registers / interface to assembler code: */
+uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
+uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
+uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
+uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
+uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but not used */
+volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow control */
+uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 0 */
+uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
+volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handshake token */
+uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains handshake token */
+#if USB_COUNT_SOF
+volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+usbTxStatus_t  usbTxStatus1;
+#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
+usbTxStatus_t  usbTxStatus3;
+#   endif
+#endif
+#if USB_CFG_CHECK_DATA_TOGGLING
+uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
+#endif
+
+/* USB status registers / not shared with asm code */
+uchar               *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
+static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
+static uchar        usbMsgFlags;    /* flag values see below */
+
+#define USB_FLG_MSGPTR_IS_ROM   (1<<6)
+#define USB_FLG_USE_USER_RW     (1<<7)
+
+/*
+optimizing hints:
+- do not post/pre inc/dec integer values in operations
+- assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
+- use narrow scope for variables which should be in X/Y/Z register
+- assign char sized expressions to variables to force 8 bit arithmetics
+*/
+
+/* -------------------------- String Descriptors --------------------------- */
+
+#if USB_CFG_DESCR_PROPS_STRINGS == 0
+
+#if USB_CFG_DESCR_PROPS_STRING_0 == 0
+#undef USB_CFG_DESCR_PROPS_STRING_0
+#define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
+PROGMEM char usbDescriptorString0[] = { /* language descriptor */
+    4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
+    3,          /* descriptor type */
+    0x09, 0x04, /* language index (0x0409 = US-English) */
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_VENDOR
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
+PROGMEM int  usbDescriptorStringVendor[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
+    USB_CFG_VENDOR_NAME
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
+PROGMEM int  usbDescriptorStringDevice[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
+    USB_CFG_DEVICE_NAME
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
+PROGMEM int usbDescriptorStringSerialNumber[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
+    USB_CFG_SERIAL_NUMBER
+};
+#endif
+
+#endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
+
+/* --------------------------- Device Descriptor --------------------------- */
+
+#if USB_CFG_DESCR_PROPS_DEVICE == 0
+#undef USB_CFG_DESCR_PROPS_DEVICE
+#define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
+PROGMEM char usbDescriptorDevice[] = {    /* USB device descriptor */
+    18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
+    USBDESCR_DEVICE,        /* descriptor type */
+    0x10, 0x01,             /* USB version supported */
+    USB_CFG_DEVICE_CLASS,
+    USB_CFG_DEVICE_SUBCLASS,
+    0,                      /* protocol */
+    8,                      /* max packet size */
+    /* the following two casts affect the first byte of the constant only, but
+     * that's sufficient to avoid a warning with the default values.
+     */
+    (char)USB_CFG_VENDOR_ID,/* 2 bytes */
+    (char)USB_CFG_DEVICE_ID,/* 2 bytes */
+    USB_CFG_DEVICE_VERSION, /* 2 bytes */
+    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
+    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
+    1,          /* number of configurations */
+};
+#endif
+
+/* ----------------------- Configuration Descriptor ------------------------ */
+
+#if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
+#undef USB_CFG_DESCR_PROPS_HID
+#define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
+#endif
+
+#if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
+#undef USB_CFG_DESCR_PROPS_CONFIGURATION
+#define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
+PROGMEM char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
+    9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
+    USBDESCR_CONFIG,    /* descriptor type */
+    18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
+                (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
+                /* total length of data returned (including inlined descriptors) */
+    1,          /* number of interfaces in this configuration */
+    1,          /* index of this configuration */
+    0,          /* configuration name string index */
+#if USB_CFG_IS_SELF_POWERED
+    (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
+#else
+    (1 << 7),                           /* attributes */
+#endif
+    USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
+/* interface descriptor follows inline: */
+    9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
+    USBDESCR_INTERFACE, /* descriptor type */
+    0,          /* index of this interface */
+    0,          /* alternate setting for this interface */
+    USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of endpoint descriptors to follow */
+    USB_CFG_INTERFACE_CLASS,
+    USB_CFG_INTERFACE_SUBCLASS,
+    USB_CFG_INTERFACE_PROTOCOL,
+    0,          /* string index for interface */
+#if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
+    9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
+    USBDESCR_HID,   /* descriptor type: HID */
+    0x01, 0x01, /* BCD representation of HID version */
+    0x00,       /* target country code */
+    0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
+    0x22,       /* descriptor type: report */
+    USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)0x81, /* IN endpoint number 1 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+};
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+static inline void  usbResetDataToggling(void)
+{
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
+#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
+    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
+#   endif
+#endif
+}
+
+static inline void  usbResetStall(void)
+{
+#if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
+        usbTxLen1 = USBPID_NAK;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+        usbTxLen3 = USBPID_NAK;
+#endif
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+#if !USB_CFG_SUPPRESS_INTR_CODE
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
+{
+uchar   *p;
+char    i;
+
+#if USB_CFG_IMPLEMENT_HALT
+    if(usbTxLen1 == USBPID_STALL)
+        return;
+#endif
+    if(txStatus->len & 0x10){   /* packet buffer was empty */
+        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
+    }else{
+        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
+    }
+    p = txStatus->buffer + 1;
+    i = len;
+    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
+        *p++ = *data++;
+    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
+    usbCrc16Append(&txStatus->buffer[1], len);
+    txStatus->len = len + 4;    /* len must be given including sync byte */
+    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
+}
+
+USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
+{
+    usbGenericSetInterrupt(data, len, &usbTxStatus1);
+}
+#endif
+
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
+{
+    usbGenericSetInterrupt(data, len, &usbTxStatus3);
+}
+#endif
+#endif /* USB_CFG_SUPPRESS_INTR_CODE */
+
+/* ------------------ utilities for code following below ------------------- */
+
+/* Use defines for the switch statement so that we can choose between an
+ * if()else if() and a switch/case based implementation. switch() is more
+ * efficient for a LARGE set of sequential choices, if() is better in all other
+ * cases.
+ */
+#if USB_CFG_USE_SWITCH_STATEMENT
+#   define SWITCH_START(cmd)       switch(cmd){{
+#   define SWITCH_CASE(value)      }break; case (value):{
+#   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
+#   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
+#   define SWITCH_DEFAULT          }break; default:{
+#   define SWITCH_END              }}
+#else
+#   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
+#   define SWITCH_CASE(value)      }else if(_cmd == (value)){
+#   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
+#   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
+#   define SWITCH_DEFAULT          }else{
+#   define SWITCH_END              }}
+#endif
+
+#ifndef USB_RX_USER_HOOK
+#define USB_RX_USER_HOOK(data, len)
+#endif
+#ifndef USB_SET_ADDRESS_HOOK
+#define USB_SET_ADDRESS_HOOK()
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+/* We use if() instead of #if in the macro below because #if can't be used
+ * in macros and the compiler optimizes constant conditions anyway.
+ * This may cause problems with undefined symbols if compiled without
+ * optimizing!
+ */
+#define GET_DESCRIPTOR(cfgProp, staticName)         \
+    if(cfgProp){                                    \
+        if((cfgProp) & USB_PROP_IS_RAM)             \
+            flags = 0;                              \
+        if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
+            len = usbFunctionDescriptor(rq);        \
+        }else{                                      \
+            len = USB_PROP_LENGTH(cfgProp);         \
+            usbMsgPtr = (uchar *)(staticName);      \
+        }                                           \
+    }
+
+/* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
+ * internally for all types of descriptors.
+ */
+static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
+{
+usbMsgLen_t len = 0;
+uchar       flags = USB_FLG_MSGPTR_IS_ROM;
+
+    SWITCH_START(rq->wValue.bytes[1])
+    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
+    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
+    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
+#if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
+        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
+            flags = 0;
+        len = usbFunctionDescriptor(rq);
+#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
+        SWITCH_START(rq->wValue.bytes[0])
+        SWITCH_CASE(0)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
+        SWITCH_CASE(1)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
+        SWITCH_CASE(2)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
+        SWITCH_CASE(3)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumber)
+        SWITCH_DEFAULT
+            if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
+                len = usbFunctionDescriptor(rq);
+            }
+        SWITCH_END
+#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
+#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
+    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
+    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
+#endif
+    SWITCH_DEFAULT
+        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
+            len = usbFunctionDescriptor(rq);
+        }
+    SWITCH_END
+    usbMsgFlags = flags;
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
+ * standard requests instead of class and custom requests.
+ */
+static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
+{
+usbMsgLen_t len = 0;
+uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
+uchar   value = rq->wValue.bytes[0];
+#if USB_CFG_IMPLEMENT_HALT
+uchar   index = rq->wIndex.bytes[0];
+#endif
+
+    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
+    SWITCH_START(rq->bRequest)
+    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
+        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */
+        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
+            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
+#if USB_CFG_IMPLEMENT_HALT
+        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
+            dataPtr[0] = usbTxLen1 == USBPID_STALL;
+#endif
+        dataPtr[1] = 0;
+        len = 2;
+#if USB_CFG_IMPLEMENT_HALT
+    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
+        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
+            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
+            usbResetDataToggling();
+        }
+#endif
+    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
+        usbNewDeviceAddr = value;
+        USB_SET_ADDRESS_HOOK();
+    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
+        len = usbDriverDescriptor(rq);
+        goto skipMsgPtrAssignment;
+    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
+        dataPtr = &usbConfiguration;  /* send current configuration value */
+        len = 1;
+    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
+        usbConfiguration = value;
+        usbResetStall();
+    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
+        len = 1;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
+        usbResetDataToggling();
+        usbResetStall();
+#endif
+    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
+        /* Should we add an optional hook here? */
+    SWITCH_END
+    usbMsgPtr = dataPtr;
+skipMsgPtrAssignment:
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbProcessRx() is called for every message received by the interrupt
+ * routine. It distinguishes between SETUP and DATA packets and processes
+ * them accordingly.
+ */
+static inline void usbProcessRx(uchar *data, uchar len)
+{
+usbRequest_t    *rq = (void *)data;
+
+/* usbRxToken can be:
+ * 0x2d 00101101 (USBPID_SETUP for setup data)
+ * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
+ * 0...0x0f for OUT on endpoint X
+ */
+    DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
+    USB_RX_USER_HOOK(data, len)
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
+        usbFunctionWriteOut(data, len);
+        return;
+    }
+#endif
+    if(usbRxToken == (uchar)USBPID_SETUP){
+        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
+            return;
+        usbMsgLen_t replyLen;
+        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
+        usbTxLen = USBPID_NAK;              /* abort pending transmit */
+        usbMsgFlags = 0;
+        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
+        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
+            replyLen = usbFunctionSetup(data);
+        }else{
+            replyLen = usbDriverSetup(rq);
+        }
+#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
+        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
+            /* do some conditioning on replyLen, but on IN transfers only */
+            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
+                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
+                    replyLen = rq->wLength.bytes[0];
+                }else{
+                    replyLen = rq->wLength.word;
+                }
+            }
+            usbMsgFlags = USB_FLG_USE_USER_RW;
+        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
+#endif
+        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
+            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
+                replyLen = rq->wLength.bytes[0];
+        }else{
+            if(replyLen > rq->wLength.word)     /* limit length to max */
+                replyLen = rq->wLength.word;
+        }
+        usbMsgLen = replyLen;
+    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
+#if USB_CFG_IMPLEMENT_FN_WRITE
+        if(usbMsgFlags & USB_FLG_USE_USER_RW){
+            uchar rval = usbFunctionWrite(data, len);
+            if(rval == 0xff){   /* an error occurred */
+                usbTxLen = USBPID_STALL;
+            }else if(rval != 0){    /* This was the final package */
+                usbMsgLen = 0;  /* answer with a zero-sized data packet */
+            }
+        }
+#endif
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* This function is similar to usbFunctionRead(), but it's also called for
+ * data handled automatically by the driver (e.g. descriptor reads).
+ */
+static uchar usbDeviceRead(uchar *data, uchar len)
+{
+    if(len > 0){    /* don't bother app with 0 sized reads */
+#if USB_CFG_IMPLEMENT_FN_READ
+        if(usbMsgFlags & USB_FLG_USE_USER_RW){
+            len = usbFunctionRead(data, len);
+        }else
+#endif
+        {
+            uchar i = len, *r = usbMsgPtr;
+            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
+                do{
+                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
+                    *data++ = c;
+                    r++;
+                }while(--i);
+            }else{  /* RAM data */
+                do{
+                    *data++ = *r++;
+                }while(--i);
+            }
+            usbMsgPtr = r;
+        }
+    }
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbBuildTxBlock() is called when we have data to transmit and the
+ * interrupt routine's transmit buffer is empty.
+ */
+static inline void usbBuildTxBlock(void)
+{
+usbMsgLen_t wantLen;
+uchar       len;
+
+    wantLen = usbMsgLen;
+    if(wantLen > 8)
+        wantLen = 8;
+    usbMsgLen -= wantLen;
+    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
+    len = usbDeviceRead(usbTxBuf + 1, wantLen);
+    if(len <= 8){           /* valid data packet */
+        usbCrc16Append(&usbTxBuf[1], len);
+        len += 4;           /* length including sync byte */
+        if(len < 12)        /* a partial package identifies end of message */
+            usbMsgLen = USB_NO_MSG;
+    }else{
+        len = USBPID_STALL;   /* stall the endpoint */
+        usbMsgLen = USB_NO_MSG;
+    }
+    usbTxLen = len;
+    DBG2(0x20, usbTxBuf, len-1);
+}
+
+/* ------------------------------------------------------------------------- */
+
+static inline void usbHandleResetHook(uchar notResetState)
+{
+#ifdef USB_RESET_HOOK
+static uchar    wasReset;
+uchar           isReset = !notResetState;
+
+    if(wasReset != isReset){
+        USB_RESET_HOOK(isReset);
+        wasReset = isReset;
+    }
+#else
+    notResetState = notResetState;  // avoid compiler warning
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+USB_PUBLIC void usbPoll(void)
+{
+schar   len;
+uchar   i;
+
+    len = usbRxLen - 3;
+    if(len >= 0){
+/* We could check CRC16 here -- but ACK has already been sent anyway. If you
+ * need data integrity checks with this driver, check the CRC in your app
+ * code and report errors back to the host. Since the ACK was already sent,
+ * retries must be handled on application level.
+ * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
+ */
+        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
+#if USB_CFG_HAVE_FLOWCONTROL
+        if(usbRxLen > 0)    /* only mark as available if not inactivated */
+            usbRxLen = 0;
+#else
+        usbRxLen = 0;       /* mark rx buffer as available */
+#endif
+    }
+    if(usbTxLen & 0x10){    /* transmit system idle */
+        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
+            usbBuildTxBlock();
+        }
+    }
+    for(i = 20; i > 0; i--){
+        uchar usbLineStatus = USBIN & USBMASK;
+        if(usbLineStatus != 0)  /* SE0 has ended */
+            goto isNotReset;
+    }
+    /* RESET condition, called multiple times during reset */
+    usbNewDeviceAddr = 0;
+    usbDeviceAddr = 0;
+    usbResetStall();
+    DBG1(0xff, 0, 0);
+isNotReset:
+    usbHandleResetHook(i);
+}
+
+/* ------------------------------------------------------------------------- */
+
+USB_PUBLIC void usbInit(void)
+{
+#if USB_INTR_CFG_SET != 0
+    USB_INTR_CFG |= USB_INTR_CFG_SET;
+#endif
+#if USB_INTR_CFG_CLR != 0
+    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
+#endif
+    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
+    usbResetDataToggling();
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    usbTxLen1 = USBPID_NAK;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+    usbTxLen3 = USBPID_NAK;
+#endif
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
Index: usbdrv/usbdrv.h
===================================================================
--- usbdrv/usbdrv.h	(nonexistent)
+++ usbdrv/usbdrv.h	(working copy)
@@ -0,0 +1,736 @@
+/* Name: usbdrv.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ * This Revision: $Id$
+ */
+
+#ifndef __usbdrv_h_included__
+#define __usbdrv_h_included__
+#include "usbconfig.h"
+#include "usbportability.h"
+
+/*
+Hardware Prerequisites:
+=======================
+USB lines D+ and D- MUST be wired to the same I/O port. We recommend that D+
+triggers the interrupt (best achieved by using INT0 for D+), but it is also
+possible to trigger the interrupt from D-. If D- is used, interrupts are also
+triggered by SOF packets. D- requires a pull-up of 1.5k to +3.5V (and the
+device must be powered at 3.5V) to identify as low-speed USB device. A
+pull-down or pull-up of 1M SHOULD be connected from D+ to +3.5V to prevent
+interference when no USB master is connected. If you use Zener diodes to limit
+the voltage on D+ and D-, you MUST use a pull-down resistor, not a pull-up.
+We use D+ as interrupt source and not D- because it does not trigger on
+keep-alive and RESET states. If you want to count keep-alive events with
+USB_COUNT_SOF, you MUST use D- as an interrupt source.
+
+As a compile time option, the 1.5k pull-up resistor on D- can be made
+switchable to allow the device to disconnect at will. See the definition of
+usbDeviceConnect() and usbDeviceDisconnect() further down in this file.
+
+Please adapt the values in usbconfig.h according to your hardware!
+
+The device MUST be clocked at exactly 12 MHz, 15 MHz, 16 MHz or 20 MHz
+or at 12.8 MHz resp. 16.5 MHz +/- 1%. See usbconfig-prototype.h for details.
+
+
+Limitations:
+============
+Robustness with respect to communication errors:
+The driver assumes error-free communication. It DOES check for errors in
+the PID, but does NOT check bit stuffing errors, SE0 in middle of a byte,
+token CRC (5 bit) and data CRC (16 bit). CRC checks can not be performed due
+to timing constraints: We must start sending a reply within 7 bit times.
+Bit stuffing and misplaced SE0 would have to be checked in real-time, but CPU
+performance does not permit that. The driver does not check Data0/Data1
+toggling, but application software can implement the check.
+
+Input characteristics:
+Since no differential receiver circuit is used, electrical interference
+robustness may suffer. The driver samples only one of the data lines with
+an ordinary I/O pin's input characteristics. However, since this is only a
+low speed USB implementation and the specification allows for 8 times the
+bit rate over the same hardware, we should be on the safe side. Even the spec
+requires detection of asymmetric states at high bit rate for SE0 detection.
+
+Number of endpoints:
+The driver supports the following endpoints:
+
+- Endpoint 0, the default control endpoint.
+- Any number of interrupt- or bulk-out endpoints. The data is sent to
+  usbFunctionWriteOut() and USB_CFG_IMPLEMENT_FN_WRITEOUT must be defined
+  to 1 to activate this feature. The endpoint number can be found in the
+  global variable 'usbRxToken'.
+- One default interrupt- or bulk-in endpoint. This endpoint is used for
+  interrupt- or bulk-in transfers which are not handled by any other endpoint.
+  You must define USB_CFG_HAVE_INTRIN_ENDPOINT in order to activate this
+  feature and call usbSetInterrupt() to send interrupt/bulk data.
+- One additional interrupt- or bulk-in endpoint. This was endpoint 3 in
+  previous versions of this driver but can now be configured to any endpoint
+  number. You must define USB_CFG_HAVE_INTRIN_ENDPOINT3 in order to activate
+  this feature and call usbSetInterrupt3() to send interrupt/bulk data. The
+  endpoint number can be set with USB_CFG_EP3_NUMBER.
+
+Please note that the USB standard forbids bulk endpoints for low speed devices!
+Most operating systems allow them anyway, but the AVR will spend 90% of the CPU
+time in the USB interrupt polling for bulk data.
+
+Maximum data payload:
+Data payload of control in and out transfers may be up to 254 bytes. In order
+to accept payload data of out transfers, you need to implement
+'usbFunctionWrite()'.
+
+USB Suspend Mode supply current:
+The USB standard limits power consumption to 500uA when the bus is in suspend
+mode. This is not a problem for self-powered devices since they don't need
+bus power anyway. Bus-powered devices can achieve this only by putting the
+CPU in sleep mode. The driver does not implement suspend handling by itself.
+However, the application may implement activity monitoring and wakeup from
+sleep. The host sends regular SE0 states on the bus to keep it active. These
+SE0 states can be detected by using D- as the interrupt source. Define
+USB_COUNT_SOF to 1 and use the global variable usbSofCount to check for bus
+activity.
+
+Operation without an USB master:
+The driver behaves neutral without connection to an USB master if D- reads
+as 1. To avoid spurious interrupts, we recommend a high impedance (e.g. 1M)
+pull-down or pull-up resistor on D+ (interrupt). If Zener diodes are used,
+use a pull-down. If D- becomes statically 0, the driver may block in the
+interrupt routine.
+
+Interrupt latency:
+The application must ensure that the USB interrupt is not disabled for more
+than 25 cycles (this is for 12 MHz, faster clocks allow longer latency).
+This implies that all interrupt routines must either have the "ISR_NOBLOCK"
+attribute set (see "avr/interrupt.h") or be written in assembler with "sei"
+as the first instruction.
+
+Maximum interrupt duration / CPU cycle consumption:
+The driver handles all USB communication during the interrupt service
+routine. The routine will not return before an entire USB message is received
+and the reply is sent. This may be up to ca. 1200 cycles @ 12 MHz (= 100us) if
+the host conforms to the standard. The driver will consume CPU cycles for all
+USB messages, even if they address another (low-speed) device on the same bus.
+
+*/
+
+/* ------------------------------------------------------------------------- */
+/* --------------------------- Module Interface ---------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#define USBDRV_VERSION  20120109
+/* This define uniquely identifies a driver version. It is a decimal number
+ * constructed from the driver's release date in the form YYYYMMDD. If the
+ * driver's behavior or interface changes, you can use this constant to
+ * distinguish versions. If it is not defined, the driver's release date is
+ * older than 2006-01-25.
+ */
+
+
+#ifndef USB_PUBLIC
+#define USB_PUBLIC
+#endif
+/* USB_PUBLIC is used as declaration attribute for all functions exported by
+ * the USB driver. The default is no attribute (see above). You may define it
+ * to static either in usbconfig.h or from the command line if you include
+ * usbdrv.c instead of linking against it. Including the C module of the driver
+ * directly in your code saves a couple of bytes in flash memory.
+ */
+
+#ifndef __ASSEMBLER__
+#ifndef uchar
+#define uchar   unsigned char
+#endif
+#ifndef schar
+#define schar   signed char
+#endif
+/* shortcuts for well defined 8 bit integer types */
+
+#if USB_CFG_LONG_TRANSFERS  /* if more than 254 bytes transfer size required */
+#   define usbMsgLen_t unsigned
+#else
+#   define usbMsgLen_t uchar
+#endif
+/* usbMsgLen_t is the data type used for transfer lengths. By default, it is
+ * defined to uchar, allowing a maximum of 254 bytes (255 is reserved for
+ * USB_NO_MSG below). If the usbconfig.h defines USB_CFG_LONG_TRANSFERS to 1,
+ * a 16 bit data type is used, allowing up to 16384 bytes (the rest is used
+ * for flags in the descriptor configuration).
+ */
+#define USB_NO_MSG  ((usbMsgLen_t)-1)   /* constant meaning "no message" */
+
+struct usbRequest;  /* forward declaration */
+
+USB_PUBLIC void usbInit(void);
+/* This function must be called before interrupts are enabled and the main
+ * loop is entered. We exepct that the PORT and DDR bits for D+ and D- have
+ * not been changed from their default status (which is 0). If you have changed
+ * them, set both back to 0 (configure them as input with no internal pull-up).
+ */
+USB_PUBLIC void usbPoll(void);
+/* This function must be called at regular intervals from the main loop.
+ * Maximum delay between calls is somewhat less than 50ms (USB timeout for
+ * accepting a Setup message). Otherwise the device will not be recognized.
+ * Please note that debug outputs through the UART take ~ 0.5ms per byte
+ * at 19200 bps.
+ */
+extern uchar *usbMsgPtr;
+/* This variable may be used to pass transmit data to the driver from the
+ * implementation of usbFunctionWrite(). It is also used internally by the
+ * driver for standard control requests.
+ */
+USB_PUBLIC usbMsgLen_t usbFunctionSetup(uchar data[8]);
+/* This function is called when the driver receives a SETUP transaction from
+ * the host which is not answered by the driver itself (in practice: class and
+ * vendor requests). All control transfers start with a SETUP transaction where
+ * the host communicates the parameters of the following (optional) data
+ * transfer. The SETUP data is available in the 'data' parameter which can
+ * (and should) be casted to 'usbRequest_t *' for a more user-friendly access
+ * to parameters.
+ *
+ * If the SETUP indicates a control-in transfer, you should provide the
+ * requested data to the driver. There are two ways to transfer this data:
+ * (1) Set the global pointer 'usbMsgPtr' to the base of the static RAM data
+ * block and return the length of the data in 'usbFunctionSetup()'. The driver
+ * will handle the rest. Or (2) return USB_NO_MSG in 'usbFunctionSetup()'. The
+ * driver will then call 'usbFunctionRead()' when data is needed. See the
+ * documentation for usbFunctionRead() for details.
+ *
+ * If the SETUP indicates a control-out transfer, the only way to receive the
+ * data from the host is through the 'usbFunctionWrite()' call. If you
+ * implement this function, you must return USB_NO_MSG in 'usbFunctionSetup()'
+ * to indicate that 'usbFunctionWrite()' should be used. See the documentation
+ * of this function for more information. If you just want to ignore the data
+ * sent by the host, return 0 in 'usbFunctionSetup()'.
+ *
+ * Note that calls to the functions usbFunctionRead() and usbFunctionWrite()
+ * are only done if enabled by the configuration in usbconfig.h.
+ */
+USB_PUBLIC usbMsgLen_t usbFunctionDescriptor(struct usbRequest *rq);
+/* You need to implement this function ONLY if you provide USB descriptors at
+ * runtime (which is an expert feature). It is very similar to
+ * usbFunctionSetup() above, but it is called only to request USB descriptor
+ * data. See the documentation of usbFunctionSetup() above for more info.
+ */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len);
+/* This function sets the message which will be sent during the next interrupt
+ * IN transfer. The message is copied to an internal buffer and must not exceed
+ * a length of 8 bytes. The message may be 0 bytes long just to indicate the
+ * interrupt status to the host.
+ * If you need to transfer more bytes, use a control read after the interrupt.
+ */
+#define usbInterruptIsReady()   (usbTxLen1 & 0x10)
+/* This macro indicates whether the last interrupt message has already been
+ * sent. If you set a new interrupt message before the old was sent, the
+ * message already buffered will be lost.
+ */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len);
+#define usbInterruptIsReady3()   (usbTxLen3 & 0x10)
+/* Same as above for endpoint 3 */
+#endif
+#endif /* USB_CFG_HAVE_INTRIN_ENDPOINT */
+#if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    /* simplified interface for backward compatibility */
+#define usbHidReportDescriptor  usbDescriptorHidReport
+/* should be declared as: PROGMEM char usbHidReportDescriptor[]; */
+/* If you implement an HID device, you need to provide a report descriptor.
+ * The HID report descriptor syntax is a bit complex. If you understand how
+ * report descriptors are constructed, we recommend that you use the HID
+ * Descriptor Tool from usb.org, see http://www.usb.org/developers/hidpage/.
+ * Otherwise you should probably start with a working example.
+ */
+#endif  /* USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH */
+#if USB_CFG_IMPLEMENT_FN_WRITE
+USB_PUBLIC uchar usbFunctionWrite(uchar *data, uchar len);
+/* This function is called by the driver to provide a control transfer's
+ * payload data (control-out). It is called in chunks of up to 8 bytes. The
+ * total count provided in the current control transfer can be obtained from
+ * the 'length' property in the setup data. If an error occurred during
+ * processing, return 0xff (== -1). The driver will answer the entire transfer
+ * with a STALL token in this case. If you have received the entire payload
+ * successfully, return 1. If you expect more data, return 0. If you don't
+ * know whether the host will send more data (you should know, the total is
+ * provided in the usbFunctionSetup() call!), return 1.
+ * NOTE: If you return 0xff for STALL, 'usbFunctionWrite()' may still be called
+ * for the remaining data. You must continue to return 0xff for STALL in these
+ * calls.
+ * In order to get usbFunctionWrite() called, define USB_CFG_IMPLEMENT_FN_WRITE
+ * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_WRITE */
+#if USB_CFG_IMPLEMENT_FN_READ
+USB_PUBLIC uchar usbFunctionRead(uchar *data, uchar len);
+/* This function is called by the driver to ask the application for a control
+ * transfer's payload data (control-in). It is called in chunks of up to 8
+ * bytes each. You should copy the data to the location given by 'data' and
+ * return the actual number of bytes copied. If you return less than requested,
+ * the control-in transfer is terminated. If you return 0xff, the driver aborts
+ * the transfer with a STALL token.
+ * In order to get usbFunctionRead() called, define USB_CFG_IMPLEMENT_FN_READ
+ * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_READ */
+
+extern uchar usbRxToken;    /* may be used in usbFunctionWriteOut() below */
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+USB_PUBLIC void usbFunctionWriteOut(uchar *data, uchar len);
+/* This function is called by the driver when data is received on an interrupt-
+ * or bulk-out endpoint. The endpoint number can be found in the global
+ * variable usbRxToken. You must define USB_CFG_IMPLEMENT_FN_WRITEOUT to 1 in
+ * usbconfig.h to get this function called.
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_WRITEOUT */
+#ifdef USB_CFG_PULLUP_IOPORTNAME
+#define usbDeviceConnect()      ((USB_PULLUP_DDR |= (1<<USB_CFG_PULLUP_BIT)), \
+                                  (USB_PULLUP_OUT |= (1<<USB_CFG_PULLUP_BIT)))
+#define usbDeviceDisconnect()   ((USB_PULLUP_DDR &= ~(1<<USB_CFG_PULLUP_BIT)), \
+                                  (USB_PULLUP_OUT &= ~(1<<USB_CFG_PULLUP_BIT)))
+#else /* USB_CFG_PULLUP_IOPORTNAME */
+#define usbDeviceConnect()      (USBDDR &= ~(1<<USBMINUS))
+#define usbDeviceDisconnect()   (USBDDR |= (1<<USBMINUS))
+#endif /* USB_CFG_PULLUP_IOPORTNAME */
+/* The macros usbDeviceConnect() and usbDeviceDisconnect() (intended to look
+ * like a function) connect resp. disconnect the device from the host's USB.
+ * If the constants USB_CFG_PULLUP_IOPORT and USB_CFG_PULLUP_BIT are defined
+ * in usbconfig.h, a disconnect consists of removing the pull-up resisitor
+ * from D-, otherwise the disconnect is done by brute-force pulling D- to GND.
+ * This does not conform to the spec, but it works.
+ * Please note that the USB interrupt must be disabled while the device is
+ * in disconnected state, or the interrupt handler will hang! You can either
+ * turn off the USB interrupt selectively with
+ *     USB_INTR_ENABLE &= ~(1 << USB_INTR_ENABLE_BIT)
+ * or use cli() to disable interrupts globally.
+ */
+extern unsigned usbCrc16(unsigned data, uchar len);
+#define usbCrc16(data, len) usbCrc16((unsigned)(data), len)
+/* This function calculates the binary complement of the data CRC used in
+ * USB data packets. The value is used to build raw transmit packets.
+ * You may want to use this function for data checksums or to verify received
+ * data. We enforce 16 bit calling conventions for compatibility with IAR's
+ * tiny memory model.
+ */
+extern unsigned usbCrc16Append(unsigned data, uchar len);
+#define usbCrc16Append(data, len)    usbCrc16Append((unsigned)(data), len)
+/* This function is equivalent to usbCrc16() above, except that it appends
+ * the 2 bytes CRC (lowbyte first) in the 'data' buffer after reading 'len'
+ * bytes.
+ */
+#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
+extern unsigned usbMeasureFrameLength(void);
+/* This function MUST be called IMMEDIATELY AFTER USB reset and measures 1/7 of
+ * the number of CPU cycles during one USB frame minus one low speed bit
+ * length. In other words: return value = 1499 * (F_CPU / 10.5 MHz)
+ * Since this is a busy wait, you MUST disable all interrupts with cli() before
+ * calling this function.
+ * This can be used to calibrate the AVR's RC oscillator.
+ */
+#endif
+extern uchar    usbConfiguration;
+/* This value contains the current configuration set by the host. The driver
+ * allows setting and querying of this variable with the USB SET_CONFIGURATION
+ * and GET_CONFIGURATION requests, but does not use it otherwise.
+ * You may want to reflect the "configured" status with a LED on the device or
+ * switch on high power parts of the circuit only if the device is configured.
+ */
+#if USB_COUNT_SOF
+extern volatile uchar   usbSofCount;
+/* This variable is incremented on every SOF packet. It is only available if
+ * the macro USB_COUNT_SOF is defined to a value != 0.
+ */
+#endif
+#if USB_CFG_CHECK_DATA_TOGGLING
+extern uchar    usbCurrentDataToken;
+/* This variable can be checked in usbFunctionWrite() and usbFunctionWriteOut()
+ * to ignore duplicate packets.
+ */
+#endif
+
+#define USB_STRING_DESCRIPTOR_HEADER(stringLength) ((2*(stringLength)+2) | (3<<8))
+/* This macro builds a descriptor header for a string descriptor given the
+ * string's length. See usbdrv.c for an example how to use it.
+ */
+#if USB_CFG_HAVE_FLOWCONTROL
+extern volatile schar   usbRxLen;
+#define usbDisableAllRequests()     usbRxLen = -1
+/* Must be called from usbFunctionWrite(). This macro disables all data input
+ * from the USB interface. Requests from the host are answered with a NAK
+ * while they are disabled.
+ */
+#define usbEnableAllRequests()      usbRxLen = 0
+/* May only be called if requests are disabled. This macro enables input from
+ * the USB interface after it has been disabled with usbDisableAllRequests().
+ */
+#define usbAllRequestsAreDisabled() (usbRxLen < 0)
+/* Use this macro to find out whether requests are disabled. It may be needed
+ * to ensure that usbEnableAllRequests() is never called when requests are
+ * enabled.
+ */
+#endif
+
+#define USB_SET_DATATOKEN1(token)   usbTxBuf1[0] = token
+#define USB_SET_DATATOKEN3(token)   usbTxBuf3[0] = token
+/* These two macros can be used by application software to reset data toggling
+ * for interrupt-in endpoints 1 and 3. Since the token is toggled BEFORE
+ * sending data, you must set the opposite value of the token which should come
+ * first.
+ */
+
+#endif  /* __ASSEMBLER__ */
+
+
+/* ------------------------------------------------------------------------- */
+/* ----------------- Definitions for Descriptor Properties ----------------- */
+/* ------------------------------------------------------------------------- */
+/* This is advanced stuff. See usbconfig-prototype.h for more information
+ * about the various methods to define USB descriptors. If you do nothing,
+ * the default descriptors will be used.
+ */
+#define USB_PROP_IS_DYNAMIC     (1 << 14)
+/* If this property is set for a descriptor, usbFunctionDescriptor() will be
+ * used to obtain the particular descriptor. Data directly returned via
+ * usbMsgPtr are FLASH data by default, combine (OR) with USB_PROP_IS_RAM to
+ * return RAM data.
+ */
+#define USB_PROP_IS_RAM         (1 << 15)
+/* If this property is set for a descriptor, the data is read from RAM
+ * memory instead of Flash. The property is used for all methods to provide
+ * external descriptors.
+ */
+#define USB_PROP_LENGTH(len)    ((len) & 0x3fff)
+/* If a static external descriptor is used, this is the total length of the
+ * descriptor in bytes.
+ */
+
+/* all descriptors which may have properties: */
+#ifndef USB_CFG_DESCR_PROPS_DEVICE
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_CONFIGURATION
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRINGS
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_VENDOR
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_PRODUCT
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_HID
+#define USB_CFG_DESCR_PROPS_HID                     0
+#endif
+#if !(USB_CFG_DESCR_PROPS_HID_REPORT)
+#   undef USB_CFG_DESCR_PROPS_HID_REPORT
+#   if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH /* do some backward compatibility tricks */
+#       define USB_CFG_DESCR_PROPS_HID_REPORT       USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH
+#   else
+#       define USB_CFG_DESCR_PROPS_HID_REPORT       0
+#   endif
+#endif
+#ifndef USB_CFG_DESCR_PROPS_UNKNOWN
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+#endif
+
+/* ------------------ forward declaration of descriptors ------------------- */
+/* If you use external static descriptors, they must be stored in global
+ * arrays as declared below:
+ */
+#ifndef __ASSEMBLER__
+extern
+#if !(USB_CFG_DESCR_PROPS_DEVICE & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+char usbDescriptorDevice[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_CONFIGURATION & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+char usbDescriptorConfiguration[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_HID_REPORT & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+char usbDescriptorHidReport[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_0 & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+char usbDescriptorString0[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_VENDOR & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+int usbDescriptorStringVendor[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_PRODUCT & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+int usbDescriptorStringDevice[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER & USB_PROP_IS_RAM)
+PROGMEM
+#endif
+int usbDescriptorStringSerialNumber[];
+
+#endif /* __ASSEMBLER__ */
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------ General Purpose Macros ------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#define USB_CONCAT(a, b)            a ## b
+#define USB_CONCAT_EXPANDED(a, b)   USB_CONCAT(a, b)
+
+#define USB_OUTPORT(name)           USB_CONCAT(PORT, name)
+#define USB_INPORT(name)            USB_CONCAT(PIN, name)
+#define USB_DDRPORT(name)           USB_CONCAT(DDR, name)
+/* The double-define trick above lets us concatenate strings which are
+ * defined by macros.
+ */
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------- Constant definitions -------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#if !defined __ASSEMBLER__ && (!defined USB_CFG_VENDOR_ID || !defined USB_CFG_DEVICE_ID)
+#warning "You should define USB_CFG_VENDOR_ID and USB_CFG_DEVICE_ID in usbconfig.h"
+/* If the user has not defined IDs, we default to obdev's free IDs.
+ * See USB-IDs-for-free.txt for details.
+ */
+#endif
+
+/* make sure we have a VID and PID defined, byte order is lowbyte, highbyte */
+#ifndef USB_CFG_VENDOR_ID
+#   define  USB_CFG_VENDOR_ID   0xc0, 0x16  /* = 0x16c0 = 5824 = voti.nl */
+#endif
+
+#ifndef USB_CFG_DEVICE_ID
+#   if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH
+#       define USB_CFG_DEVICE_ID    0xdf, 0x05  /* = 0x5df = 1503, shared PID for HIDs */
+#   elif USB_CFG_INTERFACE_CLASS == 2
+#       define USB_CFG_DEVICE_ID    0xe1, 0x05  /* = 0x5e1 = 1505, shared PID for CDC Modems */
+#   else
+#       define USB_CFG_DEVICE_ID    0xdc, 0x05  /* = 0x5dc = 1500, obdev's free PID */
+#   endif
+#endif
+
+/* Derive Output, Input and DataDirection ports from port names */
+#ifndef USB_CFG_IOPORTNAME
+#error "You must define USB_CFG_IOPORTNAME in usbconfig.h, see usbconfig-prototype.h"
+#endif
+
+#define USBOUT          USB_OUTPORT(USB_CFG_IOPORTNAME)
+#define USB_PULLUP_OUT  USB_OUTPORT(USB_CFG_PULLUP_IOPORTNAME)
+#define USBIN           USB_INPORT(USB_CFG_IOPORTNAME)
+#define USBDDR          USB_DDRPORT(USB_CFG_IOPORTNAME)
+#define USB_PULLUP_DDR  USB_DDRPORT(USB_CFG_PULLUP_IOPORTNAME)
+
+#define USBMINUS    USB_CFG_DMINUS_BIT
+#define USBPLUS     USB_CFG_DPLUS_BIT
+#define USBIDLE     (1<<USB_CFG_DMINUS_BIT) /* value representing J state */
+#define USBMASK     ((1<<USB_CFG_DPLUS_BIT) | (1<<USB_CFG_DMINUS_BIT))  /* mask for USB I/O bits */
+
+/* defines for backward compatibility with older driver versions: */
+#define USB_CFG_IOPORT          USB_OUTPORT(USB_CFG_IOPORTNAME)
+#ifdef USB_CFG_PULLUP_IOPORTNAME
+#define USB_CFG_PULLUP_IOPORT   USB_OUTPORT(USB_CFG_PULLUP_IOPORTNAME)
+#endif
+
+#ifndef USB_CFG_EP3_NUMBER  /* if not defined in usbconfig.h */
+#define USB_CFG_EP3_NUMBER  3
+#endif
+
+#ifndef USB_CFG_HAVE_INTRIN_ENDPOINT3
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+#endif
+
+#define USB_BUFSIZE     11  /* PID, 8 bytes data, 2 bytes CRC */
+
+/* ----- Try to find registers and bits responsible for ext interrupt 0 ----- */
+
+#ifndef USB_INTR_CFG    /* allow user to override our default */
+#   if defined  EICRA
+#       define USB_INTR_CFG EICRA
+#   else
+#       define USB_INTR_CFG MCUCR
+#   endif
+#endif
+#ifndef USB_INTR_CFG_SET    /* allow user to override our default */
+#   if defined(USB_COUNT_SOF) || defined(USB_SOF_HOOK)
+#       define USB_INTR_CFG_SET (1 << ISC01)                    /* cfg for falling edge */
+        /* If any SOF logic is used, the interrupt must be wired to D- where
+         * we better trigger on falling edge
+         */
+#   else
+#       define USB_INTR_CFG_SET ((1 << ISC00) | (1 << ISC01))   /* cfg for rising edge */
+#   endif
+#endif
+#ifndef USB_INTR_CFG_CLR    /* allow user to override our default */
+#   define USB_INTR_CFG_CLR 0    /* no bits to clear */
+#endif
+
+#ifndef USB_INTR_ENABLE     /* allow user to override our default */
+#   if defined GIMSK
+#       define USB_INTR_ENABLE  GIMSK
+#   elif defined EIMSK
+#       define USB_INTR_ENABLE  EIMSK
+#   else
+#       define USB_INTR_ENABLE  GICR
+#   endif
+#endif
+#ifndef USB_INTR_ENABLE_BIT /* allow user to override our default */
+#   define USB_INTR_ENABLE_BIT  INT0
+#endif
+
+#ifndef USB_INTR_PENDING    /* allow user to override our default */
+#   if defined  EIFR
+#       define USB_INTR_PENDING EIFR
+#   else
+#       define USB_INTR_PENDING GIFR
+#   endif
+#endif
+#ifndef USB_INTR_PENDING_BIT    /* allow user to override our default */
+#   define USB_INTR_PENDING_BIT INTF0
+#endif
+
+/*
+The defines above don't work for the following chips
+at90c8534: no ISC0?, no PORTB, can't find a data sheet
+at86rf401: no PORTB, no MCUCR etc, low clock rate
+atmega103: no ISC0? (maybe omission in header, can't find data sheet)
+atmega603: not defined in avr-libc
+at43usb320, at43usb355, at76c711: have USB anyway
+at94k: is different...
+
+at90s1200, attiny11, attiny12, attiny15, attiny28: these have no RAM
+*/
+
+/* ------------------------------------------------------------------------- */
+/* ----------------- USB Specification Constants and Types ----------------- */
+/* ------------------------------------------------------------------------- */
+
+/* USB Token values */
+#define USBPID_SETUP    0x2d
+#define USBPID_OUT      0xe1
+#define USBPID_IN       0x69
+#define USBPID_DATA0    0xc3
+#define USBPID_DATA1    0x4b
+
+#define USBPID_ACK      0xd2
+#define USBPID_NAK      0x5a
+#define USBPID_STALL    0x1e
+
+#ifndef USB_INITIAL_DATATOKEN
+#define USB_INITIAL_DATATOKEN   USBPID_DATA1
+#endif
+
+#ifndef __ASSEMBLER__
+
+typedef struct usbTxStatus{
+    volatile uchar   len;
+    uchar   buffer[USB_BUFSIZE];
+}usbTxStatus_t;
+
+extern usbTxStatus_t   usbTxStatus1, usbTxStatus3;
+#define usbTxLen1   usbTxStatus1.len
+#define usbTxBuf1   usbTxStatus1.buffer
+#define usbTxLen3   usbTxStatus3.len
+#define usbTxBuf3   usbTxStatus3.buffer
+
+
+typedef union usbWord{
+    unsigned    word;
+    uchar       bytes[2];
+}usbWord_t;
+
+typedef struct usbRequest{
+    uchar       bmRequestType;
+    uchar       bRequest;
+    usbWord_t   wValue;
+    usbWord_t   wIndex;
+    usbWord_t   wLength;
+}usbRequest_t;
+/* This structure matches the 8 byte setup request */
+#endif
+
+/* bmRequestType field in USB setup:
+ * d t t r r r r r, where
+ * d ..... direction: 0=host->device, 1=device->host
+ * t ..... type: 0=standard, 1=class, 2=vendor, 3=reserved
+ * r ..... recipient: 0=device, 1=interface, 2=endpoint, 3=other
+ */
+
+/* USB setup recipient values */
+#define USBRQ_RCPT_MASK         0x1f
+#define USBRQ_RCPT_DEVICE       0
+#define USBRQ_RCPT_INTERFACE    1
+#define USBRQ_RCPT_ENDPOINT     2
+
+/* USB request type values */
+#define USBRQ_TYPE_MASK         0x60
+#define USBRQ_TYPE_STANDARD     (0<<5)
+#define USBRQ_TYPE_CLASS        (1<<5)
+#define USBRQ_TYPE_VENDOR       (2<<5)
+
+/* USB direction values: */
+#define USBRQ_DIR_MASK              0x80
+#define USBRQ_DIR_HOST_TO_DEVICE    (0<<7)
+#define USBRQ_DIR_DEVICE_TO_HOST    (1<<7)
+
+/* USB Standard Requests */
+#define USBRQ_GET_STATUS        0
+#define USBRQ_CLEAR_FEATURE     1
+#define USBRQ_SET_FEATURE       3
+#define USBRQ_SET_ADDRESS       5
+#define USBRQ_GET_DESCRIPTOR    6
+#define USBRQ_SET_DESCRIPTOR    7
+#define USBRQ_GET_CONFIGURATION 8
+#define USBRQ_SET_CONFIGURATION 9
+#define USBRQ_GET_INTERFACE     10
+#define USBRQ_SET_INTERFACE     11
+#define USBRQ_SYNCH_FRAME       12
+
+/* USB descriptor constants */
+#define USBDESCR_DEVICE         1
+#define USBDESCR_CONFIG         2
+#define USBDESCR_STRING         3
+#define USBDESCR_INTERFACE      4
+#define USBDESCR_ENDPOINT       5
+#define USBDESCR_HID            0x21
+#define USBDESCR_HID_REPORT     0x22
+#define USBDESCR_HID_PHYS       0x23
+
+//#define USBATTR_BUSPOWER        0x80  // USB 1.1 does not define this value any more
+#define USBATTR_BUSPOWER        0
+#define USBATTR_SELFPOWER       0x40
+#define USBATTR_REMOTEWAKE      0x20
+
+/* USB HID Requests */
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_GET_IDLE      0x02
+#define USBRQ_HID_GET_PROTOCOL  0x03
+#define USBRQ_HID_SET_REPORT    0x09
+#define USBRQ_HID_SET_IDLE      0x0a
+#define USBRQ_HID_SET_PROTOCOL  0x0b
+
+/* ------------------------------------------------------------------------- */
+
+#endif /* __usbdrv_h_included__ */
Index: usbdrv/usbdrvasm.asm
===================================================================
--- usbdrv/usbdrvasm.asm	(nonexistent)
+++ usbdrv/usbdrvasm.asm	(working copy)
@@ -0,0 +1,20 @@
+/* Name: usbdrvasm.asm
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-03-01
+ * Tabsize: 4
+ * Copyright: (c) 2006 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The IAR compiler/assembler system prefers assembler files with file extension
+".asm". We simply provide this file as an alias for usbdrvasm.S.
+
+Thanks to Oleg Semyonov for his help with the IAR tools port!
+*/
+
+#include "usbdrvasm.S"
+
+end
Index: usbdrv/usbdrvasm.S
===================================================================
--- usbdrv/usbdrvasm.S	(nonexistent)
+++ usbdrv/usbdrvasm.S	(working copy)
@@ -0,0 +1,393 @@
+/* Name: usbdrvasm.S
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-13
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ * Revision: $Id$
+ */
+
+/*
+General Description:
+This module is the assembler part of the USB driver. This file contains
+general code (preprocessor acrobatics and CRC computation) and then includes
+the file appropriate for the given clock rate.
+*/
+
+#define __SFR_OFFSET 0      /* used by avr-libc's register definitions */
+#include "usbportability.h"
+#include "usbdrv.h"         /* for common defs */
+
+/* register names */
+#define x1      r16
+#define x2      r17
+#define shift   r18
+#define cnt     r19
+#define x3      r20
+#define x4      r21
+#define x5		r22
+#define bitcnt  x5
+#define phase   x4
+#define leap    x4
+
+/* Some assembler dependent definitions and declarations: */
+
+#ifdef __IAR_SYSTEMS_ASM__
+    extern  usbRxBuf, usbDeviceAddr, usbNewDeviceAddr, usbInputBufOffset
+    extern  usbCurrentTok, usbRxLen, usbRxToken, usbTxLen
+    extern  usbTxBuf, usbTxStatus1, usbTxStatus3
+#   if USB_COUNT_SOF
+        extern usbSofCount
+#   endif
+    public  usbCrc16
+    public  usbCrc16Append
+
+    COMMON  INTVEC
+#   ifndef USB_INTR_VECTOR
+        ORG     INT0_vect
+#   else /* USB_INTR_VECTOR */
+        ORG     USB_INTR_VECTOR
+#       undef   USB_INTR_VECTOR
+#   endif /* USB_INTR_VECTOR */
+#   define  USB_INTR_VECTOR usbInterruptHandler
+    rjmp    USB_INTR_VECTOR
+    RSEG    CODE
+
+#else /* __IAR_SYSTEMS_ASM__ */
+
+#   ifndef USB_INTR_VECTOR /* default to hardware interrupt INT0 */
+#       ifdef INT0_vect
+#           define USB_INTR_VECTOR  INT0_vect       // this is the "new" define for the vector
+#       else
+#           define USB_INTR_VECTOR  SIG_INTERRUPT0  // this is the "old" vector
+#       endif
+#   endif
+    .text
+    .global USB_INTR_VECTOR
+    .type   USB_INTR_VECTOR, @function
+    .global usbCrc16
+    .global usbCrc16Append
+#endif /* __IAR_SYSTEMS_ASM__ */
+
+
+#if USB_INTR_PENDING < 0x40 /* This is an I/O address, use in and out */
+#   define  USB_LOAD_PENDING(reg)   in reg, USB_INTR_PENDING
+#   define  USB_STORE_PENDING(reg)  out USB_INTR_PENDING, reg
+#else   /* It's a memory address, use lds and sts */
+#   define  USB_LOAD_PENDING(reg)   lds reg, USB_INTR_PENDING
+#   define  USB_STORE_PENDING(reg)  sts USB_INTR_PENDING, reg
+#endif
+
+#define usbTxLen1   usbTxStatus1
+#define usbTxBuf1   (usbTxStatus1 + 1)
+#define usbTxLen3   usbTxStatus3
+#define usbTxBuf3   (usbTxStatus3 + 1)
+
+
+;----------------------------------------------------------------------------
+; Utility functions
+;----------------------------------------------------------------------------
+
+#ifdef __IAR_SYSTEMS_ASM__
+/* Register assignments for usbCrc16 on IAR cc */
+/* Calling conventions on IAR:
+ * First parameter passed in r16/r17, second in r18/r19 and so on.
+ * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+ * Result is passed in r16/r17
+ * In case of the "tiny" memory model, pointers are only 8 bit with no
+ * padding. We therefore pass argument 1 as "16 bit unsigned".
+ */
+RTMODEL "__rt_version", "3"
+/* The line above will generate an error if cc calling conventions change.
+ * The value "3" above is valid for IAR 4.10B/W32
+ */
+#   define argLen   r18 /* argument 2 */
+#   define argPtrL  r16 /* argument 1 */
+#   define argPtrH  r17 /* argument 1 */
+
+#   define resCrcL  r16 /* result */
+#   define resCrcH  r17 /* result */
+
+#   define ptrL     ZL
+#   define ptrH     ZH
+#   define ptr      Z
+#   define byte     r22
+#   define bitCnt   r19
+#   define polyL    r20
+#   define polyH    r21
+#   define scratch  r23
+
+#else  /* __IAR_SYSTEMS_ASM__ */
+/* Register assignments for usbCrc16 on gcc */
+/* Calling conventions on gcc:
+ * First parameter passed in r24/r25, second in r22/23 and so on.
+ * Callee must preserve r1-r17, r28/r29
+ * Result is passed in r24/r25
+ */
+#   define argLen   r22 /* argument 2 */
+#   define argPtrL  r24 /* argument 1 */
+#   define argPtrH  r25 /* argument 1 */
+
+#   define resCrcL  r24 /* result */
+#   define resCrcH  r25 /* result */
+
+#   define ptrL     XL
+#   define ptrH     XH
+#   define ptr      x
+#   define byte     r18
+#   define bitCnt   r19
+#   define polyL    r20
+#   define polyH    r21
+#   define scratch  r23
+
+#endif
+
+#if USB_USE_FAST_CRC
+
+; This implementation is faster, but has bigger code size
+; Thanks to Slawomir Fras (BoskiDialer) for this code!
+; It implements the following C pseudo-code:
+; unsigned table(unsigned char x)
+; {
+; unsigned    value;
+;
+;     value = (unsigned)x << 6;
+;     value ^= (unsigned)x << 7;
+;     if(parity(x))
+;         value ^= 0xc001;
+;     return value;
+; }
+; unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen)
+; {
+; unsigned crc = 0xffff;
+;
+;     while(argLen--)
+;         crc = table(lo8(crc) ^ *argPtr++) ^ hi8(crc);
+;     return ~crc;
+; }
+
+; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+;   argPtr  r24+25 / r16+r17
+;   argLen  r22 / r18
+; temp variables:
+;   byte    r18 / r22
+;   scratch r23
+;   resCrc  r24+r25 / r16+r17
+;   ptr     X / Z
+usbCrc16:
+    mov     ptrL, argPtrL
+    mov     ptrH, argPtrH
+    ldi     resCrcL, 0xFF
+    ldi     resCrcH, 0xFF
+    rjmp    usbCrc16LoopTest
+usbCrc16ByteLoop:
+    ld      byte, ptr+
+    eor     resCrcL, byte   ; resCrcL is now 'x' in table()
+    mov     byte, resCrcL   ; compute parity of 'x'
+    swap    byte
+    eor     byte, resCrcL
+    mov     scratch, byte
+    lsr     byte
+    lsr     byte
+    eor     byte, scratch
+    inc     byte
+    lsr     byte
+    andi    byte, 1         ; byte is now parity(x)
+    mov     scratch, resCrcL
+    mov     resCrcL, resCrcH
+    eor     resCrcL, byte   ; low byte of if(parity(x)) value ^= 0xc001;
+    neg     byte
+    andi    byte, 0xc0
+    mov     resCrcH, byte   ; high byte of if(parity(x)) value ^= 0xc001;
+    clr     byte
+    lsr     scratch
+    ror     byte
+    eor     resCrcH, scratch
+    eor     resCrcL, byte
+    lsr     scratch
+    ror     byte
+    eor     resCrcH, scratch
+    eor     resCrcL, byte
+usbCrc16LoopTest:
+    subi    argLen, 1
+    brsh    usbCrc16ByteLoop
+    com     resCrcL
+    com     resCrcH
+    ret
+
+#else   /* USB_USE_FAST_CRC */
+
+; This implementation is slower, but has less code size
+;
+; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+;   argPtr  r24+25 / r16+r17
+;   argLen  r22 / r18
+; temp variables:
+;   byte    r18 / r22
+;   bitCnt  r19
+;   poly    r20+r21
+;   scratch r23
+;   resCrc  r24+r25 / r16+r17
+;   ptr     X / Z
+usbCrc16:
+    mov     ptrL, argPtrL
+    mov     ptrH, argPtrH
+    ldi     resCrcL, 0
+    ldi     resCrcH, 0
+    ldi     polyL, lo8(0xa001)
+    ldi     polyH, hi8(0xa001)
+    com     argLen      ; argLen = -argLen - 1: modified loop to ensure that carry is set
+    ldi     bitCnt, 0   ; loop counter with starnd condition = end condition
+    rjmp    usbCrcLoopEntry
+usbCrcByteLoop:
+    ld      byte, ptr+
+    eor     resCrcL, byte
+usbCrcBitLoop:
+    ror     resCrcH     ; carry is always set here (see brcs jumps to here)
+    ror     resCrcL
+    brcs    usbCrcNoXor
+    eor     resCrcL, polyL
+    eor     resCrcH, polyH
+usbCrcNoXor:
+    subi    bitCnt, 224 ; (8 * 224) % 256 = 0; this loop iterates 8 times
+    brcs    usbCrcBitLoop
+usbCrcLoopEntry:
+    subi    argLen, -1
+    brcs    usbCrcByteLoop
+usbCrcReady:
+    ret
+; Thanks to Reimar Doeffinger for optimizing this CRC routine!
+
+#endif /* USB_USE_FAST_CRC */
+
+; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
+usbCrc16Append:
+    rcall   usbCrc16
+    st      ptr+, resCrcL
+    st      ptr+, resCrcH
+    ret
+
+#undef argLen
+#undef argPtrL
+#undef argPtrH
+#undef resCrcL
+#undef resCrcH
+#undef ptrL
+#undef ptrH
+#undef ptr
+#undef byte
+#undef bitCnt
+#undef polyL
+#undef polyH
+#undef scratch
+
+
+#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
+#ifdef __IAR_SYSTEMS_ASM__
+/* Register assignments for usbMeasureFrameLength on IAR cc */
+/* Calling conventions on IAR:
+ * First parameter passed in r16/r17, second in r18/r19 and so on.
+ * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+ * Result is passed in r16/r17
+ * In case of the "tiny" memory model, pointers are only 8 bit with no
+ * padding. We therefore pass argument 1 as "16 bit unsigned".
+ */
+#   define resL     r16
+#   define resH     r17
+#   define cnt16L   r30
+#   define cnt16H   r31
+#   define cntH     r18
+
+#else  /* __IAR_SYSTEMS_ASM__ */
+/* Register assignments for usbMeasureFrameLength on gcc */
+/* Calling conventions on gcc:
+ * First parameter passed in r24/r25, second in r22/23 and so on.
+ * Callee must preserve r1-r17, r28/r29
+ * Result is passed in r24/r25
+ */
+#   define resL     r24
+#   define resH     r25
+#   define cnt16L   r24
+#   define cnt16H   r25
+#   define cntH     r26
+#endif
+#   define cnt16    cnt16L
+
+; extern unsigned usbMeasurePacketLength(void);
+; returns time between two idle strobes in multiples of 7 CPU clocks
+.global usbMeasureFrameLength
+usbMeasureFrameLength:
+    ldi     cntH, 6         ; wait ~ 10 ms for D- == 0
+    clr     cnt16L
+    clr     cnt16H
+usbMFTime16:
+    dec     cntH
+    breq    usbMFTimeout
+usbMFWaitStrobe:            ; first wait for D- == 0 (idle strobe)
+    sbiw    cnt16, 1        ;[0] [6]
+    breq    usbMFTime16     ;[2]
+    sbic    USBIN, USBMINUS ;[3]
+    rjmp    usbMFWaitStrobe ;[4]
+usbMFWaitIdle:              ; then wait until idle again
+    sbis    USBIN, USBMINUS ;1 wait for D- == 1
+    rjmp    usbMFWaitIdle   ;2
+    ldi     cnt16L, 1       ;1 represents cycles so far
+    clr     cnt16H          ;1
+usbMFWaitLoop:
+    in      cntH, USBIN     ;[0] [7]
+    adiw    cnt16, 1        ;[1]
+    breq    usbMFTimeout    ;[3]
+    andi    cntH, USBMASK   ;[4]
+    brne    usbMFWaitLoop   ;[5]
+usbMFTimeout:
+#if resL != cnt16L
+    mov     resL, cnt16L
+    mov     resH, cnt16H
+#endif
+    ret
+
+#undef resL
+#undef resH
+#undef cnt16
+#undef cnt16L
+#undef cnt16H
+#undef cntH
+
+#endif  /* USB_CFG_HAVE_MEASURE_FRAME_LENGTH */
+
+;----------------------------------------------------------------------------
+; Now include the clock rate specific code
+;----------------------------------------------------------------------------
+
+#ifndef USB_CFG_CLOCK_KHZ
+#   ifdef F_CPU
+#       define USB_CFG_CLOCK_KHZ (F_CPU/1000)
+#   else
+#       error "USB_CFG_CLOCK_KHZ not defined in usbconfig.h and no F_CPU set!"
+#   endif
+#endif
+
+#if USB_CFG_CHECK_CRC   /* separate dispatcher for CRC type modules */
+#   if USB_CFG_CLOCK_KHZ == 18000
+#       include "usbdrvasm18-crc.inc"
+#   else
+#       error "USB_CFG_CLOCK_KHZ is not one of the supported crc-rates!"
+#   endif
+#else   /* USB_CFG_CHECK_CRC */
+#   if USB_CFG_CLOCK_KHZ == 12000
+#       include "usbdrvasm12.inc"
+#   elif USB_CFG_CLOCK_KHZ == 12800
+#       include "usbdrvasm128.inc"
+#   elif USB_CFG_CLOCK_KHZ == 15000
+#       include "usbdrvasm15.inc"
+#   elif USB_CFG_CLOCK_KHZ == 16000
+#       include "usbdrvasm16.inc"
+#   elif USB_CFG_CLOCK_KHZ == 16500
+#       include "usbdrvasm165.inc"
+#   elif USB_CFG_CLOCK_KHZ == 20000
+#       include "usbdrvasm20.inc"
+#   else
+#       error "USB_CFG_CLOCK_KHZ is not one of the supported non-crc-rates!"
+#   endif
+#endif /* USB_CFG_CHECK_CRC */
Index: usbdrv/usbdrvasm12.inc
===================================================================
--- usbdrv/usbdrvasm12.inc	(nonexistent)
+++ usbdrv/usbdrvasm12.inc	(working copy)
@@ -0,0 +1,392 @@
+/* Name: usbdrvasm12.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 12 MHz version of the asssembler part of the USB driver. It
+requires a 12 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+
+
+Timing constraints according to spec (in bit times):
+timing subject                                      min max    CPUcycles
+---------------------------------------------------------------------------
+EOP of OUT/SETUP to sync pattern of DATA0 (both rx) 2   16     16-128
+EOP of IN to sync pattern of DATA0 (rx, then tx)    2   7.5    16-60
+DATAx (rx) to ACK/NAK/STALL (tx)                    2   7.5    16-60
+*/
+
+;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
+;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
+;max allowable interrupt latency: 34 cycles -> max 25 cycles interrupt disable
+;max stack usage: [ret(2), YL, SREG, YH, shift, x1, x2, x3, cnt, x4] = 11 bytes
+;Numbers in brackets are maximum cycles since SOF.
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt
+    push    YL              ;2 [35] push only what is necessary to sync with edge ASAP
+    in      YL, SREG        ;1 [37]
+    push    YL              ;2 [39]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    YH                  ;2 [2]
+    lds     YL, usbInputBufOffset;2 [4]
+    clr     YH                  ;1 [5]
+    subi    YL, lo8(-(usbRxBuf));1 [6]
+    sbci    YH, hi8(-(usbRxBuf));1 [7]
+
+    sbis    USBIN, USBMINUS ;1 [8] we want two bits K [sample 1 cycle too early]
+    rjmp    haveTwoBitsK    ;2 [10]
+    pop     YH              ;2 [11] undo the push from before
+    rjmp    waitForK        ;2 [13] this was not the end of sync, retry
+haveTwoBitsK:
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+    push    shift           ;2 [16]
+    push    x1              ;2 [12]
+    push    x2              ;2 [14]
+
+    in      x1, USBIN       ;1 [17] <-- sample bit 0
+    ldi     shift, 0xff     ;1 [18]
+    bst     x1, USBMINUS    ;1 [19]
+    bld     shift, 0        ;1 [20]
+    push    x3              ;2 [22]
+    push    cnt             ;2 [24]
+    
+    in      x2, USBIN       ;1 [25] <-- sample bit 1
+    ser     x3              ;1 [26] [inserted init instruction]
+    eor     x1, x2          ;1 [27]
+    bst     x1, USBMINUS    ;1 [28]
+    bld     shift, 1        ;1 [29]
+    ldi     cnt, USB_BUFSIZE;1 [30] [inserted init instruction]
+    rjmp    rxbit2          ;2 [32]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+
+unstuff0:               ;1 (branch taken)
+    andi    x3, ~0x01   ;1 [15]
+    mov     x1, x2      ;1 [16] x2 contains last sampled (stuffed) bit
+    in      x2, USBIN   ;1 [17] <-- sample bit 1 again
+    ori     shift, 0x01 ;1 [18]
+    rjmp    didUnstuff0 ;2 [20]
+
+unstuff1:               ;1 (branch taken)
+    mov     x2, x1      ;1 [21] x1 contains last sampled (stuffed) bit
+    andi    x3, ~0x02   ;1 [22]
+    ori     shift, 0x02 ;1 [23]
+    nop                 ;1 [24]
+    in      x1, USBIN   ;1 [25] <-- sample bit 2 again
+    rjmp    didUnstuff1 ;2 [27]
+
+unstuff2:               ;1 (branch taken)
+    andi    x3, ~0x04   ;1 [29]
+    ori     shift, 0x04 ;1 [30]
+    mov     x1, x2      ;1 [31] x2 contains last sampled (stuffed) bit
+    nop                 ;1 [32]
+    in      x2, USBIN   ;1 [33] <-- sample bit 3
+    rjmp    didUnstuff2 ;2 [35]
+
+unstuff3:               ;1 (branch taken)
+    in      x2, USBIN   ;1 [34] <-- sample stuffed bit 3 [one cycle too late]
+    andi    x3, ~0x08   ;1 [35]
+    ori     shift, 0x08 ;1 [36]
+    rjmp    didUnstuff3 ;2 [38]
+
+unstuff4:               ;1 (branch taken)
+    andi    x3, ~0x10   ;1 [40]
+    in      x1, USBIN   ;1 [41] <-- sample stuffed bit 4
+    ori     shift, 0x10 ;1 [42]
+    rjmp    didUnstuff4 ;2 [44]
+
+unstuff5:               ;1 (branch taken)
+    andi    x3, ~0x20   ;1 [48]
+    in      x2, USBIN   ;1 [49] <-- sample stuffed bit 5
+    ori     shift, 0x20 ;1 [50]
+    rjmp    didUnstuff5 ;2 [52]
+
+unstuff6:               ;1 (branch taken)
+    andi    x3, ~0x40   ;1 [56]
+    in      x1, USBIN   ;1 [57] <-- sample stuffed bit 6
+    ori     shift, 0x40 ;1 [58]
+    rjmp    didUnstuff6 ;2 [60]
+
+; extra jobs done during bit interval:
+; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs]
+; bit 1:    se0 check
+; bit 2:    overflow check
+; bit 3:    recovery from delay [bit 0 tasks took too long]
+; bit 4:    none
+; bit 5:    none
+; bit 6:    none
+; bit 7:    jump, eor
+rxLoop:
+    eor     x3, shift   ;1 [0] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    in      x1, USBIN   ;1 [1] <-- sample bit 0
+    st      y+, x3      ;2 [3] store data
+    ser     x3          ;1 [4]
+    nop                 ;1 [5]
+    eor     x2, x1      ;1 [6]
+    bst     x2, USBMINUS;1 [7]
+    bld     shift, 0    ;1 [8]
+    in      x2, USBIN   ;1 [9] <-- sample bit 1 (or possibly bit 0 stuffed)
+    andi    x2, USBMASK ;1 [10]
+    breq    se0         ;1 [11] SE0 check for bit 1
+    andi    shift, 0xf9 ;1 [12]
+didUnstuff0:
+    breq    unstuff0    ;1 [13]
+    eor     x1, x2      ;1 [14]
+    bst     x1, USBMINUS;1 [15]
+    bld     shift, 1    ;1 [16]
+rxbit2:
+    in      x1, USBIN   ;1 [17] <-- sample bit 2 (or possibly bit 1 stuffed)
+    andi    shift, 0xf3 ;1 [18]
+    breq    unstuff1    ;1 [19] do remaining work for bit 1
+didUnstuff1:
+    subi    cnt, 1      ;1 [20]
+    brcs    overflow    ;1 [21] loop control
+    eor     x2, x1      ;1 [22]
+    bst     x2, USBMINUS;1 [23]
+    bld     shift, 2    ;1 [24]
+    in      x2, USBIN   ;1 [25] <-- sample bit 3 (or possibly bit 2 stuffed)
+    andi    shift, 0xe7 ;1 [26]
+    breq    unstuff2    ;1 [27]
+didUnstuff2:
+    eor     x1, x2      ;1 [28]
+    bst     x1, USBMINUS;1 [29]
+    bld     shift, 3    ;1 [30]
+didUnstuff3:
+    andi    shift, 0xcf ;1 [31]
+    breq    unstuff3    ;1 [32]
+    in      x1, USBIN   ;1 [33] <-- sample bit 4
+    eor     x2, x1      ;1 [34]
+    bst     x2, USBMINUS;1 [35]
+    bld     shift, 4    ;1 [36]
+didUnstuff4:
+    andi    shift, 0x9f ;1 [37]
+    breq    unstuff4    ;1 [38]
+    nop2                ;2 [40]
+    in      x2, USBIN   ;1 [41] <-- sample bit 5
+    eor     x1, x2      ;1 [42]
+    bst     x1, USBMINUS;1 [43]
+    bld     shift, 5    ;1 [44]
+didUnstuff5:
+    andi    shift, 0x3f ;1 [45]
+    breq    unstuff5    ;1 [46]
+    nop2                ;2 [48]
+    in      x1, USBIN   ;1 [49] <-- sample bit 6
+    eor     x2, x1      ;1 [50]
+    bst     x2, USBMINUS;1 [51]
+    bld     shift, 6    ;1 [52]
+didUnstuff6:
+    cpi     shift, 0x02 ;1 [53]
+    brlo    unstuff6    ;1 [54]
+    nop2                ;2 [56]
+    in      x2, USBIN   ;1 [57] <-- sample bit 7
+    eor     x1, x2      ;1 [58]
+    bst     x1, USBMINUS;1 [59]
+    bld     shift, 7    ;1 [60]
+didUnstuff7:
+    cpi     shift, 0x04 ;1 [61]
+    brsh    rxLoop      ;2 [63] loop control
+unstuff7:
+    andi    x3, ~0x80   ;1 [63]
+    ori     shift, 0x80 ;1 [64]
+    in      x2, USBIN   ;1 [65] <-- sample stuffed bit 7
+    nop                 ;1 [66]
+    rjmp    didUnstuff7 ;2 [68]
+
+macro POP_STANDARD ; 12 cycles
+    pop     cnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;----------------------------------------------------------------------------
+; Transmitting data
+;----------------------------------------------------------------------------
+
+txByteLoop:
+txBitloop:
+stuffN1Delay:                   ;     [03]
+    ror     shift               ;[-5] [11] [59]
+    brcc    doExorN1            ;[-4]      [60]
+    subi    x4, 1               ;[-3]
+    brne    commonN1            ;[-2]
+    lsl     shift               ;[-1] compensate ror after rjmp stuffDelay
+    nop                         ;[00] stuffing consists of just waiting 8 cycles
+    rjmp    stuffN1Delay        ;[01] after ror, C bit is reliably clear
+
+sendNakAndReti:                 ;0 [-19] 19 cycles until SOP
+    ldi     x3, USBPID_NAK      ;1 [-18]
+    rjmp    usbSendX3           ;2 [-16]
+sendAckAndReti:                 ;0 [-19] 19 cycles until SOP
+    ldi     x3, USBPID_ACK      ;1 [-18]
+    rjmp    usbSendX3           ;2 [-16]
+sendCntAndReti:                 ;0 [-17] 17 cycles until SOP
+    mov     x3, cnt             ;1 [-16]
+usbSendX3:                      ;0 [-16]
+    ldi     YL, 20              ;1 [-15] 'x3' is R20
+    ldi     YH, 0               ;1 [-14]
+    ldi     cnt, 2              ;1 [-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
+; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
+; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte
+;uses: x1...x2, x4, shift, cnt, Y [x1 = mirror USBOUT, x2 = USBMASK, x4 = bitstuff cnt]
+;Numbers in brackets are time since first bit of sync pattern is sent (start of instruction)
+usbSendAndReti:
+    in      x2, USBDDR          ;[-12] 12 cycles until SOP
+    ori     x2, USBMASK         ;[-11]
+    sbi     USBOUT, USBMINUS    ;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    out     USBDDR, x2          ;[-8] <--- acquire bus
+    in      x1, USBOUT          ;[-7] port mirror for tx loop
+    ldi     shift, 0x40         ;[-6] sync byte is first byte sent (we enter loop after ror)
+    ldi     x2, USBMASK         ;[-5]
+    push    x4                  ;[-4]
+doExorN1:
+    eor     x1, x2              ;[-2] [06] [62]
+    ldi     x4, 6               ;[-1] [07] [63]
+commonN1:
+stuffN2Delay:
+    out     USBOUT, x1          ;[00] [08] [64] <--- set bit
+    ror     shift               ;[01]
+    brcc    doExorN2            ;[02]
+    subi    x4, 1               ;[03]
+    brne    commonN2            ;[04]
+    lsl     shift               ;[05] compensate ror after rjmp stuffDelay
+    rjmp    stuffN2Delay        ;[06] after ror, C bit is reliably clear
+doExorN2:
+    eor     x1, x2              ;[04] [12]
+    ldi     x4, 6               ;[05] [13]
+commonN2:
+    nop                         ;[06] [14]
+    subi    cnt, 171            ;[07] [15] trick: (3 * 171) & 0xff = 1
+    out     USBOUT, x1          ;[08] [16] <--- set bit
+    brcs    txBitloop           ;[09]      [25] [41]
+
+stuff6Delay:
+    ror     shift               ;[42] [50]
+    brcc    doExor6             ;[43]
+    subi    x4, 1               ;[44]
+    brne    common6             ;[45]
+    lsl     shift               ;[46] compensate ror after rjmp stuffDelay
+    nop                         ;[47] stuffing consists of just waiting 8 cycles
+    rjmp    stuff6Delay         ;[48] after ror, C bit is reliably clear
+doExor6:
+    eor     x1, x2              ;[45] [53]
+    ldi     x4, 6               ;[46]
+common6:
+stuff7Delay:
+    ror     shift               ;[47] [55]
+    out     USBOUT, x1          ;[48] <--- set bit
+    brcc    doExor7             ;[49]
+    subi    x4, 1               ;[50]
+    brne    common7             ;[51]
+    lsl     shift               ;[52] compensate ror after rjmp stuffDelay
+    rjmp    stuff7Delay         ;[53] after ror, C bit is reliably clear
+doExor7:
+    eor     x1, x2              ;[51] [59]
+    ldi     x4, 6               ;[52]
+common7:
+    ld      shift, y+           ;[53]
+    tst     cnt                 ;[55]
+    out     USBOUT, x1          ;[56] <--- set bit
+    brne    txByteLoop          ;[57]
+
+;make SE0:
+    cbr     x1, USBMASK         ;[58] prepare SE0 [spec says EOP may be 15 to 18 cycles]
+    lds     x2, usbNewDeviceAddr;[59]
+    lsl     x2                  ;[61] we compare with left shifted address
+    subi    YL, 2 + 20          ;[62] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0               ;[63]
+    out     USBOUT, x1          ;[00] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign      ;[01]
+    sts     usbDeviceAddr, x2   ; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[03] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)       ;[04]
+    ori     x1, USBIDLE         ;[05]
+    in      x2, USBDDR          ;[06]
+    cbr     x2, USBMASK         ;[07] set both pins to input
+    mov     x3, x1              ;[08]
+    cbr     x3, USBMASK         ;[09] configure no pullup on both pins
+    pop     x4                  ;[10]
+    nop2                        ;[12]
+    nop2                        ;[14]
+    out     USBOUT, x1          ;[16] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2          ;[17] <-- release bus now
+    out     USBOUT, x3          ;[18] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: usbdrv/usbdrvasm128.inc
===================================================================
--- usbdrv/usbdrvasm128.inc	(nonexistent)
+++ usbdrv/usbdrvasm128.inc	(working copy)
@@ -0,0 +1,749 @@
+/* Name: usbdrvasm128.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-10-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 12.8 MHz version of the USB driver. It is intended for use
+with the internal RC oscillator. Although 12.8 MHz is outside the guaranteed
+calibration range of the oscillator, almost all AVRs can reach this frequency.
+This version contains a phase locked loop in the receiver routine to cope with
+slight clock rate deviations of up to +/- 1%.
+
+See usbdrv.h for a description of the entire driver.
+
+LIMITATIONS
+===========
+Although it may seem very handy to save the crystal and use the internal
+RC oscillator of the CPU, this method (and this module) has some serious
+limitations:
+(1) The guaranteed calibration range of the oscillator is only 8.1 MHz.
+They typical range is 14.5 MHz and most AVRs can actually reach this rate.
+(2) Writing EEPROM and Flash may be unreliable (short data lifetime) since
+the write procedure is timed from the RC oscillator.
+(3) End Of Packet detection (SE0) should be in bit 1, bit it is only checked
+if bits 0 and 1 both read as 0 on D- and D+ read as 0 in the middle. This may
+cause problems with old hubs which delay SE0 by up to one cycle.
+(4) Code size is much larger than that of the other modules.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+
+Implementation notes:
+======================
+min frequency: 67 cycles for 8 bit -> 12.5625 MHz
+max frequency: 69.286 cycles for 8 bit -> 12.99 MHz
+nominal frequency: 12.77 MHz ( = sqrt(min * max))
+
+sampling positions: (next even number in range [+/- 0.5])
+cycle index range: 0 ... 66
+bits:
+.5, 8.875, 17.25, 25.625, 34, 42.375, 50.75, 59.125
+[0/1], [9], [17], [25/+26], [34], [+42/43], [51], [59]
+
+bit number:     0   1   2   3   4   5   6   7
+spare cycles    1   2   1   2   1   1   1   0
+
+operations to perform:      duration cycle
+                            ----------------
+    eor     fix, shift          1 -> 00
+    andi    phase, USBMASK      1 -> 08
+    breq    se0                 1 -> 16 (moved to 11)
+    st      y+, data            2 -> 24, 25
+    mov     data, fix           1 -> 33
+    ser     data                1 -> 41
+    subi    cnt, 1              1 -> 49
+    brcs    overflow            1 -> 50
+
+layout of samples and operations:
+[##] = sample bit
+<##> = sample phase
+*##* = operation
+
+0:  *00* [01]  02   03   04  <05>  06   07
+1:  *08* [09]  10   11   12  <13>  14   15  *16*
+2:  [17]  18   19   20  <21>  22   23
+3:  *24* *25* [26]  27   28   29  <30>  31   32
+4:  *33* [34]  35   36   37  <38>  39   40
+5:  *41* [42]  43   44   45  <46>  47   48
+6:  *49* *50* [51]  52   53   54  <55>  56   57   58
+7:  [59]  60   61   62  <63>  64   65   66
+*****************************************************************************/
+
+/* we prefer positive expressions (do if condition) instead of negative
+ * (skip if condition), therefore use defines for skip instructions:
+ */
+#define ifioclr sbis
+#define ifioset sbic
+#define ifrclr  sbrs
+#define ifrset  sbrc
+
+/* The registers "fix" and "data" swap their meaning during the loop. Use
+ * defines to keep their name constant.
+ */
+#define fix     x2
+#define data    x1
+#undef phase        /* phase has a default definition to x4 */
+#define phase   x3
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt, r0
+    push    YL              ;2 push only what is necessary to sync with edge ASAP
+    in      YL, SREG        ;1
+    push    YL              ;2
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS ;[0]
+    rjmp    foundK          ;[1]
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+
+foundK:
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    YH                  ;[2]
+    lds     YL, usbInputBufOffset;[4]
+    clr     YH                  ;[6]
+    subi    YL, lo8(-(usbRxBuf));[7]
+    sbci    YH, hi8(-(usbRxBuf));[8]
+
+    sbis    USBIN, USBMINUS     ;[9] we want two bits K [we want to sample at 8 + 4 - 1.5 = 10.5]
+    rjmp    haveTwoBitsK        ;[10]
+    pop     YH                  ;[11] undo the push from before
+    rjmp    waitForK            ;[13] this was not the end of sync, retry
+haveTwoBitsK:
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+#define fix     x2
+#define data    x1
+
+    push    shift               ;[12]
+    push    x1                  ;[14]
+    push    x2                  ;[16]
+    ldi     shift, 0x80         ;[18] prevent bit-unstuffing but init low bits to 0
+    ifioset USBIN, USBMINUS     ;[19] [01] <--- bit 0 [10.5 + 8 = 18.5]
+    ori     shift, 1<<0         ;[02]
+    push    x3                  ;[03]
+    push    cnt                 ;[05]
+    push    r0                  ;[07]
+    ifioset USBIN, USBMINUS     ;[09] <--- bit 1
+    ori     shift, 1<<1         ;[10]
+    ser     fix                 ;[11]
+    ldi     cnt, USB_BUFSIZE    ;[12]
+    mov     data, shift         ;[13]
+    lsl     shift               ;[14]
+    nop2                        ;[15]
+    ifioset USBIN, USBMINUS     ;[17] <--- bit 2
+    ori     data, 3<<2          ;[18] store in bit 2 AND bit 3
+    eor     shift, data         ;[19] do nrzi decoding
+    andi    data, 1<<3          ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    brne    jumpToEntryAfterSet ;[22] if USBMINS at bit 3 was 1
+    nop                         ;[23]
+    rjmp    entryAfterClr       ;[24]
+jumpToEntryAfterSet:
+    rjmp    entryAfterSet       ;[24]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+#undef  fix
+#define  fix    x1
+#undef  data
+#define data    x2
+
+bit7IsSet:
+    ifrclr  phase, USBMINUS     ;[62] check phase only if D- changed
+    lpm                         ;[63]
+    in      phase, USBIN        ;[64] <- phase (one cycle too late)
+    ori     shift, 1 << 7       ;[65]
+    nop                         ;[66]
+;;;;rjmp    bit0AfterSet        ; -> [00] == [67] moved block up to save jump
+bit0AfterSet:
+    eor     fix, shift          ;[00]
+#undef  fix
+#define fix     x2
+#undef  data
+#define data    x1  /* we now have result in data, fix is reset to 0xff */
+    ifioclr USBIN, USBMINUS     ;[01] <--- sample 0
+    rjmp    bit0IsClr           ;[02]
+    andi    shift, ~(7 << 0)    ;[03]
+    breq    unstuff0s           ;[04]
+    in      phase, USBIN        ;[05] <- phase
+    rjmp    bit1AfterSet        ;[06]
+unstuff0s:
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    andi    fix, ~(1 << 0)      ;[07]
+    ifioclr USBIN, USBMINUS     ;[00]
+    ifioset USBIN, USBPLUS      ;[01]
+    rjmp    bit0IsClr           ;[02] executed if first expr false or second true
+se0AndStore:                    ; executed only if both bits 0
+    st      y+, x1              ;[15/17] cycles after start of byte
+    rjmp    se0                 ;[17/19]
+
+bit0IsClr:
+    ifrset  phase, USBMINUS     ;[04] check phase only if D- changed
+    lpm                         ;[05]
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    ori     shift, 1 << 0       ;[07]
+bit1AfterClr:
+    andi    phase, USBMASK      ;[08]
+    ifioset USBIN, USBMINUS     ;[09] <--- sample 1
+    rjmp    bit1IsSet           ;[10]
+    breq    se0AndStore         ;[11] if D- was 0 in bits 0 AND 1 and D+ was 0 in between, we have SE0
+    andi    shift, ~(7 << 1)    ;[12]
+    in      phase, USBIN        ;[13] <- phase
+    breq    unstuff1c           ;[14]
+    rjmp    bit2AfterClr        ;[15]
+unstuff1c:
+    andi    fix, ~(1 << 1)      ;[16]
+    nop2                        ;[08]
+    nop2                        ;[10]
+bit1IsSet:
+    ifrclr  phase, USBMINUS     ;[12] check phase only if D- changed
+    lpm                         ;[13]
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    ori     shift, 1 << 1       ;[15]
+    nop                         ;[16]
+bit2AfterSet:
+    ifioclr USBIN, USBMINUS     ;[17] <--- sample 2
+    rjmp    bit2IsClr           ;[18]
+    andi    shift, ~(7 << 2)    ;[19]
+    breq    unstuff2s           ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    rjmp    bit3AfterSet        ;[22]
+unstuff2s:
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    andi    fix, ~(1 << 2)      ;[23]
+    nop2                        ;[16]
+    nop2                        ;[18]
+bit2IsClr:
+    ifrset  phase, USBMINUS     ;[20] check phase only if D- changed
+    lpm                         ;[21]
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    ori     shift, 1 << 2       ;[23]
+bit3AfterClr:
+    st      y+, data            ;[24]
+entryAfterClr:
+    ifioset USBIN, USBMINUS     ;[26] <--- sample 3
+    rjmp    bit3IsSet           ;[27]
+    andi    shift, ~(7 << 3)    ;[28]
+    breq    unstuff3c           ;[29]
+    in      phase, USBIN        ;[30] <- phase
+    rjmp    bit4AfterClr        ;[31]
+unstuff3c:
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    andi    fix, ~(1 << 3)      ;[32]
+    nop2                        ;[25]
+    nop2                        ;[27]
+bit3IsSet:
+    ifrclr  phase, USBMINUS     ;[29] check phase only if D- changed
+    lpm                         ;[30]
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    ori     shift, 1 << 3       ;[32]
+bit4AfterSet:
+    mov     data, fix           ;[33] undo this move by swapping defines
+#undef  fix
+#define fix     x1
+#undef  data
+#define data    x2
+    ifioclr USBIN, USBMINUS     ;[34] <--- sample 4
+    rjmp    bit4IsClr           ;[35]
+    andi    shift, ~(7 << 4)    ;[36]
+    breq    unstuff4s           ;[37]
+    in      phase, USBIN        ;[38] <- phase
+    rjmp    bit5AfterSet        ;[39]
+unstuff4s:
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    andi    fix, ~(1 << 4)      ;[40]
+    nop2                        ;[33]
+    nop2                        ;[35]
+bit4IsClr:
+    ifrset  phase, USBMINUS     ;[37] check phase only if D- changed
+    lpm                         ;[38]
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    ori     shift, 1 << 4       ;[40]
+bit5AfterClr:
+    ser     data                ;[41]
+    ifioset USBIN, USBMINUS     ;[42] <--- sample 5
+    rjmp    bit5IsSet           ;[43]
+    andi    shift, ~(7 << 5)    ;[44]
+    breq    unstuff5c           ;[45]
+    in      phase, USBIN        ;[46] <- phase
+    rjmp    bit6AfterClr        ;[47]
+unstuff5c:
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    andi    fix, ~(1 << 5)      ;[48]
+    nop2                        ;[41]
+    nop2                        ;[43]
+bit5IsSet:
+    ifrclr  phase, USBMINUS     ;[45] check phase only if D- changed
+    lpm                         ;[46]
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    ori     shift, 1 << 5       ;[48]
+bit6AfterSet:
+    subi    cnt, 1              ;[49]
+    brcs    jumpToOverflow      ;[50]
+    ifioclr USBIN, USBMINUS     ;[51] <--- sample 6
+    rjmp    bit6IsClr           ;[52]
+    andi    shift, ~(3 << 6)    ;[53]
+    cpi     shift, 2            ;[54]
+    in      phase, USBIN        ;[55] <- phase
+    brlt    unstuff6s           ;[56]
+    rjmp    bit7AfterSet        ;[57]
+
+jumpToOverflow:
+    rjmp    overflow
+
+unstuff6s:
+    andi    fix, ~(1 << 6)      ;[50]
+    lpm                         ;[51]
+bit6IsClr:
+    ifrset  phase, USBMINUS     ;[54] check phase only if D- changed
+    lpm                         ;[55]
+    in      phase, USBIN        ;[56] <- phase (one cycle too late)
+    ori     shift, 1 << 6       ;[57]
+    nop                         ;[58]
+bit7AfterClr:
+    ifioset USBIN, USBMINUS     ;[59] <--- sample 7
+    rjmp    bit7IsSet           ;[60]
+    andi    shift, ~(1 << 7)    ;[61]
+    cpi     shift, 4            ;[62]
+    in      phase, USBIN        ;[63] <- phase
+    brlt    unstuff7c           ;[64]
+    rjmp    bit0AfterClr        ;[65] -> [00] == [67]
+unstuff7c:
+    andi    fix, ~(1 << 7)      ;[58]
+    nop                         ;[59]
+    rjmp    bit7IsSet           ;[60]
+
+bit7IsClr:
+    ifrset  phase, USBMINUS     ;[62] check phase only if D- changed
+    lpm                         ;[63]
+    in      phase, USBIN        ;[64] <- phase (one cycle too late)
+    ori     shift, 1 << 7       ;[65]
+    nop                         ;[66]
+;;;;rjmp    bit0AfterClr        ; -> [00] == [67] moved block up to save jump
+bit0AfterClr:
+    eor     fix, shift          ;[00]
+#undef  fix
+#define fix     x2
+#undef  data
+#define data    x1  /* we now have result in data, fix is reset to 0xff */
+    ifioset USBIN, USBMINUS     ;[01] <--- sample 0
+    rjmp    bit0IsSet           ;[02]
+    andi    shift, ~(7 << 0)    ;[03]
+    breq    unstuff0c           ;[04]
+    in      phase, USBIN        ;[05] <- phase
+    rjmp    bit1AfterClr        ;[06]
+unstuff0c:
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    andi    fix, ~(1 << 0)      ;[07]
+    ifioclr USBIN, USBMINUS     ;[00]
+    ifioset USBIN, USBPLUS      ;[01]
+    rjmp    bit0IsSet           ;[02] executed if first expr false or second true
+    rjmp    se0AndStore         ;[03] executed only if both bits 0
+bit0IsSet:
+    ifrclr  phase, USBMINUS     ;[04] check phase only if D- changed
+    lpm                         ;[05]
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    ori     shift, 1 << 0       ;[07]
+bit1AfterSet:
+    andi    shift, ~(7 << 1)    ;[08] compensated by "ori shift, 1<<1" if bit1IsClr
+    ifioclr USBIN, USBMINUS     ;[09] <--- sample 1
+    rjmp    bit1IsClr           ;[10]
+    breq    unstuff1s           ;[11]
+    nop2                        ;[12] do not check for SE0 if bit 0 was 1
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    rjmp    bit2AfterSet        ;[15]
+unstuff1s:
+    in      phase, USBIN        ;[13] <- phase
+    andi    fix, ~(1 << 1)      ;[14]
+    lpm                         ;[07]
+    nop2                        ;[10]
+bit1IsClr:
+    ifrset  phase, USBMINUS     ;[12] check phase only if D- changed
+    lpm                         ;[13]
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    ori     shift, 1 << 1       ;[15]
+    nop                         ;[16]
+bit2AfterClr:
+    ifioset USBIN, USBMINUS     ;[17] <--- sample 2
+    rjmp    bit2IsSet           ;[18]
+    andi    shift, ~(7 << 2)    ;[19]
+    breq    unstuff2c           ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    rjmp    bit3AfterClr        ;[22]
+unstuff2c:
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    andi    fix, ~(1 << 2)      ;[23]
+    nop2                        ;[16]
+    nop2                        ;[18]
+bit2IsSet:
+    ifrclr  phase, USBMINUS     ;[20] check phase only if D- changed
+    lpm                         ;[21]
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    ori     shift, 1 << 2       ;[23]
+bit3AfterSet:
+    st      y+, data            ;[24]
+entryAfterSet:
+    ifioclr USBIN, USBMINUS     ;[26] <--- sample 3
+    rjmp    bit3IsClr           ;[27]
+    andi    shift, ~(7 << 3)    ;[28]
+    breq    unstuff3s           ;[29]
+    in      phase, USBIN        ;[30] <- phase
+    rjmp    bit4AfterSet        ;[31]
+unstuff3s:
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    andi    fix, ~(1 << 3)      ;[32]
+    nop2                        ;[25]
+    nop2                        ;[27]
+bit3IsClr:
+    ifrset  phase, USBMINUS     ;[29] check phase only if D- changed
+    lpm                         ;[30]
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    ori     shift, 1 << 3       ;[32]
+bit4AfterClr:
+    mov     data, fix           ;[33] undo this move by swapping defines
+#undef  fix
+#define fix     x1
+#undef  data
+#define data    x2
+    ifioset USBIN, USBMINUS     ;[34] <--- sample 4
+    rjmp    bit4IsSet           ;[35]
+    andi    shift, ~(7 << 4)    ;[36]
+    breq    unstuff4c           ;[37]
+    in      phase, USBIN        ;[38] <- phase
+    rjmp    bit5AfterClr        ;[39]
+unstuff4c:
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    andi    fix, ~(1 << 4)      ;[40]
+    nop2                        ;[33]
+    nop2                        ;[35]
+bit4IsSet:
+    ifrclr  phase, USBMINUS     ;[37] check phase only if D- changed
+    lpm                         ;[38]
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    ori     shift, 1 << 4       ;[40]
+bit5AfterSet:
+    ser     data                ;[41]
+    ifioclr USBIN, USBMINUS     ;[42] <--- sample 5
+    rjmp    bit5IsClr           ;[43]
+    andi    shift, ~(7 << 5)    ;[44]
+    breq    unstuff5s           ;[45]
+    in      phase, USBIN        ;[46] <- phase
+    rjmp    bit6AfterSet        ;[47]
+unstuff5s:
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    andi    fix, ~(1 << 5)      ;[48]
+    nop2                        ;[41]
+    nop2                        ;[43]
+bit5IsClr:
+    ifrset  phase, USBMINUS     ;[45] check phase only if D- changed
+    lpm                         ;[46]
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    ori     shift, 1 << 5       ;[48]
+bit6AfterClr:
+    subi    cnt, 1              ;[49]
+    brcs    overflow            ;[50]
+    ifioset USBIN, USBMINUS     ;[51] <--- sample 6
+    rjmp    bit6IsSet           ;[52]
+    andi    shift, ~(3 << 6)    ;[53]
+    cpi     shift, 2            ;[54]
+    in      phase, USBIN        ;[55] <- phase
+    brlt    unstuff6c           ;[56]
+    rjmp    bit7AfterClr        ;[57]
+unstuff6c:
+    andi    fix, ~(1 << 6)      ;[50]
+    lpm                         ;[51]
+bit6IsSet:
+    ifrclr  phase, USBMINUS     ;[54] check phase only if D- changed
+    lpm                         ;[55]
+    in      phase, USBIN        ;[56] <- phase (one cycle too late)
+    ori     shift, 1 << 6       ;[57]
+bit7AfterSet:
+    ifioclr USBIN, USBMINUS     ;[59] <--- sample 7
+    rjmp    bit7IsClr           ;[60]
+    andi    shift, ~(1 << 7)    ;[61]
+    cpi     shift, 4            ;[62]
+    in      phase, USBIN        ;[63] <- phase
+    brlt    unstuff7s           ;[64]
+    rjmp    bit0AfterSet        ;[65] -> [00] == [67]
+unstuff7s:
+    andi    fix, ~(1 << 7)      ;[58]
+    nop                         ;[59]
+    rjmp    bit7IsClr           ;[60]
+
+macro POP_STANDARD ; 14 cycles
+    pop     r0
+    pop     cnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;----------------------------------------------------------------------------
+; Transmitting data
+;----------------------------------------------------------------------------
+
+txByteLoop:
+txBitloop:
+stuffN1Delay:                   ;     [03]
+    ror     shift               ;[-5] [11] [63]
+    brcc    doExorN1            ;[-4]      [64]
+    subi    x3, 1               ;[-3]
+    brne    commonN1            ;[-2]
+    lsl     shift               ;[-1] compensate ror after rjmp stuffDelay
+    nop                         ;[00] stuffing consists of just waiting 8 cycles
+    rjmp    stuffN1Delay        ;[01] after ror, C bit is reliably clear
+
+sendNakAndReti:
+    ldi     cnt, USBPID_NAK ;[-19]
+    rjmp    sendCntAndReti  ;[-18]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     r0, cnt         ;[-16]
+    ldi     YL, 0           ;[-15] R0 address is 0
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
+; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
+; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte
+;uses: x1...x3, shift, cnt, Y [x1 = mirror USBOUT, x2 = USBMASK, x3 = bitstuff cnt]
+;Numbers in brackets are time since first bit of sync pattern is sent (start of instruction)
+usbSendAndReti:
+    in      x2, USBDDR          ;[-10] 10 cycles until SOP
+    ori     x2, USBMASK         ;[-9]
+    sbi     USBOUT, USBMINUS    ;[-8] prepare idle state; D+ and D- must have been 0 (no pullups)
+    out     USBDDR, x2          ;[-6] <--- acquire bus
+    in      x1, USBOUT          ;[-5] port mirror for tx loop
+    ldi     shift, 0x40         ;[-4] sync byte is first byte sent (we enter loop after ror)
+    ldi     x2, USBMASK         ;[-3]
+doExorN1:
+    eor     x1, x2              ;[-2] [06] [62]
+    ldi     x3, 6               ;[-1] [07] [63]
+commonN1:
+stuffN2Delay:
+    out     USBOUT, x1          ;[00] [08] [64] <--- set bit
+    ror     shift               ;[01]
+    brcc    doExorN2            ;[02]
+    subi    x3, 1               ;[03]
+    brne    commonN2            ;[04]
+    lsl     shift               ;[05] compensate ror after rjmp stuffDelay
+    rjmp    stuffN2Delay        ;[06] after ror, C bit is reliably clear
+doExorN2:
+    eor     x1, x2              ;[04] [12]
+    ldi     x3, 6               ;[05] [13]
+commonN2:
+    nop2                        ;[06] [14]
+    subi    cnt, 171            ;[08] [16] trick: (3 * 171) & 0xff = 1
+    out     USBOUT, x1          ;[09] [17] <--- set bit
+    brcs    txBitloop           ;[10]      [27] [44]
+
+stuff6Delay:
+    ror     shift               ;[45] [53]
+    brcc    doExor6             ;[46]
+    subi    x3, 1               ;[47]
+    brne    common6             ;[48]
+    lsl     shift               ;[49] compensate ror after rjmp stuffDelay
+    nop                         ;[50] stuffing consists of just waiting 8 cycles
+    rjmp    stuff6Delay         ;[51] after ror, C bit is reliably clear
+doExor6:
+    eor     x1, x2              ;[48] [56]
+    ldi     x3, 6               ;[49]
+common6:
+stuff7Delay:
+    ror     shift               ;[50] [58]
+    out     USBOUT, x1          ;[51] <--- set bit
+    brcc    doExor7             ;[52]
+    subi    x3, 1               ;[53]
+    brne    common7             ;[54]
+    lsl     shift               ;[55] compensate ror after rjmp stuffDelay
+    rjmp    stuff7Delay         ;[56] after ror, C bit is reliably clear
+doExor7:
+    eor     x1, x2              ;[54] [62]
+    ldi     x3, 6               ;[55]
+common7:
+    ld      shift, y+           ;[56]
+    nop                         ;[58]
+    tst     cnt                 ;[59]
+    out     USBOUT, x1          ;[60] [00]<--- set bit
+    brne    txByteLoop          ;[61] [01]
+;make SE0:
+    cbr     x1, USBMASK         ;[02] prepare SE0 [spec says EOP may be 15 to 18 cycles]
+    lds     x2, usbNewDeviceAddr;[03]
+    lsl     x2                  ;[05] we compare with left shifted address
+    subi    YL, 2 + 0           ;[06] Only assign address on data packets, not ACK/NAK in r0
+    sbci    YH, 0               ;[07]
+    out     USBOUT, x1          ;[00] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign      ;[01]
+    sts     usbDeviceAddr, x2   ; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[03] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)       ;[04]
+    ori     x1, USBIDLE         ;[05]
+    in      x2, USBDDR          ;[06]
+    cbr     x2, USBMASK         ;[07] set both pins to input
+    mov     x3, x1              ;[08]
+    cbr     x3, USBMASK         ;[09] configure no pullup on both pins
+    lpm                         ;[10]
+    lpm                         ;[13]
+    out     USBOUT, x1          ;[16] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2          ;[17] <-- release bus now
+    out     USBOUT, x3          ;[18] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
+
+
+/*****************************************************************************
+The following PHP script generates a code skeleton for the receiver routine:
+
+<?php
+
+function printCmdBuffer($thisBit)
+{
+global $cycle;
+
+    $nextBit = ($thisBit + 1) % 8;
+    $s = ob_get_contents();
+    ob_end_clean();
+    $s = str_replace("#", $thisBit, $s);
+    $s = str_replace("@", $nextBit, $s);
+    $lines = explode("\n", $s);
+    for($i = 0; $i < count($lines); $i++){
+        $s = $lines[$i];
+        if(ereg("\\[([0-9-][0-9])\\]", $s, $regs)){
+            $c = $cycle + (int)$regs[1];
+            $s = ereg_replace("\\[[0-9-][0-9]\\]", sprintf("[%02d]", $c), $s);
+        }
+        if(strlen($s) > 0)
+            echo "$s\n";
+    }
+}
+
+function printBit($isAfterSet, $bitNum)
+{
+    ob_start();
+    if($isAfterSet){
+?>
+    ifioclr USBIN, USBMINUS     ;[00] <--- sample
+    rjmp    bit#IsClr           ;[01]
+    andi    shift, ~(7 << #)    ;[02]
+    breq    unstuff#s           ;[03]
+    in      phase, USBIN        ;[04] <- phase
+    rjmp    bit@AfterSet        ;[05]
+unstuff#s:
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    andi    fix, ~(1 << #)      ;[06]
+    nop2                        ;[-1]
+    nop2                        ;[01]
+bit#IsClr:
+    ifrset  phase, USBMINUS     ;[03] check phase only if D- changed
+    lpm                         ;[04]
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    ori     shift, 1 << #       ;[06]
+<?php
+    }else{
+?>
+    ifioset USBIN, USBMINUS     ;[00] <--- sample
+    rjmp    bit#IsSet           ;[01]
+    andi    shift, ~(7 << #)    ;[02]
+    breq    unstuff#c           ;[03]
+    in      phase, USBIN        ;[04] <- phase
+    rjmp    bit@AfterClr        ;[05]
+unstuff#c:
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    andi    fix, ~(1 << #)      ;[06]
+    nop2                        ;[-1]
+    nop2                        ;[01]
+bit#IsSet:
+    ifrclr  phase, USBMINUS     ;[03] check phase only if D- changed
+    lpm                         ;[04]
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    ori     shift, 1 << #       ;[06]
+<?php
+    }
+    printCmdBuffer($bitNum);
+}
+
+$bitStartCycles = array(1, 9, 17, 26, 34, 42, 51, 59);
+for($i = 0; $i < 16; $i++){
+    $bit = $i % 8;
+    $emitClrCode = ($i + (int)($i / 8)) % 2;
+    $cycle = $bitStartCycles[$bit];
+    if($emitClrCode){
+        printf("bit%dAfterClr:\n", $bit);
+    }else{
+        printf("bit%dAfterSet:\n", $bit);
+    }
+    ob_start();
+    echo "    *****                       ;[-1]\n";
+    printCmdBuffer($bit);
+    printBit(!$emitClrCode, $bit);
+    if($i == 7)
+        echo "\n";
+}
+
+?>
+*****************************************************************************/
Index: usbdrv/usbdrvasm15.inc
===================================================================
--- usbdrv/usbdrvasm15.inc	(nonexistent)
+++ usbdrv/usbdrvasm15.inc	(working copy)
@@ -0,0 +1,422 @@
+/* Name: usbdrvasm15.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: contributed by V. Bosch
+ * Creation Date: 2007-08-06
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 15 MHz version of the asssembler part of the USB driver. It
+requires a 15 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 15 MHz -> 10.0 cycles per bit, 80.0 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+;----------------------------------------------------------------------------
+; order of registers pushed: 
+;	YL, SREG [sofError] YH, shift, x1, x2, x3, bitcnt, cnt, x4
+;----------------------------------------------------------------------------
+USB_INTR_VECTOR:              
+    push    YL                   ;2 	push only what is necessary to sync with edge ASAP
+    in      YL, SREG             ;1 
+    push    YL                   ;2 
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;
+;   sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;   sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+;-------------------------------------------------------------------------------
+; The following code results in a sampling window of < 1/4 bit 
+;	which meets the spec.
+;-------------------------------------------------------------------------------
+waitForK:			 ;- 
+    sbis    USBIN, USBMINUS      ;1 [00] <-- sample
+    rjmp    foundK               ;2 [01]
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+;------------------------------------------------------------------------------
+; {3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for 
+;	center sampling] 
+; 	we have 1 bit time for setup purposes, then sample again. 
+;	Numbers in brackets are cycles from center of first sync (double K) 
+;	bit after the instruction
+;------------------------------------------------------------------------------
+foundK:                          ;- [02]
+    lds     YL, usbInputBufOffset;2 [03+04]	tx loop
+    push    YH                   ;2 [05+06]
+    clr     YH                   ;1 [07]
+    subi    YL, lo8(-(usbRxBuf)) ;1 [08] 	[rx loop init]
+    sbci    YH, hi8(-(usbRxBuf)) ;1 [09] 	[rx loop init]
+    push    shift                ;2 [10+11]
+    ser	    shift		 ;1 [12]
+    sbis    USBIN, USBMINUS      ;1 [-1] [13] <--sample:we want two bits K (sample 1 cycle too early)
+    rjmp    haveTwoBitsK         ;2 [00] [14]
+    pop     shift                ;2 	 [15+16] undo the push from before
+    pop     YH 			 ;2 	 [17+18] undo the push from before
+    rjmp    waitForK             ;2 	 [19+20] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 20 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:			;- [01]
+    push    x1              	;2 [02+03]
+    push    x2              	;2 [04+05]
+    push    x3              	;2 [06+07]
+    push    bitcnt              ;2 [08+09]	
+    in      x1, USBIN       	;1 [00] [10] <-- sample bit 0
+    bst     x1, USBMINUS    	;1 [01]
+    bld     shift, 0        	;1 [02]
+    push    cnt             	;2 [03+04]
+    ldi     cnt, USB_BUFSIZE	;1 [05] 
+    push    x4              	;2 [06+07] tx loop
+    rjmp    rxLoop          	;2 [08]
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+unstuff0:               	;- [07] (branch taken)
+    andi    x3, ~0x01   	;1 [08]
+    mov     x1, x2      	;1 [09] x2 contains last sampled (stuffed) bit
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 1 again
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 1 
+    ori     shift, 0x01 	;1 [03] 0b00000001
+    nop				;1 [04]
+    rjmp    didUnstuff0 	;2 [05]
+;-----------------------------------------------------
+unstuff1:               	;- [05] (branch taken)
+    mov     x2, x1      	;1 [06] x1 contains last sampled (stuffed) bit
+    andi    x3, ~0x02   	;1 [07]
+    ori     shift, 0x02 	;1 [08] 0b00000010
+    nop                 	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 2 again
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 2 
+    rjmp    didUnstuff1 	;2 [03]
+;-----------------------------------------------------
+unstuff2:               	;- [05] (branch taken)
+    andi    x3, ~0x04   	;1 [06]
+    ori     shift, 0x04 	;1 [07] 0b00000100
+    mov     x1, x2      	;1 [08] x2 contains last sampled (stuffed) bit
+    nop                 	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 3
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 3 
+    rjmp    didUnstuff2 	;2 [03]
+;-----------------------------------------------------
+unstuff3:               	;- [00] [10]  (branch taken)
+    in      x2, USBIN   	;1 [01] [11] <-- sample stuffed bit 3 one cycle too late
+    andi    x2, USBMASK 	;1 [02]
+    breq    se0Hop         	;1 [03] SE0 check for stuffed bit 3 
+    andi    x3, ~0x08   	;1 [04]
+    ori     shift, 0x08 	;1 [05] 0b00001000
+    rjmp    didUnstuff3 	;2 [06]
+;----------------------------------------------------------------------------
+; extra jobs done during bit interval:
+;
+; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs], 
+; 		overflow check, jump to the head of rxLoop
+; bit 1:    SE0 check
+; bit 2:    SE0 check, recovery from delay [bit 0 tasks took too long]
+; bit 3:    SE0 check, recovery from delay [bit 0 tasks took too long]
+; bit 4:    SE0 check, none
+; bit 5:    SE0 check, none
+; bit 6:    SE0 check, none
+; bit 7:    SE0 check, reconstruct: x3 is 0 at bit locations we changed, 1 at others
+;----------------------------------------------------------------------------
+rxLoop:				;- [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 1 (or possibly bit 0 stuffed)
+    andi    x2, USBMASK 	;1 [01]
+    brne    SkipSe0Hop		;1 [02]
+se0Hop:				;- [02]
+    rjmp    se0         	;2 [03] SE0 check for bit 1 
+SkipSe0Hop:			;- [03]
+    ser     x3          	;1 [04]
+    andi    shift, 0xf9 	;1 [05] 0b11111001
+    breq    unstuff0    	;1 [06]
+didUnstuff0:			;- [06]
+    eor     x1, x2      	;1 [07]
+    bst     x1, USBMINUS	;1 [08]
+    bld     shift, 1    	;1 [09] 
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 2 (or possibly bit 1 stuffed)
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 2 
+    andi    shift, 0xf3 	;1 [03] 0b11110011
+    breq    unstuff1    	;1 [04] do remaining work for bit 1
+didUnstuff1:			;- [04]
+    eor     x2, x1      	;1 [05]
+    bst     x2, USBMINUS	;1 [06]
+    bld     shift, 2    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 3 (or possibly bit 2 stuffed)
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 3 
+    andi    shift, 0xe7 	;1 [03] 0b11100111
+    breq    unstuff2    	;1 [04]
+didUnstuff2:			;- [04]
+    eor     x1, x2      	;1 [05]
+    bst     x1, USBMINUS	;1 [06]
+    bld     shift, 3    	;1 [07]
+didUnstuff3:			;- [07]
+    andi    shift, 0xcf 	;1 [08] 0b11001111
+    breq    unstuff3    	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 4
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 4
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 4    	;1 [05]
+didUnstuff4:			;- [05]
+    andi    shift, 0x9f 	;1 [06] 0b10011111
+    breq    unstuff4    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 5
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 5
+    eor     x1, x2      	;1 [03]
+    bst     x1, USBMINUS	;1 [04]
+    bld     shift, 5    	;1 [05]
+didUnstuff5:			;- [05]
+    andi    shift, 0x3f 	;1 [06] 0b00111111
+    breq    unstuff5    	;1 [07]
+    nop2			;2 [08+09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 6
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 6
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 6   	 	;1 [05]
+didUnstuff6:			;- [05]
+    cpi     shift, 0x02 	;1 [06] 0b00000010
+    brlo    unstuff6    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 7
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 7
+    eor     x1, x2      	;1 [03]
+    bst     x1, USBMINUS	;1 [04]
+    bld     shift, 7    	;1 [05]
+didUnstuff7:			;- [05] 
+    cpi     shift, 0x04 	;1 [06] 0b00000100
+    brlo    unstuff7		;1 [07]
+    eor     x3, shift   	;1 [08] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    nop				;1 [09]
+    in      x1, USBIN   	;1 [00]	[10] <-- sample bit 0
+    st      y+, x3      	;2 [01+02] store data
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 0    	;1 [05]
+    subi    cnt, 1		;1 [06]
+    brcs    overflow	;1 [07]
+    rjmp    rxLoop		;2 [08]
+;-----------------------------------------------------
+unstuff4:               	;- [08] 
+    andi    x3, ~0x10   	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample stuffed bit 4
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 4
+    ori     shift, 0x10 	;1 [03]
+    rjmp    didUnstuff4 	;2 [04]
+;-----------------------------------------------------
+unstuff5:               	;- [08] 
+    ori     shift, 0x20 	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample stuffed bit 5
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 5
+    andi    x3, ~0x20   	;1 [03]
+    rjmp    didUnstuff5		;2 [04]
+;-----------------------------------------------------
+unstuff6:               	;- [08] 
+    andi    x3, ~0x40   	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample stuffed bit 6
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 6
+    ori     shift, 0x40 	;1 [03]
+    rjmp    didUnstuff6 	;2 [04]
+;-----------------------------------------------------
+unstuff7:			;- [08]
+    andi    x3, ~0x80   	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample stuffed bit 7
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 7
+    ori     shift, 0x80 	;1 [03]
+    rjmp    didUnstuff7 	;2 [04]
+    
+macro POP_STANDARD ; 16 cycles
+    pop     x4    
+    pop     cnt
+    pop     bitcnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;---------------------------------------------------------------------------
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+;---------------------------------------------------------------------------
+bitstuffN:		    	;- [04]
+    eor     x1, x4          	;1 [05]
+    clr	    x2			;1 [06]
+    nop				;1 [07]
+    rjmp    didStuffN       	;1 [08]
+;---------------------------------------------------------------------------    
+bitstuff6:		    	;- [04]
+    eor     x1, x4          	;1 [05]
+    clr	    x2			;1 [06]
+    rjmp    didStuff6       	;1 [07]
+;---------------------------------------------------------------------------
+bitstuff7:		    	;- [02]
+    eor     x1, x4          	;1 [03]
+    clr	    x2			;1 [06]
+    nop			    	;1 [05]
+    rjmp    didStuff7       	;1 [06]
+;---------------------------------------------------------------------------
+sendNakAndReti:			;- [-19]
+    ldi     x3, USBPID_NAK  	;1 [-18]
+    rjmp    sendX3AndReti   	;1 [-17]
+;---------------------------------------------------------------------------
+sendAckAndReti:			;- [-17]
+    ldi     cnt, USBPID_ACK 	;1 [-16]
+sendCntAndReti:			;- [-16]
+    mov     x3, cnt         	;1 [-15]
+sendX3AndReti:			;- [-15]
+    ldi     YL, 20          	;1 [-14] x3==r20 address is 20
+    ldi     YH, 0           	;1 [-13]
+    ldi     cnt, 2          	;1 [-12]
+;   rjmp    usbSendAndReti      fallthrough
+;---------------------------------------------------------------------------
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We need not to match the transfer rate exactly because the spec demands 
+;only 1.5% precision anyway.
+usbSendAndReti:             	;- [-13] 13 cycles until SOP
+    in      x2, USBDDR      	;1 [-12]
+    ori     x2, USBMASK     	;1 [-11]
+    sbi     USBOUT, USBMINUS	;2 [-09-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      	;1 [-08] port mirror for tx loop
+    out     USBDDR, x2      	;1 [-07] <- acquire bus
+	; need not init x2 (bitstuff history) because sync starts with 0 
+    ldi     x4, USBMASK     	;1 [-06] 	exor mask
+    ldi     shift, 0x80     	;1 [-05] 	sync byte is first byte sent
+    ldi     bitcnt, 6    	;1 [-04] 
+txBitLoop:		    	;- [-04] [06]
+    sbrs    shift, 0        	;1 [-03] [07]
+    eor     x1, x4          	;1 [-02] [08] 
+    ror     shift           	;1 [-01] [09]  
+didStuffN:		    	;-       [09]
+    out     USBOUT, x1      	;1 [00]  [10] <-- out N
+    ror     x2              	;1 [01]
+    cpi     x2, 0xfc        	;1 [02]
+    brcc    bitstuffN       	;1 [03]
+    dec     bitcnt          	;1 [04]
+    brne    txBitLoop       	;1 [05]
+    sbrs    shift, 0        	;1 [06]
+    eor     x1, x4          	;1 [07]
+    ror     shift           	;1 [08]
+didStuff6:			;- [08]
+    nop				;1 [09]
+    out     USBOUT, x1      	;1 [00] [10] <-- out 6
+    ror     x2              	;1 [01] 
+    cpi     x2, 0xfc        	;1 [02]
+    brcc    bitstuff6       	;1 [03]
+    sbrs    shift, 0        	;1 [04]
+    eor     x1, x4          	;1 [05]
+    ror     shift           	;1 [06]
+    ror     x2              	;1 [07]
+didStuff7:			;- [07]
+    ldi     bitcnt, 6    	;1 [08]
+    cpi     x2, 0xfc        	;1 [09]
+    out     USBOUT, x1      	;1 [00] [10] <-- out 7
+    brcc    bitstuff7       	;1 [01]
+    ld      shift, y+       	;2 [02+03]
+    dec     cnt             	;1 [04]
+    brne    txBitLoop      	;1 [05]
+makeSE0:
+    cbr     x1, USBMASK     	;1 [06] 	prepare SE0 [spec says EOP may be 19 to 23 cycles]
+    lds     x2, usbNewDeviceAddr;2 [07+08]
+    lsl     x2                  ;1 [09] we compare with left shifted address
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    out     USBOUT, x1      	;1 [00] [10] <-- out SE0-- from now 2 bits==20 cycl. until bus idle
+    subi    YL, 20 + 2          ;1 [01] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           	;1 [02]
+    breq    skipAddrAssign  	;1 [03]
+    sts     usbDeviceAddr, x2	;2 [04+05] if not skipped: SE0 is one cycle longer
+;----------------------------------------------------------------------------
+;end of usbDeviceAddress transfer
+skipAddrAssign:				;- [03/04]
+    ldi     x2, 1<<USB_INTR_PENDING_BIT	;1 [05] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)           ;1 [06]
+    ori     x1, USBIDLE     		;1 [07]
+    in      x2, USBDDR      		;1 [08]
+    cbr     x2, USBMASK     		;1 [09] set both pins to input
+    mov     x3, x1          		;1 [10]
+    cbr     x3, USBMASK     		;1 [11] configure no pullup on both pins
+    ldi     x4, 3           		;1 [12]
+se0Delay:				;- [12] [15] 
+    dec     x4              		;1 [13] [16] 
+    brne    se0Delay        		;1 [14] [17] 
+    nop2				;2      [18+19]
+    out     USBOUT, x1      		;1      [20] <--out J (idle) -- end of SE0 (EOP sig.)
+    out     USBDDR, x2      		;1      [21] <--release bus now
+    out     USBOUT, x3      		;1      [22] <--ensure no pull-up resistors are active
+    rjmp    doReturn			;1	[23]
+;---------------------------------------------------------------------------
Index: usbdrv/usbdrvasm16.inc
===================================================================
--- usbdrv/usbdrvasm16.inc	(nonexistent)
+++ usbdrv/usbdrvasm16.inc	(working copy)
@@ -0,0 +1,345 @@
+/* Name: usbdrvasm16.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-15
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 16 MHz version of the asssembler part of the USB driver. It
+requires a 16 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 16 MHz -> 10.6666666 cycles per bit, 85.333333333 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-25] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-23]
+    push    YL                  ;[-22]
+    push    YH                  ;[-20]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-15]
+    rjmp    foundK              ;[-14]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-12]
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    bitcnt              ;[-12]
+;   [---]                       ;[-11]
+    lds     YL, usbInputBufOffset;[-10]
+;   [---]                       ;[-9]
+    clr     YH                  ;[-8]
+    subi    YL, lo8(-(usbRxBuf));[-7] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-6] [rx loop init]
+    push    shift               ;[-5]
+;   [---]                       ;[-4]
+    ldi     bitcnt, 0x55        ;[-3] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-2] we want two bits K (sample 2 cycles too early)
+    rjmp    haveTwoBitsK        ;[-1]
+    pop     shift               ;[0] undo the push from before
+    pop     bitcnt              ;[2] undo the push from before
+    rjmp    waitForK            ;[4] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 21 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1              ;[1]
+    push    x2              ;[3]
+    push    x3              ;[5]
+    ldi     shift, 0        ;[7]
+    ldi     x3, 1<<4        ;[8] [rx loop init] first sample is inverse bit, compensate that
+    push    x4              ;[9] == leap
+
+    in      x1, USBIN       ;[11] <-- sample bit 0
+    andi    x1, USBMASK     ;[12]
+    bst     x1, USBMINUS    ;[13]
+    bld     shift, 7        ;[14]
+    push    cnt             ;[15]
+    ldi     leap, 0         ;[17] [rx loop init]
+    ldi     cnt, USB_BUFSIZE;[18] [rx loop init]
+    rjmp    rxbit1          ;[19] arrives at [21]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+
+; duration of unstuffing code should be 10.66666667 cycles. We adjust "leap"
+; accordingly to approximate this value in the long run.
+
+unstuff6:
+    andi    x2, USBMASK ;[03]
+    ori     x3, 1<<6    ;[04] will not be shifted any more
+    andi    shift, ~0x80;[05]
+    mov     x1, x2      ;[06] sampled bit 7 is actually re-sampled bit 6
+    subi    leap, -1    ;[07] total duration = 11 bits -> subtract 1/3
+    rjmp    didUnstuff6 ;[08]
+
+unstuff7:
+    ori     x3, 1<<7    ;[09] will not be shifted any more
+    in      x2, USBIN   ;[00] [10]  re-sample bit 7
+    andi    x2, USBMASK ;[01]
+    andi    shift, ~0x80;[02]
+    subi    leap, 2     ;[03] total duration = 10 bits -> add 1/3
+    rjmp    didUnstuff7 ;[04]
+
+unstuffEven:
+    ori     x3, 1<<6    ;[09] will be shifted right 6 times for bit 0
+    in      x1, USBIN   ;[00] [10]
+    andi    shift, ~0x80;[01]
+    andi    x1, USBMASK ;[02]
+    breq    se0         ;[03]
+    subi    leap, -1    ;[04] total duration = 11 bits -> subtract 1/3
+    nop2                ;[05]
+    rjmp    didUnstuffE ;[06]
+
+unstuffOdd:
+    ori     x3, 1<<5    ;[09] will be shifted right 4 times for bit 1
+    in      x2, USBIN   ;[00] [10]
+    andi    shift, ~0x80;[01]
+    andi    x2, USBMASK ;[02]
+    breq    se0         ;[03]
+    subi    leap, -1    ;[04] total duration = 11 bits -> subtract 1/3
+    nop2                ;[05]
+    rjmp    didUnstuffO ;[06]
+
+rxByteLoop:
+    andi    x1, USBMASK ;[03]
+    eor     x2, x1      ;[04]
+    subi    leap, 1     ;[05]
+    brpl    skipLeap    ;[06]
+    subi    leap, -3    ;1 one leap cycle every 3rd byte -> 85 + 1/3 cycles per byte
+    nop                 ;1
+skipLeap:
+    subi    x2, 1       ;[08]
+    ror     shift       ;[09]
+didUnstuff6:
+    cpi     shift, 0xfc ;[10]
+    in      x2, USBIN   ;[00] [11] <-- sample bit 7
+    brcc    unstuff6    ;[01]
+    andi    x2, USBMASK ;[02]
+    eor     x1, x2      ;[03]
+    subi    x1, 1       ;[04]
+    ror     shift       ;[05]
+didUnstuff7:
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuff7    ;[07]
+    eor     x3, shift   ;[08] reconstruct: x3 is 1 at bit locations we changed, 0 at others
+    st      y+, x3      ;[09] store data
+rxBitLoop:
+    in      x1, USBIN   ;[00] [11] <-- sample bit 0/2/4
+    andi    x1, USBMASK ;[01]
+    eor     x2, x1      ;[02]
+    andi    x3, 0x3f    ;[03] topmost two bits reserved for 6 and 7
+    subi    x2, 1       ;[04]
+    ror     shift       ;[05]
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuffEven ;[07]
+didUnstuffE:
+    lsr     x3          ;[08]
+    lsr     x3          ;[09]
+rxbit1:
+    in      x2, USBIN   ;[00] [10] <-- sample bit 1/3/5
+    andi    x2, USBMASK ;[01]
+    breq    se0         ;[02]
+    eor     x1, x2      ;[03]
+    subi    x1, 1       ;[04]
+    ror     shift       ;[05]
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuffOdd  ;[07]
+didUnstuffO:
+    subi    bitcnt, 0xab;[08] == addi 0x55, 0x55 = 0x100/3
+    brcs    rxBitLoop   ;[09]
+
+    subi    cnt, 1      ;[10]
+    in      x1, USBIN   ;[00] [11] <-- sample bit 6
+    brcc    rxByteLoop  ;[01]
+    rjmp    overflow
+
+macro POP_STANDARD ; 14 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     bitcnt
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+
+bitstuffN:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6]
+    nop2                    ;[7]
+    nop                     ;[9]
+    out     USBOUT, x1      ;[10] <-- out
+    rjmp    didStuffN       ;[0]
+    
+bitstuff6:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6] Carry is zero due to brcc
+    rol     shift           ;[7] compensate for ror shift at branch destination
+    rjmp    didStuff6       ;[8]
+
+bitstuff7:
+    ldi     x2, 0           ;[2] Carry is zero due to brcc
+    rjmp    didStuff7       ;[3]
+
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We don't match the transfer rate exactly (don't insert leap cycles every third
+;byte) because the spec demands only 1.5% precision anyway.
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x35    ;[-4] [6] binary 0011 0101
+txBitLoop:
+    sbrs    shift, 0        ;[-3] [7]
+    eor     x1, x4          ;[-2] [8]
+    out     USBOUT, x1      ;[-1] [9] <-- out N
+    ror     shift           ;[0] [10]
+    ror     x2              ;[1]
+didStuffN:
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuffN       ;[3]
+    lsr     bitcnt          ;[4]
+    brcc    txBitLoop       ;[5]
+    brne    txBitLoop       ;[6]
+
+    sbrs    shift, 0        ;[7]
+    eor     x1, x4          ;[8]
+didStuff6:
+    out     USBOUT, x1      ;[-1] [9] <-- out 6
+    ror     shift           ;[0] [10]
+    ror     x2              ;[1]
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuff6       ;[3]
+    ror     shift           ;[4]
+didStuff7:
+    ror     x2              ;[5]
+    sbrs    x2, 7           ;[6]
+    eor     x1, x4          ;[7]
+    nop                     ;[8]
+    cpi     x2, 0xfc        ;[9]
+    out     USBOUT, x1      ;[-1][10] <-- out 7
+    brcc    bitstuff7       ;[0] [11]
+    ld      shift, y+       ;[1]
+    dec     cnt             ;[3]
+    brne    txByteLoop      ;[4]
+;make SE0:
+    cbr     x1, USBMASK     ;[5] prepare SE0 [spec says EOP may be 21 to 25 cycles]
+    lds     x2, usbNewDeviceAddr;[6]
+    lsl     x2              ;[8] we compare with left shifted address
+    subi    YL, 20 + 2      ;[9] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[10]
+    out     USBOUT, x1      ;[11] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[0]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[2] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[3]
+    ori     x1, USBIDLE     ;[4]
+    in      x2, USBDDR      ;[5]
+    cbr     x2, USBMASK     ;[6] set both pins to input
+    mov     x3, x1          ;[7]
+    cbr     x3, USBMASK     ;[8] configure no pullup on both pins
+    ldi     x4, 4           ;[9]
+se0Delay:
+    dec     x4              ;[10] [13] [16] [19]
+    brne    se0Delay        ;[11] [14] [17] [20]
+    out     USBOUT, x1      ;[21] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[22] <-- release bus now
+    out     USBOUT, x3      ;[23] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: usbdrv/usbdrvasm165.inc
===================================================================
--- usbdrv/usbdrvasm165.inc	(nonexistent)
+++ usbdrv/usbdrvasm165.inc	(working copy)
@@ -0,0 +1,452 @@
+/* Name: usbdrvasm165.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-04-22
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 16.5 MHz version of the USB driver. It is intended for the
+ATTiny45 and similar controllers running on 16.5 MHz internal RC oscillator.
+This version contains a phase locked loop in the receiver routine to cope with
+slight clock rate deviations of up to +/- 1%.
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
+;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
+;max allowable interrupt latency: 59 cycles -> max 52 cycles interrupt disable
+;max stack usage: [ret(2), r0, SREG, YL, YH, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 16.5 MHz -> 11 cycles per bit
+; 16.3125 MHz < F_CPU < 16.6875 MHz (+/- 1.1%)
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], r0, YH, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-23] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-21]
+    push    YL                  ;[-20]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-15]
+    rjmp    foundK              ;[-14]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-12]
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    r0                  ;[-12]
+;   [---]                       ;[-11]
+    push    YH                  ;[-10]
+;   [---]                       ;[-9]
+    lds     YL, usbInputBufOffset;[-8]
+;   [---]                       ;[-7]
+    clr     YH                  ;[-6]
+    subi    YL, lo8(-(usbRxBuf));[-5] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-4] [rx loop init]
+    mov     r0, x2              ;[-3] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-2] we want two bits K (sample 2 cycles too early)
+    rjmp    haveTwoBitsK        ;[-1]
+    pop     YH                  ;[0] undo the pushes from before
+    pop     r0                  ;[2]
+    rjmp    waitForK            ;[4] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 22 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:               ;[1]
+    push    shift           ;[1]
+    push    x1              ;[3]
+    push    x2              ;[5]
+    push    x3              ;[7]
+    ldi     shift, 0xff     ;[9] [rx loop init]
+    ori     x3, 0xff        ;[10] [rx loop init] == ser x3, clear zero flag
+
+    in      x1, USBIN       ;[11] <-- sample bit 0
+    bst     x1, USBMINUS    ;[12]
+    bld     shift, 0        ;[13]
+    push    x4              ;[14] == phase
+;   [---]                   ;[15]
+    push    cnt             ;[16]
+;   [---]                   ;[17]
+    ldi     phase, 0        ;[18] [rx loop init]
+    ldi     cnt, USB_BUFSIZE;[19] [rx loop init]
+    rjmp    rxbit1          ;[20]
+;   [---]                   ;[21]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+/*
+byte oriented operations done during loop:
+bit 0: store data
+bit 1: SE0 check
+bit 2: overflow check
+bit 3: catch up
+bit 4: rjmp to achieve conditional jump range
+bit 5: PLL
+bit 6: catch up
+bit 7: jump, fixup bitstuff
+; 87 [+ 2] cycles
+------------------------------------------------------------------
+*/
+continueWithBit5:
+    in      x2, USBIN       ;[055] <-- bit 5
+    eor     r0, x2          ;[056]
+    or      phase, r0       ;[057]
+    sbrc    phase, USBMINUS ;[058]
+    lpm                     ;[059] optional nop3; modifies r0
+    in      phase, USBIN    ;[060] <-- phase
+    eor     x1, x2          ;[061]
+    bst     x1, USBMINUS    ;[062]
+    bld     shift, 5        ;[063]
+    andi    shift, 0x3f     ;[064]
+    in      x1, USBIN       ;[065] <-- bit 6
+    breq    unstuff5        ;[066] *** unstuff escape
+    eor     phase, x1       ;[067]
+    eor     x2, x1          ;[068]
+    bst     x2, USBMINUS    ;[069]
+    bld     shift, 6        ;[070]
+didUnstuff6:                ;[   ]
+    in      r0, USBIN       ;[071] <-- phase
+    cpi     shift, 0x02     ;[072]
+    brlo    unstuff6        ;[073] *** unstuff escape
+didUnstuff5:                ;[   ]
+    nop2                    ;[074]
+;   [---]                   ;[075]
+    in      x2, USBIN       ;[076] <-- bit 7
+    eor     x1, x2          ;[077]
+    bst     x1, USBMINUS    ;[078]
+    bld     shift, 7        ;[079]
+didUnstuff7:                ;[   ]
+    eor     r0, x2          ;[080]
+    or      phase, r0       ;[081]
+    in      r0, USBIN       ;[082] <-- phase
+    cpi     shift, 0x04     ;[083]
+    brsh    rxLoop          ;[084]
+;   [---]                   ;[085]
+unstuff7:                   ;[   ]
+    andi    x3, ~0x80       ;[085]
+    ori     shift, 0x80     ;[086]
+    in      x2, USBIN       ;[087] <-- sample stuffed bit 7
+    nop                     ;[088]
+    rjmp    didUnstuff7     ;[089]
+;   [---]                   ;[090]
+                            ;[080]
+
+unstuff5:                   ;[067]
+    eor     phase, x1       ;[068]
+    andi    x3, ~0x20       ;[069]
+    ori     shift, 0x20     ;[070]
+    in      r0, USBIN       ;[071] <-- phase
+    mov     x2, x1          ;[072]
+    nop                     ;[073]
+    nop2                    ;[074]
+;   [---]                   ;[075]
+    in      x1, USBIN       ;[076] <-- bit 6
+    eor     r0, x1          ;[077]
+    or      phase, r0       ;[078]
+    eor     x2, x1          ;[079]
+    bst     x2, USBMINUS    ;[080]
+    bld     shift, 6        ;[081] no need to check bitstuffing, we just had one
+    in      r0, USBIN       ;[082] <-- phase
+    rjmp    didUnstuff5     ;[083]
+;   [---]                   ;[084]
+                            ;[074]
+
+unstuff6:                   ;[074]
+    andi    x3, ~0x40       ;[075]
+    in      x1, USBIN       ;[076] <-- bit 6 again
+    ori     shift, 0x40     ;[077]
+    nop2                    ;[078]
+;   [---]                   ;[079]
+    rjmp    didUnstuff6     ;[080]
+;   [---]                   ;[081]
+                            ;[071]
+
+unstuff0:                   ;[013]
+    eor     r0, x2          ;[014]
+    or      phase, r0       ;[015]
+    andi    x2, USBMASK     ;[016] check for SE0
+    in      r0, USBIN       ;[017] <-- phase
+    breq    didUnstuff0     ;[018] direct jump to se0 would be too long
+    andi    x3, ~0x01       ;[019]
+    ori     shift, 0x01     ;[020]
+    mov     x1, x2          ;[021] mov existing sample
+    in      x2, USBIN       ;[022] <-- bit 1 again
+    rjmp    didUnstuff0     ;[023]
+;   [---]                   ;[024]
+                            ;[014]
+
+unstuff1:                   ;[024]
+    eor     r0, x1          ;[025]
+    or      phase, r0       ;[026]
+    andi    x3, ~0x02       ;[027]
+    in      r0, USBIN       ;[028] <-- phase
+    ori     shift, 0x02     ;[029]
+    mov     x2, x1          ;[030]
+    rjmp    didUnstuff1     ;[031]
+;   [---]                   ;[032]
+                            ;[022]
+
+unstuff2:                   ;[035]
+    eor     r0, x2          ;[036]
+    or      phase, r0       ;[037]
+    andi    x3, ~0x04       ;[038]
+    in      r0, USBIN       ;[039] <-- phase
+    ori     shift, 0x04     ;[040]
+    mov     x1, x2          ;[041]
+    rjmp    didUnstuff2     ;[042]
+;   [---]                   ;[043]
+                            ;[033]
+
+unstuff3:                   ;[043]
+    in      x2, USBIN       ;[044] <-- bit 3 again
+    eor     r0, x2          ;[045]
+    or      phase, r0       ;[046]
+    andi    x3, ~0x08       ;[047]
+    ori     shift, 0x08     ;[048]
+    nop                     ;[049]
+    in      r0, USBIN       ;[050] <-- phase
+    rjmp    didUnstuff3     ;[051]
+;   [---]                   ;[052]
+                            ;[042]
+
+unstuff4:                   ;[053]
+    andi    x3, ~0x10       ;[054]
+    in      x1, USBIN       ;[055] <-- bit 4 again
+    ori     shift, 0x10     ;[056]
+    rjmp    didUnstuff4     ;[057]
+;   [---]                   ;[058]
+                            ;[048]
+
+rxLoop:                     ;[085]
+    eor     x3, shift       ;[086] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    in      x1, USBIN       ;[000] <-- bit 0
+    st      y+, x3          ;[001]
+;   [---]                   ;[002]
+    eor     r0, x1          ;[003]
+    or      phase, r0       ;[004]
+    eor     x2, x1          ;[005]
+    in      r0, USBIN       ;[006] <-- phase
+    ser     x3              ;[007]
+    bst     x2, USBMINUS    ;[008]
+    bld     shift, 0        ;[009]
+    andi    shift, 0xf9     ;[010]
+rxbit1:                     ;[   ]
+    in      x2, USBIN       ;[011] <-- bit 1
+    breq    unstuff0        ;[012] *** unstuff escape
+    andi    x2, USBMASK     ;[013] SE0 check for bit 1
+didUnstuff0:                ;[   ] Z only set if we detected SE0 in bitstuff
+    breq    se0             ;[014]
+    eor     r0, x2          ;[015]
+    or      phase, r0       ;[016]
+    in      r0, USBIN       ;[017] <-- phase
+    eor     x1, x2          ;[018]
+    bst     x1, USBMINUS    ;[019]
+    bld     shift, 1        ;[020]
+    andi    shift, 0xf3     ;[021]
+didUnstuff1:                ;[   ]
+    in      x1, USBIN       ;[022] <-- bit 2
+    breq    unstuff1        ;[023] *** unstuff escape
+    eor     r0, x1          ;[024]
+    or      phase, r0       ;[025]
+    subi    cnt, 1          ;[026] overflow check
+    brcs    overflow        ;[027]
+    in      r0, USBIN       ;[028] <-- phase
+    eor     x2, x1          ;[029]
+    bst     x2, USBMINUS    ;[030]
+    bld     shift, 2        ;[031]
+    andi    shift, 0xe7     ;[032]
+didUnstuff2:                ;[   ]
+    in      x2, USBIN       ;[033] <-- bit 3
+    breq    unstuff2        ;[034] *** unstuff escape
+    eor     r0, x2          ;[035]
+    or      phase, r0       ;[036]
+    eor     x1, x2          ;[037]
+    bst     x1, USBMINUS    ;[038]
+    in      r0, USBIN       ;[039] <-- phase
+    bld     shift, 3        ;[040]
+    andi    shift, 0xcf     ;[041]
+didUnstuff3:                ;[   ]
+    breq    unstuff3        ;[042] *** unstuff escape
+    nop                     ;[043]
+    in      x1, USBIN       ;[044] <-- bit 4
+    eor     x2, x1          ;[045]
+    bst     x2, USBMINUS    ;[046]
+    bld     shift, 4        ;[047]
+didUnstuff4:                ;[   ]
+    eor     r0, x1          ;[048]
+    or      phase, r0       ;[049]
+    in      r0, USBIN       ;[050] <-- phase
+    andi    shift, 0x9f     ;[051]
+    breq    unstuff4        ;[052] *** unstuff escape
+    rjmp    continueWithBit5;[053]
+;   [---]                   ;[054]
+
+macro POP_STANDARD ; 16 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    pop     r0
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+
+bitstuff7:
+    eor     x1, x4          ;[4]
+    ldi     x2, 0           ;[5]
+    nop2                    ;[6] C is zero (brcc)
+    rjmp    didStuff7       ;[8]
+
+bitstuffN:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6]
+    lpm                     ;[7] 3 cycle NOP, modifies r0
+    out     USBOUT, x1      ;[10] <-- out
+    rjmp    didStuffN       ;[0]
+
+#define bitStatus   x3
+
+sendNakAndReti:
+    ldi     cnt, USBPID_NAK ;[-19]
+    rjmp    sendCntAndReti  ;[-18]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     r0, cnt         ;[-16]
+    ldi     YL, 0           ;[-15] R0 address is 0
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+    ldi     bitStatus, 0xff ;[-4] init bit loop counter, works for up to 12 bytes
+byteloop:
+bitloop:
+    sbrs    shift, 0        ;[8] [-3]
+    eor     x1, x4          ;[9] [-2]
+    out     USBOUT, x1      ;[10] [-1] <-- out
+    ror     shift           ;[0]
+    ror     x2              ;[1]
+didStuffN:
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuffN       ;[3]
+    nop                     ;[4]
+    subi    bitStatus, 37   ;[5] 256 / 7 ~=~ 37
+    brcc    bitloop         ;[6] when we leave the loop, bitStatus has almost the initial value
+    sbrs    shift, 0        ;[7]
+    eor     x1, x4          ;[8]
+    ror     shift           ;[9]
+didStuff7:
+    out     USBOUT, x1      ;[10] <-- out
+    ror     x2              ;[0]
+    cpi     x2, 0xfc        ;[1]
+    brcc    bitstuff7       ;[2]
+    ld      shift, y+       ;[3]
+    dec     cnt             ;[5]
+    brne    byteloop        ;[6]
+;make SE0:
+    cbr     x1, USBMASK     ;[7] prepare SE0 [spec says EOP may be 21 to 25 cycles]
+    lds     x2, usbNewDeviceAddr;[8]
+    lsl     x2              ;[10] we compare with left shifted address
+    out     USBOUT, x1      ;[11] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    subi    YL, 2           ;[0] Only assign address on data packets, not ACK/NAK in r0
+    sbci    YH, 0           ;[1]
+    breq    skipAddrAssign  ;[2]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[5]
+    ori     x1, USBIDLE     ;[6]
+    in      x2, USBDDR      ;[7]
+    cbr     x2, USBMASK     ;[8] set both pins to input
+    mov     x3, x1          ;[9]
+    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
+    ldi     x4, 4           ;[11]
+se0Delay:
+    dec     x4              ;[12] [15] [18] [21]
+    brne    se0Delay        ;[13] [16] [19] [22]
+    out     USBOUT, x1      ;[23] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[24] <-- release bus now
+    out     USBOUT, x3      ;[25] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
Index: usbdrv/usbdrvasm18-crc.inc
===================================================================
--- usbdrv/usbdrvasm18-crc.inc	(nonexistent)
+++ usbdrv/usbdrvasm18-crc.inc	(working copy)
@@ -0,0 +1,706 @@
+/* Name: usbdrvasm18.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Lukas Schrittwieser (based on 20 MHz usbdrvasm20.inc by Jeroen Benschop)
+ * Creation Date: 2009-01-20
+ * Tabsize: 4
+ * Copyright: (c) 2008 by Lukas Schrittwieser and OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 18 MHz version of the asssembler part of the USB driver. It
+requires a 18 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+
+;max stack usage: [ret(2), YL, SREG, YH, [sofError], bitcnt(x5), shift, x1, x2, x3, x4, cnt, ZL, ZH] = 14 bytes
+;nominal frequency: 18 MHz -> 12 cycles per bit
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+;register use in receive loop to receive the data bytes:
+; shift assembles the byte currently being received
+; x1 holds the D+ and D- line state
+; x2 holds the previous line state
+; cnt holds the number of bytes left in the receive buffer
+; x3 holds the higher crc byte (see algorithm below)
+; x4 is used as temporary register for the crc algorithm
+; x5 is used for unstuffing: when unstuffing the last received bit is inverted in shift (to prevent further
+;    unstuffing calls. In the same time the corresponding bit in x5 is cleared to mark the bit as beening iverted
+; zl lower crc value and crc table index
+; zh used for crc table accesses
+
+;--------------------------------------------------------------------------------------------------------------
+; CRC mods:
+;  table driven crc checker, Z points to table in prog space
+;   ZL is the lower crc byte, x3 is the higher crc byte
+;	x4 is used as temp register to store different results
+;	the initialization of the crc register is not 0xFFFF but 0xFE54. This is because during the receipt of the
+;	first data byte an virtual zero data byte is added to the crc register, this results in the correct initial
+;	value of 0xFFFF at beginning of the second data byte before the first data byte is added to the crc.
+;	The magic number 0xFE54 results form the crc table: At tabH[0x54] = 0xFF = crcH (required) and
+;	tabL[0x54] = 0x01  ->  crcL = 0x01 xor 0xFE = 0xFF
+;  bitcnt is renamed to x5 and is used for unstuffing purposes, the unstuffing works like in the 12MHz version
+;--------------------------------------------------------------------------------------------------------------
+; CRC algorithm:
+;	The crc register is formed by x3 (higher byte) and ZL (lower byte). The algorithm uses a 'reversed' form
+;	i.e. that it takes the least significant bit first and shifts to the right. So in fact the highest order
+;	bit seen from the polynomial devision point of view is the lsb of ZL. (If this sounds strange to you i
+;	propose a research on CRC :-) )
+;	Each data byte received is xored to ZL, the lower crc byte. This byte now builds the crc
+;	table index. Next the new high byte is loaded from the table and stored in x4 until we have space in x3
+;	(its destination).
+;	Afterwards the lower table is loaded from the table and stored in ZL (the old index is overwritten as
+;	we don't need it anymore. In fact this is a right shift by 8 bits.) Now the old crc high value is xored
+;	to ZL, this is the second shift of the old crc value. Now x4 (the temp reg) is moved to x3 and the crc
+; 	calculation is done.
+;	Prior to the first byte the two CRC register have to be initialized to 0xFFFF (as defined in usb spec)
+;	however the crc engine also runs during the receipt of the first byte, therefore x3 and zl are initialized
+;	to a magic number which results in a crc value of 0xFFFF after the first complete byte.
+;
+;	This algorithm is split into the extra cycles of the different bits:
+;	bit7:	XOR the received byte to ZL
+;	bit5:	load the new high byte to x4
+;	bit6:	load the lower xor byte from the table, xor zl and x3, store result in zl (=the new crc low value)
+;			move x4 (the new high byte) to x3, the crc value is ready
+;
+
+
+macro POP_STANDARD ; 18 cycles
+    pop		ZH
+    pop		ZL
+	pop     cnt
+    pop     x5
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     x4
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+macro CRC_CLEANUP_AND_CHECK
+	; the last byte has already been xored with the lower crc byte, we have to do the table lookup and xor
+	; x3 is the higher crc byte, zl the lower one
+	ldi		ZH, hi8(usbCrcTableHigh);[+1] get the new high byte from the table
+	lpm		x2, Z				;[+2][+3][+4]
+	ldi		ZH, hi8(usbCrcTableLow);[+5] get the new low xor byte from the table
+	lpm		ZL, Z				;[+6][+7][+8]
+	eor		ZL, x3				;[+7] xor the old high byte with the value from the table, x2:ZL now holds the crc value
+	cpi		ZL, 0x01			;[+8] if the crc is ok we have a fixed remainder value of 0xb001 in x2:ZL (see usb spec)
+	brne	ignorePacket		;[+9] detected a crc fault -> paket is ignored and retransmitted by the host
+	cpi		x2, 0xb0			;[+10]
+	brne	ignorePacket		;[+11] detected a crc fault -> paket is ignored and retransmitted by the host
+    endm
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG, YH, [sofError], x4, shift, x1, x2, x3, x5, cnt, ZL, ZH
+    push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-26]
+    push    YL                  ;[-25]
+    push    YH                  ;[-23]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-17]
+    rjmp    foundK              ;[-16]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-15]
+;{3, 5} after falling D- edge, average delay: 4 cycles
+;bit0 should be at 30  (2.5 bits) for center sampling. Currently at 4 so 26 cylces till bit 0 sample
+;use 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    x4                  ;[-14]
+;   [---]                       ;[-13]
+    lds     YL, usbInputBufOffset;[-12] used to toggle the two usb receive buffers
+;   [---]                       ;[-11]
+    clr     YH                  ;[-10]
+    subi    YL, lo8(-(usbRxBuf));[-9] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-8] [rx loop init]
+    push    shift               ;[-7]
+;   [---]                       ;[-6]
+    ldi		shift, 0x80			;[-5] the last bit is the end of byte marker for the pid receiver loop
+    clc			      	      	;[-4] the carry has to be clear for receipt of pid bit 0
+    sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
+    rjmp    haveTwoBitsK        ;[-2]
+    pop     shift               ;[-1] undo the push from before
+    pop     x4                  ;[1]
+    rjmp    waitForK            ;[3] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 24 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1                  ;[0]
+    push    x2                  ;[2]
+    push    x3                  ;[4] crc high byte
+    ldi     x2, 1<<USBPLUS      ;[6] [rx loop init] current line state is K state. D+=="1", D-=="0"
+    push    x5                  ;[7]
+    push    cnt                 ;[9]
+    ldi     cnt, USB_BUFSIZE    ;[11]
+
+
+;--------------------------------------------------------------------------------------------------------------
+; receives the pid byte
+; there is no real unstuffing algorithm implemented here as a stuffing bit is impossible in the pid byte.
+; That's because the last four bits of the byte are the inverted of the first four bits. If we detect a
+; unstuffing condition something went wrong and abort
+; shift has to be initialized to 0x80
+;--------------------------------------------------------------------------------------------------------------
+
+; pid bit 0 - used for even more register saving (we need the z pointer)
+	in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    eor		x2, x1				;[2] generate inverted of actual bit
+	sbrc	x2, USBMINUS		;[3] if the bit is set we received a zero
+	sec							;[4]
+	ror		shift				;[5] we perform no unstuffing check here as this is the first bit
+	mov		x2, x1				;[6]
+	push	ZL					;[7]
+								;[8]
+	push	ZH					;[9]
+								;[10]
+	ldi		x3, 0xFE			;[11] x3 is the high order crc value
+
+
+bitloopPid:						
+	in      x1, USBIN           ;[0] sample line state
+   	andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    breq    nse0                ;[2] both lines are low so handle se0	
+	eor		x2, x1				;[3] generate inverted of actual bit
+	sbrc	x2, USBMINUS		;[4] set the carry if we received a zero
+	sec							;[5]
+	ror		shift				;[6]
+	ldi		ZL, 0x54			;[7] ZL is the low order crc value
+	ser		x4					;[8] the is no bit stuffing check here as the pid bit can't be stuffed. if so
+								; some error occured. In this case the paket is discarded later on anyway.
+	mov		x2, x1				;[9] prepare for the next cycle
+	brcc	bitloopPid			;[10] while 0s drop out of shift we get the next bit
+	eor		x4, shift			;[11] invert all bits in shift and store result in x4
+
+;--------------------------------------------------------------------------------------------------------------
+; receives data bytes and calculates the crc
+; the last USBIN state has to be in x2
+; this is only the first half, due to branch distanc limitations the second half of the loop is near the end
+; of this asm file
+;--------------------------------------------------------------------------------------------------------------
+
+rxDataStart:
+    in      x1, USBIN           ;[0] sample line state (note: a se0 check is not useful due to bit dribbling)
+    ser		x5					;[1] prepare the unstuff marker register
+    eor		x2, x1             	;[2] generates the inverted of the actual bit
+    bst		x2, USBMINUS       	;[3] copy the bit from x2
+    bld		shift, 0	        ;[4] and store it in shift
+    mov		x2, shift	     	;[5] make a copy of shift for unstuffing check
+    andi	x2, 0xF9	      	;[6] mask the last six bits, if we got six zeros (which are six ones in fact)
+    breq	unstuff0	      	;[7] then Z is set now and we branch to the unstuffing handler
+didunstuff0:
+	subi    cnt, 1         		;[8] cannot use dec because it doesn't affect the carry flag
+    brcs    nOverflow    		;[9] Too many bytes received. Ignore packet							
+    st		Y+, x4				;[10] store the last received byte
+								;[11] st needs two cycles
+
+; bit1							
+	in		x2, USBIN			;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0 during bit 0
+    breq	nse0				;[2]
+    andi	x2, USBMASK			;[3] check se0 during bit 1
+    breq	nse0				;[4]
+	eor		x1, x2				;[5]
+    bst		x1, USBMINUS		;[6]
+    bld 	shift, 1	 		;[7]
+    mov		x1, shift			;[8]
+    andi	x1, 0xF3			;[9]
+    breq	unstuff1			;[10]
+didunstuff1:
+	nop							;[11]	
+
+; bit2
+	in      x1, USBIN           ;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0 (as there is nothing else to do here
+	breq	nOverflow	 		;[2]
+    eor		x2, x1              ;[3] generates the inverted of the actual bit
+    bst		x2, USBMINUS		;[4]
+    bld		shift, 2			;[5] store the bit
+    mov		x2, shift			;[6]
+    andi	x2, 0xE7			;[7] if we have six zeros here (which means six 1 in the stream)
+    breq	unstuff2			;[8] the next bit is a stuffing bit
+didunstuff2:
+	nop2						;[9]
+								;[10]
+	nop							;[11]					
+					
+; bit3							
+	in		x2, USBIN			;[0] sample line state
+    andi	x2, USBMASK			;[1] check for se0
+    breq	nOverflow           ;[2]
+    eor		x1, x2				;[3]
+    bst		x1, USBMINUS		;[4]
+    bld 	shift, 3	 		;[5]
+    mov		x1, shift			;[6]
+    andi	x1, 0xCF			;[7]
+    breq	unstuff3			;[8]
+didunstuff3:
+	nop							;[9]
+	rjmp 	rxDataBit4			;[10]
+								;[11]				
+
+; the avr branch instructions allow an offset of +63 insturction only, so we need this
+; 'local copy' of se0
+nse0:		
+	rjmp	se0					;[4]
+								;[5]
+; the same same as for se0 is needed for overflow and StuffErr
+nOverflow:
+stuffErr:
+	rjmp	overflow
+
+
+unstuff0:						;[8] this is the branch delay of breq unstuffX
+	andi	x1, USBMASK			;[9] do an se0 check here (if the last crc byte ends with 5 one's we might end up here
+	breq	didunstuff0			;[10] event tough the message is complete -> jump back and store the byte
+	ori		shift, 0x01			;[11] invert the last received bit to prevent furhter unstuffing
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	andi	x5, 0xFE			;[1] mark this bit as inverted (will be corrected before storing shift)
+	eor		x1, x2				;[2] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[3] mask the interesting bits
+	breq	stuffErr			;[4] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[5] the next bit expects the last state to be in x1
+	rjmp 	didunstuff0			;[6]
+								;[7] jump delay of rjmp didunstuffX	
+
+unstuff1:						;[11] this is the jump delay of breq unstuffX
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	ori		shift, 0x02			;[1] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xFD			;[2] mark this bit as inverted (will be corrected before storing shift)
+	eor		x2, x1				;[3] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[4] mask the interesting bits
+	breq	stuffErr			;[5] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[6] the next bit expects the last state to be in x2
+	nop2						;[7]
+								;[8]
+	rjmp 	didunstuff1			;[9]
+								;[10] jump delay of rjmp didunstuffX		
+
+unstuff2:						;[9] this is the jump delay of breq unstuffX
+	ori		shift, 0x04			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xFB			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff2			;[7]
+								;[8] jump delay of rjmp didunstuffX	
+
+unstuff3:						;[9] this is the jump delay of breq unstuffX
+	ori		shift, 0x08			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xF7			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff3			;[7]
+								;[8] jump delay of rjmp didunstuffX			
+
+
+
+; the include has to be here due to branch distance restirctions
+#define __USE_CRC__
+#include "asmcommon.inc"
+
+	
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+; 7.5 bit times is 90 cycles. ...there is plenty of time
+
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-6] <- acquire bus
+	ldi		x2, 0			;[-6] init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-5] exor mask
+    ldi     shift, 0x80     ;[-4] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x40    ;[-3]=[9]     binary 01000000
+txBitLoop:					; the loop sends the first 7 bits of the byte
+    sbrs    shift, 0        ;[-2]=[10] if we have to send a 1 don't change the line state
+    eor     x1, x4          ;[-1]=[11]
+    out     USBOUT, x1      ;[0]
+    ror     shift           ;[1]
+    ror     x2              ;[2] transfers the last sent bit to the stuffing history
+didStuffN:
+    nop	                    ;[3]
+    nop                     ;[4]
+    cpi     x2, 0xfc        ;[5] if we sent six consecutive ones
+    brcc    bitstuffN       ;[6]
+    lsr     bitcnt          ;[7]
+    brne    txBitLoop       ;[8] restart the loop while the 1 is still in the bitcount
+
+; transmit bit 7
+    sbrs    shift, 0        ;[9]
+    eor     x1, x4          ;[10]
+didStuff7:
+    ror     shift           ;[11]
+	out     USBOUT, x1      ;[0] transfer bit 7 to the pins
+    ror     x2              ;[1] move the bit into the stuffing history	
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuff7       ;[3]
+    ld      shift, y+       ;[4] get next byte to transmit
+    dec     cnt             ;[5] decrement byte counter
+    brne    txByteLoop      ;[7] if we have more bytes start next one
+    						;[8] branch delay
+    						
+;make SE0:
+    cbr     x1, USBMASK     ;[8] 		prepare SE0 [spec says EOP may be 25 to 30 cycles]
+    lds     x2, usbNewDeviceAddr;[9]
+    lsl     x2              ;[11] 		we compare with left shifted address
+    out     USBOUT, x1      ;[0] 		<-- out SE0 -- from now 2 bits = 24 cycles until bus idle
+    subi    YL, 20 + 2      ;[1] 		Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[2]
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[3]
+    sts     usbDeviceAddr, x2		; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[5] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[6]
+    ori     x1, USBIDLE     ;[7]
+    in      x2, USBDDR      ;[8]
+    cbr     x2, USBMASK     ;[9] set both pins to input
+    mov     x3, x1          ;[10]
+    cbr     x3, USBMASK     ;[11] configure no pullup on both pins
+    ldi     x4, 4           ;[12]
+se0Delay:
+    dec     x4              ;[13] [16] [19] [22]
+    brne    se0Delay        ;[14] [17] [20] [23]
+    out     USBOUT, x1      ;[24] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[25] <-- release bus now
+    out     USBOUT, x3      ;[26] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
+bitstuffN:
+    eor     x1, x4          ;[8] generate a zero
+    ldi     x2, 0           ;[9] reset the bit stuffing history
+    nop2                    ;[10]
+    out     USBOUT, x1      ;[0] <-- send the stuffing bit
+    rjmp    didStuffN       ;[1]
+
+bitstuff7:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6] reset bit stuffing history
+    clc						;[7] fill a zero into the shift register
+    rol     shift           ;[8] compensate for ror shift at branch destination
+    rjmp    didStuff7       ;[9]
+    						;[10] jump delay
+
+;--------------------------------------------------------------------------------------------------------------
+; receives data bytes and calculates the crc
+; second half of the data byte receiver loop
+; most parts of the crc algorithm are here
+;--------------------------------------------------------------------------------------------------------------
+
+nOverflow2:
+	rjmp overflow
+
+rxDataBit4:
+	in      x1, USBIN           ;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0
+    breq	nOverflow2			;[2]
+    eor		x2, x1              ;[3]
+    bst		x2, USBMINUS		;[4]
+    bld		shift, 4			;[5]
+    mov		x2, shift			;[6]
+    andi	x2, 0x9F			;[7]
+    breq	unstuff4			;[8]
+didunstuff4:
+	nop2						;[9][10]
+	nop							;[11]
+
+; bit5							
+	in		x2, USBIN			;[0] sample line state
+    ldi		ZH, hi8(usbCrcTableHigh);[1] use the table for the higher byte
+    eor		x1, x2				;[2]
+    bst		x1, USBMINUS		;[3]
+    bld 	shift, 5	 		;[4]
+    mov		x1, shift			;[5]
+    andi	x1, 0x3F			;[6]
+    breq	unstuff5			;[7]
+didunstuff5:
+	lpm		x4, Z				;[8] load the higher crc xor-byte and store it for later use
+								;[9] lpm needs 3 cycles
+								;[10]			
+	ldi		ZH, hi8(usbCrcTableLow);[11] load the lower crc xor byte adress
+
+; bit6	    					
+	in      x1, USBIN           ;[0] sample line state
+    eor		x2, x1              ;[1]
+    bst		x2, USBMINUS		;[2]
+    bld		shift, 6			;[3]
+    mov		x2, shift			;[4]
+    andi	x2, 0x7E			;[5]
+    breq	unstuff6			;[6]
+didunstuff6:
+	lpm		ZL, Z				;[7] load the lower xor crc byte
+								;[8] lpm needs 3 cycles
+	    						;[9]
+	eor		ZL, x3				;[10] xor the old high crc byte with the low xor-byte
+	mov		x3, x4				;[11] move the new high order crc value from temp to its destination
+			
+; bit7							
+	in		x2, USBIN			;[0] sample line state
+    eor		x1, x2				;[1]
+    bst		x1, USBMINUS		;[2]
+    bld 	shift, 7	 		;[3] now shift holds the complete but inverted data byte
+    mov		x1, shift			;[4]
+    andi	x1, 0xFC			;[5]
+    breq	unstuff7			;[6]
+didunstuff7:
+	eor		x5, shift			;[7] x5 marks all bits which have not been inverted by the unstuffing subs
+	mov		x4, x5				;[8] keep a copy of the data byte it will be stored during next bit0
+	eor		ZL, x4				;[9] feed the actual byte into the crc algorithm
+	rjmp	rxDataStart			;[10] next byte
+								;[11] during the reception of the next byte this one will be fed int the crc algorithm
+
+unstuff4:						;[9] this is the jump delay of rjmp unstuffX
+	ori		shift, 0x10			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xEF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff4			;[7]
+								;[8] jump delay of rjmp didunstuffX	
+
+unstuff5:						;[8] this is the jump delay of rjmp unstuffX
+	nop							;[9]
+	ori		shift, 0x20			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xDF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	nop							;[5]
+	rjmp 	didunstuff5			;[6]
+								;[7] jump delay of rjmp didunstuffX													
+
+unstuff6:						;[7] this is the jump delay of rjmp unstuffX
+	nop2						;[8]
+								;[9]
+	ori		shift, 0x40			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xBF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	rjmp 	didunstuff6			;[5]
+								;[6] jump delay of rjmp didunstuffX	
+
+unstuff7:						;[7] this is the jump delay of rjmp unstuffX
+	nop							;[8]
+	nop							;[9]
+	ori		shift, 0x80			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0x7F			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	rjmp 	didunstuff7			;[5]
+								;[6] jump delay of rjmp didunstuff7
+
+; local copy of the stuffErr desitnation for the second half of the receiver loop
+stuffErr2:
+	rjmp	stuffErr
+
+;--------------------------------------------------------------------------------------------------------------
+; The crc table follows. It has to be aligned to enable a fast loading of the needed bytes.
+; There are two tables of 256 entries each, the low and the high byte table.
+; Table values were generated with the following C code:
+/*
+#include <stdio.h>
+int main (int argc, char **argv)
+{
+	int i, j;
+	for (i=0; i<512; i++){
+		unsigned short crc = i & 0xff;
+		for(j=0; j<8; j++) crc = (crc >> 1) ^ ((crc & 1) ? 0xa001 : 0);
+		if((i & 7) == 0) printf("\n.byte ");
+		printf("0x%02x, ", (i > 0xff ? (crc >> 8) : crc) & 0xff);
+		if(i == 255) printf("\n");
+	}
+	return 0;
+}
+
+// Use the following algorithm to compute CRC values:
+ushort computeCrc(uchar *msg, uchar msgLen)
+{
+    uchar i;
+	ushort crc = 0xffff;
+	for(i = 0; i < msgLen; i++)
+		crc = usbCrcTable16[lo8(crc) ^ msg[i]] ^ hi8(crc);
+    return crc;
+}
+*/
+
+.balign 256
+usbCrcTableLow:	
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+
+; .balign 256
+usbCrcTableHigh:
+.byte 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2
+.byte 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04
+.byte 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E
+.byte 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8
+.byte 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A
+.byte 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC
+.byte 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6
+.byte 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10
+.byte 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32
+.byte 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4
+.byte 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE
+.byte 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38
+.byte 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA
+.byte 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C
+.byte 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26
+.byte 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0
+.byte 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62
+.byte 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4
+.byte 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE
+.byte 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68
+.byte 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA
+.byte 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C
+.byte 0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76
+.byte 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0
+.byte 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92
+.byte 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54
+.byte 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E
+.byte 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98
+.byte 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A
+.byte 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C
+.byte 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86
+.byte 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40	
+
Index: usbdrv/usbdrvasm20.inc
===================================================================
--- usbdrv/usbdrvasm20.inc	(nonexistent)
+++ usbdrv/usbdrvasm20.inc	(working copy)
@@ -0,0 +1,359 @@
+/* Name: usbdrvasm20.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Jeroen Benschop
+ * Based on usbdrvasm16.inc from Christian Starkjohann
+ * Creation Date: 2008-03-05
+ * Tabsize: 4
+ * Copyright: (c) 2008 by Jeroen Benschop and OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 20 MHz version of the asssembler part of the USB driver. It
+requires a 20 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+#define leap2   x3
+#ifdef __IAR_SYSTEMS_ASM__
+#define nextInst    $+2
+#else
+#define nextInst    .+0
+#endif
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 20 MHz -> 13.333333 cycles per bit, 106.666667 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+;register use in receive loop:
+; shift assembles the byte currently being received
+; x1 holds the D+ and D- line state
+; x2 holds the previous line state
+; x4 (leap)  is used to add a leap cycle once every three bytes received
+; X3 (leap2) is used to add a leap cycle once every three stuff bits received
+; bitcnt is used to determine when a stuff bit is due
+; cnt holds the number of bytes left in the receive buffer
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-26]
+    push    YL                  ;[-25]
+    push    YH                  ;[-23]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-19]
+    rjmp    foundK              ;[-18]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-16]
+;{3, 5} after falling D- edge, average delay: 4 cycles
+;bit0 should be at 34 for center sampling. Currently at 4 so 30 cylces till bit 0 sample
+;use 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    bitcnt              ;[-16]
+;   [---]                       ;[-15]
+    lds     YL, usbInputBufOffset;[-14]
+;   [---]                       ;[-13]
+    clr     YH                  ;[-12]
+    subi    YL, lo8(-(usbRxBuf));[-11] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-10] [rx loop init]
+    push    shift               ;[-9]
+;   [---]                       ;[-8]
+    ldi     shift,0x40          ;[-7] set msb to "1" so processing bit7 can be detected
+    nop2                        ;[-6]
+;   [---]                       ;[-5]
+    ldi     bitcnt, 5           ;[-4] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
+    rjmp    haveTwoBitsK        ;[-2]
+    pop     shift               ;[-1] undo the push from before
+    pop     bitcnt              ;[1] 
+    rjmp    waitForK            ;[3] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 27 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1                  ;[0]
+    push    x2                  ;[2]
+    push    x3                  ;[4] (leap2)
+    ldi     leap2, 0x55         ;[6] add leap cycle on 2nd,5th,8th,... stuff bit
+    push    x4                  ;[7] == leap
+    ldi     leap, 0x55          ;[9] skip leap cycle on 2nd,5th,8th,... byte received
+    push    cnt                 ;[10]
+    ldi     cnt, USB_BUFSIZE    ;[12] [rx loop init]
+    ldi     x2, 1<<USBPLUS      ;[13] current line state is K state. D+=="1", D-=="0"
+bit0:       
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    rjmp    handleBit           ;[2] make bit0 14 cycles long
+
+;----------------------------------------------------------------------------
+; Process bit7. However, bit 6 still may need unstuffing.
+;----------------------------------------------------------------------------
+
+b6checkUnstuff:
+    dec     bitcnt              ;[9]
+    breq    unstuff6            ;[10]
+bit7:
+    subi    cnt, 1              ;[11] cannot use dec becaus it does not affect the carry flag
+    brcs    overflow            ;[12] Too many bytes received. Ignore packet
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    cpse    x1, x2              ;[2] when previous line state equals current line state, handle "1"
+    rjmp    b7handle0           ;[3] when line state differs, handle "0"
+    sec                         ;[4]
+    ror     shift               ;[5] shift "1" into the data
+    st      y+, shift           ;[6] store the data into the buffer
+    ldi     shift, 0x40         ;[7] reset data for receiving the next byte
+    subi    leap, 0x55          ;[9] trick to introduce a leap cycle every 3 bytes
+    brcc    nextInst            ;[10 or 11] it will fail after 85 bytes. However low speed can only receive 11
+    dec     bitcnt              ;[11 or 12]
+    brne    bit0                ;[12 or 13]
+    ldi     x1, 1               ;[13 or 14] unstuffing bit 7
+    in      bitcnt, USBIN       ;[0] sample stuff bit
+    rjmp    unstuff             ;[1]
+
+b7handle0:
+    mov     x2,x1               ;[5] Set x2 to current line state
+    ldi     bitcnt, 6           ;[6]
+    lsr     shift               ;[7] shift "0" into the data
+    st      y+, shift           ;[8] store data into the buffer
+    ldi     shift, 0x40         ;[10] reset data for receiving the next byte
+    subi    leap, 0x55          ;[11] trick to introduce a leap cycle every 3 bytes
+    brcs    bit0                ;[12] it will fail after 85 bytes. However low speed can only receive 11
+    rjmp    bit0                ;[13]
+
+
+;----------------------------------------------------------------------------
+; Handle unstuff
+; x1==0xFF indicate unstuffing bit6
+;----------------------------------------------------------------------------
+
+unstuff6:
+    ldi     x1,0xFF             ;[12] indicate unstuffing bit 6
+    in      bitcnt, USBIN       ;[0]  sample stuff bit
+    nop                         ;[1]  fix timing
+unstuff:                        ;b0-5  b6   b7
+    mov     x2,bitcnt           ;[3]  [2]  [3]  Set x2 to match line state
+    subi    leap2, 0x55         ;[4]  [3]  [4]  delay loop
+    brcs    nextInst            ;[5]  [4]  [5]  add one cycle every three stuff bits
+    sbci    leap2,0             ;[6]  [5]  [6]
+    ldi     bitcnt,6            ;[7]  [6]  [7]  reset bit stuff counter
+    andi    x2, USBMASK         ;[8]  [7]  [8] only keep D+ and D-
+    cpi     x1,0                ;[9]  [8]  [9]
+    brmi    bit7                ;[10] [9]  [10] finished unstuffing bit6 When x1<0
+    breq    bitloop             ;[11] ---  [11] finished unstuffing bit0-5 when x1=0
+    nop                         ;---  ---  [12]
+    in      x1, USBIN           ;---  ---  [0] sample line state for bit0
+    andi    x1, USBMASK         ;---  ---  [1] filter only D+ and D- bits
+    rjmp    handleBit           ;---  ---  [2] make bit0 14 cycles long
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+bitloop:
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    breq    se0                 ;[2] both lines are low so handle se0
+handleBit:
+    cpse    x1, x2              ;[3] when previous line state equals current line state, handle "1"
+    rjmp    handle0             ;[4] when line state differs, handle "0"
+    sec                         ;[5]
+    ror     shift               ;[6] shift "1" into the data
+    brcs    b6checkUnstuff      ;[7] When after shift C is set, next bit is bit7
+    nop2                        ;[8]
+    dec     bitcnt              ;[10]
+    brne    bitloop             ;[11]
+    ldi     x1,0                ;[12] indicate unstuff for bit other than bit6 or bit7
+    in      bitcnt, USBIN       ;[0] sample stuff bit
+    rjmp    unstuff             ;[1]
+
+handle0:
+    mov     x2, x1              ;[6] Set x2 to current line state
+    ldi     bitcnt, 6           ;[7] reset unstuff counter. 
+    lsr     shift               ;[8] shift "0" into the data
+    brcs    bit7                ;[9] When after shift C is set, next bit is bit7
+    nop                         ;[10]
+    rjmp    bitloop             ;[11] 
+    
+;----------------------------------------------------------------------------
+; End of receive loop. Now start handling EOP
+;----------------------------------------------------------------------------
+
+macro POP_STANDARD ; 14 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     bitcnt
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+
+
+#include "asmcommon.inc"
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+; 7.5 bit times is 100 cycles. This implementation arrives a bit later at se0
+; then specified in the include file but there is plenty of time
+
+bitstuffN:
+    eor     x1, x4          ;[8]
+    ldi     x2, 0           ;[9]
+    nop2                    ;[10]
+    out     USBOUT, x1      ;[12] <-- out
+    rjmp    didStuffN       ;[0]
+    
+bitstuff7:
+    eor     x1, x4          ;[6]
+    ldi     x2, 0           ;[7] Carry is zero due to brcc
+    rol     shift           ;[8] compensate for ror shift at branch destination
+    nop2                    ;[9]
+    rjmp    didStuff7       ;[11]
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We don't match the transfer rate exactly (don't insert leap cycles every third
+;byte) because the spec demands only 1.5% precision anyway.
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x49    ;[-4]        [10] binary 01001001
+txBitLoop:
+    sbrs    shift, 0        ;[-3] [10]   [11]
+    eor     x1, x4          ;[-2] [11]   [12]
+    out     USBOUT, x1      ;[-1] [12]   [13]   <-- out N
+    ror     shift           ;[0]  [13]   [14]
+    ror     x2              ;[1]
+didStuffN:
+    nop2                    ;[2]
+    nop                     ;[4]
+    cpi     x2, 0xfc        ;[5]
+    brcc    bitstuffN       ;[6]
+    lsr     bitcnt          ;[7]
+    brcc    txBitLoop       ;[8]
+    brne    txBitLoop       ;[9]
+
+    sbrs    shift, 0        ;[10]
+    eor     x1, x4          ;[11]
+didStuff7:
+    out     USBOUT, x1      ;[-1] [13] <-- out 7
+    ror     shift           ;[0] [14]
+    ror     x2              ;[1]
+    nop                     ;[2]
+    cpi     x2, 0xfc        ;[3]
+    brcc    bitstuff7       ;[4]
+    ld      shift, y+       ;[5]
+    dec     cnt             ;[7]
+    brne    txByteLoop      ;[8]
+;make SE0:
+    cbr     x1, USBMASK     ;[9] prepare SE0 [spec says EOP may be 25 to 30 cycles]
+    lds     x2, usbNewDeviceAddr;[10]
+    lsl     x2              ;[12] we compare with left shifted address
+    out     USBOUT, x1      ;[13] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+    subi    YL, 20 + 2      ;[0] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[1]
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[2]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[5]
+    ori     x1, USBIDLE     ;[6]
+    in      x2, USBDDR      ;[7]
+    cbr     x2, USBMASK     ;[8] set both pins to input
+    mov     x3, x1          ;[9]
+    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
+    ldi     x4, 5           ;[11]
+se0Delay:
+    dec     x4              ;[12] [15] [18] [21] [24]
+    brne    se0Delay        ;[13] [16] [19] [22] [25]
+    out     USBOUT, x1      ;[26] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[27] <-- release bus now
+    out     USBOUT, x3      ;[28] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: usbdrv/usbportability.h
===================================================================
--- usbdrv/usbportability.h	(nonexistent)
+++ usbdrv/usbportability.h	(working copy)
@@ -0,0 +1,143 @@
+/* Name: usbportability.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-06-17
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This header is intended to contain all (or at least most of) the compiler
+and library dependent stuff. The C code is written for avr-gcc and avr-libc.
+The API of other development environments is converted to gcc's and avr-libc's
+API by means of defines.
+
+This header also contains all system includes since they depend on the
+development environment.
+
+Thanks to Oleg Semyonov for his help with the IAR tools port!
+*/
+
+#ifndef __usbportability_h_INCLUDED__
+#define __usbportability_h_INCLUDED__
+
+/* We check explicitly for IAR and CodeVision. Default is avr-gcc/avr-libc. */
+
+/* ------------------------------------------------------------------------- */
+#if defined __IAR_SYSTEMS_ICC__ || defined __IAR_SYSTEMS_ASM__  /* check for IAR */
+/* ------------------------------------------------------------------------- */
+
+#ifndef ENABLE_BIT_DEFINITIONS
+#   define ENABLE_BIT_DEFINITIONS	1   /* Enable bit definitions */
+#endif
+
+/* Include IAR headers */
+#include <ioavr.h>
+#ifndef __IAR_SYSTEMS_ASM__
+#   include <inavr.h>
+#endif
+
+#define __attribute__(arg)  /* not supported on IAR */
+
+#ifdef __IAR_SYSTEMS_ASM__
+#   define __ASSEMBLER__    /* IAR does not define standard macro for asm */
+#endif
+
+#ifdef __HAS_ELPM__
+#   define PROGMEM __farflash
+#else
+#   define PROGMEM __flash
+#endif
+
+#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+
+/* The following definitions are not needed by the driver, but may be of some
+ * help if you port a gcc based project to IAR.
+ */
+#define cli()       __disable_interrupt()
+#define sei()       __enable_interrupt()
+#define wdt_reset() __watchdog_reset()
+#define _BV(x)      (1 << (x))
+
+/* assembler compatibility macros */
+#define nop2    rjmp    $+2 /* jump to next instruction */
+#define XL      r26
+#define XH      r27
+#define YL      r28
+#define YH      r29
+#define ZL      r30
+#define ZH      r31
+#define lo8(x)  LOW(x)
+#define hi8(x)  (((x)>>8) & 0xff)   /* not HIGH to allow XLINK to make a proper range check */
+
+/* Depending on the device you use, you may get problems with the way usbdrv.h
+ * handles the differences between devices. Since IAR does not use #defines
+ * for MCU registers, we can't check for the existence of a particular
+ * register with an #ifdef. If the autodetection mechanism fails, include
+ * definitions for the required USB_INTR_* macros in your usbconfig.h. See
+ * usbconfig-prototype.h and usbdrv.h for details.
+ */
+
+/* ------------------------------------------------------------------------- */
+#elif __CODEVISIONAVR__ /* check for CodeVision AVR */
+/* ------------------------------------------------------------------------- */
+/* This port is not working (yet) */
+
+/* #define F_CPU   _MCU_CLOCK_FREQUENCY_    seems to be defined automatically */
+
+#include <io.h>
+#include <delay.h>
+
+#define __attribute__(arg)  /* not supported on IAR */
+
+#define PROGMEM                 __flash
+#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+
+#ifndef __ASSEMBLER__
+static inline void  cli(void)
+{
+    #asm("cli");
+}
+static inline void  sei(void)
+{
+    #asm("sei");
+}
+#endif
+#define _delay_ms(t)    delay_ms(t)
+#define _BV(x)          (1 << (x))
+#define USB_CFG_USE_SWITCH_STATEMENT 1  /* macro for if() cascase fails for unknown reason */
+
+#define macro   .macro
+#define endm    .endmacro
+#define nop2    rjmp    .+0 /* jump to next instruction */
+
+/* ------------------------------------------------------------------------- */
+#else   /* default development environment is avr-gcc/avr-libc */
+/* ------------------------------------------------------------------------- */
+
+#include <avr/io.h>
+#ifdef __ASSEMBLER__
+#   define _VECTOR(N)   __vector_ ## N   /* io.h does not define this for asm */
+#else
+#   include <avr/pgmspace.h>
+#endif
+
+#if USB_CFG_DRIVER_FLASH_PAGE
+#   define USB_READ_FLASH(addr)    pgm_read_byte_far(((long)USB_CFG_DRIVER_FLASH_PAGE << 16) | (long)(addr))
+#else
+#   define USB_READ_FLASH(addr)    pgm_read_byte(addr)
+#endif
+
+#define macro   .macro
+#define endm    .endm
+#define nop2    rjmp    .+0 /* jump to next instruction */
+
+#endif  /* development environment */
+
+/* for conveniecne, ensure that PRG_RDB exists */
+#ifndef PRG_RDB
+#   define PRG_RDB(addr)    USB_READ_FLASH(addr)
+#endif
+#endif  /* __usbportability_h_INCLUDED__ */
Index: vusb-20121206/Changelog.txt
===================================================================
--- vusb-20121206/Changelog.txt	(nonexistent)
+++ vusb-20121206/Changelog.txt	(working copy)
@@ -0,0 +1,329 @@
+This file documents changes in the firmware-only USB driver for atmel's AVR
+microcontrollers. New entries are always appended to the end of the file.
+Scroll down to the bottom to see the most recent changes.
+
+2005-04-01:
+  - Implemented endpoint 1 as interrupt-in endpoint.
+  - Moved all configuration options to usbconfig.h which is not part of the
+    driver.
+  - Changed interface for usbVendorSetup().
+  - Fixed compatibility with ATMega8 device.
+  - Various minor optimizations.
+
+2005-04-11:
+  - Changed interface to application: Use usbFunctionSetup(), usbFunctionRead()
+    and usbFunctionWrite() now. Added configuration options to choose which
+    of these functions to compile in.
+  - Assembler module delivers receive data non-inverted now.
+  - Made register and bit names compatible with more AVR devices.
+
+2005-05-03:
+  - Allow address of usbRxBuf on any memory page as long as the buffer does
+    not cross 256 byte page boundaries.
+  - Better device compatibility: works with Mega88 now.
+  - Code optimization in debugging module.
+  - Documentation updates.
+
+2006-01-02:
+  - Added (free) default Vendor- and Product-IDs bought from voti.nl.
+  - Added USBID-License.txt file which defines the rules for using the free
+    shared VID/PID pair.
+  - Added Readme.txt to the usbdrv directory which clarifies administrative
+    issues.
+
+2006-01-25:
+  - Added "configured state" to become more standards compliant.
+  - Added "HALT" state for interrupt endpoint.
+  - Driver passes the "USB Command Verifier" test from usb.org now.
+  - Made "serial number" a configuration option.
+  - Minor optimizations, we now recommend compiler option "-Os" for best
+    results.
+  - Added a version number to usbdrv.h
+
+2006-02-03:
+  - New configuration variable USB_BUFFER_SECTION for the memory section where
+    the USB rx buffer will go. This defaults to ".bss" if not defined. Since
+    this buffer MUST NOT cross 256 byte pages (not even touch a page at the
+    end), the user may want to pass a linker option similar to
+    "-Wl,--section-start=.mybuffer=0x800060".
+  - Provide structure for usbRequest_t.
+  - New defines for USB constants.
+  - Prepared for HID implementations.
+  - Increased data size limit for interrupt transfers to 8 bytes.
+  - New macro usbInterruptIsReady() to query interrupt buffer state.
+
+2006-02-18:
+  - Ensure that the data token which is sent as an ack to an OUT transfer is
+    always zero sized. This fixes a bug where the host reports an error after
+    sending an out transfer to the device, although all data arrived at the
+    device.
+  - Updated docs in usbdrv.h to reflect changed API in usbFunctionWrite().
+
+* Release 2006-02-20
+
+  - Give a compiler warning when compiling with debugging turned on.
+  - Added Oleg Semyonov's changes for IAR-cc compatibility.
+  - Added new (optional) functions usbDeviceConnect() and usbDeviceDisconnect()
+    (also thanks to Oleg!).
+  - Rearranged tests in usbPoll() to save a couple of instructions in the most
+    likely case that no actions are pending.
+  - We need a delay between the SET ADDRESS request until the new address
+    becomes active. This delay was handled in usbPoll() until now. Since the
+    spec says that the delay must not exceed 2ms, previous versions required
+    aggressive polling during the enumeration phase. We have now moved the
+    handling of the delay into the interrupt routine.
+  - We must not reply with NAK to a SETUP transaction. We can only achieve this
+    by making sure that the rx buffer is empty when SETUP tokens are expected.
+    We therefore don't pass zero sized data packets from the status phase of
+    a transfer to usbPoll(). This change MAY cause troubles if you rely on
+    receiving a less than 8 bytes long packet in usbFunctionWrite() to
+    identify the end of a transfer. usbFunctionWrite() will NEVER be called
+    with a zero length.
+
+* Release 2006-03-14
+
+  - Improved IAR C support: tiny memory model, more devices
+  - Added template usbconfig.h file under the name usbconfig-prototype.h
+
+* Release 2006-03-26
+
+  - Added provision for one more interrupt-in endpoint (endpoint 3).
+  - Added provision for one interrupt-out endpoint (endpoint 1).
+  - Added flowcontrol macros for USB.
+  - Added provision for custom configuration descriptor.
+  - Allow ANY two port bits for D+ and D-.
+  - Merged (optional) receive endpoint number into global usbRxToken variable.
+  - Use USB_CFG_IOPORTNAME instead of USB_CFG_IOPORT. We now construct the
+    variable name from the single port letter instead of computing the address
+    of related ports from the output-port address.
+
+* Release 2006-06-26
+
+  - Updated documentation in usbdrv.h and usbconfig-prototype.h to reflect the
+    new features.
+  - Removed "#warning" directives because IAR does not understand them. Use
+    unused static variables instead to generate a warning.
+  - Do not include <avr/io.h> when compiling with IAR.
+  - Introduced USB_CFG_DESCR_PROPS_* in usbconfig.h to configure how each
+    USB descriptor should be handled. It is now possible to provide descriptor
+    data in Flash, RAM or dynamically at runtime.
+  - STALL is now a status in usbTxLen* instead of a message. We can now conform
+    to the spec and leave the stall status pending until it is cleared.
+  - Made usbTxPacketCnt1 and usbTxPacketCnt3 public. This allows the
+    application code to reset data toggling on interrupt pipes.
+
+* Release 2006-07-18
+
+  - Added an #if !defined __ASSEMBLER__ to the warning in usbdrv.h. This fixes
+    an assembler error.
+  - usbDeviceDisconnect() takes pull-up resistor to high impedance now.
+
+* Release 2007-02-01
+
+  - Merged in some code size improvements from usbtiny (thanks to Dick
+    Streefland for these optimizations!)
+  - Special alignment requirement for usbRxBuf not required any more. Thanks
+    again to Dick Streefland for this hint!
+  - Reverted to "#warning" instead of unused static variables -- new versions
+    of IAR CC should handle this directive.
+  - Changed Open Source license to GNU GPL v2 in order to make linking against
+    other free libraries easier. We no longer require publication of the
+    circuit diagrams, but we STRONGLY encourage it. If you improve the driver
+    itself, PLEASE grant us a royalty free license to your changes for our
+    commercial license.
+
+* Release 2007-03-29
+
+  - New configuration option "USB_PUBLIC" in usbconfig.h.
+  - Set USB version number to 1.10 instead of 1.01.
+  - Code used USB_CFG_DESCR_PROPS_STRING_DEVICE and
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT inconsistently. Changed all occurrences
+    to USB_CFG_DESCR_PROPS_STRING_PRODUCT.
+  - New assembler module for 16.5 MHz RC oscillator clock with PLL in receiver
+    code.
+  - New assembler module for 16 MHz crystal.
+  - usbdrvasm.S contains common code only, clock-specific parts have been moved
+    to usbdrvasm12.S, usbdrvasm16.S and usbdrvasm165.S respectively.
+
+* Release 2007-06-25
+
+  - 16 MHz module: Do SE0 check in stuffed bits as well.
+
+* Release 2007-07-07
+
+  - Define hi8(x) for IAR compiler to limit result to 8 bits. This is necessary
+    for negative values.
+  - Added 15 MHz module contributed by V. Bosch.
+  - Interrupt vector name can now be configured. This is useful if somebody
+    wants to use a different hardware interrupt than INT0.
+
+* Release 2007-08-07
+
+  - Moved handleIn3 routine in usbdrvasm16.S so that relative jump range is
+    not exceeded.
+  - More config options: USB_RX_USER_HOOK(), USB_INITIAL_DATATOKEN,
+    USB_COUNT_SOF
+  - USB_INTR_PENDING can now be a memory address, not just I/O
+
+* Release 2007-09-19
+
+  - Split out common parts of assembler modules into separate include file
+  - Made endpoint numbers configurable so that given interface definitions
+    can be matched. See USB_CFG_EP3_NUMBER in usbconfig-prototype.h.
+  - Store endpoint number for interrupt/bulk-out so that usbFunctionWriteOut()
+    can handle any number of endpoints.
+  - Define usbDeviceConnect() and usbDeviceDisconnect() even if no
+    USB_CFG_PULLUP_IOPORTNAME is defined. Directly set D+ and D- to 0 in this
+    case.
+
+* Release 2007-12-01
+
+  - Optimize usbDeviceConnect() and usbDeviceDisconnect() for less code size
+    when USB_CFG_PULLUP_IOPORTNAME is not defined.
+
+* Release 2007-12-13
+
+  - Renamed all include-only assembler modules from *.S to *.inc so that
+    people don't add them to their project sources.
+  - Distribute leap bits in tx loop more evenly for 16 MHz module.
+  - Use "macro" and "endm" instead of ".macro" and ".endm" for IAR
+  - Avoid compiler warnings for constant expr range by casting some values in
+    USB descriptors.
+
+* Release 2008-01-21
+
+  - Fixed bug in 15 and 16 MHz module where the new address set with
+    SET_ADDRESS was already accepted at the next NAK or ACK we send, not at
+    the next data packet we send. This caused problems when the host polled
+    too fast. Thanks to Alexander Neumann for his help and patience debugging
+    this issue!
+
+* Release 2008-02-05
+
+  - Fixed bug in 16.5 MHz module where a register was used in the interrupt
+    handler before it was pushed. This bug was introduced with version
+    2007-09-19 when common parts were moved to a separate file.
+  - Optimized CRC routine (thanks to Reimar Doeffinger).
+
+* Release 2008-02-16
+
+  - Removed outdated IAR compatibility stuff (code sections).
+  - Added hook macros for USB_RESET_HOOK() and USB_SET_ADDRESS_HOOK().
+  - Added optional routine usbMeasureFrameLength() for calibration of the
+    internal RC oscillator.
+
+* Release 2008-02-28
+
+  - USB_INITIAL_DATATOKEN defaults to USBPID_DATA1 now, which means that we
+    start with sending USBPID_DATA0.
+  - Changed defaults in usbconfig-prototype.h
+  - Added free USB VID/PID pair for MIDI class devices
+  - Restructured AVR-USB as separate package, not part of PowerSwitch any more.
+
+* Release 2008-04-18
+
+  - Restructured usbdrv.c so that it is easier to read and understand.
+  - Better code optimization with gcc 4.
+  - If a second interrupt in endpoint is enabled, also add it to config
+    descriptor.
+  - Added config option for long transfers (above 254 bytes), see
+    USB_CFG_LONG_TRANSFERS in usbconfig.h.
+  - Added 20 MHz module contributed by Jeroen Benschop.
+
+* Release 2008-05-13
+
+  - Fixed bug in libs-host/hiddata.c function usbhidGetReport(): length
+    was not incremented, pointer to length was incremented instead.
+  - Added code to command line tool(s) which claims an interface. This code
+    is disabled by default, but may be necessary on newer Linux kernels.
+  - Added usbconfig.h option "USB_CFG_CHECK_DATA_TOGGLING".
+  - New header "usbportability.h" prepares ports to other development
+    environments.
+  - Long transfers (above 254 bytes) did not work when usbFunctionRead() was
+    used to supply the data. Fixed this bug. [Thanks to Alexander Neumann!]
+  - In hiddata.c (example code for sending/receiving data over HID), use
+    USB_RECIP_DEVICE instead of USB_RECIP_INTERFACE for control transfers so
+    that we need not claim the interface.
+  - in usbPoll() loop 20 times polling for RESET state instead of 10 times.
+    This accounts for the higher clock rates we now support.
+  - Added a module for 12.8 MHz RC oscillator with PLL in receiver loop.
+  - Added hook to SOF code so that oscillator can be tuned to USB frame clock.
+  - Added timeout to waitForJ loop. Helps preventing unexpected hangs.
+  - Added example code for oscillator tuning to libs-device (thanks to
+    Henrik Haftmann for the idea to this routine).
+  - Implemented option USB_CFG_SUPPRESS_INTR_CODE.
+
+* Release 2008-10-22
+
+  - Fixed libs-device/osctune.h: OSCCAL is memory address on ATMega88 and
+    similar, not offset of 0x20 needs to be added.
+  - Allow distribution under GPLv3 for those who have to link against other
+    code distributed under GPLv3.
+
+* Release 2008-11-26
+
+  - Removed libusb-win32 dependency for hid-data example in Makefile.windows.
+    It was never required and confused many people.
+  - Added extern uchar usbRxToken to usbdrv.h.
+  - Integrated a module with CRC checks at 18 MHz by Lukas Schrittwieser.
+
+* Release 2009-03-23
+
+  - Hid-mouse example used settings from hid-data example, fixed that.
+  - Renamed project to V-USB due to a trademark issue with Atmel(r).
+  - Changed CommercialLicense.txt and USBID-License.txt to make the
+    background of USB ID registration clearer.
+
+* Release 2009-04-15
+
+  - Changed CommercialLicense.txt to reflect the new range of PIDs from
+    Jason Kotzin.
+  - Removed USBID-License.txt in favor of USB-IDs-for-free.txt and
+    USB-ID-FAQ.txt
+  - Fixed a bug in the 12.8 MHz module: End Of Packet decection was made in
+    the center between bit 0 and 1 of each byte. This is where the data lines
+    are expected to change and the sampled data may therefore be nonsense.
+    We therefore check EOP ONLY if bits 0 AND 1 have both been read as 0 on D-.
+  - Fixed a bitstuffing problem in the 16 MHz module: If bit 6 was stuffed,
+    the unstuffing code in the receiver routine was 1 cycle too long. If
+    multiple bytes had the unstuffing in bit 6, the error summed up until the
+    receiver was out of sync.
+  - Included option for faster CRC routine.
+    Thanks to Slawomir Fras (BoskiDialer) for this code!
+  - Updated bits in Configuration Descriptor's bmAttributes according to
+    USB 1.1 (in particular bit 7, it is a must-be-set bit now).
+
+* Release 2009-08-22
+
+  - Moved first DBG1() after odDebugInit() in all examples.
+  - Use vector INT0_vect instead of SIG_INTERRUPT0 if defined. This makes
+    V-USB compatible with the new "p" suffix devices (e.g. ATMega328p).
+  - USB_CFG_CLOCK_KHZ setting is now required in usbconfig.h (no default any
+    more).
+  - New option USB_CFG_DRIVER_FLASH_PAGE allows boot loaders on devices with
+    more than 64 kB flash.
+  - Built-in configuration descriptor allows custom definition for second
+    endpoint now.
+
+* Release 2010-07-15
+
+  - Fixed bug in usbDriverSetup() which prevented descriptor sizes above 255
+    bytes.
+  - Avoid a compiler warning for unused parameter in usbHandleResetHook() when
+    compiler option -Wextra is enabled.
+  - Fixed wrong hex value for some IDs in USB-IDs-for-free.txt.
+  - Keep a define for USBATTR_BUSPOWER, although the flag does not exist
+    in USB 1.1 any more. Set it to 0. This is for backward compatibility.
+
+* Release 2012-01-09
+
+  - Define a separate (defined) type for usbMsgPtr so that projects using a
+    tiny memory model can define it to an 8 bit type in usbconfig.h. This
+    change also saves a couple of bytes when using a scalar 16 bit type.
+  - Inserted "const" keyword for all PROGMEM declarations because new GCC
+    requires it.
+  - Fixed problem with dependence of usbportability.h on usbconfig.h. This
+    problem occurred with IAR CC only.
+  - Prepared repository for github.com.
+
+* Release 2012-12-06
\ No newline at end of file
Index: vusb-20121206/CommercialLicense.txt
===================================================================
--- vusb-20121206/CommercialLicense.txt	(nonexistent)
+++ vusb-20121206/CommercialLicense.txt	(working copy)
@@ -0,0 +1,166 @@
+V-USB Driver Software License Agreement
+Version 2012-07-09
+
+THIS LICENSE AGREEMENT GRANTS YOU CERTAIN RIGHTS IN A SOFTWARE. YOU CAN
+ENTER INTO THIS AGREEMENT AND ACQUIRE THE RIGHTS OUTLINED BELOW BY PAYING
+THE AMOUNT ACCORDING TO SECTION 4 ("PAYMENT") TO OBJECTIVE DEVELOPMENT.
+
+
+1 DEFINITIONS
+
+1.1 "OBJECTIVE DEVELOPMENT" shall mean OBJECTIVE DEVELOPMENT Software GmbH,
+Grosse Schiffgasse 1A/7, 1020 Wien, AUSTRIA.
+
+1.2 "You" shall mean the Licensee.
+
+1.3 "V-USB" shall mean all files included in the package distributed under
+the name "vusb" by OBJECTIVE DEVELOPMENT (http://www.obdev.at/vusb/)
+unless otherwise noted. This includes the firmware-only USB device
+implementation for Atmel AVR microcontrollers, some simple device examples
+and host side software examples and libraries.
+
+
+2 LICENSE GRANTS
+
+2.1 Source Code. OBJECTIVE DEVELOPMENT shall furnish you with the source
+code of V-USB.
+
+2.2 Distribution and Use. OBJECTIVE DEVELOPMENT grants you the
+non-exclusive right to use, copy and distribute V-USB with your hardware
+product(s), restricted by the limitations in section 3 below.
+
+2.3 Modifications. OBJECTIVE DEVELOPMENT grants you the right to modify
+the source code and your copy of V-USB according to your needs.
+
+2.4 USB IDs. OBJECTIVE DEVELOPMENT furnishes you with one or two USB
+Product ID(s), sent to you in e-mail. These Product IDs are reserved
+exclusively for you. OBJECTIVE DEVELOPMENT has obtained USB Product ID
+ranges under the Vendor ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under the Vendor ID 8352 from
+Jason Kotzin (now flirc.tv, Inc.). Both owners of the Vendor IDs have
+obtained these IDs from the USB Implementers Forum, Inc. (www.usb.org).
+OBJECTIVE DEVELOPMENT disclaims all liability which might arise from the
+assignment of USB IDs.
+
+2.5 USB Certification. Although not part of this agreement, we want to make
+it clear that you cannot become USB certified when you use V-USB or a USB
+Product ID assigned by OBJECTIVE DEVELOPMENT. AVR microcontrollers don't
+meet the electrical specifications required by the USB specification and
+the USB Implementers Forum certifies only members who bought a Vendor ID of
+their own.
+
+
+3 LICENSE RESTRICTIONS
+
+3.1 Number of Units. Only one of the following three definitions is
+applicable. Which one is determined by the amount you pay to OBJECTIVE
+DEVELOPMENT, see section 4 ("Payment") below.
+
+Hobby License: You may use V-USB according to section 2 above in no more
+than 5 hardware units. These units must not be sold for profit.
+
+Entry Level License: You may use V-USB according to section 2 above in no
+more than 150 hardware units.
+
+Professional License: You may use V-USB according to section 2 above in
+any number of hardware units, except for large scale production ("unlimited
+fair use"). Quantities below 10,000 units are not considered large scale
+production. If your reach quantities which are obviously large scale
+production, you must pay a license fee of 0.10 EUR per unit for all units
+above 10,000.
+
+3.2 Rental. You may not rent, lease, or lend V-USB or otherwise encumber
+any copy of V-USB, or any of the rights granted herein.
+
+3.3 Transfer. You may not transfer your rights under this Agreement to
+another party without OBJECTIVE DEVELOPMENT's prior written consent. If
+such consent is obtained, you may permanently transfer this License to
+another party. The recipient of such transfer must agree to all terms and
+conditions of this Agreement.
+
+3.4 Reservation of Rights. OBJECTIVE DEVELOPMENT retains all rights not
+expressly granted.
+
+3.5 Non-Exclusive Rights. Your license rights under this Agreement are
+non-exclusive.
+
+3.6 Third Party Rights. This Agreement cannot grant you rights controlled
+by third parties. In particular, you are not allowed to use the USB logo or
+other trademarks owned by the USB Implementers Forum, Inc. without their
+consent. Since such consent depends on USB certification, it should be
+noted that V-USB will not pass certification because it does not
+implement checksum verification and the microcontroller ports do not meet
+the electrical specifications.
+
+
+4 PAYMENT
+
+The payment amount depends on the variation of this agreement (according to
+section 3.1) into which you want to enter. Concrete prices are listed on
+OBJECTIVE DEVELOPMENT's web site, usually at
+http://www.obdev.at/vusb/license.html. You agree to pay the amount listed
+there to OBJECTIVE DEVELOPMENT or OBJECTIVE DEVELOPMENT's payment processor
+or reseller.
+
+
+5 COPYRIGHT AND OWNERSHIP
+
+V-USB is protected by copyright laws and international copyright
+treaties, as well as other intellectual property laws and treaties. V-USB
+is licensed, not sold.
+
+
+6 TERM AND TERMINATION
+
+6.1 Term. This Agreement shall continue indefinitely. However, OBJECTIVE
+DEVELOPMENT may terminate this Agreement and revoke the granted license and
+USB-IDs if you fail to comply with any of its terms and conditions.
+
+6.2 Survival of Terms. All provisions regarding secrecy, confidentiality
+and limitation of liability shall survive termination of this agreement.
+
+
+7 DISCLAIMER OF WARRANTY AND LIABILITY
+
+LIMITED WARRANTY. V-USB IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
+KIND. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, OBJECTIVE
+DEVELOPMENT AND ITS SUPPLIERS HEREBY DISCLAIM ALL WARRANTIES, EITHER
+EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND
+NON-INFRINGEMENT, WITH REGARD TO V-USB, AND THE PROVISION OF OR FAILURE
+TO PROVIDE SUPPORT SERVICES. THIS LIMITED WARRANTY GIVES YOU SPECIFIC LEGAL
+RIGHTS. YOU MAY HAVE OTHERS, WHICH VARY FROM STATE/JURISDICTION TO
+STATE/JURISDICTION.
+
+LIMITATION OF LIABILITY. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW,
+IN NO EVENT SHALL OBJECTIVE DEVELOPMENT OR ITS SUPPLIERS BE LIABLE FOR ANY
+SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER
+(INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
+BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY
+LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE V-USB OR THE
+PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES, EVEN IF OBJECTIVE
+DEVELOPMENT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY
+CASE, OBJECTIVE DEVELOPMENT'S ENTIRE LIABILITY UNDER ANY PROVISION OF THIS
+AGREEMENT SHALL BE LIMITED TO THE AMOUNT ACTUALLY PAID BY YOU FOR V-USB.
+
+
+8 MISCELLANEOUS TERMS
+
+8.1 Marketing. OBJECTIVE DEVELOPMENT has the right to mention for marketing
+purposes that you entered into this agreement.
+
+8.2 Entire Agreement. This document represents the entire agreement between
+OBJECTIVE DEVELOPMENT and you. It may only be modified in writing signed by
+an authorized representative of both, OBJECTIVE DEVELOPMENT and you.
+
+8.3 Severability. In case a provision of these terms and conditions should
+be or become partly or entirely invalid, ineffective, or not executable,
+the validity of all other provisions shall not be affected.
+
+8.4 Applicable Law. This agreement is governed by the laws of the Republic
+of Austria.
+
+8.5 Responsible Courts. The responsible courts in Vienna/Austria will have
+exclusive jurisdiction regarding all disputes in connection with this
+agreement.
+
Index: vusb-20121206/License.txt
===================================================================
--- vusb-20121206/License.txt	(nonexistent)
+++ vusb-20121206/License.txt	(working copy)
@@ -0,0 +1,361 @@
+OBJECTIVE DEVELOPMENT GmbH's V-USB driver software is distributed under the
+terms and conditions of the GNU GPL version 2 or the GNU GPL version 3. It is
+your choice whether you apply the terms of version 2 or version 3. The full
+text of GPLv2 is included below. In addition to the requirements in the GPL,
+we STRONGLY ENCOURAGE you to do the following:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: vusb-20121206/Makefile
===================================================================
--- vusb-20121206/Makefile	(nonexistent)
+++ vusb-20121206/Makefile	(working copy)
@@ -0,0 +1,60 @@
+# Name: Makefile
+# Project: v-usb
+# Author: Christian Starkjohann
+# Creation Date: 2012-12-05
+# Tabsize: 4
+# Copyright: (c) 2012 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# This is the main Makefile. The two primary targets are "all", to build
+# everything which can be built (except tests), and "clean" to remove all
+# dependent files. In a repository clone, derived source files are generated
+# and deleted as well.
+#
+# We distinguish between repository clones and source packages by the existence
+# of make-files.sh scripts in various subdirectories.
+
+
+all:
+	if [ ! -f examples/hid-mouse/firmware/Makefile ]; then \
+		$(MAKE) files; \
+	fi
+	if [ -n "$(uname -s | grep -i mingw)" ]; then \
+		$(MAKE) windows; \
+	else \
+		$(MAKE) unix; \
+	fi
+
+clean:
+	$(MAKE) unixclean
+	if cross-make.sh --help >/dev/null 2>&1; then \
+		$(MAKE) windowsclean; \
+	fi
+	$(MAKE) filesremove
+
+
+unix unixclean:
+	target=$$(echo $@ | sed -e 's/unix//g'); \
+	find . -mindepth 3 -name Makefile -print | while read i; do \
+		dir=$$(dirname $$i); \
+		dirname=$$(basename $$dir); \
+		pushd $$dir >/dev/null; \
+		if [ "$$dirname" = firmware -a -z "$$target" ]; then \
+			if ! $(MAKE) hex; then break; fi; \
+		else \
+			if ! $(MAKE) $$target; then break; fi;\
+		fi; \
+		popd >/dev/null; \
+	done
+
+
+windows windowsclean:
+	target=$$(echo $@ | sed -e 's/windows//g'); \
+	find . -mindepth 3 -name Makefile.windows -execdir cross-make.sh $$target \; ; \
+	if [ -z "$$target" ]; then target=hex; fi; \
+	find . -mindepth 2 -name firmware -exec sh -c "cd '{}'; $(MAKE) $$target" \;
+
+files filesremove:
+	target=$$(echo $@ | sed -e 's/files//g'); \
+	find . -mindepth 2 -name make-files.sh -execdir ./make-files.sh $$target \;
+
Index: vusb-20121206/Readme.txt
===================================================================
--- vusb-20121206/Readme.txt	(nonexistent)
+++ vusb-20121206/Readme.txt	(working copy)
@@ -0,0 +1,83 @@
+This is the Readme file for V-USB and related code. V-USB is Objective
+Development's firmware-only USB driver for Atmel's(r) AVR(r) microcontrollers.
+For more information please visit http://www.obdev.at/vusb/.
+
+To avoid name confusion: This project was formerly known as AVR-USB. Due to
+a trademark issue, it was renamed to V-USB in April 2009.
+
+
+WHAT IS INCLUDED IN THIS PACKAGE?
+=================================
+This package consists of the device side USB driver firmware, library code
+for device and host and fully working examples for device and host:
+
+  Readme.txt .............. The file you are currently reading.
+  usbdrv .................. V-USB firmware, to be included in your project.
+  examples ................ Example code for device and host side.
+  libs-device ............. Useful code snippets for the device firmware.
+  libs-host ............... Useful code snippets for host-side drivers.
+  circuits ................ Example circuits using this driver.
+  Changelog.txt ........... Documentation of changes between versions.
+  License.txt ............. Free Open Source license for this package (GPL).
+  CommercialLicense.txt ... Alternative commercial license for this package.
+  USB-ID-FAQ.txt .......... General infos about USB Product- and Vendor-IDs.
+  USB-IDs-for-free.txt .... List and terms of use for free shared PIDs.
+
+Each subdirectory contains a separate Readme file which explains its
+contents. We recommend that you also read the Readme.txt file in the
+usbdrv subdirectory.
+
+
+PREREQUISITES
+=============
+The AVR code of V-USB is written in C and assembler. You need either
+avr-gcc or IAR CC to compile the project. We recommend avr-gcc because it
+is free and easily available. Gcc version 3 generates slightly more
+efficient code than version 4 for V-USB. Not every release is tested with
+the IAR compiler. Previous versions have been tested with IAR 4.10B/W32 and
+4.12A/W32 on an ATmega8 with the "small" and "tiny" memory model.
+
+Ready made avr-gcc tool chains are available for most operating systems:
+  * Windows: WinAVR http://winavr.sourceforge.net/
+  * Mac: CrossPack for AVR Development http://www.obdev.at/crosspack/
+  * Linux and other Unixes: Most free Unixes have optional packages for AVR
+    development. If not, follow the instructions at
+    http://www.nongnu.org/avr-libc/user-manual/install_tools.html
+
+Our host side examples are compiled with gcc on all platforms. Gcc is the
+default C compiler on Mac, Linux and many other Unixes. On windows, we
+recommend MinGW (http://www.mingw.org/). Use the automated MinGW installer
+for least troubles. You also need MSYS from the same site to work with
+standard Makefiles.
+
+Most examples also depend on libusb. Libusb is available from
+http://libusb.sourceforge.net/ for Unix and
+http://libusb-win32.sourceforge.net/ for Windows.
+
+
+TECHNICAL DOCUMENTATION
+=======================
+The API reference of the driver firmware can be found in usbdrv/usbdrv.h.
+Documentation for host and device library files are in the respective header
+files. For more information, see our documentation wiki at
+http://www.obdev.at/goto.php?t=vusb-wiki.
+
+See the file usbdrv/Readme.txt for more info about the driver itself.
+
+
+LICENSE
+=======
+V-USB and related code is distributed under the terms of the GNU General
+Public License (GPL) version 2 (see License.txt for details) and the GNU
+General Public License (GPL) version 3. It is your choice whether you apply
+the terms of version 2 or version 3. In addition to the terms of the GPL, we
+strongly encourage you to publish your entire project and mail OBJECTIVE
+DEVELOPMENT a link to your publication.
+
+Alternatively, we offer a commercial license without the restrictions of the
+GPL. See CommercialLicense.txt for details.
+
+
+----------------------------------------------------------------------------
+(c) 2010 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/USB-ID-FAQ.txt
===================================================================
--- vusb-20121206/USB-ID-FAQ.txt	(nonexistent)
+++ vusb-20121206/USB-ID-FAQ.txt	(working copy)
@@ -0,0 +1,149 @@
+Version 2012-07-09
+
+==========================
+WHY DO WE NEED THESE IDs?
+==========================
+
+USB is more than a low level protocol for data transport. It also defines a
+common set of requests which must be understood by all devices. And as part
+of these common requests, the specification defines data structures, the
+USB Descriptors, which are used to describe the properties of the device.
+
+From the perspective of an operating system, it is therefore possible to find
+out basic properties of a device (such as e.g. the manufacturer and the name
+of the device) without a device-specific driver. This is essential because
+the operating system can choose a driver to load based on this information
+(Plug-And-Play).
+
+Among the most important properties in the Device Descriptor are the USB
+Vendor- and Product-ID. Both are 16 bit integers. The most simple form of
+driver matching is based on these IDs. The driver announces the Vendor- and
+Product-IDs of the devices it can handle and the operating system loads the
+appropriate driver when the device is connected.
+
+It is obvious that this technique only works if the pair Vendor- plus
+Product-ID is unique: Only devices which require the same driver can have the
+same pair of IDs.
+
+
+=====================================================
+HOW DOES THE USB STANDARD ENSURE THAT IDs ARE UNIQUE?
+=====================================================
+
+Since it is so important that USB IDs are unique, the USB Implementers Forum,
+Inc. (usb.org) needs a way to enforce this legally. It is not forbidden by
+law to build a device and assign it any random numbers as IDs. Usb.org
+therefore needs an agreement to regulate the use of USB IDs. The agreement
+binds only parties who agreed to it, of course. Everybody else is free to use
+any numbers for their IDs.
+
+So how can usb.org ensure that every manufacturer of USB devices enters into
+an agreement with them? They do it via trademark licensing. Usb.org has
+registered the trademark "USB", all associated logos and related terms. If
+you want to put an USB logo on your product or claim that it is USB
+compliant, you must license these trademarks from usb.org. And this is where
+you enter into an agreement. See the "USB-IF Trademark License Agreement and
+Usage Guidelines for the USB-IF Logo" at
+http://www.usb.org/developers/logo_license/.
+
+Licensing the USB trademarks requires that you buy a USB Vendor-ID from
+usb.org (one-time fee of ca. 2,000 USD), that you become a member of usb.org
+(yearly fee of ca. 4,000 USD) and that you meet all the technical
+specifications from the USB spec.
+
+This means that most hobbyists and small companies will never be able to
+become USB compliant, just because membership is so expensive. And you can't
+be compliant with a driver based on V-USB anyway, because the AVR's port pins
+don't meet the electrical specifications for USB. So, in principle, all
+hobbyists and small companies are free to choose any random numbers for their
+IDs. They have nothing to lose...
+
+There is one exception worth noting, though: If you use a sub-component which
+implements USB, the vendor of the sub-components may guarantee USB
+compliance. This might apply to some or all of FTDI's solutions.
+
+
+=======================================================================
+WHY SHOULD YOU OBTAIN USB IDs EVEN IF YOU DON'T LICENSE USB TRADEMARKS?
+=======================================================================
+
+You have learned in the previous section that you are free to choose any
+numbers for your IDs anyway. So why not do exactly this? There is still the
+technical issue. If you choose IDs which are already in use by somebody else,
+operating systems will load the wrong drivers and your device won't work.
+Even if you choose IDs which are not currently in use, they may be in use in
+the next version of the operating system or even after an automatic update.
+
+So what you need is a pair of Vendor- and Product-IDs for which you have the
+guarantee that no USB compliant product uses them. This implies that no
+operating system will ever ship with drivers responsible for these IDs.
+
+
+==============================================
+HOW DOES OBJECTIVE DEVELOPMENT HANDLE USB IDs?
+==============================================
+
+Objective Development gives away pairs of USB-IDs with their V-USB licenses.
+In order to ensure that these IDs are unique, Objective Development has an
+agreement with the company/person who has bought the USB Vendor-ID from
+usb.org. This agreement ensures that a range of USB Product-IDs is reserved
+for assignment by Objective Development and that the owner of the Vendor-ID
+won't give it to anybody else.
+
+This means that you have to trust three parties to ensure uniqueness of
+your IDs:
+
+  - Objective Development, that they don't give the same PID to more than
+    one person.
+  - The owner of the Vendor-ID that they don't assign PIDs from the range
+    assigned to Objective Development to anybody else.
+  - Usb.org that they don't assign the same Vendor-ID a second time.
+
+
+==================================
+WHO IS THE OWNER OF THE VENDOR-ID?
+==================================
+
+Objective Development has obtained ranges of USB Product-IDs under two
+Vendor-IDs: Under Vendor-ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under Vendor-ID 8352 from Jason
+Kotzin (now flirc.tv, Inc.). Both VID owners have received their Vendor-ID
+directly from usb.org.
+
+
+=========================================================================
+CAN I USE USB-IDs FROM OBJECTIVE DEVELOPMENT WITH OTHER DRIVERS/HARDWARE?
+=========================================================================
+
+The short answer is: Yes. All you get is a guarantee that the IDs are never
+assigned to anybody else. What more do you need?
+
+
+============================
+WHAT ABOUT SHARED ID PAIRS?
+============================
+
+Objective Development has reserved some PID/VID pairs for shared use. You
+have no guarantee of uniqueness for them, except that no USB compliant device
+uses them. In order to avoid technical problems, we must ensure that all
+devices with the same pair of IDs use the same driver on kernel level. For
+details, see the file USB-IDs-for-free.txt.
+
+
+======================================================
+I HAVE HEARD THAT SUB-LICENSING OF USB-IDs IS ILLEGAL?
+======================================================
+
+A 16 bit integer number cannot be protected by copyright laws. It is not
+sufficiently complex. And since none of the parties involved entered into the
+USB-IF Trademark License Agreement, we are not bound by this agreement. So
+there is no reason why it should be illegal to sub-license USB-IDs.
+
+
+=============================================
+WHO IS LIABLE IF THERE ARE INCOMPATIBILITIES?
+=============================================
+
+Objective Development disclaims all liabilities which might arise from the
+assignment of IDs. If you guarantee product features to your customers
+without proper disclaimer, YOU are liable for that.
Index: vusb-20121206/USB-IDs-for-free.txt
===================================================================
--- vusb-20121206/USB-IDs-for-free.txt	(nonexistent)
+++ vusb-20121206/USB-IDs-for-free.txt	(working copy)
@@ -0,0 +1,154 @@
+Version 2009-08-22
+
+===========================
+FREE USB-IDs FOR SHARED USE
+===========================
+
+Objective Development has reserved a set of USB Product-IDs for use according
+to the guidelines outlined below. For more information about the concept of
+USB IDs please see the file USB-ID-FAQ.txt. Objective Development guarantees
+that the IDs listed below are not used by any USB compliant devices.
+
+
+====================
+MECHANISM OF SHARING
+====================
+
+From a technical point of view, two different devices can share the same USB
+Vendor- and Product-ID if they require the same driver on operating system
+level. We make use of this fact by assigning separate IDs for various device
+classes. On application layer, devices must be distinguished by their textual
+name or serial number. We offer separate sets of IDs for discrimination by
+textual name and for serial number.
+
+Examples for shared use of USB IDs are included with V-USB in the "examples"
+subdirectory.
+
+
+======================================
+IDs FOR DISCRIMINATION BY TEXTUAL NAME
+======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the manufacturer
+and product identification. The manufacturer identification MUST be available
+at least in USB language 0x0409 (English/US).
+
+(2) The textual manufacturer identification MUST contain either an Internet
+domain name (e.g. "mycompany.com") registered and owned by you, or an e-mail
+address under your control (e.g. "myname@gmx.net"). You can embed the domain
+name or e-mail address in any string you like, e.g.  "Objective Development
+http://www.obdev.at/vusb/".
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(4) You may choose any string for the textual product identification, as long
+as this string is unique within the scope of your textual manufacturer
+identification.
+
+(5) Application side device look-up MUST be based on the textual manufacturer
+and product identification in addition to VID/PID matching. The driver
+matching MUST be a comparison of the entire strings, NOT a sub-string match.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+Table if IDs for discrimination by textual name:
+
+PID dec (hex) | VID dec (hex) | Description of use
+==============+===============+============================================
+1500 (0x05dc) | 5824 (0x16c0) | For Vendor Class devices with libusb
+--------------+---------------+--------------------------------------------
+1503 (0x05df) | 5824 (0x16c0) | For generic HID class devices (which are
+              |               | NOT mice, keyboards or joysticks)
+--------------+---------------+--------------------------------------------
+1505 (0x05e1) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+--------------+---------------+--------------------------------------------
+1508 (0x05e4) | 5824 (0x16c0) | For MIDI class devices
+--------------+---------------+--------------------------------------------
+
+Note that Windows caches the textual product- and vendor-description for
+mice, keyboards and joysticks. Name-bsed discrimination is therefore not
+recommended for these device classes.
+
+
+=======================================
+IDs FOR DISCRIMINATION BY SERIAL NUMBER
+=======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the serial
+number, unless ONLY the operating system's default class driver is used.
+The serial number string MUST be available at least in USB language 0x0409
+(English/US).
+
+(2) The serial number MUST start with either an Internet domain name (e.g.
+"mycompany.com") registered and owned by you, or an e-mail address under your
+control (e.g. "myname@gmx.net"), both terminated with a colon (":") character.
+You MAY append any string you like for further discrimination of your devices.
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(5) Application side device look-up MUST be based on the serial number string
+in addition to VID/PID matching. The matching must start at the first
+character of the serial number string and include the colon character
+terminating your domain or e-mail address. It MAY stop anywhere after that.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+(7) If ONLY the operating system's default class driver is used, e.g. for
+mice, keyboards, joysticks, CDC or MIDI devices and no discrimination by an
+application is needed, the serial number may be omitted.
+
+
+Table if IDs for discrimination by serial number string:
+
+PID dec (hex)  | VID dec (hex) | Description of use
+===============+===============+===========================================
+10200 (0x27d8) | 5824 (0x16c0) | For Vendor Class devices with libusb
+---------------+---------------+-------------------------------------------
+10201 (0x27d9) | 5824 (0x16c0) | For generic HID class devices (which are
+               |               | NOT mice, keyboards or joysticks)
+---------------+---------------+-------------------------------------------
+10202 (0x27da) | 5824 (0x16c0) | For USB Mice
+---------------+---------------+-------------------------------------------
+10203 (0x27db) | 5824 (0x16c0) | For USB Keyboards
+---------------+---------------+-------------------------------------------
+10204 (0x27dc) | 5824 (0x16c0) | For USB Joysticks
+---------------+---------------+-------------------------------------------
+10205 (0x27dd) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+---------------+---------------+-------------------------------------------
+10206 (0x27de) | 5824 (0x16c0) | For MIDI class devices
+---------------+---------------+-------------------------------------------
+
+
+=================
+ORIGIN OF USB-IDs
+=================
+
+OBJECTIVE DEVELOPMENT Software GmbH has obtained all VID/PID pairs listed
+here from Wouter van Ooijen (see www.voti.nl) for exclusive disposition.
+Wouter van Ooijen has obtained the VID from the USB Implementers Forum, Inc.
+(see www.usb.org). The VID is registered for the company name "Van Ooijen
+Technische Informatica".
+
+
+==========
+DISCLAIMER
+==========
+
+OBJECTIVE DEVELOPMENT Software GmbH disclaims all liability for any
+problems which are caused by the shared use of these VID/PID pairs.
Index: vusb-20121206/circuits/Readme.txt
===================================================================
--- vusb-20121206/circuits/Readme.txt	(nonexistent)
+++ vusb-20121206/circuits/Readme.txt	(working copy)
@@ -0,0 +1,79 @@
+This is the Readme file for the V-USB example circuits directory.
+
+
+CIRCUITS IN THIS DIRECTORY
+==========================
+Since USB requires 3.3 V levels on D+ and D- but delivers a power supply of
+ca. 5 V, some kind of level conversion must be performed. There are several
+ways to implement this level conversion, see the example circuits below.
+
+with-vreg.png and with-vreg.sch (EAGLE schematics):
+  This circuit uses a low drop voltage regulator to reduce the USB supply to
+  3.3 V. You MUST use a low drop regulator because standard regulators such
+  as the LM317 require at least ca. 2 V drop. The advantage of this approach
+  is that it comes closest to the voltage levels required by the USB
+  specification and that the circuit is powered from a regulated supply. If
+  no USB cable is used (connector directly soldered on PCB), you can even
+  omit the 68 Ohm series resistors. The disadvantage is that you may want to
+  use other chips in your design which require 5 V. Please check that the AVR
+  used in your design allows the chosen clock rate at 3.3 V.
+
+with-zener.png and with-zener.sch (EAGLE schematics):
+  This circuit enforces lower voltage levels on D+ and D- with zener diodes.
+  The zener diodes MUST be low power / low current types to ensure that the
+  1k5 pull-up resistor on D- generates a voltage of well above 2.5 V (but
+  below 3.6 V). The advantage of this circuit is its simplicity and that the
+  circuit can be powered at 5 V (usually precise enough if the cable drop is
+  neglected). The disadvantage is that some zener diodes have a lower voltage
+  than 3 V when powered through 1k5 and the choice of components becomes
+  relevant. In addition to that, the power consumption during USB data
+  transfer is increased because the current is only limited by the 68 Ohm
+  series resistor. The zeners may even distort the signal waveforms due to
+  their capacity.
+
+with-series-diodes.png and with-series-diodes.sch (EAGLE schematics):
+  This is a simplified low-cost version of the voltage regulator approach.
+  Instead of using a voltage regulator, we reduce the voltage by the forward
+  voltage of two silicon diodes (roughly 1.4 V). This gives ca. 3.6 V which
+  is practically inside the allowed range. The big disadvantage is that the
+  supply is not regulated -- it even depends strongly on the power
+  consumption. This cannot be tolerated for analog circuits.
+
+tiny45-rc.png and tiny45-rc.sch (EAGLE schematics):
+  This is mostly an example for connecting an 8 pin device using the internal
+  RC oscillator for system clock. This example uses series diodes to limit
+  the supply, but you may choose any other method. Please note that you must
+  choose a clock rate of 12.8 or 16.5 MHz because only the receiver modules
+  for these frequencies have a PLL to allow higher clock rate tolerances.
+
+
+GENERAL DESIGN NOTES
+====================
+All examples have D+ on hardware interrupt INT0 because this is the highest
+priority interrupt on AVRs. You may use other hardware interrupts (and
+configure the options at the end of usbconfig.h accordingly) if you make sure
+that no higher priority interrupt is used.
+
+If you use USB_SOF_HOOK or USB_COUNT_SOF in usbconfig.h, you must wire D- to
+the interrupt instead. This way the interrupt is triggered on USB Start Of
+Frame pulses as well.
+
+Most examples have a 1M pull-down resistor at D+. This pull-up ensures that
+in self-powered designs no interrupts occur while USB is not connected. You
+may omit this resistor in bus-powered designs. Older examples had a pull-up
+resistor instead. This is not compatible with the zener diode approach to
+level conversion: 1M pull-up in conjunction with a 3.6 V zener diode give an
+invalid logic level.
+
+All examples with ATMega8/88/168 have D+ at port D bit 2 (because this is
+hardware interrupt 0) and D- on port D bit 4 because it is also a clock input
+for timer/counter 0. This way the firmware can easily check for activity on
+D- (USB frame pulses) by checking the counter value in regular intervals. If
+no activity is found, the firmware should (according to the USB
+specification) put the system into a low power suspend mode.
+
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/circuits/tiny45-rc.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/tiny45-rc.png
===================================================================
--- vusb-20121206/circuits/tiny45-rc.png	(nonexistent)
+++ vusb-20121206/circuits/tiny45-rc.png	(working copy)

Property changes on: vusb-20121206/circuits/tiny45-rc.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/tiny45-rc.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/tiny45-rc.sch
===================================================================
--- vusb-20121206/circuits/tiny45-rc.sch	(nonexistent)
+++ vusb-20121206/circuits/tiny45-rc.sch	(working copy)

Property changes on: vusb-20121206/circuits/tiny45-rc.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-series-diodes.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-series-diodes.png
===================================================================
--- vusb-20121206/circuits/with-series-diodes.png	(nonexistent)
+++ vusb-20121206/circuits/with-series-diodes.png	(working copy)

Property changes on: vusb-20121206/circuits/with-series-diodes.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-series-diodes.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-series-diodes.sch
===================================================================
--- vusb-20121206/circuits/with-series-diodes.sch	(nonexistent)
+++ vusb-20121206/circuits/with-series-diodes.sch	(working copy)

Property changes on: vusb-20121206/circuits/with-series-diodes.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-vreg.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-vreg.png
===================================================================
--- vusb-20121206/circuits/with-vreg.png	(nonexistent)
+++ vusb-20121206/circuits/with-vreg.png	(working copy)

Property changes on: vusb-20121206/circuits/with-vreg.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-vreg.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-vreg.sch
===================================================================
--- vusb-20121206/circuits/with-vreg.sch	(nonexistent)
+++ vusb-20121206/circuits/with-vreg.sch	(working copy)

Property changes on: vusb-20121206/circuits/with-vreg.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-zener.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-zener.png
===================================================================
--- vusb-20121206/circuits/with-zener.png	(nonexistent)
+++ vusb-20121206/circuits/with-zener.png	(working copy)

Property changes on: vusb-20121206/circuits/with-zener.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-zener.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-zener.sch
===================================================================
--- vusb-20121206/circuits/with-zener.sch	(nonexistent)
+++ vusb-20121206/circuits/with-zener.sch	(working copy)

Property changes on: vusb-20121206/circuits/with-zener.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/examples/Readme.txt
===================================================================
--- vusb-20121206/examples/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/Readme.txt	(working copy)
@@ -0,0 +1,102 @@
+This is the Readme file for the directory "examples" of V-USB, a firmware-
+only USB driver for AVR microcontrollers.
+
+WHAT IS IN THIS DIRECTORY?
+==========================
+This directory contains examples which are mostly for educational purposes.
+Examples can be device firmware only, host software only or both. Here is
+a summary:
+
+custom-class
+  A custom class device with host software based on libusb. It demonstrates
+  the straight forward way of sending small amounts of data to a device and
+  receiving data from the device. It does NOT demonstrate how to send large
+  amounts of data to the device or how to receive data generated on the fly
+  by the device (how to use usbFunctionWrite() and usbFunctionRead()). See
+  the hid-data example for how usbFunctionWrite() and usbFunctionRead() are
+  used.
+
+hid-custom-rq
+  This example implements the same functionality as the custom-class example
+  above, but declares the device as HID. This prevents the "give me a driver
+  CD" dialog on Windows. The device can still be controlled with libusb as in
+  the previous example (on Windows, the filter version of libusb-win32 must
+  be installed). In addition to the features presented in custom-class, this
+  example demonstrates how a HID class device is defined.
+
+hid-mouse
+  This example implements a mouse device. No host driver is required since
+  today's operating systems have drivers for USB mice built-in. It
+  demonstrates how a real-world HID class device is implemented and how
+  interrupt-in endpoints are used.
+
+hid-data
+  This example demonstrates how the HID class can be misused to transfer
+  arbitrary data over HID feature reports. This technique is of great value
+  on Windows because no driver DLLs are needed (the hid-custom-rq example
+  still requires the libusb-win32 DLL, although it may be in the program's
+  directory). The host side application requires no installation, it can
+  even be started directly from a CD. This example also demonstrates how
+  to transfer data using usbFunctionWrite() and usbFunctionRead().
+
+usbtool
+  This is a general purpose development and debugging tool for USB devices.
+  You can use it during development of your device to test various requests
+  without special test programs. But it is also an example how all the
+  libusb API functions are used.
+
+More information about each example can be found in the Readme file in the
+respective directory.
+
+Hardware dependencies of AVR code has been kept at a minimum. All examples
+should work on any AVR chip which has enough resources to run the driver.
+Makefile and usbconfig.h have been configured for the metaboard hardware (see
+http://www.obdev.at/goto.php?t=metaboard for details). Edit the target
+device, fuse values, clock rate and programmer in Makefile and the I/O pins
+dedicated to USB in usbconfig.h.
+
+
+WHAT IS NOT DEMONSTRATED IN THESE EXAMPLES?
+===========================================
+These examples show only the most basic functionality. More elaborate
+examples and real world applications showing more features of the driver are
+available at http://www.obdev.at/vusb/projects.html. Most of these
+features are described in our documentation wiki at
+http://www.obdev.at/goto.php?t=vusb-wiki.
+
+To mention just a few:
+
+Using RC oscillator for system clock
+  The 12.8 MHz and 16.5 MHz modules of V-USB have been designed to cope
+  with clock rate deviations up to 1%. This allows an RC oscillator to be
+  used. Since the AVR's RC oscillator has a factory precision of only 10%,
+  it must be calibrated to an external reference. The EasyLogger example
+  shows how this can be done.
+
+Dynamically generated descriptors
+  Sometimes you want to implement different typtes of USB device depending
+  on a jumper or other condition. V-USB has a very flexible interface for
+  providing USB descriptors. See AVR-Doper for how to provide descriptors
+  at runtime.
+
+Virtual COM port
+  Some people prefer a virtual serial interface to communicate with their
+  device. We strongly discourage this method because it does things
+  forbidden by the USB specification. If you still want to go this route,
+  see AVR-CDC.
+
+Implementing suspend mode
+  V-USB does not implement suspend mode. This means that the device does
+  not reduce power consumption when the host goes into sleep mode. Device
+  firmware is free to implement suspend mode, though. See USB2LPT for an
+  example.
+
+The projects mentioned above can best be found on
+
+    http://www.obdev.at/vusb/prjall.html
+
+where all projects are listed.
+
+----------------------------------------------------------------------------
+(c) 2009 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/custom-class/Readme.txt
===================================================================
--- vusb-20121206/examples/custom-class/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/custom-class/Readme.txt	(working copy)
@@ -0,0 +1,64 @@
+This is the Readme file for the custom-class example. In this example, we
+show how an LED can be controlled via USB.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example shows how small amounts of data (several bytes) can be
+transferred between the device and the host. In addition to a very basic
+USB device, it demonstrates how to build a host side driver application
+using libusb or libusb-win32. It does NOT show how usbFunctionWrite() and
+usbFunctionRead() are used. See the hid-data example if you want to learn
+about these functions.
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+Host development environment: A C compiler and libusb. See the top level
+Readme file, section Prerequisites for more information.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware. You should have wired an LED with a
+current limiting resistor of ca. 270 Ohm to a free I/O pin. Change the
+defines in main.c to match the port and bit number.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+BUILDING THE HOST SOFTWARE
+==========================
+Since the host software is based on libusb or libusb-win32, make sure that
+this library is installed. On Unix, ensure that libusb-config is in your
+search PATH. On Windows, edit Makefile.windows and set the library path
+appropriately. Then type "make" on Unix or "make -f Makefile.windows" on
+Windows to build the command line tool.
+
+
+USING THE COMMAND LINE TOOL
+===========================
+The command line tool has three valid arguments: "status" to query the
+current LED status, "on" to turn on the LED and "off" to turn it off.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/custom-class/commandline/Makefile
===================================================================
--- vusb-20121206/examples/custom-class/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = set-led
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/custom-class/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/custom-class/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/custom-class/commandline/opendevice.c
===================================================================
--- vusb-20121206/examples/custom-class/commandline/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/custom-class/commandline/opendevice.h
===================================================================
--- vusb-20121206/examples/custom-class/commandline/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/custom-class/commandline/set-led.c
===================================================================
--- vusb-20121206/examples/custom-class/commandline/set-led.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/set-led.c	(working copy)
@@ -0,0 +1,134 @@
+/* Name: set-led.c
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This is the host-side driver for the custom-class example device. It searches
+the USB for the LEDControl device and sends the requests understood by this
+device.
+This program must be linked with libusb on Unix and libusb-win32 on Windows.
+See http://libusb.sourceforge.net/ or http://libusb-win32.sourceforge.net/
+respectively.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <usb.h>        /* this is libusb */
+#include "opendevice.h" /* common code moved to separate module */
+
+#include "../firmware/requests.h"   /* custom request numbers */
+#include "../firmware/usbconfig.h"  /* device's VID/PID and names */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s on ....... turn on LED\n", name);
+    fprintf(stderr, "  %s off ...... turn off LED\n", name);
+    fprintf(stderr, "  %s status ... ask current status of LED\n", name);
+#if ENABLE_TEST
+    fprintf(stderr, "  %s test ..... run driver reliability test\n", name);
+#endif /* ENABLE_TEST */
+}
+
+int main(int argc, char **argv)
+{
+usb_dev_handle      *handle = NULL;
+const unsigned char rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char                vendor[] = {USB_CFG_VENDOR_NAME, 0}, product[] = {USB_CFG_DEVICE_NAME, 0};
+char                buffer[4];
+int                 cnt, vid, pid, isOn;
+
+    usb_init();
+    if(argc < 2){   /* we need at least one argument */
+        usage(argv[0]);
+        exit(1);
+    }
+    /* compute VID/PID from usbconfig.h so that there is a central source of information */
+    vid = rawVid[1] * 256 + rawVid[0];
+    pid = rawPid[1] * 256 + rawPid[0];
+    /* The following function is in opendevice.c: */
+    if(usbOpenDevice(&handle, vid, vendor, pid, product, NULL, NULL, NULL) != 0){
+        fprintf(stderr, "Could not find USB device \"%s\" with vid=0x%x pid=0x%x\n", product, vid, pid);
+        exit(1);
+    }
+    /* Since we use only control endpoint 0, we don't need to choose a
+     * configuration and interface. Reading device descriptor and setting a
+     * configuration and interface is done through endpoint 0 after all.
+     * However, newer versions of Linux require that we claim an interface
+     * even for endpoint 0. Enable the following code if your operating system
+     * needs it: */
+#if 0
+    int retries = 1, usbConfiguration = 1, usbInterface = 0;
+    if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+        fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+    }
+    /* now try to claim the interface and detach the kernel HID driver on
+     * Linux and other operating systems which support the call. */
+    while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+        if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+            fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+        }
+#endif
+    }
+#endif
+
+    if(strcasecmp(argv[1], "status") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_GET_STATUS, 0, 0, buffer, sizeof(buffer), 5000);
+        if(cnt < 1){
+            if(cnt < 0){
+                fprintf(stderr, "USB error: %s\n", usb_strerror());
+            }else{
+                fprintf(stderr, "only %d bytes received.\n", cnt);
+            }
+        }else{
+            printf("LED is %s\n", buffer[0] ? "on" : "off");
+        }
+    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
+        if(cnt < 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+#if ENABLE_TEST
+    }else if(strcasecmp(argv[1], "test") == 0){
+        int i;
+        srandomdev();
+        for(i = 0; i < 50000; i++){
+            int value = random() & 0xffff, index = random() & 0xffff;
+            int rxValue, rxIndex;
+            if((i+1) % 100 == 0){
+                fprintf(stderr, "\r%05d", i+1);
+                fflush(stderr);
+            }
+            cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_ECHO, value, index, buffer, sizeof(buffer), 5000);
+            if(cnt < 0){
+                fprintf(stderr, "\nUSB error in iteration %d: %s\n", i, usb_strerror());
+                break;
+            }else if(cnt != 4){
+                fprintf(stderr, "\nerror in iteration %d: %d bytes received instead of 4\n", i, cnt);
+                break;
+            }
+            rxValue = ((int)buffer[0] & 0xff) | (((int)buffer[1] & 0xff) << 8);
+            rxIndex = ((int)buffer[2] & 0xff) | (((int)buffer[3] & 0xff) << 8);
+            if(rxValue != value || rxIndex != index){
+                fprintf(stderr, "\ndata error in iteration %d:\n", i);
+                fprintf(stderr, "rxValue = 0x%04x value = 0x%04x\n", rxValue, value);
+                fprintf(stderr, "rxIndex = 0x%04x index = 0x%04x\n", rxIndex, index);
+            }
+        }
+        fprintf(stderr, "\nTest completed.\n");
+#endif /* ENABLE_TEST */
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usb_close(handle);
+    return 0;
+}
Index: vusb-20121206/examples/custom-class/firmware/Makefile
===================================================================
--- vusb-20121206/examples/custom-class/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/custom-class/firmware/main.c
===================================================================
--- vusb-20121206/examples/custom-class/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/main.c	(working copy)
@@ -0,0 +1,96 @@
+/* Name: main.c
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+We assume that an LED is connected to port B bit 0. If you connect it to a
+different port or bit, change the macros below:
+*/
+#define LED_PORT_DDR        DDRB
+#define LED_PORT_OUTPUT     PORTB
+#define LED_BIT             0
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+#include "requests.h"       /* The custom request numbers we use */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+static uchar    dataBuffer[4];  /* buffer must stay valid when usbFunctionSetup returns */
+
+    if(rq->bRequest == CUSTOM_RQ_ECHO){ /* echo -- used for reliability tests */
+        dataBuffer[0] = rq->wValue.bytes[0];
+        dataBuffer[1] = rq->wValue.bytes[1];
+        dataBuffer[2] = rq->wIndex.bytes[0];
+        dataBuffer[3] = rq->wIndex.bytes[1];
+        usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+        return 4;
+    }else if(rq->bRequest == CUSTOM_RQ_SET_STATUS){
+        if(rq->wValue.bytes[0] & 1){    /* set LED */
+            LED_PORT_OUTPUT |= _BV(LED_BIT);
+        }else{                          /* clear LED */
+            LED_PORT_OUTPUT &= ~_BV(LED_BIT);
+        }
+    }else if(rq->bRequest == CUSTOM_RQ_GET_STATUS){
+        dataBuffer[0] = ((LED_PORT_OUTPUT & _BV(LED_BIT)) != 0);
+        usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+        return 1;                       /* tell the driver to send 1 byte */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    LED_PORT_DDR |= _BV(LED_BIT);   /* make the LED bit an output */
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/custom-class/firmware/requests.h
===================================================================
--- vusb-20121206/examples/custom-class/firmware/requests.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/requests.h	(working copy)
@@ -0,0 +1,35 @@
+/* Name: requests.h
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* This header is shared between the firmware and the host software. It
+ * defines the USB request numbers (and optionally data types) used to
+ * communicate between the host and the device.
+ */
+
+#ifndef __REQUESTS_H_INCLUDED__
+#define __REQUESTS_H_INCLUDED__
+
+#define CUSTOM_RQ_ECHO          0
+/* Request that the device sends back wValue and wIndex. This is used with
+ * random data to test the reliability of the communication.
+ */
+#define CUSTOM_RQ_SET_STATUS    1
+/* Set the LED status. Control-OUT.
+ * The requested status is passed in the "wValue" field of the control
+ * transfer. No OUT data is sent. Bit 0 of the low byte of wValue controls
+ * the LED.
+ */
+
+#define CUSTOM_RQ_GET_STATUS    2
+/* Get the current LED status. Control-IN.
+ * This control transfer involves a 1 byte data phase where the device sends
+ * the current status to the host. The status is in bit 0 of the byte.
+ */
+
+#endif /* __REQUESTS_H_INCLUDED__ */
Index: vusb-20121206/examples/custom-class/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/custom-class/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    0
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdc, 0x05 /* = 0x05dc = 1500 */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'L', 'E', 'D', 'C', 'o', 'n', 't', 'r', 'o', 'l'
+#define USB_CFG_DEVICE_NAME_LEN 10
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-custom-rq/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-custom-rq/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/Readme.txt	(working copy)
@@ -0,0 +1,28 @@
+This is the Readme file for the hid-custom-rq example. This is basically the
+same as the custom-class example, except that the device conforms to the USB
+HID class.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how custom requests can be sent to devices which
+are otherwise HID compliant. This mechanism can be used to prevent the
+"driver CD" dialog on Windows and still control the device with libusb-win32.
+It can also be used to extend the functionality of the USB class, e.g. by
+setting parameters.
+
+Please note that you should install the filter version of libusb-win32 to
+take full advantage or this mode. The device driver version only has access
+to devices which have been registered for it with a *.inf file. The filter
+version has access to all devices.
+
+
+MORE INFORMATION
+================
+For information about how to build this example and how to use the command
+line tool see the Readme file in the custom-class example.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-custom-rq/commandline/Makefile
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = set-led
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-custom-rq/commandline/set-led.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/set-led.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/set-led.c	(working copy)
@@ -0,0 +1,134 @@
+/* Name: set-led.c
+ * Project: hid-custom-rq example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This is the host-side driver for the custom-class example device. It searches
+the USB for the LEDControl device and sends the requests understood by this
+device.
+This program must be linked with libusb on Unix and libusb-win32 on Windows.
+See http://libusb.sourceforge.net/ or http://libusb-win32.sourceforge.net/
+respectively.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <usb.h>        /* this is libusb */
+#include "opendevice.h" /* common code moved to separate module */
+
+#include "../firmware/requests.h"   /* custom request numbers */
+#include "../firmware/usbconfig.h"  /* device's VID/PID and names */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s on ....... turn on LED\n", name);
+    fprintf(stderr, "  %s off ...... turn off LED\n", name);
+    fprintf(stderr, "  %s status ... ask current status of LED\n", name);
+#if ENABLE_TEST
+    fprintf(stderr, "  %s test ..... run driver reliability test\n", name);
+#endif /* ENABLE_TEST */
+}
+
+int main(int argc, char **argv)
+{
+usb_dev_handle      *handle = NULL;
+const unsigned char rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char                vendor[] = {USB_CFG_VENDOR_NAME, 0}, product[] = {USB_CFG_DEVICE_NAME, 0};
+char                buffer[4];
+int                 cnt, vid, pid, isOn;
+
+    usb_init();
+    if(argc < 2){   /* we need at least one argument */
+        usage(argv[0]);
+        exit(1);
+    }
+    /* compute VID/PID from usbconfig.h so that there is a central source of information */
+    vid = rawVid[1] * 256 + rawVid[0];
+    pid = rawPid[1] * 256 + rawPid[0];
+    /* The following function is in opendevice.c: */
+    if(usbOpenDevice(&handle, vid, vendor, pid, product, NULL, NULL, NULL) != 0){
+        fprintf(stderr, "Could not find USB device \"%s\" with vid=0x%x pid=0x%x\n", product, vid, pid);
+        exit(1);
+    }
+    /* Since we use only control endpoint 0, we don't need to choose a
+     * configuration and interface. Reading device descriptor and setting a
+     * configuration and interface is done through endpoint 0 after all.
+     * However, newer versions of Linux require that we claim an interface
+     * even for endpoint 0. Enable the following code if your operating system
+     * needs it: */
+#if 0
+    int retries = 1, usbConfiguration = 1, usbInterface = 0;
+    if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+        fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+    }
+    /* now try to claim the interface and detach the kernel HID driver on
+     * Linux and other operating systems which support the call. */
+    while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+        if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+            fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+        }
+#endif
+    }
+#endif
+
+    if(strcasecmp(argv[1], "status") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_GET_STATUS, 0, 0, buffer, sizeof(buffer), 5000);
+        if(cnt < 1){
+            if(cnt < 0){
+                fprintf(stderr, "USB error: %s\n", usb_strerror());
+            }else{
+                fprintf(stderr, "only %d bytes received.\n", cnt);
+            }
+        }else{
+            printf("LED is %s\n", buffer[0] ? "on" : "off");
+        }
+    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
+        if(cnt < 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+#if ENABLE_TEST
+    }else if(strcasecmp(argv[1], "test") == 0){
+        int i;
+        srandomdev();
+        for(i = 0; i < 50000; i++){
+            int value = random() & 0xffff, index = random() & 0xffff;
+            int rxValue, rxIndex;
+            if((i+1) % 100 == 0){
+                fprintf(stderr, "\r%05d", i+1);
+                fflush(stderr);
+            }
+            cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_ECHO, value, index, buffer, sizeof(buffer), 5000);
+            if(cnt < 0){
+                fprintf(stderr, "\nUSB error in iteration %d: %s\n", i, usb_strerror());
+                break;
+            }else if(cnt != 4){
+                fprintf(stderr, "\nerror in iteration %d: %d bytes received instead of 4\n", i, cnt);
+                break;
+            }
+            rxValue = ((int)buffer[0] & 0xff) | (((int)buffer[1] & 0xff) << 8);
+            rxIndex = ((int)buffer[2] & 0xff) | (((int)buffer[3] & 0xff) << 8);
+            if(rxValue != value || rxIndex != index){
+                fprintf(stderr, "\ndata error in iteration %d:\n", i);
+                fprintf(stderr, "rxValue = 0x%04x value = 0x%04x\n", rxValue, value);
+                fprintf(stderr, "rxIndex = 0x%04x index = 0x%04x\n", rxIndex, index);
+            }
+        }
+        fprintf(stderr, "\nTest completed.\n");
+#endif /* ENABLE_TEST */
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usb_close(handle);
+    return 0;
+}
Index: vusb-20121206/examples/hid-custom-rq/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-custom-rq/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/main.c	(working copy)
@@ -0,0 +1,119 @@
+/* Name: main.c
+ * Project: hid-custom-rq example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-07
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+We assume that an LED is connected to port B bit 0. If you connect it to a
+different port or bit, change the macros below:
+*/
+#define LED_PORT_DDR        DDRB
+#define LED_PORT_OUTPUT     PORTB
+#define LED_BIT             0
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+#include "requests.h"       /* The custom request numbers we use */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[22] = {   /* USB report descriptor */
+    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
+    0x09, 0x01,                    // USAGE (Vendor Usage 1)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x09, 0x00,                    //   USAGE (Undefined)
+    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)
+    0xc0                           // END_COLLECTION
+};
+/* The descriptor above is a dummy only, it silences the drivers. The report
+ * it describes consists of one byte of undefined data.
+ * We don't transfer our data through HID reports, we use custom requests
+ * instead.
+ */
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_VENDOR){
+        DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
+        if(rq->bRequest == CUSTOM_RQ_SET_STATUS){
+            if(rq->wValue.bytes[0] & 1){    /* set LED */
+                LED_PORT_OUTPUT |= _BV(LED_BIT);
+            }else{                          /* clear LED */
+                LED_PORT_OUTPUT &= ~_BV(LED_BIT);
+            }
+        }else if(rq->bRequest == CUSTOM_RQ_GET_STATUS){
+            static uchar dataBuffer[1];     /* buffer must stay valid when usbFunctionSetup returns */
+            dataBuffer[0] = ((LED_PORT_OUTPUT & _BV(LED_BIT)) != 0);
+            usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+            return 1;                       /* tell the driver to send 1 byte */
+        }
+    }else{
+        /* calss requests USBRQ_HID_GET_REPORT and USBRQ_HID_SET_REPORT are
+         * not implemented since we never call them. The operating system
+         * won't call them either because our descriptor defines no meaning.
+         */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    LED_PORT_DDR |= _BV(LED_BIT);   /* make the LED bit an output */
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+#if 0   /* this is a bit too aggressive for a debug output */
+        DBG2(0x02, 0, 0);   /* debug output: main loop iterates */
+#endif
+        wdt_reset();
+        usbPoll();
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-custom-rq/firmware/requests.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/requests.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/requests.h	(working copy)
@@ -0,0 +1,31 @@
+/* Name: requests.h
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* This header is shared between the firmware and the host software. It
+ * defines the USB request numbers (and optionally data types) used to
+ * communicate between the host and the device.
+ */
+
+#ifndef __REQUESTS_H_INCLUDED__
+#define __REQUESTS_H_INCLUDED__
+
+#define CUSTOM_RQ_SET_STATUS    1
+/* Set the LED status. Control-OUT.
+ * The requested status is passed in the "wValue" field of the control
+ * transfer. No OUT data is sent. Bit 0 of the low byte of wValue controls
+ * the LED.
+ */
+
+#define CUSTOM_RQ_GET_STATUS    2
+/* Get the current LED status. Control-IN.
+ * This control transfer involves a 1 byte data phase where the device sends
+ * the current status to the host. The status is in bit 0 of the byte.
+ */
+
+#endif /* __REQUESTS_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdf, 0x05 /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'L', 'E', 'D', 'C', 't', 'l', 'H', 'I', 'D'
+#define USB_CFG_DEVICE_NAME_LEN 9
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    22
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-data/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-data/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-data/Readme.txt	(working copy)
@@ -0,0 +1,75 @@
+This is the Readme file for the hid-data example. In this example, we show
+how blocks of data can be exchanged with the device using only functionality
+compliant to the HID class. Since class drivers for HID are included with
+Windows, you don't need to install drivers on Windows.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how the HID class can be misused to transfer fixed
+size blocks of data (up to the driver's transfer size limit) over HID feature
+reports. This technique is of great value on Windows because no driver DLLs
+are needed (the hid-custom-rq example still requires the libusb-win32 DLL,
+although it may be in the program's directory). The host side application
+requires no installation, it can even be started directly from a CD. This
+example also demonstrates how to transfer data using usbFunctionWrite() and
+usbFunctionRead().
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+Host development environment: A C compiler and libusb on Unix. On Windows
+you need the Driver Development Kit (DDK) Instead of libusb. MinGW ships
+with a free version of the DDK.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+BUILDING THE HOST SOFTWARE
+==========================
+Make sure that you have libusb (on Unix) or the DDK (on Windows) installed.
+We recommend MinGW on Windows since it includes a free version of the DDK.
+Then change to directory "commandline" and run "make" on Unix or
+"make -f Makefile.windows" on Windows.
+
+
+USING THE COMMAND LINE TOOL
+===========================
+The device implements a data store of 128 bytes in EEPROM. You can send a
+block of 128 bytes to the device or read the block using the command line
+tool.
+
+To send a block to the device, use e.g.
+
+    hidtool write 0x01,0x02,0x03,0x04,...
+
+and to receive the block, use
+
+    hidtool read
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-data/commandline/Makefile
===================================================================
--- vusb-20121206/examples/hid-data/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/Makefile	(working copy)
@@ -0,0 +1,41 @@
+# Name: Makefile
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-11
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# Please read the definitions below and edit them as appropriate for your
+# system:
+
+# Use the following 3 lines on Unix and Mac OS X:
+USBFLAGS=   `libusb-config --cflags`
+USBLIBS=    `libusb-config --libs`
+EXE_SUFFIX=
+
+# Use the following 3 lines on Windows and comment out the 3 above:
+#USBFLAGS=
+#USBLIBS=    -lhid -lusb -lsetupapi
+#EXE_SUFFIX= .exe
+
+CC=				gcc
+CFLAGS=			-O -Wall $(USBFLAGS)
+LIBS=			$(USBLIBS)
+
+OBJ=		hidtool.o hiddata.o
+PROGRAM=	hidtool$(EXE_SUFFIX)
+
+all: $(PROGRAM)
+
+$(PROGRAM): $(OBJ)
+	$(CC) -o $(PROGRAM) $(OBJ) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f $(OBJ) $(PROGRAM)
+
+.c.o:
+	$(CC) $(ARCH_COMPILE) $(CFLAGS) -c $*.c -o $*.o
Index: vusb-20121206/examples/hid-data/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/hid-data/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-11
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS=
+USBLIBS=    -lhid -lsetupapi
+EXE_SUFFIX= .exe
Index: vusb-20121206/examples/hid-data/commandline/hiddata.c
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hiddata.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hiddata.c	(working copy)
@@ -0,0 +1,323 @@
+/* Name: hiddata.c
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include "hiddata.h"
+
+/* ######################################################################## */
+#if defined(WIN32) /* ##################################################### */
+/* ######################################################################## */
+
+#include <windows.h>
+#include <setupapi.h>
+#include "hidsdi.h"
+#include <ddk/hidpi.h>
+
+#ifdef DEBUG
+#define DEBUG_PRINT(arg)    printf arg
+#else
+#define DEBUG_PRINT(arg)
+#endif
+
+/* ------------------------------------------------------------------------ */
+
+static void convertUniToAscii(char *buffer)
+{
+unsigned short  *uni = (void *)buffer;
+char            *ascii = buffer;
+
+    while(*uni != 0){
+        if(*uni >= 256){
+            *ascii++ = '?';
+        }else{
+            *ascii++ = *uni++;
+        }
+    }
+    *ascii++ = 0;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int usesReportIDs)
+{
+GUID                                hidGuid;        /* GUID for HID driver */
+HDEVINFO                            deviceInfoList;
+SP_DEVICE_INTERFACE_DATA            deviceInfo;
+SP_DEVICE_INTERFACE_DETAIL_DATA     *deviceDetails = NULL;
+DWORD                               size;
+int                                 i, openFlag = 0;  /* may be FILE_FLAG_OVERLAPPED */
+int                                 errorCode = USBOPEN_ERR_NOTFOUND;
+HANDLE                              handle = INVALID_HANDLE_VALUE;
+HIDD_ATTRIBUTES                     deviceAttributes;
+				
+    HidD_GetHidGuid(&hidGuid);
+    deviceInfoList = SetupDiGetClassDevs(&hidGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
+    deviceInfo.cbSize = sizeof(deviceInfo);
+    for(i=0;;i++){
+        if(handle != INVALID_HANDLE_VALUE){
+            CloseHandle(handle);
+            handle = INVALID_HANDLE_VALUE;
+        }
+        if(!SetupDiEnumDeviceInterfaces(deviceInfoList, 0, &hidGuid, i, &deviceInfo))
+            break;  /* no more entries */
+        /* first do a dummy call just to determine the actual size required */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, NULL, 0, &size, NULL);
+        if(deviceDetails != NULL)
+            free(deviceDetails);
+        deviceDetails = malloc(size);
+        deviceDetails->cbSize = sizeof(*deviceDetails);
+        /* this call is for real: */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, deviceDetails, size, &size, NULL);
+        DEBUG_PRINT(("checking HID path \"%s\"\n", deviceDetails->DevicePath));
+#if 0
+        /* If we want to access a mouse our keyboard, we can only use feature
+         * requests as the device is locked by Windows. It must be opened
+         * with ACCESS_TYPE_NONE.
+         */
+        handle = CreateFile(deviceDetails->DevicePath, ACCESS_TYPE_NONE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+#endif
+        /* attempt opening for R/W -- we don't care about devices which can't be accessed */
+        handle = CreateFile(deviceDetails->DevicePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+        if(handle == INVALID_HANDLE_VALUE){
+            DEBUG_PRINT(("opening failed: %d\n", (int)GetLastError()));
+            /* errorCode = USBOPEN_ERR_ACCESS; opening will always fail for mouse -- ignore */
+            continue;
+        }
+        deviceAttributes.Size = sizeof(deviceAttributes);
+        HidD_GetAttributes(handle, &deviceAttributes);
+        DEBUG_PRINT(("device attributes: vid=%d pid=%d\n", deviceAttributes.VendorID, deviceAttributes.ProductID));
+        if(deviceAttributes.VendorID != vendor || deviceAttributes.ProductID != product)
+            continue;   /* ignore this device */
+        errorCode = USBOPEN_ERR_NOTFOUND;
+        if(vendorName != NULL && productName != NULL){
+            char    buffer[512];
+            if(!HidD_GetManufacturerString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining vendor name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("vendorName = \"%s\"\n", buffer));
+            if(strcmp(vendorName, buffer) != 0)
+                continue;
+            if(!HidD_GetProductString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining product name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("productName = \"%s\"\n", buffer));
+            if(strcmp(productName, buffer) != 0)
+                continue;
+        }
+        break;  /* we have found the device we are looking for! */
+    }
+    SetupDiDestroyDeviceInfoList(deviceInfoList);
+    if(deviceDetails != NULL)
+        free(deviceDetails);
+    if(handle != INVALID_HANDLE_VALUE){
+        *device = (usbDevice_t *)handle;
+        errorCode = 0;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------ */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    CloseHandle((HANDLE)device);
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+BOOLEAN rval;
+
+    rval = HidD_SetFeature((HANDLE)device, buffer, len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+BOOLEAN rval = 0;
+
+    buffer[0] = reportNumber;
+    rval = HidD_GetFeature((HANDLE)device, buffer, *len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+/* ######################################################################## */
+#else /* defined WIN32 #################################################### */
+/* ######################################################################## */
+
+#include <string.h>
+#include <usb.h>
+
+#define usbDevice   usb_dev_handle  /* use libusb's device structure */
+
+/* ------------------------------------------------------------------------- */
+
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_SET_REPORT    0x09
+
+#define USB_HID_REPORT_TYPE_FEATURE 3
+
+
+static int  usesReportIDs;
+
+/* ------------------------------------------------------------------------- */
+
+static int usbhidGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int _usesReportIDs)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+static int          didUsbInit = 0;
+
+    if(!didUsbInit){
+        usb_init();
+        didUsbInit = 1;
+    }
+    usb_find_busses();
+    usb_find_devices();
+    for(bus=usb_get_busses(); bus; bus=bus->next){
+        for(dev=bus->devices; dev; dev=dev->next){
+            if(dev->descriptor.idVendor == vendor && dev->descriptor.idProduct == product){
+                char    string[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    fprintf(stderr, "Warning: cannot open USB device: %s\n", usb_strerror());
+                    continue;
+                }
+                if(vendorName == NULL && productName == NULL){  /* name does not matter */
+                    break;
+                }
+                /* now check whether the names match: */
+                len = usbhidGetStringAscii(handle, dev->descriptor.iManufacturer, string, sizeof(string));
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_IO;
+                    fprintf(stderr, "Warning: cannot query manufacturer for device: %s\n", usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* fprintf(stderr, "seen device from vendor ->%s<-\n", string); */
+                    if(strcmp(string, vendorName) == 0){
+                        len = usbhidGetStringAscii(handle, dev->descriptor.iProduct, string, sizeof(string));
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_IO;
+                            fprintf(stderr, "Warning: cannot query product for device: %s\n", usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* fprintf(stderr, "seen product ->%s<-\n", string); */
+                            if(strcmp(string, productName) == 0)
+                                break;
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = (void *)handle;
+        usesReportIDs = _usesReportIDs;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    if(device != NULL)
+        usb_close((void *)device);
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+int bytesSent, reportId = buffer[0];
+
+    if(!usesReportIDs){
+        buffer++;   /* skip dummy report ID */
+        len--;
+    }
+    bytesSent = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, USBRQ_HID_SET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | (reportId & 0xff), 0, buffer, len, 5000);
+    if(bytesSent != len){
+        if(bytesSent < 0)
+            fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+int bytesReceived, maxLen = *len;
+
+    if(!usesReportIDs){
+        buffer++;   /* make room for dummy report ID */
+        maxLen--;
+    }
+    bytesReceived = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_IN, USBRQ_HID_GET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | reportNumber, 0, buffer, maxLen, 5000);
+    if(bytesReceived < 0){
+        fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    *len = bytesReceived;
+    if(!usesReportIDs){
+        buffer[-1] = reportNumber;  /* add dummy report ID */
+        (*len)++;
+    }
+    return 0;
+}
+
+/* ######################################################################## */
+#endif /* defined WIN32 ################################################### */
+/* ######################################################################## */
Index: vusb-20121206/examples/hid-data/commandline/hiddata.h
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hiddata.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hiddata.h	(working copy)
@@ -0,0 +1,70 @@
+/* Name: hiddata.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __HIDDATA_H_INCLUDED__
+#define __HIDDATA_H_INCLUDED__
+
+/*
+General Description:
+This module implements an abstraction layer for data transfer over HID feature
+requests. The implementation uses native Windows functions on Windows so that
+no driver installation is required and libusb on Unix. You must link the
+appropriate libraries in either case: "-lhid -lusb -lsetupapi" on Windows and
+`libusb-config --libs` on Unix.
+*/
+
+/* ------------------------------------------------------------------------ */
+
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+/* ------------------------------------------------------------------------ */
+
+typedef struct usbDevice    usbDevice_t;
+/* Opaque data type representing the USB device. This can be a Windows handle
+ * or a libusb handle, depending on the backend implementation.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidOpenDevice(usbDevice_t **device, int vendorID, char *vendorName, int productID, char *productName, int usesReportIDs);
+/* This function opens a USB device. 'vendorID' and 'productID' are the numeric
+ * Vendor-ID and Product-ID of the device we want to open. If 'vendorName' and
+ * 'productName' are both not NULL, only devices with matching manufacturer-
+ * and product name strings are accepted. If the device uses report IDs,
+ * 'usesReportIDs' must be set to a non-zero value.
+ * Returns: If a matching device has been found, USBOPEN_SUCCESS is returned
+ * and '*device' is set to an opaque pointer representing the device. The
+ * device must be closed with usbhidCloseDevice(). If the device has not been
+ * found or opening failed, an error code is returned.
+ */
+void    usbhidCloseDevice(usbDevice_t *device);
+/* Every device opened with usbhidOpenDevice() must be closed with this function.
+ */
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len);
+/* This function sends a feature report to the device. The report ID must be
+ * in the first byte of buffer and the length 'len' of the report is specified
+ * including this report ID. If no report IDs are used, buffer[0] must be set
+ * to 0 (dummy report ID).
+ * Returns: 0 on success, an error code otherwise.
+ */
+int usbhidGetReport(usbDevice_t *device, int reportID, char *buffer, int *len);
+/* This function obtains a feature report from the device. The requested
+ * report-ID is passed in 'reportID'. The caller must pass a buffer of the size
+ * of the expected report in 'buffer' and initialize the variable pointed to by
+ * 'len' to the total size of this buffer. Upon successful return, the report
+ * (prefixed with the report-ID) is in 'buffer' and the actual length of the
+ * report is returned in '*len'.
+ * Returns: 0 on success, an error code otherwise.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+#endif /* __HIDDATA_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-data/commandline/hidsdi.h
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hidsdi.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hidsdi.h	(working copy)
@@ -0,0 +1,48 @@
+/* Name: hidsdi.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-02-02
+ * Tabsize: 4
+ * Copyright: (c) 2006-2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description
+This file is a replacement for hidsdi.h from the Windows DDK. It defines some
+of the types and function prototypes of this header for our project. If you
+have the Windows DDK version of this file or a version shipped with MinGW, use
+that instead.
+*/
+
+#ifndef _HIDSDI_H
+#define _HIDSDI_H
+
+#include <pshpack4.h>
+
+#include <ddk/hidusage.h>
+#include <ddk/hidpi.h>
+
+typedef struct{
+    ULONG   Size;
+    USHORT  VendorID;
+    USHORT  ProductID;
+    USHORT  VersionNumber;
+}HIDD_ATTRIBUTES;
+
+void __stdcall      HidD_GetHidGuid(OUT LPGUID hidGuid);
+
+BOOLEAN __stdcall   HidD_GetAttributes(IN HANDLE device, OUT HIDD_ATTRIBUTES *attributes);
+
+BOOLEAN __stdcall   HidD_GetManufacturerString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetProductString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetSerialNumberString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetFeature(IN HANDLE device, OUT void *reportBuffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_SetFeature(IN HANDLE device, IN void *reportBuffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetNumInputBuffers(IN HANDLE device, OUT ULONG *numBuffers);
+BOOLEAN __stdcall   HidD_SetNumInputBuffers(IN HANDLE device, OUT ULONG numBuffers);
+
+#include <poppack.h>
+
+#endif
Index: vusb-20121206/examples/hid-data/commandline/hidtool.c
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hidtool.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hidtool.c	(working copy)
@@ -0,0 +1,126 @@
+/* Name: hidtool.c
+ * Project: hid-data example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "hiddata.h"
+#include "../firmware/usbconfig.h"  /* for device VID, PID, vendor name and product name */
+
+/* ------------------------------------------------------------------------- */
+
+static char *usbErrorMessage(int errCode)
+{
+static char buffer[80];
+
+    switch(errCode){
+        case USBOPEN_ERR_ACCESS:      return "Access to device denied";
+        case USBOPEN_ERR_NOTFOUND:    return "The specified device was not found";
+        case USBOPEN_ERR_IO:          return "Communication error with device";
+        default:
+            sprintf(buffer, "Unknown USB error %d", errCode);
+            return buffer;
+    }
+    return NULL;    /* not reached */
+}
+
+static usbDevice_t  *openDevice(void)
+{
+usbDevice_t     *dev = NULL;
+unsigned char   rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char            vendorName[] = {USB_CFG_VENDOR_NAME, 0}, productName[] = {USB_CFG_DEVICE_NAME, 0};
+int             vid = rawVid[0] + 256 * rawVid[1];
+int             pid = rawPid[0] + 256 * rawPid[1];
+int             err;
+
+    if((err = usbhidOpenDevice(&dev, vid, vendorName, pid, productName, 0)) != 0){
+        fprintf(stderr, "error finding %s: %s\n", productName, usbErrorMessage(err));
+        return NULL;
+    }
+    return dev;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void hexdump(char *buffer, int len)
+{
+int     i;
+FILE    *fp = stdout;
+
+    for(i = 0; i < len; i++){
+        if(i != 0){
+            if(i % 16 == 0){
+                fprintf(fp, "\n");
+            }else{
+                fprintf(fp, " ");
+            }
+        }
+        fprintf(fp, "0x%02x", buffer[i] & 0xff);
+    }
+    if(i != 0)
+        fprintf(fp, "\n");
+}
+
+static int  hexread(char *buffer, char *string, int buflen)
+{
+char    *s;
+int     pos = 0;
+
+    while((s = strtok(string, ", ")) != NULL && pos < buflen){
+        string = NULL;
+        buffer[pos++] = (char)strtol(s, NULL, 0);
+    }
+    return pos;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void usage(char *myName)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s read\n", myName);
+    fprintf(stderr, "  %s write <listofbytes>\n", myName);
+}
+
+int main(int argc, char **argv)
+{
+usbDevice_t *dev;
+char        buffer[129];    /* room for dummy report ID */
+int         err;
+
+    if(argc < 2){
+        usage(argv[0]);
+        exit(1);
+    }
+    if((dev = openDevice()) == NULL)
+        exit(1);
+    if(strcasecmp(argv[1], "read") == 0){
+        int len = sizeof(buffer);
+        if((err = usbhidGetReport(dev, 0, buffer, &len)) != 0){
+            fprintf(stderr, "error reading data: %s\n", usbErrorMessage(err));
+        }else{
+            hexdump(buffer + 1, sizeof(buffer) - 1);
+        }
+    }else if(strcasecmp(argv[1], "write") == 0){
+        int i, pos;
+        memset(buffer, 0, sizeof(buffer));
+        for(pos = 1, i = 2; i < argc && pos < sizeof(buffer); i++){
+            pos += hexread(buffer + pos, argv[i], sizeof(buffer) - pos);
+        }
+        if((err = usbhidSetReport(dev, buffer, sizeof(buffer))) != 0)   /* add a dummy report ID */
+            fprintf(stderr, "error writing data: %s\n", usbErrorMessage(err));
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usbhidCloseDevice(dev);
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-data/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-data/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-data/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-data/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/main.c	(working copy)
@@ -0,0 +1,140 @@
+/* Name: main.c
+ * Project: hid-data, example how to use HID for data transfer
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+*/
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+#include <avr/eeprom.h>
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[22] = {    /* USB report descriptor */
+    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
+    0x09, 0x01,                    // USAGE (Vendor Usage 1)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x95, 0x80,                    //   REPORT_COUNT (128)
+    0x09, 0x00,                    //   USAGE (Undefined)
+    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)
+    0xc0                           // END_COLLECTION
+};
+/* Since we define only one feature report, we don't use report-IDs (which
+ * would be the first byte of the report). The entire report consists of 128
+ * opaque data bytes.
+ */
+
+/* The following variables store the status of the current data transfer */
+static uchar    currentAddress;
+static uchar    bytesRemaining;
+
+/* ------------------------------------------------------------------------- */
+
+/* usbFunctionRead() is called when the host requests a chunk of data from
+ * the device. For more information see the documentation in usbdrv/usbdrv.h.
+ */
+uchar   usbFunctionRead(uchar *data, uchar len)
+{
+    if(len > bytesRemaining)
+        len = bytesRemaining;
+    eeprom_read_block(data, (uchar *)0 + currentAddress, len);
+    currentAddress += len;
+    bytesRemaining -= len;
+    return len;
+}
+
+/* usbFunctionWrite() is called when the host sends a chunk of data to the
+ * device. For more information see the documentation in usbdrv/usbdrv.h.
+ */
+uchar   usbFunctionWrite(uchar *data, uchar len)
+{
+    if(bytesRemaining == 0)
+        return 1;               /* end of transfer */
+    if(len > bytesRemaining)
+        len = bytesRemaining;
+    eeprom_write_block(data, (uchar *)0 + currentAddress, len);
+    currentAddress += len;
+    bytesRemaining -= len;
+    return bytesRemaining == 0; /* return 1 if this was the last chunk */
+}
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* HID class request */
+        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
+            /* since we have only one report type, we can ignore the report-ID */
+            bytesRemaining = 128;
+            currentAddress = 0;
+            return USB_NO_MSG;  /* use usbFunctionRead() to obtain data */
+        }else if(rq->bRequest == USBRQ_HID_SET_REPORT){
+            /* since we have only one report type, we can ignore the report-ID */
+            bytesRemaining = 128;
+            currentAddress = 0;
+            return USB_NO_MSG;  /* use usbFunctionWrite() to receive data from host */
+        }
+    }else{
+        /* ignore vendor type requests, we don't use any */
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-data/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-data/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      1
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       1
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdf, 0x05 /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'D', 'a', 't', 'a', 'S', 't', 'o', 'r', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 9
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    22
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-mouse/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-mouse/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/Readme.txt	(working copy)
@@ -0,0 +1,48 @@
+This is the Readme file for hid-mouse, an example of a USB mouse device. In
+order to have as little dependencies on hardware and architecture as
+possible, mouse movements are computed internally so that the mouse pointer
+moves in a circle.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how HID class devices are implemented. The example
+is kept as simple as possible, except the report descriptor which is taken
+from a real-world mouse.
+
+It does NOT include a host side driver because all modern operating systems
+include one. It does NOT implement USBRQ_HID_SET_REPORT and report-IDs. See
+the "hid-data" example for this topic. It does NOT implement any special
+features such as suspend mode etc.
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-mouse/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-mouse example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-mouse/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/main.c	(working copy)
@@ -0,0 +1,163 @@
+/* Name: main.c
+ * Project: hid-mouse, a very simple HID example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-07
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+
+We use VID/PID 0x046D/0xC00E which is taken from a Logitech mouse. Don't
+publish any hardware using these IDs! This is for demonstration only!
+*/
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[52] = { /* USB report descriptor, size must match usbconfig.h */
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
+    0x09, 0x02,                    // USAGE (Mouse)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x09, 0x01,                    //   USAGE (Pointer)
+    0xA1, 0x00,                    //   COLLECTION (Physical)
+    0x05, 0x09,                    //     USAGE_PAGE (Button)
+    0x19, 0x01,                    //     USAGE_MINIMUM
+    0x29, 0x03,                    //     USAGE_MAXIMUM
+    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x75, 0x01,                    //     REPORT_SIZE (1)
+    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
+    0x95, 0x01,                    //     REPORT_COUNT (1)
+    0x75, 0x05,                    //     REPORT_SIZE (5)
+    0x81, 0x03,                    //     INPUT (Const,Var,Abs)
+    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
+    0x09, 0x30,                    //     USAGE (X)
+    0x09, 0x31,                    //     USAGE (Y)
+    0x09, 0x38,                    //     USAGE (Wheel)
+    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
+    0x25, 0x7F,                    //     LOGICAL_MAXIMUM (127)
+    0x75, 0x08,                    //     REPORT_SIZE (8)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
+    0xC0,                          //   END_COLLECTION
+    0xC0,                          // END COLLECTION
+};
+/* This is the same report descriptor as seen in a Logitech mouse. The data
+ * described by this descriptor consists of 4 bytes:
+ *      .  .  .  .  . B2 B1 B0 .... one byte with mouse button states
+ *     X7 X6 X5 X4 X3 X2 X1 X0 .... 8 bit signed relative coordinate x
+ *     Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 .... 8 bit signed relative coordinate y
+ *     W7 W6 W5 W4 W3 W2 W1 W0 .... 8 bit signed relative coordinate wheel
+ */
+typedef struct{
+    uchar   buttonMask;
+    char    dx;
+    char    dy;
+    char    dWheel;
+}report_t;
+
+static report_t reportBuffer;
+static int      sinus = 7 << 6, cosinus = 0;
+static uchar    idleRate;   /* repeat rate for keyboards, never used for mice */
+
+
+/* The following function advances sin/cos by a fixed angle
+ * and stores the difference to the previous coordinates in the report
+ * descriptor.
+ * The algorithm is the simulation of a second order differential equation.
+ */
+static void advanceCircleByFixedAngle(void)
+{
+char    d;
+
+#define DIVIDE_BY_64(val)  (val + (val > 0 ? 32 : -32)) >> 6    /* rounding divide */
+    reportBuffer.dx = d = DIVIDE_BY_64(cosinus);
+    sinus += d;
+    reportBuffer.dy = d = DIVIDE_BY_64(sinus);
+    cosinus -= d;
+}
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    /* The following requests are never used. But since they are required by
+     * the specification, we implement them in this example.
+     */
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
+        DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
+        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
+            /* we only have one report type, so don't look at wValue */
+            usbMsgPtr = (void *)&reportBuffer;
+            return sizeof(reportBuffer);
+        }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
+            usbMsgPtr = &idleRate;
+            return 1;
+        }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
+            idleRate = rq->wValue.bytes[1];
+        }
+    }else{
+        /* no vendor specific requests implemented */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+        if(usbInterruptIsReady()){
+            /* called after every poll of the interrupt endpoint */
+            advanceCircleByFixedAngle();
+            DBG1(0x03, 0, 0);   /* debug output: interrupt report prepared */
+            usbSetInterrupt((void *)&reportBuffer, sizeof(reportBuffer));
+        }
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-mouse/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xe8, 0x03 /* VOTI's lab use PID */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'M', 'o', 'u', 's', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 5
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    52
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/usbtool/Makefile
===================================================================
--- vusb-20121206/examples/usbtool/Makefile	(nonexistent)
+++ vusb-20121206/examples/usbtool/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: usbtool
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = usbtool
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/usbtool/Makefile.windows
===================================================================
--- vusb-20121206/examples/usbtool/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/usbtool/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: usbtool
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/usbtool/Readme.txt
===================================================================
--- vusb-20121206/examples/usbtool/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/usbtool/Readme.txt	(working copy)
@@ -0,0 +1,209 @@
+This is the Readme file for usbtool, a general purpose command line utility
+which can send USB requests to arbitrary devices. Usbtool is based on libusb.
+
+
+WHAT IS USBTOOL GOOD FOR?
+=========================
+When you implement a communication protocol like USB, you must usually write
+two programs: one on each end of the communication. For USB, this means that
+you must write a firmware for the device and driver software for the host.
+
+Usbtool can save you the work of writing the host software, at least during
+firmware development and testing. Usbtool can send control-in and -out
+requests to arbitrary devices and send and receive data on interrupt- and
+bulk-endpoints.
+
+Usbtool is not only a useful developer tool, it's also an example for using
+libusb for communication with the device.
+
+
+SYNOPSIS
+========
+  usbtool [options] <command>
+
+
+COMMANDS
+========
+  list
+    This command prints a list of devices found on all available USB busses.
+    Options -v, -V, -p and -P can be used to filter the list.
+
+  control in|out <type> <recipient> <request> <value> <index>
+    Sends a control-in or control-out request to the device. The request
+    parameters are:
+      type ........ Type of request, can be "standard", "class", "vendor" or
+                    "reserved". The type determines which software module in
+                    the device is responsible for answering the request:
+                    Standard requests are answered by the driver, class
+                    requests by the class implementation (e.g. HID, CDC) and
+                    vendor requests by custom code.
+      recipient ... Recipient of the request in the device. Can be "device",
+                    "interface", "endpoint" or "other". For standard and
+                    class requests, the specification defines a recipient for
+                    each request. For vendor requests, choose whatever your
+                    code expects.
+      request ..... 8 bit numeric value identifying the request.
+      value ....... 16 bit numeric value passed to the device.
+      index ....... another 16 bit numeric value passed to the device.
+    Use options -v, -V, -p and -P to single out a particular device. Use
+    options -d or -D to to send data in an OUT request. Use options -n, -O
+    and -b to determine what to do with data received in an IN request.
+
+  interrupt in|out
+    Sends or receives data on an interrupt-out resp. -in endpoint.
+    Use options -v, -V, -p and -P to single out a particular device. Use
+    options -d or -D to to send data to an OUT endpoint. Use options -n, -O
+    and -b to determine what to do with data received from an IN endpoint.
+    Use option -e to set the endpoint number, -c to choose a configuration
+    -i to claim a particular interface.
+
+  bulk in|out
+    Same as "interrupt in" and "interrupt out", but for bulk endpoints.
+
+
+OPTIONS
+=======
+Most options have already been mentioned at the commands which use them.
+here is a complete list:
+
+  -h or -?
+    Prints a short help.
+
+  -v <vendor-id>
+    Numeric vendor ID, can be "*" to allow any VID. Take only devices with
+    matching vendor ID into account.
+
+  -p <product-id>
+    Numeric product ID, can be "*" to allow any PID. Take only devices with
+    matching product ID into account.
+
+  -V <vendor-name-pattern>
+    Shell style matching pattern for vendor name. Take only devices into
+    account which have a vendor name that matches this pattern.
+
+  -P <product-name-pattern>
+    Shell style matching pattern for product name. Take only devices into
+    account which have a product name that matches this pattern.
+
+  -S <serial-pattern>
+    Shell style matching pattern for serial number. Take only devices into
+    account which have a serial number that matches this pattern.
+
+  -d <databytes>
+    Data bytes to send to the device, comma separated list of numeric values.
+    E.g.: "1,2,3,4,5".
+
+  -D <file>
+    Binary data sent to the device should be taken from this file.
+
+  -O <file>
+    Write received data bytes to the given file. Format is either hex or
+    binary, depending on the -b flag. By default, received data is printed
+    to standard output.
+
+  -b
+    Request binary output format for files and standard output. Default is
+    a hexadecimal listing.
+
+  -n <count>
+    Numeric value: Maximum number of bytes to receive. This value is passed
+    directly to the libusb API functions.
+
+  -e <endpoint>
+    Numeric value: Endpoint number for interrupt and bulk commands.
+
+  -t <timeout>
+    Numeric value: Timeout in milliseconds for the request. This value is
+    passed directly to the libusb API functions.
+
+  -c <configuration>
+    Numeric value: Interrupt and bulk endpoints can usually only be used if
+    a configuration and an interface has been chosen. Use -c and -i to
+    specify configuration and interface values.
+
+  -i <interface>
+    Numeric value: Interrupt and bulk endpoints can usually only be used if
+    a configuration and an interface has been chosen. Use -c and -i to
+    specify configuration and interface values.
+
+  -w
+    Usbtool may be too verbose with warnings for some applications. Use this
+    option to suppress USB warnings.
+
+
+NUMERIC VALUES
+==============
+All numeric values can be given in hexadecimal, decimal or octal. Hex values
+are identified by their 0x or 0X prefix, octal values by a leading "0" (the
+digit zero) and decimal values because they start with a non-zero digit. An
+optional sign character is allowed. The special value "*" is translated to
+zero and stands for "any value" in some contexts.
+
+
+SHELL STYLE MATCHING PATTERNS
+=============================
+Some options take shell style matching patterns as an argument. This refers
+to Unix shells and their file wildcard operations:
+  + "*" (asterisk character) matches any number (0 to infinite) of any
+    characters.
+  + "?" matches exactly one arbitrary character.
+  + A list of characters in square brackets (e.g. "[abc]") matches any of the
+    characters in the list. If a dash ("-") is in the list, it must be the
+    first or the last character. If a caret ("^") is in the list, it must
+    not be the first character. A closing square bracket ("]") must be the
+    first character in the list. A range of characters can be specified in
+    the way "[a-z]". This matches all characters with numeric representation
+    (usually ASCII) starting with "a" and ending with "z". The entire
+    construct matches only one character.
+  + A list of characters in square brackets starting with a caret ("^"), e.g.
+    ("[^abc]") matches any character NOT in the list. The other rules are as
+    above.
+  + "\" (backslash) followed by any character matches that following
+    character. This can be used to escape "*", "?", "[" and "\".
+
+
+BUILDING USBTOOL
+================
+Usbtool uses libusb on Unix and libusb-win32 on Windows. These libraries can
+be obtained from http://libusb.sourceforge.net/ and
+http://libusb-win32.sourceforge.net/ respectively. On Unix, a simple "make"
+should compile the sources (although you may have to edit Makefile to
+include or remove additional libraries). On Windows, we recommend that you
+use MinGW and MSYS. See the top level Readme file for details. Edit
+Makefile.windows according to your library installation paths and build with
+"make -f Makefile.windows".
+
+
+EXAMPLES
+========
+To list all devices connected to your computer, do
+
+    usbtool -w list
+
+To check whether our selection options single out the desired device, use eg.
+
+    usbtool -w -P LEDControl list
+
+This command shows all LEDControl devices connected or prints nothing if
+none is found. LEDControl is the device from the "custom-class" example.
+
+You can also send commands to the LEDControl device using usbtool. From
+the file requests.h in custom-class/firmware, we know that the set-status
+request has numeric value 1 and the get-status request is 2. See this file
+for details of the protocol used. We can therefore query the status with
+
+    usbtool -w -P LEDControl control in vendor device 2 0 0
+
+This command prints 0x00 if the LED is off or 0x01 if it is on. To turn the
+LED on, use
+
+    usbtool -w -P LEDControl control out vendor device 1 1 0
+
+and to turn it off, use
+
+    usbtool -w -P LEDControl control out vendor device 1 0 0
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/usbtool/opendevice.c
===================================================================
--- vusb-20121206/examples/usbtool/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/usbtool/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/usbtool/opendevice.h
===================================================================
--- vusb-20121206/examples/usbtool/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/usbtool/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/usbtool/usbtool.c
===================================================================
--- vusb-20121206/examples/usbtool/usbtool.c	(nonexistent)
+++ vusb-20121206/examples/usbtool/usbtool.c	(working copy)
@@ -0,0 +1,355 @@
+/* Name: usbtool.c
+ * Project: V-USB examples, host side
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-06
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This command line tool can perform various USB requests at arbitrary
+USB devices. It is intended as universal host side tool for experimentation
+and debugging purposes. It must be linked with libusb, a library for accessing
+the USB bus from Linux, FreeBSD, Mac OS X and other Unix operating systems.
+Libusb can be obtained from http://libusb.sourceforge.net/.
+On Windows use libusb-win32 from http://libusb-win32.sourceforge.net/.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include <usb.h>        /* this is libusb, see http://libusb.sourceforge.net/ */
+#include "opendevice.h" /* common code moved to separate module */
+
+#define DEFAULT_USB_VID         0   /* any */
+#define DEFAULT_USB_PID         0   /* any */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage: %s [options] <command>\n", name);
+    fprintf(stderr,
+        "Options are:\n"
+        "  -h or -? (print this help and exit)\n"
+        "  -v <vendor-id> (defaults to 0x%x, can be '*' for any VID)\n"
+        "  -p <product-id> (defaults to 0x%x, can be '*' for any PID)\n"
+        "  -V <vendor-name-pattern> (shell style matching, defaults to '*')\n"
+        "  -P <product-name-pattern> (shell style matching, defaults to '*')\n"
+        "  -S <serial-pattern> (shell style matching, defaults to '*')\n"
+        "  -d <databytes> (data byte for request, comma separated list)\n"
+        "  -D <file> (binary data for request taken from file)\n"
+        "  -O <file> (write received data bytes to file)\n"
+        "  -b (binary output format, default is hex)\n"
+        "  -n <count> (maximum number of bytes to receive)\n"
+        "  -e <endpoint> (specify endpoint for some commands)\n"
+        "  -t <timeout> (specify USB timeout in milliseconds)\n"
+        "  -c <configuration> (device configuration to choose)\n"
+        "  -i <interface> (configuration interface to claim)\n"
+        "  -w (suppress USB warnings, default is verbose)\n"
+        "\n"
+        "Commands are:\n"
+        "  list (list all matching devices by name)\n"
+        "  control in|out <type> <recipient> <request> <value> <index> (send control request)\n"
+        "  interrupt in|out (send or receive interrupt data)\n"
+        "  bulk in|out (send or receive bulk data)\n"
+        "For valid enum values for <type> and <recipient> pass \"x\" for the value.\n"
+        "Objective Development's free VID/PID pairs are:\n"
+        "  5824/1500 for vendor class devices\n"
+        "  5824/1503 for HID class devices excluding mice and keyboards\n"
+        "  5824/1505 for CDC-ACM class devices\n"
+        "  5824/1508 for MIDI class devices\n"
+        , DEFAULT_USB_VID, DEFAULT_USB_PID
+    );
+
+
+}
+
+static int  vendorID = DEFAULT_USB_VID;
+static int  productID = DEFAULT_USB_PID;
+static char *vendorNamePattern = "*";
+static char *productNamePattern = "*";
+static char *serialPattern = "*";
+static char *sendBytes = NULL;
+static int  sendByteCount;
+static char *outputFile = NULL;
+static int  endpoint = 0;
+static int  outputFormatIsBinary = 0;
+static int  showWarnings = 1;
+static int  usbTimeout = 5000;
+static int  usbCount = 128;
+static int  usbConfiguration = 1;
+static int  usbInterface = 0;
+
+static int  usbDirection, usbType, usbRecipient, usbRequest, usbValue, usbIndex; /* arguments of control transfer */
+
+/* ------------------------------------------------------------------------- */
+
+/* ASCII to integer (number parsing) which allows hex (0x prefix),
+ * octal (0 prefix) and decimal (1-9 prefix) input.
+ */
+static int  myAtoi(char *text)
+{
+long    l;
+char    *endPtr;
+
+    if(strcmp(text, "*") == 0)
+        return 0;
+    l = strtol(text, &endPtr, 0);
+    if(endPtr == text){
+        fprintf(stderr, "warning: can't parse numeric parameter ->%s<-, defaults to 0.\n", text);
+        l = 0;
+    }else if(*endPtr != 0){
+        fprintf(stderr, "warning: numeric parameter ->%s<- only partially parsed.\n", text);
+    }
+    return l;
+}
+
+static int  parseEnum(char *text, ...)
+{
+va_list vlist;
+char    *entries[64];
+int     i, numEntries;
+
+    va_start(vlist, text);
+    for(i = 0; i < 64; i++){
+        entries[i] = va_arg(vlist, char *);
+        if(entries[i] == NULL)
+            break;
+    }
+    numEntries = i;
+    va_end(vlist);
+    for(i = 0; i < numEntries; i++){
+        if(strcasecmp(text, entries[i]) == 0)
+            return i;
+    }
+    if(isdigit(*text)){
+        return myAtoi(text);
+    }
+    fprintf(stderr, "Enum value \"%s\" not allowed. Allowed values are:\n", text);
+    for(i = 0; i < numEntries; i++){
+        fprintf(stderr, "  %s\n", entries[i]);
+    }
+    exit(1);
+}
+
+/* ------------------------------------------------------------------------- */
+
+#define ACTION_LIST         0
+#define ACTION_CONTROL      1
+#define ACTION_INTERRUPT    2
+#define ACTION_BULK         3
+
+int main(int argc, char **argv)
+{
+usb_dev_handle  *handle = NULL;
+int             opt, len, action, argcnt;
+char            *myName = argv[0], *s, *rxBuffer = NULL;
+FILE            *fp;
+
+    while((opt = getopt(argc, argv, "?hv:p:V:P:S:d:D:O:e:n:tbw")) != -1){
+        switch(opt){
+        case 'h':
+        case '?':   /* -h or -? (print this help and exit) */
+            usage(myName);
+            exit(1);
+        case 'v':   /* -v <vendor-id> (defaults to 0x%x, can be '*' for any VID) */
+            vendorID = myAtoi(optarg);
+            break;
+        case 'p':   /* -p <product-id> (defaults to 0x%x, can be '*' for any PID) */
+            productID = myAtoi(optarg);
+            break;
+        case 'V':   /* -V <vendor-name-pattern> (shell style matching, defaults to '*') */
+            vendorNamePattern = optarg;
+            break;
+        case 'P':   /* -P <product-name-pattern> (shell style matching, defaults to '*') */
+            productNamePattern = optarg;
+            break;
+        case 'S':   /* -S <serial-pattern> (shell style matching, defaults to '*') */
+            serialPattern = optarg;
+            break;
+        case 'd':   /* -d <databytes> (data bytes for requests given on command line) */
+            while((s = strtok(optarg, ", ")) != NULL){
+                optarg = NULL;
+                if(sendBytes != NULL){
+                    sendBytes = realloc(sendBytes, sendByteCount + 1);
+                }else{
+                    sendBytes = malloc(sendByteCount + 1);
+                }
+                sendBytes[sendByteCount++] = myAtoi(s);
+            }
+            break;
+        case 'D':   /* -D <file> (data bytes for request taken from file) */
+            if((fp = fopen(optarg, "rb")) == NULL){
+                fprintf(stderr, "error opening %s: %s\n", optarg, strerror(errno));
+                exit(1);
+            }
+            fseek(fp, 0, SEEK_END);
+            len = ftell(fp);
+            fseek(fp, 0, SEEK_SET);
+            if(sendBytes != NULL){
+                sendBytes = realloc(sendBytes, sendByteCount + len);
+            }else{
+                sendBytes = malloc(sendByteCount + len);
+            }
+            fread(sendBytes + sendByteCount, 1, len, fp);   /* would need error checking */
+            sendByteCount += len;
+            fclose(fp);
+            break;
+        case 'O':   /* -O <file> (write received data bytes to file) */
+            outputFile = optarg;
+            break;
+        case 'e':   /* -e <endpoint> (specify endpoint for some commands) */
+            endpoint = myAtoi(optarg);
+            break;
+        case 't':   /* -t <timeout> (specify USB timeout in milliseconds) */
+            usbTimeout = myAtoi(optarg);
+            break;
+        case 'b':   /* -b (binary output format, default is hex) */
+            outputFormatIsBinary = 1;
+            break;
+        case 'n':   /* -n <count> (maximum number of bytes to receive) */
+            usbCount = myAtoi(optarg);
+            break;
+        case 'c':   /* -c <configuration> (device configuration to choose) */
+            usbConfiguration = myAtoi(optarg);
+            break;
+        case 'i':   /* -i <interface> (configuration interface to claim) */
+            usbInterface = myAtoi(optarg);
+            break;
+        case 'w':   /* -w (suppress USB warnings, default is verbose) */
+            showWarnings = 0;
+            break;
+        default:
+            fprintf(stderr, "Option -%c unknown\n", opt);
+            exit(1);
+        }
+    }
+    argc -= optind;
+    argv += optind;
+    if(argc < 1){
+        usage(myName);
+        exit(1);
+    }
+    argcnt = 2;
+    if(strcasecmp(argv[0], "list") == 0){
+        action = ACTION_LIST;
+        argcnt = 1;
+    }else if(strcasecmp(argv[0], "control") == 0){
+        action = ACTION_CONTROL;
+        argcnt = 7;
+    }else if(strcasecmp(argv[0], "interrupt") == 0){
+        action = ACTION_INTERRUPT;
+    }else if(strcasecmp(argv[0], "bulk") == 0){
+        action = ACTION_BULK;
+    }else{
+        fprintf(stderr, "command %s not known\n", argv[0]);
+        usage(myName);
+        exit(1);
+    }
+    if(argc < argcnt){
+        fprintf(stderr, "Not enough arguments.\n");
+        usage(myName);
+        exit(1);
+    }
+    if(argc > argcnt){
+        fprintf(stderr, "Warning: only %d arguments expected, rest ignored.\n", argcnt);
+    }
+    usb_init();
+    if(usbOpenDevice(&handle, vendorID, vendorNamePattern, productID, productNamePattern, serialPattern, action == ACTION_LIST ? stdout : NULL, showWarnings ? stderr : NULL) != 0){
+        fprintf(stderr, "Could not find USB device with VID=0x%x PID=0x%x Vname=%s Pname=%s Serial=%s\n", vendorID, productID, vendorNamePattern, productNamePattern, serialPattern);
+        exit(1);
+    }
+    if(action == ACTION_LIST)
+        exit(0);                /* we've done what we were asked to do already */
+    usbDirection = parseEnum(argv[1], "out", "in", NULL);
+    if(usbDirection){   /* IN transfer */
+        rxBuffer = malloc(usbCount);
+    }
+    if(action == ACTION_CONTROL){
+        int requestType;
+        usbType = parseEnum(argv[2], "standard", "class", "vendor", "reserved", NULL);
+        usbRecipient = parseEnum(argv[3], "device", "interface", "endpoint", "other", NULL);
+        usbRequest = myAtoi(argv[4]);
+        usbValue = myAtoi(argv[5]);
+        usbIndex = myAtoi(argv[6]);
+        requestType = ((usbDirection & 1) << 7) | ((usbType & 3) << 5) | (usbRecipient & 0x1f);
+        if(usbDirection){   /* IN transfer */
+            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, rxBuffer, usbCount, usbTimeout);
+        }else{              /* OUT transfer */
+            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, sendBytes, sendByteCount, usbTimeout);
+        }
+    }else{  /* must be ACTION_INTERRUPT or ACTION_BULK */
+        int retries = 1;
+        if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+            fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+        }
+        /* now try to claim the interface and detach the kernel HID driver on
+         * linux and other operating systems which support the call.
+         */
+        while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+            if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+                fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+            }
+#endif
+        }
+        if(len != 0 && showWarnings)
+            fprintf(stderr, "Warning: could not claim interface: %s\n", usb_strerror());
+        if(action == ACTION_INTERRUPT){
+            if(usbDirection){   /* IN transfer */
+                len = usb_interrupt_read(handle, endpoint, rxBuffer, usbCount, usbTimeout);
+            }else{
+                len = usb_interrupt_write(handle, endpoint, sendBytes, sendByteCount, usbTimeout);
+            }
+        }else{
+            if(usbDirection){   /* IN transfer */
+                len = usb_bulk_read(handle, endpoint, rxBuffer, usbCount, usbTimeout);
+            }else{
+                len = usb_bulk_write(handle, endpoint, sendBytes, sendByteCount, usbTimeout);
+            }
+        }
+    }
+    if(len < 0){
+        fprintf(stderr, "USB error: %s\n", usb_strerror());
+        exit(1);
+    }
+    if(usbDirection == 0)   /* OUT */
+        printf("%d bytes sent.\n", len);
+    if(rxBuffer != NULL){
+        FILE *fp = stdout;
+        if(outputFile != NULL){
+            fp = fopen(outputFile, outputFormatIsBinary ? "wb" : "w");
+            if(fp == NULL){
+                fprintf(stderr, "Error writing \"%s\": %s\n", outputFile, strerror(errno));
+                exit(1);
+            }
+        }
+        if(outputFormatIsBinary){
+            fwrite(rxBuffer, 1, len, fp);
+        }else{
+            int i;
+            for(i = 0; i < len; i++){
+                if(i != 0){
+                    if(i % 16 == 0){
+                        fprintf(fp, "\n");
+                    }else{
+                        fprintf(fp, " ");
+                    }
+                }
+                fprintf(fp, "0x%02x", rxBuffer[i] & 0xff);
+            }
+            if(i != 0)
+                fprintf(fp, "\n");
+        }
+    }
+    usb_close(handle);
+    if(rxBuffer != NULL)
+        free(rxBuffer);
+    return 0;
+}
Index: vusb-20121206/libs-device/Readme.txt
===================================================================
--- vusb-20121206/libs-device/Readme.txt	(nonexistent)
+++ vusb-20121206/libs-device/Readme.txt	(working copy)
@@ -0,0 +1,22 @@
+This is the Readme file for the libs-device directory. This directory contains
+code snippets which may be useful for USB device firmware.
+
+
+WHAT IS INCLUDED IN THIS DIRECTORY?
+===================================
+
+osccal.c and osccal.h
+  This module contains a function which calibrates the AVR's built-in RC
+  oscillator based on the USB frame clock. See osccal.h for a documentation
+  of the API.
+
+osctune.h
+  This header file contains a code snippet for usbconfig.h. With this code,
+  you can keep the AVR's internal RC oscillator in sync with the USB frame
+  clock. This is a continuous synchronization, not a single calibration at
+  USB reset as with osccal.c above. Please note that this code works only
+  if D- is wired to the interrupt, not D+.
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/libs-device/osccal.c
===================================================================
--- vusb-20121206/libs-device/osccal.c	(nonexistent)
+++ vusb-20121206/libs-device/osccal.c	(working copy)
@@ -0,0 +1,62 @@
+/* Name: osccal.c
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <avr/io.h>
+
+#ifndef uchar
+#define uchar   unsigned char
+#endif
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------ Oscillator Calibration ------------------------- */
+/* ------------------------------------------------------------------------- */
+
+/* Calibrate the RC oscillator. Our timing reference is the Start Of Frame
+ * signal (a single SE0 bit) repeating every millisecond immediately after
+ * a USB RESET. We first do a binary search for the OSCCAL value and then
+ * optimize this value with a neighboorhod search.
+ */
+void    calibrateOscillator(void)
+{
+uchar       step = 128;
+uchar       trialValue = 0, optimumValue;
+int         x, optimumDev, targetValue = (unsigned)(1499 * (double)F_CPU / 10.5e6 + 0.5);
+
+    /* do a binary search: */
+    do{
+        OSCCAL = trialValue + step;
+        x = usbMeasureFrameLength();    /* proportional to current real frequency */
+        if(x < targetValue)             /* frequency still too low */
+            trialValue += step;
+        step >>= 1;
+    }while(step > 0);
+    /* We have a precision of +/- 1 for optimum OSCCAL here */
+    /* now do a neighborhood search for optimum value */
+    optimumValue = trialValue;
+    optimumDev = x; /* this is certainly far away from optimum */
+    for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){
+        x = usbMeasureFrameLength() - targetValue;
+        if(x < 0)
+            x = -x;
+        if(x < optimumDev){
+            optimumDev = x;
+            optimumValue = OSCCAL;
+        }
+    }
+    OSCCAL = optimumValue;
+}
+/*
+Note: This calibration algorithm may try OSCCAL values of up to 192 even if
+the optimum value is far below 192. It may therefore exceed the allowed clock
+frequency of the CPU in low voltage designs!
+You may replace this search algorithm with any other algorithm you like if
+you have additional constraints such as a maximum CPU clock.
+For version 5.x RC oscillators (those with a split range of 2x128 steps, e.g.
+ATTiny25, ATTiny45, ATTiny85), it may be useful to search for the optimum in
+both regions.
+*/
Index: vusb-20121206/libs-device/osccal.h
===================================================================
--- vusb-20121206/libs-device/osccal.h	(nonexistent)
+++ vusb-20121206/libs-device/osccal.h	(working copy)
@@ -0,0 +1,62 @@
+/* Name: osccal.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module contains a function which calibrates the AVR's internal RC
+oscillator so that the CPU runs at F_CPU (F_CPU is a macro which must be
+defined when the module is compiled, best passed in the compiler command
+line). The time reference is the USB frame clock of 1 kHz available
+immediately after a USB RESET condition. Timing is done by counting CPU
+cycles, so all interrupts must be disabled while the calibration runs. For
+low level timing measurements, usbMeasureFrameLength() is called. This
+function must be enabled in usbconfig.h by defining
+USB_CFG_HAVE_MEASURE_FRAME_LENGTH to 1. It is recommended to call
+calibrateOscillator() from the reset hook in usbconfig.h:
+
+#ifndef __ASSEMBLER__
+#include <avr/interrupt.h>  // for sei()
+extern void calibrateOscillator(void);
+#endif
+#define USB_RESET_HOOK(resetStarts)  if(!resetStarts){cli(); calibrateOscillator(); sei();}
+
+This routine is an alternative to the continuous synchronization described
+in osctune.h.
+
+Algorithm used:
+calibrateOscillator() first does a binary search in the OSCCAL register for
+the best matching oscillator frequency. Then it does a next neighbor search
+to find the value with the lowest clock rate deviation. It is guaranteed to
+find the best match among neighboring values, but for version 5 oscillators
+(which have a discontinuous relationship between OSCCAL and frequency) a
+better match might be available in another OSCCAL region.
+
+Limitations:
+This calibration algorithm may try OSCCAL values of up to 192 even if the
+optimum value is far below 192. It may therefore exceed the allowed clock
+frequency of the CPU in low voltage designs!
+Precision depends on the OSCCAL vs. frequency dependency of the oscillator.
+Typical precision for an ATMega168 (derived from the OSCCAL vs. F_RC diagram
+in the data sheet) should be in the range of 0.4%. Only the 12.8 MHz and
+16.5 MHz versions of V-USB (with built-in receiver PLL) can tolerate this
+deviation! All other frequency modules require at least 0.2% precision.
+*/
+
+#ifndef __OSCCAL_H_INCLUDED__
+#define __OSCCAL_H_INCLUDED__
+
+void    calibrateOscillator(void);
+/* This function calibrates the RC oscillator so that the CPU runs at F_CPU.
+ * It MUST be called immediately after the end of a USB RESET condition!
+ * Disable all interrupts during the call!
+ * It is recommended that you store the resulting value in EEPROM so that a
+ * good guess value is available after the next reset.
+ */
+
+
+#endif /* __OSCCAL_H_INCLUDED__ */
Index: vusb-20121206/libs-device/osctune.h
===================================================================
--- vusb-20121206/libs-device/osctune.h	(nonexistent)
+++ vusb-20121206/libs-device/osctune.h	(working copy)
@@ -0,0 +1,87 @@
+/* Name: osctune.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-10-18
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This file is declared as C-header file although it is mostly documentation
+how the RC oscillator can be kept in sync to the USB frame rate. The code
+shown here must be added to usbconfig.h or this header file is included from
+there. This code works only if D- is wired to the interrupt, not D+!!!
+
+This is an alternative to the osccal routine in osccal.c. It has the advantage
+that the synchronization is done continuously and that it has more compact
+code size. The disadvantages are slow synchronization (it may take a while
+until the driver works), that messages immediately after the SOF pulse may be
+lost (and need to be retried by the host) and that the interrupt is on D-
+contrary to most examples.
+
+You may want to store a good calibration value in EEPROM for the next startup.
+You know that the calibration value is good when the first USB message is
+received. Do not store the value on every received message because the EEPROM
+has a limited endurance.
+
+Notes:
+(*) You must declare the global character variable "lastTimer0Value" in your
+main code.
+
+(*) Timer 0 must be free running (not written by your code) and the prescaling
+must be consistent with the TIMER0_PRESCALING define.
+
+(*) Good values for Timer 0 prescaling depend on how precise the clock must
+be tuned and how far away from the default clock rate the target clock is.
+For precise tuning, choose a low prescaler factor, for a broad range of tuning
+choose a high one. A prescaler factor of 64 is good for the entire OSCCAL
+range and allows a precision of better than +/-1%. A prescaler factor of 8
+allows tuning to slightly more than +/-6% of the default frequency and is
+more precise than one step of OSCCAL. It is therefore not suitable to tune an
+8 MHz oscillator to 12.5 MHz.
+
+Thanks to Henrik Haftmann for the idea to this routine!
+*/
+
+#define TIMER0_PRESCALING           64 /* must match the configuration for TIMER0 in main */
+#define TOLERATED_DEVIATION_PPT     5  /* max clock deviation before we tune in 1/10 % */
+/* derived constants: */
+#define EXPECTED_TIMER0_INCREMENT   ((F_CPU / (1000 * TIMER0_PRESCALING)) & 0xff)
+#define TOLERATED_DEVIATION         (TOLERATED_DEVIATION_PPT * F_CPU / (1000000 * TIMER0_PRESCALING))
+
+#ifdef __ASSEMBLER__
+macro tuneOsccal
+    push    YH                              ;[0]
+    in      YL, TCNT0                       ;[2]
+    lds     YH, lastTimer0Value             ;[3]
+    sts     lastTimer0Value, YL             ;[5]
+    sub     YL, YH                          ;[7] time passed since last frame
+    subi    YL, EXPECTED_TIMER0_INCREMENT   ;[8]
+#if OSCCAL > 0x3f   /* outside I/O addressable range */
+    lds     YH, OSCCAL                      ;[6]
+#else
+    in      YH, OSCCAL                      ;[6] assembler modle uses __SFR_OFFSET == 0
+#endif
+    cpi     YL, TOLERATED_DEVIATION + 1     ;[10]
+    brmi    notTooHigh                      ;[11]
+    subi    YH, 1                           ;[12] clock rate was too high
+;   brcs    tuningOverflow                  ; optionally check for overflow
+    rjmp    osctuneDone                     ;[13]
+notTooHigh:
+    cpi     YL, -TOLERATED_DEVIATION        ;[13]
+    brpl    osctuneDone                     ;[14] not too low
+    inc     YH                              ;[15] clock rate was too low
+;   breq    tuningOverflow                  ; optionally check for overflow
+osctuneDone:
+#if OSCCAL > 0x3f   /* outside I/O addressable range */
+    sts     OSCCAL, YH                      ;[12-13] store tuned value
+#else
+    out     OSCCAL, YH                      ;[12-13] store tuned value
+#endif
+tuningOverflow:
+    pop     YH                              ;[17]
+    endm                                    ;[19] max number of cycles
+#endif
+
+#define USB_SOF_HOOK        tuneOsccal
Index: vusb-20121206/libs-host/Readme.txt
===================================================================
--- vusb-20121206/libs-host/Readme.txt	(nonexistent)
+++ vusb-20121206/libs-host/Readme.txt	(working copy)
@@ -0,0 +1,26 @@
+This is the Readme file for the libs-host directory. This directory contains
+code snippets which may be useful for host side USB software.
+
+
+WHAT IS INCLUDED IN THIS DIRECTORY?
+===================================
+
+opendevice.c and opendevice.h
+  This module contains a function to find and open a device given its
+  numeric IDs (VID, PID), names (vendor name and product name) and serial
+  number. It is based on libusb/libusb-win32 and returns a libusb device
+  handle. See opendevice.h for an API documentation.
+
+hiddata.c and hiddata.h
+  This module contains functions for data transfer over HID feature reports.
+  It is based on libusb on Unix and native Windows functions on Windows. No
+  driver DLL is needed on Windows. See hiddata.h for an API documentation.
+
+hidsdi.h
+  This DDK header file is missing in the free MinGW version of the Windows
+  DDK. Use this version if you get an "include file not found" error.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/libs-host/hiddata.c
===================================================================
--- vusb-20121206/libs-host/hiddata.c	(nonexistent)
+++ vusb-20121206/libs-host/hiddata.c	(working copy)
@@ -0,0 +1,323 @@
+/* Name: hiddata.c
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include "hiddata.h"
+
+/* ######################################################################## */
+#if defined(WIN32) /* ##################################################### */
+/* ######################################################################## */
+
+#include <windows.h>
+#include <setupapi.h>
+#include "hidsdi.h"
+#include <ddk/hidpi.h>
+
+#ifdef DEBUG
+#define DEBUG_PRINT(arg)    printf arg
+#else
+#define DEBUG_PRINT(arg)
+#endif
+
+/* ------------------------------------------------------------------------ */
+
+static void convertUniToAscii(char *buffer)
+{
+unsigned short  *uni = (void *)buffer;
+char            *ascii = buffer;
+
+    while(*uni != 0){
+        if(*uni >= 256){
+            *ascii++ = '?';
+        }else{
+            *ascii++ = *uni++;
+        }
+    }
+    *ascii++ = 0;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int usesReportIDs)
+{
+GUID                                hidGuid;        /* GUID for HID driver */
+HDEVINFO                            deviceInfoList;
+SP_DEVICE_INTERFACE_DATA            deviceInfo;
+SP_DEVICE_INTERFACE_DETAIL_DATA     *deviceDetails = NULL;
+DWORD                               size;
+int                                 i, openFlag = 0;  /* may be FILE_FLAG_OVERLAPPED */
+int                                 errorCode = USBOPEN_ERR_NOTFOUND;
+HANDLE                              handle = INVALID_HANDLE_VALUE;
+HIDD_ATTRIBUTES                     deviceAttributes;
+				
+    HidD_GetHidGuid(&hidGuid);
+    deviceInfoList = SetupDiGetClassDevs(&hidGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
+    deviceInfo.cbSize = sizeof(deviceInfo);
+    for(i=0;;i++){
+        if(handle != INVALID_HANDLE_VALUE){
+            CloseHandle(handle);
+            handle = INVALID_HANDLE_VALUE;
+        }
+        if(!SetupDiEnumDeviceInterfaces(deviceInfoList, 0, &hidGuid, i, &deviceInfo))
+            break;  /* no more entries */
+        /* first do a dummy call just to determine the actual size required */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, NULL, 0, &size, NULL);
+        if(deviceDetails != NULL)
+            free(deviceDetails);
+        deviceDetails = malloc(size);
+        deviceDetails->cbSize = sizeof(*deviceDetails);
+        /* this call is for real: */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, deviceDetails, size, &size, NULL);
+        DEBUG_PRINT(("checking HID path \"%s\"\n", deviceDetails->DevicePath));
+#if 0
+        /* If we want to access a mouse our keyboard, we can only use feature
+         * requests as the device is locked by Windows. It must be opened
+         * with ACCESS_TYPE_NONE.
+         */
+        handle = CreateFile(deviceDetails->DevicePath, ACCESS_TYPE_NONE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+#endif
+        /* attempt opening for R/W -- we don't care about devices which can't be accessed */
+        handle = CreateFile(deviceDetails->DevicePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+        if(handle == INVALID_HANDLE_VALUE){
+            DEBUG_PRINT(("opening failed: %d\n", (int)GetLastError()));
+            /* errorCode = USBOPEN_ERR_ACCESS; opening will always fail for mouse -- ignore */
+            continue;
+        }
+        deviceAttributes.Size = sizeof(deviceAttributes);
+        HidD_GetAttributes(handle, &deviceAttributes);
+        DEBUG_PRINT(("device attributes: vid=%d pid=%d\n", deviceAttributes.VendorID, deviceAttributes.ProductID));
+        if(deviceAttributes.VendorID != vendor || deviceAttributes.ProductID != product)
+            continue;   /* ignore this device */
+        errorCode = USBOPEN_ERR_NOTFOUND;
+        if(vendorName != NULL && productName != NULL){
+            char    buffer[512];
+            if(!HidD_GetManufacturerString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining vendor name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("vendorName = \"%s\"\n", buffer));
+            if(strcmp(vendorName, buffer) != 0)
+                continue;
+            if(!HidD_GetProductString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining product name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("productName = \"%s\"\n", buffer));
+            if(strcmp(productName, buffer) != 0)
+                continue;
+        }
+        break;  /* we have found the device we are looking for! */
+    }
+    SetupDiDestroyDeviceInfoList(deviceInfoList);
+    if(deviceDetails != NULL)
+        free(deviceDetails);
+    if(handle != INVALID_HANDLE_VALUE){
+        *device = (usbDevice_t *)handle;
+        errorCode = 0;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------ */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    CloseHandle((HANDLE)device);
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+BOOLEAN rval;
+
+    rval = HidD_SetFeature((HANDLE)device, buffer, len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+BOOLEAN rval = 0;
+
+    buffer[0] = reportNumber;
+    rval = HidD_GetFeature((HANDLE)device, buffer, *len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+/* ######################################################################## */
+#else /* defined WIN32 #################################################### */
+/* ######################################################################## */
+
+#include <string.h>
+#include <usb.h>
+
+#define usbDevice   usb_dev_handle  /* use libusb's device structure */
+
+/* ------------------------------------------------------------------------- */
+
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_SET_REPORT    0x09
+
+#define USB_HID_REPORT_TYPE_FEATURE 3
+
+
+static int  usesReportIDs;
+
+/* ------------------------------------------------------------------------- */
+
+static int usbhidGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int _usesReportIDs)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+static int          didUsbInit = 0;
+
+    if(!didUsbInit){
+        usb_init();
+        didUsbInit = 1;
+    }
+    usb_find_busses();
+    usb_find_devices();
+    for(bus=usb_get_busses(); bus; bus=bus->next){
+        for(dev=bus->devices; dev; dev=dev->next){
+            if(dev->descriptor.idVendor == vendor && dev->descriptor.idProduct == product){
+                char    string[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    fprintf(stderr, "Warning: cannot open USB device: %s\n", usb_strerror());
+                    continue;
+                }
+                if(vendorName == NULL && productName == NULL){  /* name does not matter */
+                    break;
+                }
+                /* now check whether the names match: */
+                len = usbhidGetStringAscii(handle, dev->descriptor.iManufacturer, string, sizeof(string));
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_IO;
+                    fprintf(stderr, "Warning: cannot query manufacturer for device: %s\n", usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* fprintf(stderr, "seen device from vendor ->%s<-\n", string); */
+                    if(strcmp(string, vendorName) == 0){
+                        len = usbhidGetStringAscii(handle, dev->descriptor.iProduct, string, sizeof(string));
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_IO;
+                            fprintf(stderr, "Warning: cannot query product for device: %s\n", usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* fprintf(stderr, "seen product ->%s<-\n", string); */
+                            if(strcmp(string, productName) == 0)
+                                break;
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = (void *)handle;
+        usesReportIDs = _usesReportIDs;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    if(device != NULL)
+        usb_close((void *)device);
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+int bytesSent, reportId = buffer[0];
+
+    if(!usesReportIDs){
+        buffer++;   /* skip dummy report ID */
+        len--;
+    }
+    bytesSent = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, USBRQ_HID_SET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | (reportId & 0xff), 0, buffer, len, 5000);
+    if(bytesSent != len){
+        if(bytesSent < 0)
+            fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+int bytesReceived, maxLen = *len;
+
+    if(!usesReportIDs){
+        buffer++;   /* make room for dummy report ID */
+        maxLen--;
+    }
+    bytesReceived = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_IN, USBRQ_HID_GET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | reportNumber, 0, buffer, maxLen, 5000);
+    if(bytesReceived < 0){
+        fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    *len = bytesReceived;
+    if(!usesReportIDs){
+        buffer[-1] = reportNumber;  /* add dummy report ID */
+        (*len)++;
+    }
+    return 0;
+}
+
+/* ######################################################################## */
+#endif /* defined WIN32 ################################################### */
+/* ######################################################################## */
Index: vusb-20121206/libs-host/hiddata.h
===================================================================
--- vusb-20121206/libs-host/hiddata.h	(nonexistent)
+++ vusb-20121206/libs-host/hiddata.h	(working copy)
@@ -0,0 +1,70 @@
+/* Name: hiddata.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __HIDDATA_H_INCLUDED__
+#define __HIDDATA_H_INCLUDED__
+
+/*
+General Description:
+This module implements an abstraction layer for data transfer over HID feature
+requests. The implementation uses native Windows functions on Windows so that
+no driver installation is required and libusb on Unix. You must link the
+appropriate libraries in either case: "-lhid -lusb -lsetupapi" on Windows and
+`libusb-config --libs` on Unix.
+*/
+
+/* ------------------------------------------------------------------------ */
+
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+/* ------------------------------------------------------------------------ */
+
+typedef struct usbDevice    usbDevice_t;
+/* Opaque data type representing the USB device. This can be a Windows handle
+ * or a libusb handle, depending on the backend implementation.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidOpenDevice(usbDevice_t **device, int vendorID, char *vendorName, int productID, char *productName, int usesReportIDs);
+/* This function opens a USB device. 'vendorID' and 'productID' are the numeric
+ * Vendor-ID and Product-ID of the device we want to open. If 'vendorName' and
+ * 'productName' are both not NULL, only devices with matching manufacturer-
+ * and product name strings are accepted. If the device uses report IDs,
+ * 'usesReportIDs' must be set to a non-zero value.
+ * Returns: If a matching device has been found, USBOPEN_SUCCESS is returned
+ * and '*device' is set to an opaque pointer representing the device. The
+ * device must be closed with usbhidCloseDevice(). If the device has not been
+ * found or opening failed, an error code is returned.
+ */
+void    usbhidCloseDevice(usbDevice_t *device);
+/* Every device opened with usbhidOpenDevice() must be closed with this function.
+ */
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len);
+/* This function sends a feature report to the device. The report ID must be
+ * in the first byte of buffer and the length 'len' of the report is specified
+ * including this report ID. If no report IDs are used, buffer[0] must be set
+ * to 0 (dummy report ID).
+ * Returns: 0 on success, an error code otherwise.
+ */
+int usbhidGetReport(usbDevice_t *device, int reportID, char *buffer, int *len);
+/* This function obtains a feature report from the device. The requested
+ * report-ID is passed in 'reportID'. The caller must pass a buffer of the size
+ * of the expected report in 'buffer' and initialize the variable pointed to by
+ * 'len' to the total size of this buffer. Upon successful return, the report
+ * (prefixed with the report-ID) is in 'buffer' and the actual length of the
+ * report is returned in '*len'.
+ * Returns: 0 on success, an error code otherwise.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+#endif /* __HIDDATA_H_INCLUDED__ */
Index: vusb-20121206/libs-host/hidsdi.h
===================================================================
--- vusb-20121206/libs-host/hidsdi.h	(nonexistent)
+++ vusb-20121206/libs-host/hidsdi.h	(working copy)
@@ -0,0 +1,48 @@
+/* Name: hidsdi.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-02-02
+ * Tabsize: 4
+ * Copyright: (c) 2006-2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description
+This file is a replacement for hidsdi.h from the Windows DDK. It defines some
+of the types and function prototypes of this header for our project. If you
+have the Windows DDK version of this file or a version shipped with MinGW, use
+that instead.
+*/
+
+#ifndef _HIDSDI_H
+#define _HIDSDI_H
+
+#include <pshpack4.h>
+
+#include <ddk/hidusage.h>
+#include <ddk/hidpi.h>
+
+typedef struct{
+    ULONG   Size;
+    USHORT  VendorID;
+    USHORT  ProductID;
+    USHORT  VersionNumber;
+}HIDD_ATTRIBUTES;
+
+void __stdcall      HidD_GetHidGuid(OUT LPGUID hidGuid);
+
+BOOLEAN __stdcall   HidD_GetAttributes(IN HANDLE device, OUT HIDD_ATTRIBUTES *attributes);
+
+BOOLEAN __stdcall   HidD_GetManufacturerString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetProductString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetSerialNumberString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetFeature(IN HANDLE device, OUT void *reportBuffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_SetFeature(IN HANDLE device, IN void *reportBuffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetNumInputBuffers(IN HANDLE device, OUT ULONG *numBuffers);
+BOOLEAN __stdcall   HidD_SetNumInputBuffers(IN HANDLE device, OUT ULONG numBuffers);
+
+#include <poppack.h>
+
+#endif
Index: vusb-20121206/libs-host/opendevice.c
===================================================================
--- vusb-20121206/libs-host/opendevice.c	(nonexistent)
+++ vusb-20121206/libs-host/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/libs-host/opendevice.h
===================================================================
--- vusb-20121206/libs-host/opendevice.h	(nonexistent)
+++ vusb-20121206/libs-host/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/tests/Makefile
===================================================================
--- vusb-20121206/tests/Makefile	(nonexistent)
+++ vusb-20121206/tests/Makefile	(working copy)
@@ -0,0 +1,126 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = attiny2313
+F_CPU   = 16000000	# in Hz
+DEFINES =
+
+CFLAGS  = $(DEFINES) -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+SIZES_TMP = /tmp/sizetmp.txt
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make clean ..... to delete objects and hex file"
+	@echo "make sizes ..... compute code and RAM sizes for various options"
+	@echo "make test ...... test with all features whether everything compiles"
+
+sizes sizes.txt:
+	rm -f $(SIZES_TMP) sizes.txt
+	$(MAKE) null.elf
+	avr-size null.elf | tail -1 | awk '{print "null", $$1+$$2, $$3+$$2}' >$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_16_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=12000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_12_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=12800000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_12_8_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=15000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_15_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=16500000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_16_5_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=18000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_18_MHz+CRC", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=20000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_20_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf DEFINES=-DUSB_CFG_IMPLEMENT_FN_WRITE=1
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionWrite", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf DEFINES=-DUSB_CFG_IMPLEMENT_FN_READ=1
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionRead", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_IMPLEMENT_FN_READ=1 -DUSB_CFG_IMPLEMENT_FN_WRITE=1"
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionRead_and_Write", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_IMPLEMENT_FN_WRITEOUT=1"
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionWriteOut", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_HAVE_INTRIN_ENDPOINT=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Interrupt_In_Endpoint_1", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_IMPLEMENT_HALT=1 -DUSB_CFG_HAVE_INTRIN_ENDPOINT=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Interrupt_In_Endpoint_1_and_Halt", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_HAVE_INTRIN_ENDPOINT3=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Interrupt_In_Endpoint_1_and_3", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSE_DYNAMIC_DESCRIPTOR=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Dynamic_Descriptor", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_LONG_TRANSFERS=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Long_Transfers", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	cat $(SIZES_TMP) | awk 'BEGIN{printf("%39s %5s %5s %5s %5s\n"), "Variation", "Flash", "RAM", "+F", "+RAM"}\
+		/^null/{nullRom=$$2; nullRam=$$3; next} \
+		{rom=$$2-nullRom; ram=$$3-nullRam; if(!refRom){refRom=rom; refRam=ram} \
+		printf("%39s %5d %5d %+5d %+5d\n", $$1, rom, ram, rom-refRom, ram-refRam)}' | tee sizes.txt
+	rm $(SIZES_TMP)
+
+test:
+	for freq in 12000000 12800000 15000000 16000000 16500000 18000000 20000000; do \
+		for opt in USB_COUNT_SOF USB_CFG_HAVE_INTRIN_ENDPOINT USB_CFG_HAVE_INTRIN_ENDPOINT3 USB_CFG_HAVE_MEASURE_FRAME_LENGTH USB_CFG_LONG_TRANSFERS; do \
+			$(MAKE) clean; $(MAKE) main.elf F_CPU=$$freq "DEFINES=-D$$opt=1" || exit 1; \
+			$(MAKE) clean; $(MAKE) main.elf F_CPU=$$freq "DEFINES=-D$$opt=1 -DDUSB_CFG_IMPLEMENT_FN_WRITEOUT=1" || exit 1; \
+		done \
+	done
+
+# The following rule is used to check the compiler
+devices: #exclude devices without RAM for stack and atmega603 for gcc 3
+	excludes="at90s1200 attiny11 attiny12 attiny15 attiny28"; \
+	for gccVersion in 3 4; do \
+		avr-gcc-select $$gccVersion; \
+		for device in `echo | avr-gcc -xc -mmcu=x - 2>&1 | egrep '^ *at[a-zA-Z0-9_-]+$$'`; do \
+			if echo "$$excludes" | grep "$$device" >/dev/null; then continue; fi; \
+			if [ "$$gccVersion" = 3 -a "$$device" = atmega603 ]; then continue; fi; \
+			$(MAKE) clean; $(MAKE) null.elf DEVICE=$$device || exit 1; \
+		done \
+	done
+	$(MAKE) clean
+	avr-gcc-select 3
+	@echo "+++ Device test succeeded!"
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f *.hex *.lst *.map  *.elf *.o
+	rm -rf usbdrv
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main_i.elf: usbdrv main.o usbdrv/usbdrvasm.o	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main_i.elf main.o usbdrv/usbdrvasm.o
+
+null.elf: null.o
+	$(COMPILE) -o null.elf null.o
Index: vusb-20121206/tests/Readme.txt
===================================================================
--- vusb-20121206/tests/Readme.txt	(nonexistent)
+++ vusb-20121206/tests/Readme.txt	(working copy)
@@ -0,0 +1,13 @@
+This is the Readme file for the directory "tests" of V-USB, a firmware-only
+USB driver for AVR microcontrollers.
+
+WHAT IS IN THIS DIRECTORY?
+==========================
+This directory is for driver development only. It contains tests to check
+whether all branches of #ifdef code compile as they should and whether the
+code size of the driver increased.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/tests/compare-sizes.awk
===================================================================
--- vusb-20121206/tests/compare-sizes.awk	(nonexistent)
+++ vusb-20121206/tests/compare-sizes.awk	(working copy)
@@ -0,0 +1,44 @@
+#!/usr/bin/awk -f
+# Name: compare-sizes.awk
+# Project: v-usb
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-29
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+BEGIN{
+	opt = 0;
+	if(ARGC != 3){
+		printf("usage: compare-sizes.awk file1 file2\n");
+		printf("  computes size differences between two size lists\n");
+		exit 1;
+	}
+	file1 = ARGV[1];
+	file2 = ARGV[2];
+}
+
+{
+	if(($2 + 0) != 0){
+		if(!hadOption[$1]){
+			hadOption[$1] = 1;
+			options[opt++] = $1;
+		}
+		flash[FILENAME, $1] = $2;
+		ram[FILENAME, $1] = $3;
+	}
+}
+
+END{
+	if(opt > 0){
+		printf ("%39s %6s %5s\n", "Variation", "+Flash", "+RAM");
+	}
+	for(i = 0; i < opt; i++){
+		option = options[i];
+        if(!flash[file2, option] || !flash[file1, option]){
+            printf("%39s %6s %5s\n", option, "n/a", "n/a");
+        }else{
+            printf("%39s %+6d %+5d\n", option, flash[file2, option] - flash[file1, option], ram[file2, option] - ram[file1, option]);
+        }
+	}
+}
Index: vusb-20121206/tests/main.c
===================================================================
--- vusb-20121206/tests/main.c	(nonexistent)
+++ vusb-20121206/tests/main.c	(working copy)
@@ -0,0 +1,158 @@
+/* Name: main.c
+ * Project: Testing driver features
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-29
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This module is a do-nothing test code linking against (or including) the USB
+driver. It is used to determine the code size for various options and to
+check whether the code compiles with all options.
+*/
+#include <avr/io.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include <util/delay.h>     /* for _delay_ms() */
+#include "usbdrv.h"
+#if USE_INCLUDE
+#include "usbdrv.c"
+#endif
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#if USB_CFG_IMPLEMENT_FN_WRITE
+uchar usbFunctionWrite(uchar *data, uchar len)
+{
+    return 1;
+}
+#endif
+
+#if USB_CFG_IMPLEMENT_FN_READ
+uchar usbFunctionRead(uchar *data, uchar len)
+{
+    return len;
+}
+#endif
+
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+void usbFunctionWriteOut(uchar *data, uchar len)
+{
+}
+#endif
+
+#if USE_DYNAMIC_DESCRIPTOR
+
+static PROGMEM const char myDescriptorDevice[] = {    /* USB device descriptor */
+    18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
+    USBDESCR_DEVICE,        /* descriptor type */
+    0x10, 0x01,             /* USB version supported */
+    USB_CFG_DEVICE_CLASS,
+    USB_CFG_DEVICE_SUBCLASS,
+    0,                      /* protocol */
+    8,                      /* max packet size */
+    /* the following two casts affect the first byte of the constant only, but
+     * that's sufficient to avoid a warning with the default values.
+     */
+    (char)USB_CFG_VENDOR_ID,/* 2 bytes */
+    (char)USB_CFG_DEVICE_ID,/* 2 bytes */
+    USB_CFG_DEVICE_VERSION, /* 2 bytes */
+    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
+    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
+    1,          /* number of configurations */
+};
+
+static PROGMEM const char myDescriptorConfiguration[] = { /* USB configuration descriptor */
+    9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
+    USBDESCR_CONFIG,    /* descriptor type */
+    18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
+                /* total length of data returned (including inlined descriptors) */
+    1,          /* number of interfaces in this configuration */
+    1,          /* index of this configuration */
+    0,          /* configuration name string index */
+#if USB_CFG_IS_SELF_POWERED
+    USBATTR_SELFPOWER,      /* attributes */
+#else
+    0,                      /* attributes */
+#endif
+    USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
+/* interface descriptor follows inline: */
+    9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
+    USBDESCR_INTERFACE, /* descriptor type */
+    0,          /* index of this interface */
+    0,          /* alternate setting for this interface */
+    USB_CFG_HAVE_INTRIN_ENDPOINT,   /* endpoints excl 0: number of endpoint descriptors to follow */
+    USB_CFG_INTERFACE_CLASS,
+    USB_CFG_INTERFACE_SUBCLASS,
+    USB_CFG_INTERFACE_PROTOCOL,
+    0,          /* string index for interface */
+#if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
+    9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
+    USBDESCR_HID,   /* descriptor type: HID */
+    0x01, 0x01, /* BCD representation of HID version */
+    0x00,       /* target country code */
+    0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
+    0x22,       /* descriptor type: report */
+    USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)0x81, /* IN endpoint number 1 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+};
+
+USB_PUBLIC usbMsgLen_t usbFunctionDescriptor(usbRequest_t *rq)
+{
+uchar *p = 0, len = 0;
+
+    if(rq->wValue.bytes[1] == USBDESCR_DEVICE){
+        p = (uchar *)myDescriptorDevice;
+        len = sizeof(myDescriptorDevice);
+    }else{  /* must be configuration descriptor */
+        p = (uchar *)(myDescriptorConfiguration);
+        len = sizeof(myDescriptorConfiguration);
+    }
+    usbMsgPtr = (usbMsgPtr_t)p;
+    return len;
+}
+#endif
+
+USB_PUBLIC usbMsgLen_t  usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if(rq->bRequest == 0)   /* request using usbFunctionRead()/usbFunctionWrite() */
+        return 0xff;
+	return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int	main(void)
+{
+uchar   i;
+
+	usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+	sei();
+	for(;;){                /* main event loop */
+		usbPoll();
+	}
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/tests/null.c
===================================================================
--- vusb-20121206/tests/null.c	(nonexistent)
+++ vusb-20121206/tests/null.c	(working copy)
@@ -0,0 +1,25 @@
+/* Name: null.c
+ * Project: Testing driver features
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-29
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This is a NULL main() function to find out the code size required by libusb's
+startup code, interrupt vectors etc.
+*/
+#include <avr/io.h>
+
+
+/* ------------------------------------------------------------------------- */
+
+int	main(void)
+{
+    for(;;);
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,13 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1154    45    +0    +0
+                    Minimum_with_12_MHz  1274    45  +120    +0
+                    Minimum_with_15_MHz  1260    45  +106    +0
+                  Minimum_with_16_5_MHz  1276    45  +122    +0
+                  With_usbFunctionWrite  1214    45   +60    +0
+                   With_usbFunctionRead  1200    45   +46    +0
+         With_usbFunctionRead_and_Write  1246    45   +92    +0
+               With_usbFunctionWriteOut  1178    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1284    58  +130   +13
+  With_Interrupt_In_Endpoint_1_and_Halt  1372    58  +218   +13
+     With_Interrupt_In_Endpoint_1_and_3  1386    69  +232   +24
+                With_Dynamic_Descriptor  1186    45   +32    +0
Index: vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt	(working copy)
@@ -0,0 +1,13 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1208    45    +0    +0
+                    Minimum_with_12_MHz  1328    45  +120    +0
+                    Minimum_with_15_MHz  1314    45  +106    +0
+                  Minimum_with_16_5_MHz  1330    45  +122    +0
+                  With_usbFunctionWrite  1268    45   +60    +0
+                   With_usbFunctionRead  1264    45   +56    +0
+         With_usbFunctionRead_and_Write  1314    45  +106    +0
+               With_usbFunctionWriteOut  1218    45   +10    +0
+           With_Interrupt_In_Endpoint_1  1340    58  +132   +13
+  With_Interrupt_In_Endpoint_1_and_Halt  1414    58  +206   +13
+     With_Interrupt_In_Endpoint_1_and_3  1426    69  +218   +24
+                With_Dynamic_Descriptor  1238    45   +30    +0
Index: vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,15 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1154    45    +0    +0
+                    Minimum_with_12_MHz  1274    45  +120    +0
+                    Minimum_with_15_MHz  1260    45  +106    +0
+                  Minimum_with_16_5_MHz  1276    45  +122    +0
+                    Minimum_with_20_MHz  1136    45   -18    +0
+                  With_usbFunctionWrite  1214    45   +60    +0
+                   With_usbFunctionRead  1192    45   +38    +0
+         With_usbFunctionRead_and_Write  1234    45   +80    +0
+               With_usbFunctionWriteOut  1178    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1280    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1370    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1346    69  +192   +24
+                With_Dynamic_Descriptor  1182    45   +28    +0
+                    With_Long_Transfers  1200    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,15 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1192    45    +0    +0
+                    Minimum_with_12_MHz  1312    45  +120    +0
+                    Minimum_with_15_MHz  1298    45  +106    +0
+                  Minimum_with_16_5_MHz  1314    45  +122    +0
+                    Minimum_with_20_MHz  1174    45   -18    +0
+                  With_usbFunctionWrite  1246    45   +54    +0
+                   With_usbFunctionRead  1242    45   +50    +0
+         With_usbFunctionRead_and_Write  1280    45   +88    +0
+               With_usbFunctionWriteOut  1208    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1320    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1410    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1428    69  +236   +24
+                With_Dynamic_Descriptor  1212    45   +20    +0
+                    With_Long_Transfers  1270    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1194    45    +0    +0
+                    Minimum_with_12_MHz  1244    45   +50    +0
+                  Minimum_with_12_8_MHz  1564    45  +370    +0
+                    Minimum_with_15_MHz  1300    45  +106    +0
+                  Minimum_with_16_5_MHz  1316    45  +122    +0
+                    Minimum_with_20_MHz  1176    45   -18    +0
+                  With_usbFunctionWrite  1248    45   +54    +0
+                   With_usbFunctionRead  1244    45   +50    +0
+         With_usbFunctionRead_and_Write  1282    45   +88    +0
+               With_usbFunctionWriteOut  1210    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1322    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1412    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1430    69  +236   +24
+                With_Dynamic_Descriptor  1214    45   +20    +0
+                    With_Long_Transfers  1272    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1194    45    +0    +0
+                    Minimum_with_12_MHz  1244    45   +50    +0
+                  Minimum_with_12_8_MHz  1564    45  +370    +0
+                    Minimum_with_15_MHz  1300    45  +106    +0
+                  Minimum_with_16_5_MHz  1316    45  +122    +0
+                    Minimum_with_20_MHz  1176    45   -18    +0
+                  With_usbFunctionWrite  1248    45   +54    +0
+                   With_usbFunctionRead  1244    45   +50    +0
+         With_usbFunctionRead_and_Write  1282    45   +88    +0
+               With_usbFunctionWriteOut  1210    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1322    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1412    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1430    69  +236   +24
+                With_Dynamic_Descriptor  1214    45   +20    +0
+                    With_Long_Transfers  1272    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1224    45    +0    +0
+                    Minimum_with_12_MHz  1274    45   +50    +0
+                  Minimum_with_12_8_MHz  1594    45  +370    +0
+                    Minimum_with_15_MHz  1330    45  +106    +0
+                  Minimum_with_16_5_MHz  1346    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1074    +0
+                    Minimum_with_20_MHz  1206    45   -18    +0
+                  With_usbFunctionWrite  1284    45   +60    +0
+                   With_usbFunctionRead  1280    45   +56    +0
+         With_usbFunctionRead_and_Write  1318    45   +94    +0
+               With_usbFunctionWriteOut  1246    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1358    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1448    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1466    69  +242   +24
+                With_Dynamic_Descriptor  1250    45   +26    +0
+                    With_Long_Transfers  1302    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1224    45    +0    +0
+                    Minimum_with_12_MHz  1274    45   +50    +0
+                  Minimum_with_12_8_MHz  1594    45  +370    +0
+                    Minimum_with_15_MHz  1330    45  +106    +0
+                  Minimum_with_16_5_MHz  1346    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1074    +0
+                    Minimum_with_20_MHz  1206    45   -18    +0
+                  With_usbFunctionWrite  1284    45   +60    +0
+                   With_usbFunctionRead  1280    45   +56    +0
+         With_usbFunctionRead_and_Write  1318    45   +94    +0
+               With_usbFunctionWriteOut  1246    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1358    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1448    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1466    69  +242   +24
+                With_Dynamic_Descriptor  1250    45   +26    +0
+                    With_Long_Transfers  1302    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1518    45  +366    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1226    45    +0    +0
+                    Minimum_with_12_MHz  1276    45   +50    +0
+                  Minimum_with_12_8_MHz  1592    45  +366    +0
+                    Minimum_with_15_MHz  1332    45  +106    +0
+                  Minimum_with_16_5_MHz  1348    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1072    +0
+                    Minimum_with_20_MHz  1208    45   -18    +0
+                  With_usbFunctionWrite  1286    45   +60    +0
+                   With_usbFunctionRead  1282    45   +56    +0
+         With_usbFunctionRead_and_Write  1320    45   +94    +0
+               With_usbFunctionWriteOut  1248    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1360    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1450    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1418    69  +192   +24
+                With_Dynamic_Descriptor  1252    45   +26    +0
+                    With_Long_Transfers  1304    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1518    45  +366    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1206    47   +54    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1226    45    +0    +0
+                    Minimum_with_12_MHz  1276    45   +50    +0
+                  Minimum_with_12_8_MHz  1592    45  +366    +0
+                    Minimum_with_15_MHz  1332    45  +106    +0
+                  Minimum_with_16_5_MHz  1348    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1072    +0
+                    Minimum_with_20_MHz  1208    45   -18    +0
+                  With_usbFunctionWrite  1286    45   +60    +0
+                   With_usbFunctionRead  1282    45   +56    +0
+         With_usbFunctionRead_and_Write  1320    45   +94    +0
+               With_usbFunctionWriteOut  1248    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1360    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1450    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1418    69  +192   +24
+                With_Dynamic_Descriptor  1252    45   +26    +0
+                    With_Long_Transfers  1300    47   +74    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1192    45    +0    +0
+                    Minimum_with_12_MHz  1242    45   +50    +0
+                  Minimum_with_12_8_MHz  1558    45  +366    +0
+                    Minimum_with_15_MHz  1298    45  +106    +0
+                  Minimum_with_16_5_MHz  1314    45  +122    +0
+                Minimum_with_18_MHz+CRC  2262    45 +1070    +0
+                    Minimum_with_20_MHz  1174    45   -18    +0
+                  With_usbFunctionWrite  1252    45   +60    +0
+                   With_usbFunctionRead  1248    45   +56    +0
+         With_usbFunctionRead_and_Write  1286    45   +94    +0
+               With_usbFunctionWriteOut  1214    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1328    57  +136   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1420    57  +228   +12
+     With_Interrupt_In_Endpoint_1_and_3  1386    69  +194   +24
+                With_Dynamic_Descriptor  1198    45    +6    +0
+                    With_Long_Transfers  1236    47   +44    +2
Index: vusb-20121206/tests/usbconfig.h
===================================================================
--- vusb-20121206/tests/usbconfig.h	(nonexistent)
+++ vusb-20121206/tests/usbconfig.h	(working copy)
@@ -0,0 +1,295 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This is the config file for tests. It is not updated to the latest set of
+features. Don't use it as a prototype, use usbconfig-prototype.h instead!
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+#define USB_CFG_DMINUS_BIT      4
+#define USB_CFG_DPLUS_BIT       2
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+#define USB_CFG_CHECK_CRC       (USB_CFG_CLOCK_KHZ == 18000)
+
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#ifndef USB_CFG_HAVE_INTRIN_ENDPOINT3
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+#endif
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#ifndef USB_CFG_HAVE_INTRIN_ENDPOINT
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    USB_CFG_HAVE_INTRIN_ENDPOINT3
+#endif
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+//#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+//#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+//#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+//#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+//#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+//#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+//#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you use one of obdev's free shared
+ * VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ */
+#define  USB_CFG_DEVICE_ID       0x08, 0x3e /* 1000 dec, "free for lab use" */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you use obdev's free shared VID/PID pair. Be sure to read the rules in
+ * USB-IDs-for-free.txt!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'T', 'e', 's', 't'
+#define USB_CFG_DEVICE_NAME_LEN 4
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor().
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ */
+
+#if USE_DYNAMIC_DESCRIPTOR
+#define USB_CFG_DESCR_PROPS_DEVICE                  USB_PROP_IS_DYNAMIC
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           USB_PROP_IS_DYNAMIC
+#else
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#endif
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/usbdrv/Changelog.txt
===================================================================
--- vusb-20121206/usbdrv/Changelog.txt	(nonexistent)
+++ vusb-20121206/usbdrv/Changelog.txt	(working copy)
@@ -0,0 +1,329 @@
+This file documents changes in the firmware-only USB driver for atmel's AVR
+microcontrollers. New entries are always appended to the end of the file.
+Scroll down to the bottom to see the most recent changes.
+
+2005-04-01:
+  - Implemented endpoint 1 as interrupt-in endpoint.
+  - Moved all configuration options to usbconfig.h which is not part of the
+    driver.
+  - Changed interface for usbVendorSetup().
+  - Fixed compatibility with ATMega8 device.
+  - Various minor optimizations.
+
+2005-04-11:
+  - Changed interface to application: Use usbFunctionSetup(), usbFunctionRead()
+    and usbFunctionWrite() now. Added configuration options to choose which
+    of these functions to compile in.
+  - Assembler module delivers receive data non-inverted now.
+  - Made register and bit names compatible with more AVR devices.
+
+2005-05-03:
+  - Allow address of usbRxBuf on any memory page as long as the buffer does
+    not cross 256 byte page boundaries.
+  - Better device compatibility: works with Mega88 now.
+  - Code optimization in debugging module.
+  - Documentation updates.
+
+2006-01-02:
+  - Added (free) default Vendor- and Product-IDs bought from voti.nl.
+  - Added USBID-License.txt file which defines the rules for using the free
+    shared VID/PID pair.
+  - Added Readme.txt to the usbdrv directory which clarifies administrative
+    issues.
+
+2006-01-25:
+  - Added "configured state" to become more standards compliant.
+  - Added "HALT" state for interrupt endpoint.
+  - Driver passes the "USB Command Verifier" test from usb.org now.
+  - Made "serial number" a configuration option.
+  - Minor optimizations, we now recommend compiler option "-Os" for best
+    results.
+  - Added a version number to usbdrv.h
+
+2006-02-03:
+  - New configuration variable USB_BUFFER_SECTION for the memory section where
+    the USB rx buffer will go. This defaults to ".bss" if not defined. Since
+    this buffer MUST NOT cross 256 byte pages (not even touch a page at the
+    end), the user may want to pass a linker option similar to
+    "-Wl,--section-start=.mybuffer=0x800060".
+  - Provide structure for usbRequest_t.
+  - New defines for USB constants.
+  - Prepared for HID implementations.
+  - Increased data size limit for interrupt transfers to 8 bytes.
+  - New macro usbInterruptIsReady() to query interrupt buffer state.
+
+2006-02-18:
+  - Ensure that the data token which is sent as an ack to an OUT transfer is
+    always zero sized. This fixes a bug where the host reports an error after
+    sending an out transfer to the device, although all data arrived at the
+    device.
+  - Updated docs in usbdrv.h to reflect changed API in usbFunctionWrite().
+
+* Release 2006-02-20
+
+  - Give a compiler warning when compiling with debugging turned on.
+  - Added Oleg Semyonov's changes for IAR-cc compatibility.
+  - Added new (optional) functions usbDeviceConnect() and usbDeviceDisconnect()
+    (also thanks to Oleg!).
+  - Rearranged tests in usbPoll() to save a couple of instructions in the most
+    likely case that no actions are pending.
+  - We need a delay between the SET ADDRESS request until the new address
+    becomes active. This delay was handled in usbPoll() until now. Since the
+    spec says that the delay must not exceed 2ms, previous versions required
+    aggressive polling during the enumeration phase. We have now moved the
+    handling of the delay into the interrupt routine.
+  - We must not reply with NAK to a SETUP transaction. We can only achieve this
+    by making sure that the rx buffer is empty when SETUP tokens are expected.
+    We therefore don't pass zero sized data packets from the status phase of
+    a transfer to usbPoll(). This change MAY cause troubles if you rely on
+    receiving a less than 8 bytes long packet in usbFunctionWrite() to
+    identify the end of a transfer. usbFunctionWrite() will NEVER be called
+    with a zero length.
+
+* Release 2006-03-14
+
+  - Improved IAR C support: tiny memory model, more devices
+  - Added template usbconfig.h file under the name usbconfig-prototype.h
+
+* Release 2006-03-26
+
+  - Added provision for one more interrupt-in endpoint (endpoint 3).
+  - Added provision for one interrupt-out endpoint (endpoint 1).
+  - Added flowcontrol macros for USB.
+  - Added provision for custom configuration descriptor.
+  - Allow ANY two port bits for D+ and D-.
+  - Merged (optional) receive endpoint number into global usbRxToken variable.
+  - Use USB_CFG_IOPORTNAME instead of USB_CFG_IOPORT. We now construct the
+    variable name from the single port letter instead of computing the address
+    of related ports from the output-port address.
+
+* Release 2006-06-26
+
+  - Updated documentation in usbdrv.h and usbconfig-prototype.h to reflect the
+    new features.
+  - Removed "#warning" directives because IAR does not understand them. Use
+    unused static variables instead to generate a warning.
+  - Do not include <avr/io.h> when compiling with IAR.
+  - Introduced USB_CFG_DESCR_PROPS_* in usbconfig.h to configure how each
+    USB descriptor should be handled. It is now possible to provide descriptor
+    data in Flash, RAM or dynamically at runtime.
+  - STALL is now a status in usbTxLen* instead of a message. We can now conform
+    to the spec and leave the stall status pending until it is cleared.
+  - Made usbTxPacketCnt1 and usbTxPacketCnt3 public. This allows the
+    application code to reset data toggling on interrupt pipes.
+
+* Release 2006-07-18
+
+  - Added an #if !defined __ASSEMBLER__ to the warning in usbdrv.h. This fixes
+    an assembler error.
+  - usbDeviceDisconnect() takes pull-up resistor to high impedance now.
+
+* Release 2007-02-01
+
+  - Merged in some code size improvements from usbtiny (thanks to Dick
+    Streefland for these optimizations!)
+  - Special alignment requirement for usbRxBuf not required any more. Thanks
+    again to Dick Streefland for this hint!
+  - Reverted to "#warning" instead of unused static variables -- new versions
+    of IAR CC should handle this directive.
+  - Changed Open Source license to GNU GPL v2 in order to make linking against
+    other free libraries easier. We no longer require publication of the
+    circuit diagrams, but we STRONGLY encourage it. If you improve the driver
+    itself, PLEASE grant us a royalty free license to your changes for our
+    commercial license.
+
+* Release 2007-03-29
+
+  - New configuration option "USB_PUBLIC" in usbconfig.h.
+  - Set USB version number to 1.10 instead of 1.01.
+  - Code used USB_CFG_DESCR_PROPS_STRING_DEVICE and
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT inconsistently. Changed all occurrences
+    to USB_CFG_DESCR_PROPS_STRING_PRODUCT.
+  - New assembler module for 16.5 MHz RC oscillator clock with PLL in receiver
+    code.
+  - New assembler module for 16 MHz crystal.
+  - usbdrvasm.S contains common code only, clock-specific parts have been moved
+    to usbdrvasm12.S, usbdrvasm16.S and usbdrvasm165.S respectively.
+
+* Release 2007-06-25
+
+  - 16 MHz module: Do SE0 check in stuffed bits as well.
+
+* Release 2007-07-07
+
+  - Define hi8(x) for IAR compiler to limit result to 8 bits. This is necessary
+    for negative values.
+  - Added 15 MHz module contributed by V. Bosch.
+  - Interrupt vector name can now be configured. This is useful if somebody
+    wants to use a different hardware interrupt than INT0.
+
+* Release 2007-08-07
+
+  - Moved handleIn3 routine in usbdrvasm16.S so that relative jump range is
+    not exceeded.
+  - More config options: USB_RX_USER_HOOK(), USB_INITIAL_DATATOKEN,
+    USB_COUNT_SOF
+  - USB_INTR_PENDING can now be a memory address, not just I/O
+
+* Release 2007-09-19
+
+  - Split out common parts of assembler modules into separate include file
+  - Made endpoint numbers configurable so that given interface definitions
+    can be matched. See USB_CFG_EP3_NUMBER in usbconfig-prototype.h.
+  - Store endpoint number for interrupt/bulk-out so that usbFunctionWriteOut()
+    can handle any number of endpoints.
+  - Define usbDeviceConnect() and usbDeviceDisconnect() even if no
+    USB_CFG_PULLUP_IOPORTNAME is defined. Directly set D+ and D- to 0 in this
+    case.
+
+* Release 2007-12-01
+
+  - Optimize usbDeviceConnect() and usbDeviceDisconnect() for less code size
+    when USB_CFG_PULLUP_IOPORTNAME is not defined.
+
+* Release 2007-12-13
+
+  - Renamed all include-only assembler modules from *.S to *.inc so that
+    people don't add them to their project sources.
+  - Distribute leap bits in tx loop more evenly for 16 MHz module.
+  - Use "macro" and "endm" instead of ".macro" and ".endm" for IAR
+  - Avoid compiler warnings for constant expr range by casting some values in
+    USB descriptors.
+
+* Release 2008-01-21
+
+  - Fixed bug in 15 and 16 MHz module where the new address set with
+    SET_ADDRESS was already accepted at the next NAK or ACK we send, not at
+    the next data packet we send. This caused problems when the host polled
+    too fast. Thanks to Alexander Neumann for his help and patience debugging
+    this issue!
+
+* Release 2008-02-05
+
+  - Fixed bug in 16.5 MHz module where a register was used in the interrupt
+    handler before it was pushed. This bug was introduced with version
+    2007-09-19 when common parts were moved to a separate file.
+  - Optimized CRC routine (thanks to Reimar Doeffinger).
+
+* Release 2008-02-16
+
+  - Removed outdated IAR compatibility stuff (code sections).
+  - Added hook macros for USB_RESET_HOOK() and USB_SET_ADDRESS_HOOK().
+  - Added optional routine usbMeasureFrameLength() for calibration of the
+    internal RC oscillator.
+
+* Release 2008-02-28
+
+  - USB_INITIAL_DATATOKEN defaults to USBPID_DATA1 now, which means that we
+    start with sending USBPID_DATA0.
+  - Changed defaults in usbconfig-prototype.h
+  - Added free USB VID/PID pair for MIDI class devices
+  - Restructured AVR-USB as separate package, not part of PowerSwitch any more.
+
+* Release 2008-04-18
+
+  - Restructured usbdrv.c so that it is easier to read and understand.
+  - Better code optimization with gcc 4.
+  - If a second interrupt in endpoint is enabled, also add it to config
+    descriptor.
+  - Added config option for long transfers (above 254 bytes), see
+    USB_CFG_LONG_TRANSFERS in usbconfig.h.
+  - Added 20 MHz module contributed by Jeroen Benschop.
+
+* Release 2008-05-13
+
+  - Fixed bug in libs-host/hiddata.c function usbhidGetReport(): length
+    was not incremented, pointer to length was incremented instead.
+  - Added code to command line tool(s) which claims an interface. This code
+    is disabled by default, but may be necessary on newer Linux kernels.
+  - Added usbconfig.h option "USB_CFG_CHECK_DATA_TOGGLING".
+  - New header "usbportability.h" prepares ports to other development
+    environments.
+  - Long transfers (above 254 bytes) did not work when usbFunctionRead() was
+    used to supply the data. Fixed this bug. [Thanks to Alexander Neumann!]
+  - In hiddata.c (example code for sending/receiving data over HID), use
+    USB_RECIP_DEVICE instead of USB_RECIP_INTERFACE for control transfers so
+    that we need not claim the interface.
+  - in usbPoll() loop 20 times polling for RESET state instead of 10 times.
+    This accounts for the higher clock rates we now support.
+  - Added a module for 12.8 MHz RC oscillator with PLL in receiver loop.
+  - Added hook to SOF code so that oscillator can be tuned to USB frame clock.
+  - Added timeout to waitForJ loop. Helps preventing unexpected hangs.
+  - Added example code for oscillator tuning to libs-device (thanks to
+    Henrik Haftmann for the idea to this routine).
+  - Implemented option USB_CFG_SUPPRESS_INTR_CODE.
+
+* Release 2008-10-22
+
+  - Fixed libs-device/osctune.h: OSCCAL is memory address on ATMega88 and
+    similar, not offset of 0x20 needs to be added.
+  - Allow distribution under GPLv3 for those who have to link against other
+    code distributed under GPLv3.
+
+* Release 2008-11-26
+
+  - Removed libusb-win32 dependency for hid-data example in Makefile.windows.
+    It was never required and confused many people.
+  - Added extern uchar usbRxToken to usbdrv.h.
+  - Integrated a module with CRC checks at 18 MHz by Lukas Schrittwieser.
+
+* Release 2009-03-23
+
+  - Hid-mouse example used settings from hid-data example, fixed that.
+  - Renamed project to V-USB due to a trademark issue with Atmel(r).
+  - Changed CommercialLicense.txt and USBID-License.txt to make the
+    background of USB ID registration clearer.
+
+* Release 2009-04-15
+
+  - Changed CommercialLicense.txt to reflect the new range of PIDs from
+    Jason Kotzin.
+  - Removed USBID-License.txt in favor of USB-IDs-for-free.txt and
+    USB-ID-FAQ.txt
+  - Fixed a bug in the 12.8 MHz module: End Of Packet decection was made in
+    the center between bit 0 and 1 of each byte. This is where the data lines
+    are expected to change and the sampled data may therefore be nonsense.
+    We therefore check EOP ONLY if bits 0 AND 1 have both been read as 0 on D-.
+  - Fixed a bitstuffing problem in the 16 MHz module: If bit 6 was stuffed,
+    the unstuffing code in the receiver routine was 1 cycle too long. If
+    multiple bytes had the unstuffing in bit 6, the error summed up until the
+    receiver was out of sync.
+  - Included option for faster CRC routine.
+    Thanks to Slawomir Fras (BoskiDialer) for this code!
+  - Updated bits in Configuration Descriptor's bmAttributes according to
+    USB 1.1 (in particular bit 7, it is a must-be-set bit now).
+
+* Release 2009-08-22
+
+  - Moved first DBG1() after odDebugInit() in all examples.
+  - Use vector INT0_vect instead of SIG_INTERRUPT0 if defined. This makes
+    V-USB compatible with the new "p" suffix devices (e.g. ATMega328p).
+  - USB_CFG_CLOCK_KHZ setting is now required in usbconfig.h (no default any
+    more).
+  - New option USB_CFG_DRIVER_FLASH_PAGE allows boot loaders on devices with
+    more than 64 kB flash.
+  - Built-in configuration descriptor allows custom definition for second
+    endpoint now.
+
+* Release 2010-07-15
+
+  - Fixed bug in usbDriverSetup() which prevented descriptor sizes above 255
+    bytes.
+  - Avoid a compiler warning for unused parameter in usbHandleResetHook() when
+    compiler option -Wextra is enabled.
+  - Fixed wrong hex value for some IDs in USB-IDs-for-free.txt.
+  - Keep a define for USBATTR_BUSPOWER, although the flag does not exist
+    in USB 1.1 any more. Set it to 0. This is for backward compatibility.
+
+* Release 2012-01-09
+
+  - Define a separate (defined) type for usbMsgPtr so that projects using a
+    tiny memory model can define it to an 8 bit type in usbconfig.h. This
+    change also saves a couple of bytes when using a scalar 16 bit type.
+  - Inserted "const" keyword for all PROGMEM declarations because new GCC
+    requires it.
+  - Fixed problem with dependence of usbportability.h on usbconfig.h. This
+    problem occurred with IAR CC only.
+  - Prepared repository for github.com.
+
+* Release 2012-12-06
\ No newline at end of file
Index: vusb-20121206/usbdrv/CommercialLicense.txt
===================================================================
--- vusb-20121206/usbdrv/CommercialLicense.txt	(nonexistent)
+++ vusb-20121206/usbdrv/CommercialLicense.txt	(working copy)
@@ -0,0 +1,166 @@
+V-USB Driver Software License Agreement
+Version 2012-07-09
+
+THIS LICENSE AGREEMENT GRANTS YOU CERTAIN RIGHTS IN A SOFTWARE. YOU CAN
+ENTER INTO THIS AGREEMENT AND ACQUIRE THE RIGHTS OUTLINED BELOW BY PAYING
+THE AMOUNT ACCORDING TO SECTION 4 ("PAYMENT") TO OBJECTIVE DEVELOPMENT.
+
+
+1 DEFINITIONS
+
+1.1 "OBJECTIVE DEVELOPMENT" shall mean OBJECTIVE DEVELOPMENT Software GmbH,
+Grosse Schiffgasse 1A/7, 1020 Wien, AUSTRIA.
+
+1.2 "You" shall mean the Licensee.
+
+1.3 "V-USB" shall mean all files included in the package distributed under
+the name "vusb" by OBJECTIVE DEVELOPMENT (http://www.obdev.at/vusb/)
+unless otherwise noted. This includes the firmware-only USB device
+implementation for Atmel AVR microcontrollers, some simple device examples
+and host side software examples and libraries.
+
+
+2 LICENSE GRANTS
+
+2.1 Source Code. OBJECTIVE DEVELOPMENT shall furnish you with the source
+code of V-USB.
+
+2.2 Distribution and Use. OBJECTIVE DEVELOPMENT grants you the
+non-exclusive right to use, copy and distribute V-USB with your hardware
+product(s), restricted by the limitations in section 3 below.
+
+2.3 Modifications. OBJECTIVE DEVELOPMENT grants you the right to modify
+the source code and your copy of V-USB according to your needs.
+
+2.4 USB IDs. OBJECTIVE DEVELOPMENT furnishes you with one or two USB
+Product ID(s), sent to you in e-mail. These Product IDs are reserved
+exclusively for you. OBJECTIVE DEVELOPMENT has obtained USB Product ID
+ranges under the Vendor ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under the Vendor ID 8352 from
+Jason Kotzin (now flirc.tv, Inc.). Both owners of the Vendor IDs have
+obtained these IDs from the USB Implementers Forum, Inc. (www.usb.org).
+OBJECTIVE DEVELOPMENT disclaims all liability which might arise from the
+assignment of USB IDs.
+
+2.5 USB Certification. Although not part of this agreement, we want to make
+it clear that you cannot become USB certified when you use V-USB or a USB
+Product ID assigned by OBJECTIVE DEVELOPMENT. AVR microcontrollers don't
+meet the electrical specifications required by the USB specification and
+the USB Implementers Forum certifies only members who bought a Vendor ID of
+their own.
+
+
+3 LICENSE RESTRICTIONS
+
+3.1 Number of Units. Only one of the following three definitions is
+applicable. Which one is determined by the amount you pay to OBJECTIVE
+DEVELOPMENT, see section 4 ("Payment") below.
+
+Hobby License: You may use V-USB according to section 2 above in no more
+than 5 hardware units. These units must not be sold for profit.
+
+Entry Level License: You may use V-USB according to section 2 above in no
+more than 150 hardware units.
+
+Professional License: You may use V-USB according to section 2 above in
+any number of hardware units, except for large scale production ("unlimited
+fair use"). Quantities below 10,000 units are not considered large scale
+production. If your reach quantities which are obviously large scale
+production, you must pay a license fee of 0.10 EUR per unit for all units
+above 10,000.
+
+3.2 Rental. You may not rent, lease, or lend V-USB or otherwise encumber
+any copy of V-USB, or any of the rights granted herein.
+
+3.3 Transfer. You may not transfer your rights under this Agreement to
+another party without OBJECTIVE DEVELOPMENT's prior written consent. If
+such consent is obtained, you may permanently transfer this License to
+another party. The recipient of such transfer must agree to all terms and
+conditions of this Agreement.
+
+3.4 Reservation of Rights. OBJECTIVE DEVELOPMENT retains all rights not
+expressly granted.
+
+3.5 Non-Exclusive Rights. Your license rights under this Agreement are
+non-exclusive.
+
+3.6 Third Party Rights. This Agreement cannot grant you rights controlled
+by third parties. In particular, you are not allowed to use the USB logo or
+other trademarks owned by the USB Implementers Forum, Inc. without their
+consent. Since such consent depends on USB certification, it should be
+noted that V-USB will not pass certification because it does not
+implement checksum verification and the microcontroller ports do not meet
+the electrical specifications.
+
+
+4 PAYMENT
+
+The payment amount depends on the variation of this agreement (according to
+section 3.1) into which you want to enter. Concrete prices are listed on
+OBJECTIVE DEVELOPMENT's web site, usually at
+http://www.obdev.at/vusb/license.html. You agree to pay the amount listed
+there to OBJECTIVE DEVELOPMENT or OBJECTIVE DEVELOPMENT's payment processor
+or reseller.
+
+
+5 COPYRIGHT AND OWNERSHIP
+
+V-USB is protected by copyright laws and international copyright
+treaties, as well as other intellectual property laws and treaties. V-USB
+is licensed, not sold.
+
+
+6 TERM AND TERMINATION
+
+6.1 Term. This Agreement shall continue indefinitely. However, OBJECTIVE
+DEVELOPMENT may terminate this Agreement and revoke the granted license and
+USB-IDs if you fail to comply with any of its terms and conditions.
+
+6.2 Survival of Terms. All provisions regarding secrecy, confidentiality
+and limitation of liability shall survive termination of this agreement.
+
+
+7 DISCLAIMER OF WARRANTY AND LIABILITY
+
+LIMITED WARRANTY. V-USB IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
+KIND. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, OBJECTIVE
+DEVELOPMENT AND ITS SUPPLIERS HEREBY DISCLAIM ALL WARRANTIES, EITHER
+EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND
+NON-INFRINGEMENT, WITH REGARD TO V-USB, AND THE PROVISION OF OR FAILURE
+TO PROVIDE SUPPORT SERVICES. THIS LIMITED WARRANTY GIVES YOU SPECIFIC LEGAL
+RIGHTS. YOU MAY HAVE OTHERS, WHICH VARY FROM STATE/JURISDICTION TO
+STATE/JURISDICTION.
+
+LIMITATION OF LIABILITY. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW,
+IN NO EVENT SHALL OBJECTIVE DEVELOPMENT OR ITS SUPPLIERS BE LIABLE FOR ANY
+SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER
+(INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
+BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY
+LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE V-USB OR THE
+PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES, EVEN IF OBJECTIVE
+DEVELOPMENT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY
+CASE, OBJECTIVE DEVELOPMENT'S ENTIRE LIABILITY UNDER ANY PROVISION OF THIS
+AGREEMENT SHALL BE LIMITED TO THE AMOUNT ACTUALLY PAID BY YOU FOR V-USB.
+
+
+8 MISCELLANEOUS TERMS
+
+8.1 Marketing. OBJECTIVE DEVELOPMENT has the right to mention for marketing
+purposes that you entered into this agreement.
+
+8.2 Entire Agreement. This document represents the entire agreement between
+OBJECTIVE DEVELOPMENT and you. It may only be modified in writing signed by
+an authorized representative of both, OBJECTIVE DEVELOPMENT and you.
+
+8.3 Severability. In case a provision of these terms and conditions should
+be or become partly or entirely invalid, ineffective, or not executable,
+the validity of all other provisions shall not be affected.
+
+8.4 Applicable Law. This agreement is governed by the laws of the Republic
+of Austria.
+
+8.5 Responsible Courts. The responsible courts in Vienna/Austria will have
+exclusive jurisdiction regarding all disputes in connection with this
+agreement.
+
Index: vusb-20121206/usbdrv/License.txt
===================================================================
--- vusb-20121206/usbdrv/License.txt	(nonexistent)
+++ vusb-20121206/usbdrv/License.txt	(working copy)
@@ -0,0 +1,361 @@
+OBJECTIVE DEVELOPMENT GmbH's V-USB driver software is distributed under the
+terms and conditions of the GNU GPL version 2 or the GNU GPL version 3. It is
+your choice whether you apply the terms of version 2 or version 3. The full
+text of GPLv2 is included below. In addition to the requirements in the GPL,
+we STRONGLY ENCOURAGE you to do the following:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: vusb-20121206/usbdrv/Readme.txt
===================================================================
--- vusb-20121206/usbdrv/Readme.txt	(nonexistent)
+++ vusb-20121206/usbdrv/Readme.txt	(working copy)
@@ -0,0 +1,172 @@
+This is the Readme file to Objective Development's firmware-only USB driver
+for Atmel AVR microcontrollers. For more information please visit
+http://www.obdev.at/vusb/
+
+This directory contains the USB firmware only. Copy it as-is to your own
+project and add all .c and .S files to your project (these files are marked
+with an asterisk in the list below). Then copy usbconfig-prototype.h as
+usbconfig.h to your project and edit it according to your configuration.
+
+
+TECHNICAL DOCUMENTATION
+=======================
+The technical documentation (API) for the firmware driver is contained in the
+file "usbdrv.h". Please read all of it carefully! Configuration options are
+documented in "usbconfig-prototype.h".
+
+The driver consists of the following files:
+  Readme.txt ............. The file you are currently reading.
+  Changelog.txt .......... Release notes for all versions of the driver.
+  usbdrv.h ............... Driver interface definitions and technical docs.
+* usbdrv.c ............... High level language part of the driver. Link this
+                           module to your code!
+* usbdrvasm.S ............ Assembler part of the driver. This module is mostly
+                           a stub and includes one of the usbdrvasm*.S files
+                           depending on processor clock. Link this module to
+                           your code!
+  usbdrvasm*.inc ......... Assembler routines for particular clock frequencies.
+                           Included by usbdrvasm.S, don't link it directly!
+  asmcommon.inc .......... Common assembler routines. Included by
+                           usbdrvasm*.inc, don't link it directly!
+  usbconfig-prototype.h .. Prototype for your own usbdrv.h file.
+* oddebug.c .............. Debug functions. Only used when DEBUG_LEVEL is
+                           defined to a value greater than 0. Link this module
+                           to your code!
+  oddebug.h .............. Interface definitions of the debug module.
+  usbportability.h ....... Header with compiler-dependent stuff.
+  usbdrvasm.asm .......... Compatibility stub for IAR-C-compiler. Use this
+                           module instead of usbdrvasm.S when you assembler
+                           with IAR's tools.
+  License.txt ............ Open Source license for this driver.
+  CommercialLicense.txt .. Optional commercial license for this driver.
+  USB-ID-FAQ.txt ......... General infos about USB Product- and Vendor-IDs.
+  USB-IDs-for-free.txt ... List and terms of use for free shared PIDs.
+
+(*) ... These files should be linked to your project.
+
+
+CPU CORE CLOCK FREQUENCY
+========================
+We supply assembler modules for clock frequencies of 12 MHz, 12.8 MHz, 15 MHz,
+16 MHz, 16.5 MHz 18 MHz and 20 MHz. Other clock rates are not supported. The
+actual clock rate must be configured in usbconfig.h.
+
+12 MHz Clock
+This is the traditional clock rate of V-USB because it's the lowest clock
+rate where the timing constraints of the USB spec can be met.
+
+15 MHz Clock
+Similar to 12 MHz, but some NOPs inserted. On the other hand, the higher clock
+rate allows for some loops which make the resulting code size somewhat smaller
+than the 12 MHz version.
+
+16 MHz Clock
+This clock rate has been added for users of the Arduino board and other
+ready-made boards which come with a fixed 16 MHz crystal. It's also an option
+if you need the slightly higher clock rate for performance reasons. Since
+16 MHz is not divisible by the USB low speed bit clock of 1.5 MHz, the code
+is somewhat tricky and has to insert a leap cycle every third byte.
+
+12.8 MHz and 16.5 MHz Clock
+The assembler modules for these clock rates differ from the other modules
+because they have been built for an RC oscillator with only 1% precision. The
+receiver code inserts leap cycles to compensate for clock deviations. 1% is
+also the precision which can be achieved by calibrating the internal RC
+oscillator of the AVR. Please note that only AVRs with internal 64 MHz PLL
+oscillator can reach 16.5 MHz with the RC oscillator. This includes the very
+popular ATTiny25, ATTiny45, ATTiny85 series as well as the ATTiny26. Almost
+all AVRs can reach 12.8 MHz, although this is outside the specified range.
+
+See the EasyLogger example at http://www.obdev.at/vusb/easylogger.html for
+code which calibrates the RC oscillator based on the USB frame clock.
+
+18 MHz Clock
+This module is closer to the USB specification because it performs an on the
+fly CRC check for incoming packets. Packets with invalid checksum are
+discarded as required by the spec. If you also implement checks for data
+PID toggling on application level (see option USB_CFG_CHECK_DATA_TOGGLING
+in usbconfig.h for more info), this ensures data integrity. Due to the CRC
+tables and alignment requirements, this code is bigger than modules for other
+clock rates. To activate this module, you must define USB_CFG_CHECK_CRC to 1
+and USB_CFG_CLOCK_KHZ to 18000 in usbconfig.h.
+
+20 MHz Clock
+This module is for people who won't do it with less than the maximum. Since
+20 MHz is not divisible by the USB low speed bit clock of 1.5 MHz, the code
+uses similar tricks as the 16 MHz module to insert leap cycles.
+
+
+USB IDENTIFIERS
+===============
+Every USB device needs a vendor- and a product-identifier (VID and PID). VIDs
+are obtained from usb.org for a price of 1,500 USD. Once you have a VID, you
+can assign PIDs at will.
+
+Since an entry level cost of 1,500 USD is too high for most small companies
+and hobbyists, we provide some VID/PID pairs for free. See the file
+USB-IDs-for-free.txt for details.
+
+Objective Development also has some license offerings which include product
+IDs. See http://www.obdev.at/vusb/ for details.
+
+
+DEVELOPMENT SYSTEM
+==================
+This driver has been developed and optimized for the GNU compiler version 3
+and 4. We recommend that you use the GNU compiler suite because it is freely
+available. V-USB has also been ported to the IAR compiler and assembler. It
+has been tested with IAR 4.10B/W32 and 4.12A/W32 on an ATmega8 with the
+"small" and "tiny" memory model. Not every release is tested with IAR CC and
+the driver may therefore fail to compile with IAR. Please note that gcc is
+more efficient for usbdrv.c because this module has been deliberately
+optimized for gcc.
+
+Gcc version 3 produces smaller code than version 4 due to new optimizing
+capabilities which don't always improve things on 8 bit CPUs. The code size
+generated by gcc 4 can be reduced with the compiler options
+-fno-move-loop-invariants, -fno-tree-scev-cprop and
+-fno-inline-small-functions in addition to -Os. On devices with more than
+8k of flash memory, we also recommend the linker option --relax (written as
+-Wl,--relax for gcc) to convert absolute calls into relative where possible.
+
+For more information about optimizing options see:
+
+    http://www.tty1.net/blog/2008-04-29-avr-gcc-optimisations_en.html
+
+These optimizations are good for gcc 4.x. Version 3.x of gcc does not support
+most of these options and produces good code anyway.
+
+
+USING V-USB FOR FREE
+====================
+The AVR firmware driver is published under the GNU General Public License
+Version 2 (GPL2) and the GNU General Public License Version 3 (GPL3). It is
+your choice whether you apply the terms of version 2 or version 3.
+
+If you decide for the free GPL2 or GPL3, we STRONGLY ENCOURAGE you to do the
+following things IN ADDITION to the obligations from the GPL:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+If you don't have a web site, you can publish the project in obdev's
+documentation wiki at
+http://www.obdev.at/goto.php?t=vusb-wiki&p=hosted-projects.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+COMMERCIAL LICENSES FOR V-USB
+=============================
+If you don't want to publish your source code under the terms of the GPL,
+you can simply pay money for V-USB. As an additional benefit you get
+USB PIDs for free, reserved exclusively to you. See the file
+"CommercialLicense.txt" for details.
+
Index: vusb-20121206/usbdrv/USB-ID-FAQ.txt
===================================================================
--- vusb-20121206/usbdrv/USB-ID-FAQ.txt	(nonexistent)
+++ vusb-20121206/usbdrv/USB-ID-FAQ.txt	(working copy)
@@ -0,0 +1,149 @@
+Version 2012-07-09
+
+==========================
+WHY DO WE NEED THESE IDs?
+==========================
+
+USB is more than a low level protocol for data transport. It also defines a
+common set of requests which must be understood by all devices. And as part
+of these common requests, the specification defines data structures, the
+USB Descriptors, which are used to describe the properties of the device.
+
+From the perspective of an operating system, it is therefore possible to find
+out basic properties of a device (such as e.g. the manufacturer and the name
+of the device) without a device-specific driver. This is essential because
+the operating system can choose a driver to load based on this information
+(Plug-And-Play).
+
+Among the most important properties in the Device Descriptor are the USB
+Vendor- and Product-ID. Both are 16 bit integers. The most simple form of
+driver matching is based on these IDs. The driver announces the Vendor- and
+Product-IDs of the devices it can handle and the operating system loads the
+appropriate driver when the device is connected.
+
+It is obvious that this technique only works if the pair Vendor- plus
+Product-ID is unique: Only devices which require the same driver can have the
+same pair of IDs.
+
+
+=====================================================
+HOW DOES THE USB STANDARD ENSURE THAT IDs ARE UNIQUE?
+=====================================================
+
+Since it is so important that USB IDs are unique, the USB Implementers Forum,
+Inc. (usb.org) needs a way to enforce this legally. It is not forbidden by
+law to build a device and assign it any random numbers as IDs. Usb.org
+therefore needs an agreement to regulate the use of USB IDs. The agreement
+binds only parties who agreed to it, of course. Everybody else is free to use
+any numbers for their IDs.
+
+So how can usb.org ensure that every manufacturer of USB devices enters into
+an agreement with them? They do it via trademark licensing. Usb.org has
+registered the trademark "USB", all associated logos and related terms. If
+you want to put an USB logo on your product or claim that it is USB
+compliant, you must license these trademarks from usb.org. And this is where
+you enter into an agreement. See the "USB-IF Trademark License Agreement and
+Usage Guidelines for the USB-IF Logo" at
+http://www.usb.org/developers/logo_license/.
+
+Licensing the USB trademarks requires that you buy a USB Vendor-ID from
+usb.org (one-time fee of ca. 2,000 USD), that you become a member of usb.org
+(yearly fee of ca. 4,000 USD) and that you meet all the technical
+specifications from the USB spec.
+
+This means that most hobbyists and small companies will never be able to
+become USB compliant, just because membership is so expensive. And you can't
+be compliant with a driver based on V-USB anyway, because the AVR's port pins
+don't meet the electrical specifications for USB. So, in principle, all
+hobbyists and small companies are free to choose any random numbers for their
+IDs. They have nothing to lose...
+
+There is one exception worth noting, though: If you use a sub-component which
+implements USB, the vendor of the sub-components may guarantee USB
+compliance. This might apply to some or all of FTDI's solutions.
+
+
+=======================================================================
+WHY SHOULD YOU OBTAIN USB IDs EVEN IF YOU DON'T LICENSE USB TRADEMARKS?
+=======================================================================
+
+You have learned in the previous section that you are free to choose any
+numbers for your IDs anyway. So why not do exactly this? There is still the
+technical issue. If you choose IDs which are already in use by somebody else,
+operating systems will load the wrong drivers and your device won't work.
+Even if you choose IDs which are not currently in use, they may be in use in
+the next version of the operating system or even after an automatic update.
+
+So what you need is a pair of Vendor- and Product-IDs for which you have the
+guarantee that no USB compliant product uses them. This implies that no
+operating system will ever ship with drivers responsible for these IDs.
+
+
+==============================================
+HOW DOES OBJECTIVE DEVELOPMENT HANDLE USB IDs?
+==============================================
+
+Objective Development gives away pairs of USB-IDs with their V-USB licenses.
+In order to ensure that these IDs are unique, Objective Development has an
+agreement with the company/person who has bought the USB Vendor-ID from
+usb.org. This agreement ensures that a range of USB Product-IDs is reserved
+for assignment by Objective Development and that the owner of the Vendor-ID
+won't give it to anybody else.
+
+This means that you have to trust three parties to ensure uniqueness of
+your IDs:
+
+  - Objective Development, that they don't give the same PID to more than
+    one person.
+  - The owner of the Vendor-ID that they don't assign PIDs from the range
+    assigned to Objective Development to anybody else.
+  - Usb.org that they don't assign the same Vendor-ID a second time.
+
+
+==================================
+WHO IS THE OWNER OF THE VENDOR-ID?
+==================================
+
+Objective Development has obtained ranges of USB Product-IDs under two
+Vendor-IDs: Under Vendor-ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under Vendor-ID 8352 from Jason
+Kotzin (now flirc.tv, Inc.). Both VID owners have received their Vendor-ID
+directly from usb.org.
+
+
+=========================================================================
+CAN I USE USB-IDs FROM OBJECTIVE DEVELOPMENT WITH OTHER DRIVERS/HARDWARE?
+=========================================================================
+
+The short answer is: Yes. All you get is a guarantee that the IDs are never
+assigned to anybody else. What more do you need?
+
+
+============================
+WHAT ABOUT SHARED ID PAIRS?
+============================
+
+Objective Development has reserved some PID/VID pairs for shared use. You
+have no guarantee of uniqueness for them, except that no USB compliant device
+uses them. In order to avoid technical problems, we must ensure that all
+devices with the same pair of IDs use the same driver on kernel level. For
+details, see the file USB-IDs-for-free.txt.
+
+
+======================================================
+I HAVE HEARD THAT SUB-LICENSING OF USB-IDs IS ILLEGAL?
+======================================================
+
+A 16 bit integer number cannot be protected by copyright laws. It is not
+sufficiently complex. And since none of the parties involved entered into the
+USB-IF Trademark License Agreement, we are not bound by this agreement. So
+there is no reason why it should be illegal to sub-license USB-IDs.
+
+
+=============================================
+WHO IS LIABLE IF THERE ARE INCOMPATIBILITIES?
+=============================================
+
+Objective Development disclaims all liabilities which might arise from the
+assignment of IDs. If you guarantee product features to your customers
+without proper disclaimer, YOU are liable for that.
Index: vusb-20121206/usbdrv/USB-IDs-for-free.txt
===================================================================
--- vusb-20121206/usbdrv/USB-IDs-for-free.txt	(nonexistent)
+++ vusb-20121206/usbdrv/USB-IDs-for-free.txt	(working copy)
@@ -0,0 +1,154 @@
+Version 2009-08-22
+
+===========================
+FREE USB-IDs FOR SHARED USE
+===========================
+
+Objective Development has reserved a set of USB Product-IDs for use according
+to the guidelines outlined below. For more information about the concept of
+USB IDs please see the file USB-ID-FAQ.txt. Objective Development guarantees
+that the IDs listed below are not used by any USB compliant devices.
+
+
+====================
+MECHANISM OF SHARING
+====================
+
+From a technical point of view, two different devices can share the same USB
+Vendor- and Product-ID if they require the same driver on operating system
+level. We make use of this fact by assigning separate IDs for various device
+classes. On application layer, devices must be distinguished by their textual
+name or serial number. We offer separate sets of IDs for discrimination by
+textual name and for serial number.
+
+Examples for shared use of USB IDs are included with V-USB in the "examples"
+subdirectory.
+
+
+======================================
+IDs FOR DISCRIMINATION BY TEXTUAL NAME
+======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the manufacturer
+and product identification. The manufacturer identification MUST be available
+at least in USB language 0x0409 (English/US).
+
+(2) The textual manufacturer identification MUST contain either an Internet
+domain name (e.g. "mycompany.com") registered and owned by you, or an e-mail
+address under your control (e.g. "myname@gmx.net"). You can embed the domain
+name or e-mail address in any string you like, e.g.  "Objective Development
+http://www.obdev.at/vusb/".
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(4) You may choose any string for the textual product identification, as long
+as this string is unique within the scope of your textual manufacturer
+identification.
+
+(5) Application side device look-up MUST be based on the textual manufacturer
+and product identification in addition to VID/PID matching. The driver
+matching MUST be a comparison of the entire strings, NOT a sub-string match.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+Table if IDs for discrimination by textual name:
+
+PID dec (hex) | VID dec (hex) | Description of use
+==============+===============+============================================
+1500 (0x05dc) | 5824 (0x16c0) | For Vendor Class devices with libusb
+--------------+---------------+--------------------------------------------
+1503 (0x05df) | 5824 (0x16c0) | For generic HID class devices (which are
+              |               | NOT mice, keyboards or joysticks)
+--------------+---------------+--------------------------------------------
+1505 (0x05e1) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+--------------+---------------+--------------------------------------------
+1508 (0x05e4) | 5824 (0x16c0) | For MIDI class devices
+--------------+---------------+--------------------------------------------
+
+Note that Windows caches the textual product- and vendor-description for
+mice, keyboards and joysticks. Name-bsed discrimination is therefore not
+recommended for these device classes.
+
+
+=======================================
+IDs FOR DISCRIMINATION BY SERIAL NUMBER
+=======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the serial
+number, unless ONLY the operating system's default class driver is used.
+The serial number string MUST be available at least in USB language 0x0409
+(English/US).
+
+(2) The serial number MUST start with either an Internet domain name (e.g.
+"mycompany.com") registered and owned by you, or an e-mail address under your
+control (e.g. "myname@gmx.net"), both terminated with a colon (":") character.
+You MAY append any string you like for further discrimination of your devices.
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(5) Application side device look-up MUST be based on the serial number string
+in addition to VID/PID matching. The matching must start at the first
+character of the serial number string and include the colon character
+terminating your domain or e-mail address. It MAY stop anywhere after that.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+(7) If ONLY the operating system's default class driver is used, e.g. for
+mice, keyboards, joysticks, CDC or MIDI devices and no discrimination by an
+application is needed, the serial number may be omitted.
+
+
+Table if IDs for discrimination by serial number string:
+
+PID dec (hex)  | VID dec (hex) | Description of use
+===============+===============+===========================================
+10200 (0x27d8) | 5824 (0x16c0) | For Vendor Class devices with libusb
+---------------+---------------+-------------------------------------------
+10201 (0x27d9) | 5824 (0x16c0) | For generic HID class devices (which are
+               |               | NOT mice, keyboards or joysticks)
+---------------+---------------+-------------------------------------------
+10202 (0x27da) | 5824 (0x16c0) | For USB Mice
+---------------+---------------+-------------------------------------------
+10203 (0x27db) | 5824 (0x16c0) | For USB Keyboards
+---------------+---------------+-------------------------------------------
+10204 (0x27dc) | 5824 (0x16c0) | For USB Joysticks
+---------------+---------------+-------------------------------------------
+10205 (0x27dd) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+---------------+---------------+-------------------------------------------
+10206 (0x27de) | 5824 (0x16c0) | For MIDI class devices
+---------------+---------------+-------------------------------------------
+
+
+=================
+ORIGIN OF USB-IDs
+=================
+
+OBJECTIVE DEVELOPMENT Software GmbH has obtained all VID/PID pairs listed
+here from Wouter van Ooijen (see www.voti.nl) for exclusive disposition.
+Wouter van Ooijen has obtained the VID from the USB Implementers Forum, Inc.
+(see www.usb.org). The VID is registered for the company name "Van Ooijen
+Technische Informatica".
+
+
+==========
+DISCLAIMER
+==========
+
+OBJECTIVE DEVELOPMENT Software GmbH disclaims all liability for any
+problems which are caused by the shared use of these VID/PID pairs.
Index: vusb-20121206/usbdrv/asmcommon.inc
===================================================================
--- vusb-20121206/usbdrv/asmcommon.inc	(nonexistent)
+++ vusb-20121206/usbdrv/asmcommon.inc	(working copy)
@@ -0,0 +1,187 @@
+/* Name: asmcommon.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-11-05
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file contains assembler code which is shared among the USB driver
+implementations for different CPU cocks. Since the code must be inserted
+in the middle of the module, it's split out into this file and #included.
+
+Jump destinations called from outside:
+    sofError: Called when no start sequence was found.
+    se0: Called when a package has been successfully received.
+    overflow: Called when receive buffer overflows.
+    doReturn: Called after sending data.
+
+Outside jump destinations used by this module:
+    waitForJ: Called to receive an already arriving packet.
+    sendAckAndReti:
+    sendNakAndReti:
+    sendCntAndReti:
+    usbSendAndReti:
+
+The following macros must be defined before this file is included:
+    .macro POP_STANDARD
+    .endm
+    .macro POP_RETI
+    .endm
+*/
+
+#define token   x1
+
+overflow:
+    ldi     x2, 1<<USB_INTR_PENDING_BIT
+    USB_STORE_PENDING(x2)       ; clear any pending interrupts
+ignorePacket:
+    clr     token
+    rjmp    storeTokenAndReturn
+
+;----------------------------------------------------------------------------
+; Processing of received packet (numbers in brackets are cycles after center of SE0)
+;----------------------------------------------------------------------------
+;This is the only non-error exit point for the software receiver loop
+;we don't check any CRCs here because there is no time left.
+se0:
+    subi    cnt, USB_BUFSIZE    ;[5]
+    neg     cnt                 ;[6]
+    sub     YL, cnt             ;[7]
+    sbci    YH, 0               ;[8]
+    ldi     x2, 1<<USB_INTR_PENDING_BIT ;[9]
+    USB_STORE_PENDING(x2)       ;[10] clear pending intr and check flag later. SE0 should be over.
+    ld      token, y            ;[11]
+    cpi     token, USBPID_DATA0 ;[13]
+    breq    handleData          ;[14]
+    cpi     token, USBPID_DATA1 ;[15]
+    breq    handleData          ;[16]
+    lds     shift, usbDeviceAddr;[17]
+    ldd     x2, y+1             ;[19] ADDR and 1 bit endpoint number
+    lsl     x2                  ;[21] shift out 1 bit endpoint number
+    cpse    x2, shift           ;[22]
+    rjmp    ignorePacket        ;[23]
+/* only compute endpoint number in x3 if required later */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT || USB_CFG_IMPLEMENT_FN_WRITEOUT
+    ldd     x3, y+2             ;[24] endpoint number + crc
+    rol     x3                  ;[26] shift in LSB of endpoint
+#endif
+    cpi     token, USBPID_IN    ;[27]
+    breq    handleIn            ;[28]
+    cpi     token, USBPID_SETUP ;[29]
+    breq    handleSetupOrOut    ;[30]
+    cpi     token, USBPID_OUT   ;[31]
+    brne    ignorePacket        ;[32] must be ack, nak or whatever
+;   rjmp    handleSetupOrOut    ; fallthrough
+
+;Setup and Out are followed by a data packet two bit times (16 cycles) after
+;the end of SE0. The sync code allows up to 40 cycles delay from the start of
+;the sync pattern until the first bit is sampled. That's a total of 56 cycles.
+handleSetupOrOut:               ;[32]
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT   /* if we have data for endpoint != 0, set usbCurrentTok to address */
+    andi    x3, 0xf             ;[32]
+    breq    storeTokenAndReturn ;[33]
+    mov     token, x3           ;[34] indicate that this is endpoint x OUT
+#endif
+storeTokenAndReturn:
+    sts     usbCurrentTok, token;[35]
+doReturn:
+    POP_STANDARD                ;[37] 12...16 cycles
+    USB_LOAD_PENDING(YL)        ;[49]
+    sbrc    YL, USB_INTR_PENDING_BIT;[50] check whether data is already arriving
+    rjmp    waitForJ            ;[51] save the pops and pushes -- a new interrupt is already pending
+sofError:
+    POP_RETI                    ;macro call
+    reti
+
+handleData:
+#if USB_CFG_CHECK_CRC
+    CRC_CLEANUP_AND_CHECK       ; jumps to ignorePacket if CRC error
+#endif
+    lds     shift, usbCurrentTok;[18]
+    tst     shift               ;[20]
+    breq    doReturn            ;[21]
+    lds     x2, usbRxLen        ;[22]
+    tst     x2                  ;[24]
+    brne    sendNakAndReti      ;[25]
+; 2006-03-11: The following two lines fix a problem where the device was not
+; recognized if usbPoll() was called less frequently than once every 4 ms.
+    cpi     cnt, 4              ;[26] zero sized data packets are status phase only -- ignore and ack
+    brmi    sendAckAndReti      ;[27] keep rx buffer clean -- we must not NAK next SETUP
+#if USB_CFG_CHECK_DATA_TOGGLING
+    sts     usbCurrentDataToken, token  ; store for checking by C code
+#endif
+    sts     usbRxLen, cnt       ;[28] store received data, swap buffers
+    sts     usbRxToken, shift   ;[30]
+    lds     x2, usbInputBufOffset;[32] swap buffers
+    ldi     cnt, USB_BUFSIZE    ;[34]
+    sub     cnt, x2             ;[35]
+    sts     usbInputBufOffset, cnt;[36] buffers now swapped
+    rjmp    sendAckAndReti      ;[38] 40 + 17 = 57 until SOP
+
+handleIn:
+;We don't send any data as long as the C code has not processed the current
+;input data and potentially updated the output data. That's more efficient
+;in terms of code size than clearing the tx buffers when a packet is received.
+    lds     x1, usbRxLen        ;[30]
+    cpi     x1, 1               ;[32] negative values are flow control, 0 means "buffer free"
+    brge    sendNakAndReti      ;[33] unprocessed input packet?
+    ldi     x1, USBPID_NAK      ;[34] prepare value for usbTxLen
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+    andi    x3, 0xf             ;[35] x3 contains endpoint
+#if USB_CFG_SUPPRESS_INTR_CODE
+    brne    sendNakAndReti      ;[36]
+#else
+    brne    handleIn1           ;[36]
+#endif
+#endif
+    lds     cnt, usbTxLen       ;[37]
+    sbrc    cnt, 4              ;[39] all handshake tokens have bit 4 set
+    rjmp    sendCntAndReti      ;[40] 42 + 16 = 58 until SOP
+    sts     usbTxLen, x1        ;[41] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf)   ;[43]
+    ldi     YH, hi8(usbTxBuf)   ;[44]
+    rjmp    usbSendAndReti      ;[45] 57 + 12 = 59 until SOP
+
+; Comment about when to set usbTxLen to USBPID_NAK:
+; We should set it back when we receive the ACK from the host. This would
+; be simple to implement: One static variable which stores whether the last
+; tx was for endpoint 0 or 1 and a compare in the receiver to distinguish the
+; ACK. However, we set it back immediately when we send the package,
+; assuming that no error occurs and the host sends an ACK. We save one byte
+; RAM this way and avoid potential problems with endless retries. The rest of
+; the driver assumes error-free transfers anyway.
+
+#if !USB_CFG_SUPPRESS_INTR_CODE && USB_CFG_HAVE_INTRIN_ENDPOINT /* placed here due to relative jump range */
+handleIn1:                      ;[38]
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+; 2006-06-10 as suggested by O.Tamura: support second INTR IN / BULK IN endpoint
+    cpi     x3, USB_CFG_EP3_NUMBER;[38]
+    breq    handleIn3           ;[39]
+#endif
+    lds     cnt, usbTxLen1      ;[40]
+    sbrc    cnt, 4              ;[42] all handshake tokens have bit 4 set
+    rjmp    sendCntAndReti      ;[43] 47 + 16 = 63 until SOP
+    sts     usbTxLen1, x1       ;[44] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf1)  ;[46]
+    ldi     YH, hi8(usbTxBuf1)  ;[47]
+    rjmp    usbSendAndReti      ;[48] 50 + 12 = 62 until SOP
+
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+handleIn3:
+    lds     cnt, usbTxLen3      ;[41]
+    sbrc    cnt, 4              ;[43]
+    rjmp    sendCntAndReti      ;[44] 49 + 16 = 65 until SOP
+    sts     usbTxLen3, x1       ;[45] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf3)  ;[47]
+    ldi     YH, hi8(usbTxBuf3)  ;[48]
+    rjmp    usbSendAndReti      ;[49] 51 + 12 = 63 until SOP
+#endif
+#endif
Index: vusb-20121206/usbdrv/oddebug.c
===================================================================
--- vusb-20121206/usbdrv/oddebug.c	(nonexistent)
+++ vusb-20121206/usbdrv/oddebug.c	(working copy)
@@ -0,0 +1,49 @@
+/* Name: oddebug.c
+ * Project: AVR library
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-01-16
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include "oddebug.h"
+
+#if DEBUG_LEVEL > 0
+
+#warning "Never compile production devices with debugging enabled"
+
+static void uartPutc(char c)
+{
+    while(!(ODDBG_USR & (1 << ODDBG_UDRE)));    /* wait for data register empty */
+    ODDBG_UDR = c;
+}
+
+static uchar    hexAscii(uchar h)
+{
+    h &= 0xf;
+    if(h >= 10)
+        h += 'a' - (uchar)10 - '0';
+    h += '0';
+    return h;
+}
+
+static void printHex(uchar c)
+{
+    uartPutc(hexAscii(c >> 4));
+    uartPutc(hexAscii(c));
+}
+
+void    odDebug(uchar prefix, uchar *data, uchar len)
+{
+    printHex(prefix);
+    uartPutc(':');
+    while(len--){
+        uartPutc(' ');
+        printHex(*data++);
+    }
+    uartPutc('\r');
+    uartPutc('\n');
+}
+
+#endif
Index: vusb-20121206/usbdrv/oddebug.h
===================================================================
--- vusb-20121206/usbdrv/oddebug.h	(nonexistent)
+++ vusb-20121206/usbdrv/oddebug.h	(working copy)
@@ -0,0 +1,122 @@
+/* Name: oddebug.h
+ * Project: AVR library
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-01-16
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __oddebug_h_included__
+#define __oddebug_h_included__
+
+/*
+General Description:
+This module implements a function for debug logs on the serial line of the
+AVR microcontroller. Debugging can be configured with the define
+'DEBUG_LEVEL'. If this macro is not defined or defined to 0, all debugging
+calls are no-ops. If it is 1, DBG1 logs will appear, but not DBG2. If it is
+2, DBG1 and DBG2 logs will be printed.
+
+A debug log consists of a label ('prefix') to indicate which debug log created
+the output and a memory block to dump in hex ('data' and 'len').
+*/
+
+
+#ifndef F_CPU
+#   define  F_CPU   12000000    /* 12 MHz */
+#endif
+
+/* make sure we have the UART defines: */
+#include "usbportability.h"
+
+#ifndef uchar
+#   define  uchar   unsigned char
+#endif
+
+#if DEBUG_LEVEL > 0 && !(defined TXEN || defined TXEN0) /* no UART in device */
+#   warning "Debugging disabled because device has no UART"
+#   undef   DEBUG_LEVEL
+#endif
+
+#ifndef DEBUG_LEVEL
+#   define  DEBUG_LEVEL 0
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#if DEBUG_LEVEL > 0
+#   define  DBG1(prefix, data, len) odDebug(prefix, data, len)
+#else
+#   define  DBG1(prefix, data, len)
+#endif
+
+#if DEBUG_LEVEL > 1
+#   define  DBG2(prefix, data, len) odDebug(prefix, data, len)
+#else
+#   define  DBG2(prefix, data, len)
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#if DEBUG_LEVEL > 0
+extern void odDebug(uchar prefix, uchar *data, uchar len);
+
+/* Try to find our control registers; ATMEL likes to rename these */
+
+#if defined UBRR
+#   define  ODDBG_UBRR  UBRR
+#elif defined UBRRL
+#   define  ODDBG_UBRR  UBRRL
+#elif defined UBRR0
+#   define  ODDBG_UBRR  UBRR0
+#elif defined UBRR0L
+#   define  ODDBG_UBRR  UBRR0L
+#endif
+
+#if defined UCR
+#   define  ODDBG_UCR   UCR
+#elif defined UCSRB
+#   define  ODDBG_UCR   UCSRB
+#elif defined UCSR0B
+#   define  ODDBG_UCR   UCSR0B
+#endif
+
+#if defined TXEN
+#   define  ODDBG_TXEN  TXEN
+#else
+#   define  ODDBG_TXEN  TXEN0
+#endif
+
+#if defined USR
+#   define  ODDBG_USR   USR
+#elif defined UCSRA
+#   define  ODDBG_USR   UCSRA
+#elif defined UCSR0A
+#   define  ODDBG_USR   UCSR0A
+#endif
+
+#if defined UDRE
+#   define  ODDBG_UDRE  UDRE
+#else
+#   define  ODDBG_UDRE  UDRE0
+#endif
+
+#if defined UDR
+#   define  ODDBG_UDR   UDR
+#elif defined UDR0
+#   define  ODDBG_UDR   UDR0
+#endif
+
+static inline void  odDebugInit(void)
+{
+    ODDBG_UCR |= (1<<ODDBG_TXEN);
+    ODDBG_UBRR = F_CPU / (19200 * 16L) - 1;
+}
+#else
+#   define odDebugInit()
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#endif /* __oddebug_h_included__ */
Index: vusb-20121206/usbdrv/usbconfig-prototype.h
===================================================================
--- vusb-20121206/usbdrv/usbconfig-prototype.h	(nonexistent)
+++ vusb-20121206/usbdrv/usbconfig-prototype.h	(working copy)
@@ -0,0 +1,384 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
++ To create your own usbconfig.h file, copy this file to your project's
++ firmware source directory) and rename it to "usbconfig.h".
++ Then edit it accordingly.
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    0
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           100
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdc, 0x05 /* = 0x05dc = 1500 */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'T', 'e', 'm', 'p', 'l', 'a', 't', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 8
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/usbdrv/usbdrv.c
===================================================================
--- vusb-20121206/usbdrv/usbdrv.c	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrv.c	(working copy)
@@ -0,0 +1,628 @@
+/* Name: usbdrv.c
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include "usbdrv.h"
+#include "oddebug.h"
+
+/*
+General Description:
+This module implements the C-part of the USB driver. See usbdrv.h for a
+documentation of the entire driver.
+*/
+
+/* ------------------------------------------------------------------------- */
+
+/* raw USB registers / interface to assembler code: */
+uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
+uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
+uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
+uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
+uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but not used */
+volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow control */
+uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 0 */
+uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
+volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handshake token */
+uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains handshake token */
+#if USB_COUNT_SOF
+volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+usbTxStatus_t  usbTxStatus1;
+#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
+usbTxStatus_t  usbTxStatus3;
+#   endif
+#endif
+#if USB_CFG_CHECK_DATA_TOGGLING
+uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
+#endif
+
+/* USB status registers / not shared with asm code */
+usbMsgPtr_t         usbMsgPtr;      /* data to transmit next -- ROM or RAM address */
+static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
+static uchar        usbMsgFlags;    /* flag values see below */
+
+#define USB_FLG_MSGPTR_IS_ROM   (1<<6)
+#define USB_FLG_USE_USER_RW     (1<<7)
+
+/*
+optimizing hints:
+- do not post/pre inc/dec integer values in operations
+- assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
+- use narrow scope for variables which should be in X/Y/Z register
+- assign char sized expressions to variables to force 8 bit arithmetics
+*/
+
+/* -------------------------- String Descriptors --------------------------- */
+
+#if USB_CFG_DESCR_PROPS_STRINGS == 0
+
+#if USB_CFG_DESCR_PROPS_STRING_0 == 0
+#undef USB_CFG_DESCR_PROPS_STRING_0
+#define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
+PROGMEM const char usbDescriptorString0[] = { /* language descriptor */
+    4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
+    3,          /* descriptor type */
+    0x09, 0x04, /* language index (0x0409 = US-English) */
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_VENDOR
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
+PROGMEM const int  usbDescriptorStringVendor[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
+    USB_CFG_VENDOR_NAME
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
+PROGMEM const int  usbDescriptorStringDevice[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
+    USB_CFG_DEVICE_NAME
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
+PROGMEM const int usbDescriptorStringSerialNumber[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
+    USB_CFG_SERIAL_NUMBER
+};
+#endif
+
+#endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
+
+/* --------------------------- Device Descriptor --------------------------- */
+
+#if USB_CFG_DESCR_PROPS_DEVICE == 0
+#undef USB_CFG_DESCR_PROPS_DEVICE
+#define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
+PROGMEM const char usbDescriptorDevice[] = {    /* USB device descriptor */
+    18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
+    USBDESCR_DEVICE,        /* descriptor type */
+    0x10, 0x01,             /* USB version supported */
+    USB_CFG_DEVICE_CLASS,
+    USB_CFG_DEVICE_SUBCLASS,
+    0,                      /* protocol */
+    8,                      /* max packet size */
+    /* the following two casts affect the first byte of the constant only, but
+     * that's sufficient to avoid a warning with the default values.
+     */
+    (char)USB_CFG_VENDOR_ID,/* 2 bytes */
+    (char)USB_CFG_DEVICE_ID,/* 2 bytes */
+    USB_CFG_DEVICE_VERSION, /* 2 bytes */
+    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
+    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
+    1,          /* number of configurations */
+};
+#endif
+
+/* ----------------------- Configuration Descriptor ------------------------ */
+
+#if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
+#undef USB_CFG_DESCR_PROPS_HID
+#define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
+#endif
+
+#if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
+#undef USB_CFG_DESCR_PROPS_CONFIGURATION
+#define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
+PROGMEM const char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
+    9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
+    USBDESCR_CONFIG,    /* descriptor type */
+    18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
+                (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
+                /* total length of data returned (including inlined descriptors) */
+    1,          /* number of interfaces in this configuration */
+    1,          /* index of this configuration */
+    0,          /* configuration name string index */
+#if USB_CFG_IS_SELF_POWERED
+    (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
+#else
+    (1 << 7),                           /* attributes */
+#endif
+    USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
+/* interface descriptor follows inline: */
+    9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
+    USBDESCR_INTERFACE, /* descriptor type */
+    0,          /* index of this interface */
+    0,          /* alternate setting for this interface */
+    USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of endpoint descriptors to follow */
+    USB_CFG_INTERFACE_CLASS,
+    USB_CFG_INTERFACE_SUBCLASS,
+    USB_CFG_INTERFACE_PROTOCOL,
+    0,          /* string index for interface */
+#if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
+    9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
+    USBDESCR_HID,   /* descriptor type: HID */
+    0x01, 0x01, /* BCD representation of HID version */
+    0x00,       /* target country code */
+    0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
+    0x22,       /* descriptor type: report */
+    USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)0x81, /* IN endpoint number 1 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+};
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+static inline void  usbResetDataToggling(void)
+{
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
+#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
+    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
+#   endif
+#endif
+}
+
+static inline void  usbResetStall(void)
+{
+#if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
+        usbTxLen1 = USBPID_NAK;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+        usbTxLen3 = USBPID_NAK;
+#endif
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+#if !USB_CFG_SUPPRESS_INTR_CODE
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
+{
+uchar   *p;
+char    i;
+
+#if USB_CFG_IMPLEMENT_HALT
+    if(usbTxLen1 == USBPID_STALL)
+        return;
+#endif
+    if(txStatus->len & 0x10){   /* packet buffer was empty */
+        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
+    }else{
+        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
+    }
+    p = txStatus->buffer + 1;
+    i = len;
+    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
+        *p++ = *data++;
+    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
+    usbCrc16Append(&txStatus->buffer[1], len);
+    txStatus->len = len + 4;    /* len must be given including sync byte */
+    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
+}
+
+USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
+{
+    usbGenericSetInterrupt(data, len, &usbTxStatus1);
+}
+#endif
+
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
+{
+    usbGenericSetInterrupt(data, len, &usbTxStatus3);
+}
+#endif
+#endif /* USB_CFG_SUPPRESS_INTR_CODE */
+
+/* ------------------ utilities for code following below ------------------- */
+
+/* Use defines for the switch statement so that we can choose between an
+ * if()else if() and a switch/case based implementation. switch() is more
+ * efficient for a LARGE set of sequential choices, if() is better in all other
+ * cases.
+ */
+#if USB_CFG_USE_SWITCH_STATEMENT
+#   define SWITCH_START(cmd)       switch(cmd){{
+#   define SWITCH_CASE(value)      }break; case (value):{
+#   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
+#   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
+#   define SWITCH_DEFAULT          }break; default:{
+#   define SWITCH_END              }}
+#else
+#   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
+#   define SWITCH_CASE(value)      }else if(_cmd == (value)){
+#   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
+#   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
+#   define SWITCH_DEFAULT          }else{
+#   define SWITCH_END              }}
+#endif
+
+#ifndef USB_RX_USER_HOOK
+#define USB_RX_USER_HOOK(data, len)
+#endif
+#ifndef USB_SET_ADDRESS_HOOK
+#define USB_SET_ADDRESS_HOOK()
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+/* We use if() instead of #if in the macro below because #if can't be used
+ * in macros and the compiler optimizes constant conditions anyway.
+ * This may cause problems with undefined symbols if compiled without
+ * optimizing!
+ */
+#define GET_DESCRIPTOR(cfgProp, staticName)         \
+    if(cfgProp){                                    \
+        if((cfgProp) & USB_PROP_IS_RAM)             \
+            flags = 0;                              \
+        if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
+            len = usbFunctionDescriptor(rq);        \
+        }else{                                      \
+            len = USB_PROP_LENGTH(cfgProp);         \
+            usbMsgPtr = (usbMsgPtr_t)(staticName);  \
+        }                                           \
+    }
+
+/* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
+ * internally for all types of descriptors.
+ */
+static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
+{
+usbMsgLen_t len = 0;
+uchar       flags = USB_FLG_MSGPTR_IS_ROM;
+
+    SWITCH_START(rq->wValue.bytes[1])
+    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
+    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
+    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
+#if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
+        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
+            flags = 0;
+        len = usbFunctionDescriptor(rq);
+#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
+        SWITCH_START(rq->wValue.bytes[0])
+        SWITCH_CASE(0)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
+        SWITCH_CASE(1)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
+        SWITCH_CASE(2)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
+        SWITCH_CASE(3)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumber)
+        SWITCH_DEFAULT
+            if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
+                len = usbFunctionDescriptor(rq);
+            }
+        SWITCH_END
+#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
+#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
+    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
+    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
+#endif
+    SWITCH_DEFAULT
+        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
+            len = usbFunctionDescriptor(rq);
+        }
+    SWITCH_END
+    usbMsgFlags = flags;
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
+ * standard requests instead of class and custom requests.
+ */
+static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
+{
+usbMsgLen_t len = 0;
+uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
+uchar   value = rq->wValue.bytes[0];
+#if USB_CFG_IMPLEMENT_HALT
+uchar   index = rq->wIndex.bytes[0];
+#endif
+
+    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
+    SWITCH_START(rq->bRequest)
+    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
+        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */
+        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
+            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
+#if USB_CFG_IMPLEMENT_HALT
+        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
+            dataPtr[0] = usbTxLen1 == USBPID_STALL;
+#endif
+        dataPtr[1] = 0;
+        len = 2;
+#if USB_CFG_IMPLEMENT_HALT
+    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
+        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
+            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
+            usbResetDataToggling();
+        }
+#endif
+    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
+        usbNewDeviceAddr = value;
+        USB_SET_ADDRESS_HOOK();
+    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
+        len = usbDriverDescriptor(rq);
+        goto skipMsgPtrAssignment;
+    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
+        dataPtr = &usbConfiguration;  /* send current configuration value */
+        len = 1;
+    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
+        usbConfiguration = value;
+        usbResetStall();
+    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
+        len = 1;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
+        usbResetDataToggling();
+        usbResetStall();
+#endif
+    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
+        /* Should we add an optional hook here? */
+    SWITCH_END
+    usbMsgPtr = (usbMsgPtr_t)dataPtr;
+skipMsgPtrAssignment:
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbProcessRx() is called for every message received by the interrupt
+ * routine. It distinguishes between SETUP and DATA packets and processes
+ * them accordingly.
+ */
+static inline void usbProcessRx(uchar *data, uchar len)
+{
+usbRequest_t    *rq = (void *)data;
+
+/* usbRxToken can be:
+ * 0x2d 00101101 (USBPID_SETUP for setup data)
+ * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
+ * 0...0x0f for OUT on endpoint X
+ */
+    DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
+    USB_RX_USER_HOOK(data, len)
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
+        usbFunctionWriteOut(data, len);
+        return;
+    }
+#endif
+    if(usbRxToken == (uchar)USBPID_SETUP){
+        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
+            return;
+        usbMsgLen_t replyLen;
+        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
+        usbTxLen = USBPID_NAK;              /* abort pending transmit */
+        usbMsgFlags = 0;
+        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
+        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
+            replyLen = usbFunctionSetup(data);
+        }else{
+            replyLen = usbDriverSetup(rq);
+        }
+#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
+        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
+            /* do some conditioning on replyLen, but on IN transfers only */
+            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
+                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
+                    replyLen = rq->wLength.bytes[0];
+                }else{
+                    replyLen = rq->wLength.word;
+                }
+            }
+            usbMsgFlags = USB_FLG_USE_USER_RW;
+        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
+#endif
+        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
+            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
+                replyLen = rq->wLength.bytes[0];
+        }else{
+            if(replyLen > rq->wLength.word)     /* limit length to max */
+                replyLen = rq->wLength.word;
+        }
+        usbMsgLen = replyLen;
+    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
+#if USB_CFG_IMPLEMENT_FN_WRITE
+        if(usbMsgFlags & USB_FLG_USE_USER_RW){
+            uchar rval = usbFunctionWrite(data, len);
+            if(rval == 0xff){   /* an error occurred */
+                usbTxLen = USBPID_STALL;
+            }else if(rval != 0){    /* This was the final package */
+                usbMsgLen = 0;  /* answer with a zero-sized data packet */
+            }
+        }
+#endif
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* This function is similar to usbFunctionRead(), but it's also called for
+ * data handled automatically by the driver (e.g. descriptor reads).
+ */
+static uchar usbDeviceRead(uchar *data, uchar len)
+{
+    if(len > 0){    /* don't bother app with 0 sized reads */
+#if USB_CFG_IMPLEMENT_FN_READ
+        if(usbMsgFlags & USB_FLG_USE_USER_RW){
+            len = usbFunctionRead(data, len);
+        }else
+#endif
+        {
+            uchar i = len;
+            usbMsgPtr_t r = usbMsgPtr;
+            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
+                do{
+                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
+                    *data++ = c;
+                    r++;
+                }while(--i);
+            }else{  /* RAM data */
+                do{
+                    *data++ = *((uchar *)r);
+                    r++;
+                }while(--i);
+            }
+            usbMsgPtr = r;
+        }
+    }
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbBuildTxBlock() is called when we have data to transmit and the
+ * interrupt routine's transmit buffer is empty.
+ */
+static inline void usbBuildTxBlock(void)
+{
+usbMsgLen_t wantLen;
+uchar       len;
+
+    wantLen = usbMsgLen;
+    if(wantLen > 8)
+        wantLen = 8;
+    usbMsgLen -= wantLen;
+    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
+    len = usbDeviceRead(usbTxBuf + 1, wantLen);
+    if(len <= 8){           /* valid data packet */
+        usbCrc16Append(&usbTxBuf[1], len);
+        len += 4;           /* length including sync byte */
+        if(len < 12)        /* a partial package identifies end of message */
+            usbMsgLen = USB_NO_MSG;
+    }else{
+        len = USBPID_STALL;   /* stall the endpoint */
+        usbMsgLen = USB_NO_MSG;
+    }
+    usbTxLen = len;
+    DBG2(0x20, usbTxBuf, len-1);
+}
+
+/* ------------------------------------------------------------------------- */
+
+static inline void usbHandleResetHook(uchar notResetState)
+{
+#ifdef USB_RESET_HOOK
+static uchar    wasReset;
+uchar           isReset = !notResetState;
+
+    if(wasReset != isReset){
+        USB_RESET_HOOK(isReset);
+        wasReset = isReset;
+    }
+#else
+    notResetState = notResetState;  // avoid compiler warning
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+USB_PUBLIC void usbPoll(void)
+{
+schar   len;
+uchar   i;
+
+    len = usbRxLen - 3;
+    if(len >= 0){
+/* We could check CRC16 here -- but ACK has already been sent anyway. If you
+ * need data integrity checks with this driver, check the CRC in your app
+ * code and report errors back to the host. Since the ACK was already sent,
+ * retries must be handled on application level.
+ * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
+ */
+        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
+#if USB_CFG_HAVE_FLOWCONTROL
+        if(usbRxLen > 0)    /* only mark as available if not inactivated */
+            usbRxLen = 0;
+#else
+        usbRxLen = 0;       /* mark rx buffer as available */
+#endif
+    }
+    if(usbTxLen & 0x10){    /* transmit system idle */
+        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
+            usbBuildTxBlock();
+        }
+    }
+    for(i = 20; i > 0; i--){
+        uchar usbLineStatus = USBIN & USBMASK;
+        if(usbLineStatus != 0)  /* SE0 has ended */
+            goto isNotReset;
+    }
+    /* RESET condition, called multiple times during reset */
+    usbNewDeviceAddr = 0;
+    usbDeviceAddr = 0;
+    usbResetStall();
+    DBG1(0xff, 0, 0);
+isNotReset:
+    usbHandleResetHook(i);
+}
+
+/* ------------------------------------------------------------------------- */
+
+USB_PUBLIC void usbInit(void)
+{
+#if USB_INTR_CFG_SET != 0
+    USB_INTR_CFG |= USB_INTR_CFG_SET;
+#endif
+#if USB_INTR_CFG_CLR != 0
+    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
+#endif
+    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
+    usbResetDataToggling();
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    usbTxLen1 = USBPID_NAK;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+    usbTxLen3 = USBPID_NAK;
+#endif
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/usbdrv/usbdrv.h
===================================================================
--- vusb-20121206/usbdrv/usbdrv.h	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrv.h	(working copy)
@@ -0,0 +1,746 @@
+/* Name: usbdrv.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbdrv_h_included__
+#define __usbdrv_h_included__
+#include "usbconfig.h"
+#include "usbportability.h"
+
+/*
+Hardware Prerequisites:
+=======================
+USB lines D+ and D- MUST be wired to the same I/O port. We recommend that D+
+triggers the interrupt (best achieved by using INT0 for D+), but it is also
+possible to trigger the interrupt from D-. If D- is used, interrupts are also
+triggered by SOF packets. D- requires a pull-up of 1.5k to +3.5V (and the
+device must be powered at 3.5V) to identify as low-speed USB device. A
+pull-down or pull-up of 1M SHOULD be connected from D+ to +3.5V to prevent
+interference when no USB master is connected. If you use Zener diodes to limit
+the voltage on D+ and D-, you MUST use a pull-down resistor, not a pull-up.
+We use D+ as interrupt source and not D- because it does not trigger on
+keep-alive and RESET states. If you want to count keep-alive events with
+USB_COUNT_SOF, you MUST use D- as an interrupt source.
+
+As a compile time option, the 1.5k pull-up resistor on D- can be made
+switchable to allow the device to disconnect at will. See the definition of
+usbDeviceConnect() and usbDeviceDisconnect() further down in this file.
+
+Please adapt the values in usbconfig.h according to your hardware!
+
+The device MUST be clocked at exactly 12 MHz, 15 MHz, 16 MHz or 20 MHz
+or at 12.8 MHz resp. 16.5 MHz +/- 1%. See usbconfig-prototype.h for details.
+
+
+Limitations:
+============
+Robustness with respect to communication errors:
+The driver assumes error-free communication. It DOES check for errors in
+the PID, but does NOT check bit stuffing errors, SE0 in middle of a byte,
+token CRC (5 bit) and data CRC (16 bit). CRC checks can not be performed due
+to timing constraints: We must start sending a reply within 7 bit times.
+Bit stuffing and misplaced SE0 would have to be checked in real-time, but CPU
+performance does not permit that. The driver does not check Data0/Data1
+toggling, but application software can implement the check.
+
+Input characteristics:
+Since no differential receiver circuit is used, electrical interference
+robustness may suffer. The driver samples only one of the data lines with
+an ordinary I/O pin's input characteristics. However, since this is only a
+low speed USB implementation and the specification allows for 8 times the
+bit rate over the same hardware, we should be on the safe side. Even the spec
+requires detection of asymmetric states at high bit rate for SE0 detection.
+
+Number of endpoints:
+The driver supports the following endpoints:
+
+- Endpoint 0, the default control endpoint.
+- Any number of interrupt- or bulk-out endpoints. The data is sent to
+  usbFunctionWriteOut() and USB_CFG_IMPLEMENT_FN_WRITEOUT must be defined
+  to 1 to activate this feature. The endpoint number can be found in the
+  global variable 'usbRxToken'.
+- One default interrupt- or bulk-in endpoint. This endpoint is used for
+  interrupt- or bulk-in transfers which are not handled by any other endpoint.
+  You must define USB_CFG_HAVE_INTRIN_ENDPOINT in order to activate this
+  feature and call usbSetInterrupt() to send interrupt/bulk data.
+- One additional interrupt- or bulk-in endpoint. This was endpoint 3 in
+  previous versions of this driver but can now be configured to any endpoint
+  number. You must define USB_CFG_HAVE_INTRIN_ENDPOINT3 in order to activate
+  this feature and call usbSetInterrupt3() to send interrupt/bulk data. The
+  endpoint number can be set with USB_CFG_EP3_NUMBER.
+
+Please note that the USB standard forbids bulk endpoints for low speed devices!
+Most operating systems allow them anyway, but the AVR will spend 90% of the CPU
+time in the USB interrupt polling for bulk data.
+
+Maximum data payload:
+Data payload of control in and out transfers may be up to 254 bytes. In order
+to accept payload data of out transfers, you need to implement
+'usbFunctionWrite()'.
+
+USB Suspend Mode supply current:
+The USB standard limits power consumption to 500uA when the bus is in suspend
+mode. This is not a problem for self-powered devices since they don't need
+bus power anyway. Bus-powered devices can achieve this only by putting the
+CPU in sleep mode. The driver does not implement suspend handling by itself.
+However, the application may implement activity monitoring and wakeup from
+sleep. The host sends regular SE0 states on the bus to keep it active. These
+SE0 states can be detected by using D- as the interrupt source. Define
+USB_COUNT_SOF to 1 and use the global variable usbSofCount to check for bus
+activity.
+
+Operation without an USB master:
+The driver behaves neutral without connection to an USB master if D- reads
+as 1. To avoid spurious interrupts, we recommend a high impedance (e.g. 1M)
+pull-down or pull-up resistor on D+ (interrupt). If Zener diodes are used,
+use a pull-down. If D- becomes statically 0, the driver may block in the
+interrupt routine.
+
+Interrupt latency:
+The application must ensure that the USB interrupt is not disabled for more
+than 25 cycles (this is for 12 MHz, faster clocks allow longer latency).
+This implies that all interrupt routines must either have the "ISR_NOBLOCK"
+attribute set (see "avr/interrupt.h") or be written in assembler with "sei"
+as the first instruction.
+
+Maximum interrupt duration / CPU cycle consumption:
+The driver handles all USB communication during the interrupt service
+routine. The routine will not return before an entire USB message is received
+and the reply is sent. This may be up to ca. 1200 cycles @ 12 MHz (= 100us) if
+the host conforms to the standard. The driver will consume CPU cycles for all
+USB messages, even if they address another (low-speed) device on the same bus.
+
+*/
+
+/* ------------------------------------------------------------------------- */
+/* --------------------------- Module Interface ---------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#define USBDRV_VERSION  20121206
+/* This define uniquely identifies a driver version. It is a decimal number
+ * constructed from the driver's release date in the form YYYYMMDD. If the
+ * driver's behavior or interface changes, you can use this constant to
+ * distinguish versions. If it is not defined, the driver's release date is
+ * older than 2006-01-25.
+ */
+
+
+#ifndef USB_PUBLIC
+#define USB_PUBLIC
+#endif
+/* USB_PUBLIC is used as declaration attribute for all functions exported by
+ * the USB driver. The default is no attribute (see above). You may define it
+ * to static either in usbconfig.h or from the command line if you include
+ * usbdrv.c instead of linking against it. Including the C module of the driver
+ * directly in your code saves a couple of bytes in flash memory.
+ */
+
+#ifndef __ASSEMBLER__
+#ifndef uchar
+#define uchar   unsigned char
+#endif
+#ifndef schar
+#define schar   signed char
+#endif
+/* shortcuts for well defined 8 bit integer types */
+
+#if USB_CFG_LONG_TRANSFERS  /* if more than 254 bytes transfer size required */
+#   define usbMsgLen_t unsigned
+#else
+#   define usbMsgLen_t uchar
+#endif
+/* usbMsgLen_t is the data type used for transfer lengths. By default, it is
+ * defined to uchar, allowing a maximum of 254 bytes (255 is reserved for
+ * USB_NO_MSG below). If the usbconfig.h defines USB_CFG_LONG_TRANSFERS to 1,
+ * a 16 bit data type is used, allowing up to 16384 bytes (the rest is used
+ * for flags in the descriptor configuration).
+ */
+#define USB_NO_MSG  ((usbMsgLen_t)-1)   /* constant meaning "no message" */
+
+#ifndef usbMsgPtr_t
+#define usbMsgPtr_t uchar *
+#endif
+/* Making usbMsgPtr_t a define allows the user of this library to define it to
+ * an 8 bit type on tiny devices. This reduces code size, especially if the
+ * compiler supports a tiny memory model.
+ * The type can be a pointer or scalar type, casts are made where necessary.
+ * Although it's paradoxical, Gcc 4 generates slightly better code for scalar
+ * types than for pointers.
+ */
+
+struct usbRequest;  /* forward declaration */
+
+USB_PUBLIC void usbInit(void);
+/* This function must be called before interrupts are enabled and the main
+ * loop is entered. We exepct that the PORT and DDR bits for D+ and D- have
+ * not been changed from their default status (which is 0). If you have changed
+ * them, set both back to 0 (configure them as input with no internal pull-up).
+ */
+USB_PUBLIC void usbPoll(void);
+/* This function must be called at regular intervals from the main loop.
+ * Maximum delay between calls is somewhat less than 50ms (USB timeout for
+ * accepting a Setup message). Otherwise the device will not be recognized.
+ * Please note that debug outputs through the UART take ~ 0.5ms per byte
+ * at 19200 bps.
+ */
+extern usbMsgPtr_t usbMsgPtr;
+/* This variable may be used to pass transmit data to the driver from the
+ * implementation of usbFunctionWrite(). It is also used internally by the
+ * driver for standard control requests.
+ */
+USB_PUBLIC usbMsgLen_t usbFunctionSetup(uchar data[8]);
+/* This function is called when the driver receives a SETUP transaction from
+ * the host which is not answered by the driver itself (in practice: class and
+ * vendor requests). All control transfers start with a SETUP transaction where
+ * the host communicates the parameters of the following (optional) data
+ * transfer. The SETUP data is available in the 'data' parameter which can
+ * (and should) be casted to 'usbRequest_t *' for a more user-friendly access
+ * to parameters.
+ *
+ * If the SETUP indicates a control-in transfer, you should provide the
+ * requested data to the driver. There are two ways to transfer this data:
+ * (1) Set the global pointer 'usbMsgPtr' to the base of the static RAM data
+ * block and return the length of the data in 'usbFunctionSetup()'. The driver
+ * will handle the rest. Or (2) return USB_NO_MSG in 'usbFunctionSetup()'. The
+ * driver will then call 'usbFunctionRead()' when data is needed. See the
+ * documentation for usbFunctionRead() for details.
+ *
+ * If the SETUP indicates a control-out transfer, the only way to receive the
+ * data from the host is through the 'usbFunctionWrite()' call. If you
+ * implement this function, you must return USB_NO_MSG in 'usbFunctionSetup()'
+ * to indicate that 'usbFunctionWrite()' should be used. See the documentation
+ * of this function for more information. If you just want to ignore the data
+ * sent by the host, return 0 in 'usbFunctionSetup()'.
+ *
+ * Note that calls to the functions usbFunctionRead() and usbFunctionWrite()
+ * are only done if enabled by the configuration in usbconfig.h.
+ */
+USB_PUBLIC usbMsgLen_t usbFunctionDescriptor(struct usbRequest *rq);
+/* You need to implement this function ONLY if you provide USB descriptors at
+ * runtime (which is an expert feature). It is very similar to
+ * usbFunctionSetup() above, but it is called only to request USB descriptor
+ * data. See the documentation of usbFunctionSetup() above for more info.
+ */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len);
+/* This function sets the message which will be sent during the next interrupt
+ * IN transfer. The message is copied to an internal buffer and must not exceed
+ * a length of 8 bytes. The message may be 0 bytes long just to indicate the
+ * interrupt status to the host.
+ * If you need to transfer more bytes, use a control read after the interrupt.
+ */
+#define usbInterruptIsReady()   (usbTxLen1 & 0x10)
+/* This macro indicates whether the last interrupt message has already been
+ * sent. If you set a new interrupt message before the old was sent, the
+ * message already buffered will be lost.
+ */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len);
+#define usbInterruptIsReady3()   (usbTxLen3 & 0x10)
+/* Same as above for endpoint 3 */
+#endif
+#endif /* USB_CFG_HAVE_INTRIN_ENDPOINT */
+#if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    /* simplified interface for backward compatibility */
+#define usbHidReportDescriptor  usbDescriptorHidReport
+/* should be declared as: PROGMEM char usbHidReportDescriptor[]; */
+/* If you implement an HID device, you need to provide a report descriptor.
+ * The HID report descriptor syntax is a bit complex. If you understand how
+ * report descriptors are constructed, we recommend that you use the HID
+ * Descriptor Tool from usb.org, see http://www.usb.org/developers/hidpage/.
+ * Otherwise you should probably start with a working example.
+ */
+#endif  /* USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH */
+#if USB_CFG_IMPLEMENT_FN_WRITE
+USB_PUBLIC uchar usbFunctionWrite(uchar *data, uchar len);
+/* This function is called by the driver to provide a control transfer's
+ * payload data (control-out). It is called in chunks of up to 8 bytes. The
+ * total count provided in the current control transfer can be obtained from
+ * the 'length' property in the setup data. If an error occurred during
+ * processing, return 0xff (== -1). The driver will answer the entire transfer
+ * with a STALL token in this case. If you have received the entire payload
+ * successfully, return 1. If you expect more data, return 0. If you don't
+ * know whether the host will send more data (you should know, the total is
+ * provided in the usbFunctionSetup() call!), return 1.
+ * NOTE: If you return 0xff for STALL, 'usbFunctionWrite()' may still be called
+ * for the remaining data. You must continue to return 0xff for STALL in these
+ * calls.
+ * In order to get usbFunctionWrite() called, define USB_CFG_IMPLEMENT_FN_WRITE
+ * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_WRITE */
+#if USB_CFG_IMPLEMENT_FN_READ
+USB_PUBLIC uchar usbFunctionRead(uchar *data, uchar len);
+/* This function is called by the driver to ask the application for a control
+ * transfer's payload data (control-in). It is called in chunks of up to 8
+ * bytes each. You should copy the data to the location given by 'data' and
+ * return the actual number of bytes copied. If you return less than requested,
+ * the control-in transfer is terminated. If you return 0xff, the driver aborts
+ * the transfer with a STALL token.
+ * In order to get usbFunctionRead() called, define USB_CFG_IMPLEMENT_FN_READ
+ * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_READ */
+
+extern uchar usbRxToken;    /* may be used in usbFunctionWriteOut() below */
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+USB_PUBLIC void usbFunctionWriteOut(uchar *data, uchar len);
+/* This function is called by the driver when data is received on an interrupt-
+ * or bulk-out endpoint. The endpoint number can be found in the global
+ * variable usbRxToken. You must define USB_CFG_IMPLEMENT_FN_WRITEOUT to 1 in
+ * usbconfig.h to get this function called.
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_WRITEOUT */
+#ifdef USB_CFG_PULLUP_IOPORTNAME
+#define usbDeviceConnect()      ((USB_PULLUP_DDR |= (1<<USB_CFG_PULLUP_BIT)), \
+                                  (USB_PULLUP_OUT |= (1<<USB_CFG_PULLUP_BIT)))
+#define usbDeviceDisconnect()   ((USB_PULLUP_DDR &= ~(1<<USB_CFG_PULLUP_BIT)), \
+                                  (USB_PULLUP_OUT &= ~(1<<USB_CFG_PULLUP_BIT)))
+#else /* USB_CFG_PULLUP_IOPORTNAME */
+#define usbDeviceConnect()      (USBDDR &= ~(1<<USBMINUS))
+#define usbDeviceDisconnect()   (USBDDR |= (1<<USBMINUS))
+#endif /* USB_CFG_PULLUP_IOPORTNAME */
+/* The macros usbDeviceConnect() and usbDeviceDisconnect() (intended to look
+ * like a function) connect resp. disconnect the device from the host's USB.
+ * If the constants USB_CFG_PULLUP_IOPORT and USB_CFG_PULLUP_BIT are defined
+ * in usbconfig.h, a disconnect consists of removing the pull-up resisitor
+ * from D-, otherwise the disconnect is done by brute-force pulling D- to GND.
+ * This does not conform to the spec, but it works.
+ * Please note that the USB interrupt must be disabled while the device is
+ * in disconnected state, or the interrupt handler will hang! You can either
+ * turn off the USB interrupt selectively with
+ *     USB_INTR_ENABLE &= ~(1 << USB_INTR_ENABLE_BIT)
+ * or use cli() to disable interrupts globally.
+ */
+extern unsigned usbCrc16(unsigned data, uchar len);
+#define usbCrc16(data, len) usbCrc16((unsigned)(data), len)
+/* This function calculates the binary complement of the data CRC used in
+ * USB data packets. The value is used to build raw transmit packets.
+ * You may want to use this function for data checksums or to verify received
+ * data. We enforce 16 bit calling conventions for compatibility with IAR's
+ * tiny memory model.
+ */
+extern unsigned usbCrc16Append(unsigned data, uchar len);
+#define usbCrc16Append(data, len)    usbCrc16Append((unsigned)(data), len)
+/* This function is equivalent to usbCrc16() above, except that it appends
+ * the 2 bytes CRC (lowbyte first) in the 'data' buffer after reading 'len'
+ * bytes.
+ */
+#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
+extern unsigned usbMeasureFrameLength(void);
+/* This function MUST be called IMMEDIATELY AFTER USB reset and measures 1/7 of
+ * the number of CPU cycles during one USB frame minus one low speed bit
+ * length. In other words: return value = 1499 * (F_CPU / 10.5 MHz)
+ * Since this is a busy wait, you MUST disable all interrupts with cli() before
+ * calling this function.
+ * This can be used to calibrate the AVR's RC oscillator.
+ */
+#endif
+extern uchar    usbConfiguration;
+/* This value contains the current configuration set by the host. The driver
+ * allows setting and querying of this variable with the USB SET_CONFIGURATION
+ * and GET_CONFIGURATION requests, but does not use it otherwise.
+ * You may want to reflect the "configured" status with a LED on the device or
+ * switch on high power parts of the circuit only if the device is configured.
+ */
+#if USB_COUNT_SOF
+extern volatile uchar   usbSofCount;
+/* This variable is incremented on every SOF packet. It is only available if
+ * the macro USB_COUNT_SOF is defined to a value != 0.
+ */
+#endif
+#if USB_CFG_CHECK_DATA_TOGGLING
+extern uchar    usbCurrentDataToken;
+/* This variable can be checked in usbFunctionWrite() and usbFunctionWriteOut()
+ * to ignore duplicate packets.
+ */
+#endif
+
+#define USB_STRING_DESCRIPTOR_HEADER(stringLength) ((2*(stringLength)+2) | (3<<8))
+/* This macro builds a descriptor header for a string descriptor given the
+ * string's length. See usbdrv.c for an example how to use it.
+ */
+#if USB_CFG_HAVE_FLOWCONTROL
+extern volatile schar   usbRxLen;
+#define usbDisableAllRequests()     usbRxLen = -1
+/* Must be called from usbFunctionWrite(). This macro disables all data input
+ * from the USB interface. Requests from the host are answered with a NAK
+ * while they are disabled.
+ */
+#define usbEnableAllRequests()      usbRxLen = 0
+/* May only be called if requests are disabled. This macro enables input from
+ * the USB interface after it has been disabled with usbDisableAllRequests().
+ */
+#define usbAllRequestsAreDisabled() (usbRxLen < 0)
+/* Use this macro to find out whether requests are disabled. It may be needed
+ * to ensure that usbEnableAllRequests() is never called when requests are
+ * enabled.
+ */
+#endif
+
+#define USB_SET_DATATOKEN1(token)   usbTxBuf1[0] = token
+#define USB_SET_DATATOKEN3(token)   usbTxBuf3[0] = token
+/* These two macros can be used by application software to reset data toggling
+ * for interrupt-in endpoints 1 and 3. Since the token is toggled BEFORE
+ * sending data, you must set the opposite value of the token which should come
+ * first.
+ */
+
+#endif  /* __ASSEMBLER__ */
+
+
+/* ------------------------------------------------------------------------- */
+/* ----------------- Definitions for Descriptor Properties ----------------- */
+/* ------------------------------------------------------------------------- */
+/* This is advanced stuff. See usbconfig-prototype.h for more information
+ * about the various methods to define USB descriptors. If you do nothing,
+ * the default descriptors will be used.
+ */
+#define USB_PROP_IS_DYNAMIC     (1u << 14)
+/* If this property is set for a descriptor, usbFunctionDescriptor() will be
+ * used to obtain the particular descriptor. Data directly returned via
+ * usbMsgPtr are FLASH data by default, combine (OR) with USB_PROP_IS_RAM to
+ * return RAM data.
+ */
+#define USB_PROP_IS_RAM         (1u << 15)
+/* If this property is set for a descriptor, the data is read from RAM
+ * memory instead of Flash. The property is used for all methods to provide
+ * external descriptors.
+ */
+#define USB_PROP_LENGTH(len)    ((len) & 0x3fff)
+/* If a static external descriptor is used, this is the total length of the
+ * descriptor in bytes.
+ */
+
+/* all descriptors which may have properties: */
+#ifndef USB_CFG_DESCR_PROPS_DEVICE
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_CONFIGURATION
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRINGS
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_VENDOR
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_PRODUCT
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_HID
+#define USB_CFG_DESCR_PROPS_HID                     0
+#endif
+#if !(USB_CFG_DESCR_PROPS_HID_REPORT)
+#   undef USB_CFG_DESCR_PROPS_HID_REPORT
+#   if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH /* do some backward compatibility tricks */
+#       define USB_CFG_DESCR_PROPS_HID_REPORT       USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH
+#   else
+#       define USB_CFG_DESCR_PROPS_HID_REPORT       0
+#   endif
+#endif
+#ifndef USB_CFG_DESCR_PROPS_UNKNOWN
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+#endif
+
+/* ------------------ forward declaration of descriptors ------------------- */
+/* If you use external static descriptors, they must be stored in global
+ * arrays as declared below:
+ */
+#ifndef __ASSEMBLER__
+extern
+#if !(USB_CFG_DESCR_PROPS_DEVICE & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorDevice[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_CONFIGURATION & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorConfiguration[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_HID_REPORT & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorHidReport[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_0 & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorString0[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_VENDOR & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+int usbDescriptorStringVendor[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_PRODUCT & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+int usbDescriptorStringDevice[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+int usbDescriptorStringSerialNumber[];
+
+#endif /* __ASSEMBLER__ */
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------ General Purpose Macros ------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#define USB_CONCAT(a, b)            a ## b
+#define USB_CONCAT_EXPANDED(a, b)   USB_CONCAT(a, b)
+
+#define USB_OUTPORT(name)           USB_CONCAT(PORT, name)
+#define USB_INPORT(name)            USB_CONCAT(PIN, name)
+#define USB_DDRPORT(name)           USB_CONCAT(DDR, name)
+/* The double-define trick above lets us concatenate strings which are
+ * defined by macros.
+ */
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------- Constant definitions -------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#if !defined __ASSEMBLER__ && (!defined USB_CFG_VENDOR_ID || !defined USB_CFG_DEVICE_ID)
+#warning "You should define USB_CFG_VENDOR_ID and USB_CFG_DEVICE_ID in usbconfig.h"
+/* If the user has not defined IDs, we default to obdev's free IDs.
+ * See USB-IDs-for-free.txt for details.
+ */
+#endif
+
+/* make sure we have a VID and PID defined, byte order is lowbyte, highbyte */
+#ifndef USB_CFG_VENDOR_ID
+#   define  USB_CFG_VENDOR_ID   0xc0, 0x16  /* = 0x16c0 = 5824 = voti.nl */
+#endif
+
+#ifndef USB_CFG_DEVICE_ID
+#   if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH
+#       define USB_CFG_DEVICE_ID    0xdf, 0x05  /* = 0x5df = 1503, shared PID for HIDs */
+#   elif USB_CFG_INTERFACE_CLASS == 2
+#       define USB_CFG_DEVICE_ID    0xe1, 0x05  /* = 0x5e1 = 1505, shared PID for CDC Modems */
+#   else
+#       define USB_CFG_DEVICE_ID    0xdc, 0x05  /* = 0x5dc = 1500, obdev's free PID */
+#   endif
+#endif
+
+/* Derive Output, Input and DataDirection ports from port names */
+#ifndef USB_CFG_IOPORTNAME
+#error "You must define USB_CFG_IOPORTNAME in usbconfig.h, see usbconfig-prototype.h"
+#endif
+
+#define USBOUT          USB_OUTPORT(USB_CFG_IOPORTNAME)
+#define USB_PULLUP_OUT  USB_OUTPORT(USB_CFG_PULLUP_IOPORTNAME)
+#define USBIN           USB_INPORT(USB_CFG_IOPORTNAME)
+#define USBDDR          USB_DDRPORT(USB_CFG_IOPORTNAME)
+#define USB_PULLUP_DDR  USB_DDRPORT(USB_CFG_PULLUP_IOPORTNAME)
+
+#define USBMINUS    USB_CFG_DMINUS_BIT
+#define USBPLUS     USB_CFG_DPLUS_BIT
+#define USBIDLE     (1<<USB_CFG_DMINUS_BIT) /* value representing J state */
+#define USBMASK     ((1<<USB_CFG_DPLUS_BIT) | (1<<USB_CFG_DMINUS_BIT))  /* mask for USB I/O bits */
+
+/* defines for backward compatibility with older driver versions: */
+#define USB_CFG_IOPORT          USB_OUTPORT(USB_CFG_IOPORTNAME)
+#ifdef USB_CFG_PULLUP_IOPORTNAME
+#define USB_CFG_PULLUP_IOPORT   USB_OUTPORT(USB_CFG_PULLUP_IOPORTNAME)
+#endif
+
+#ifndef USB_CFG_EP3_NUMBER  /* if not defined in usbconfig.h */
+#define USB_CFG_EP3_NUMBER  3
+#endif
+
+#ifndef USB_CFG_HAVE_INTRIN_ENDPOINT3
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+#endif
+
+#define USB_BUFSIZE     11  /* PID, 8 bytes data, 2 bytes CRC */
+
+/* ----- Try to find registers and bits responsible for ext interrupt 0 ----- */
+
+#ifndef USB_INTR_CFG    /* allow user to override our default */
+#   if defined  EICRA
+#       define USB_INTR_CFG EICRA
+#   else
+#       define USB_INTR_CFG MCUCR
+#   endif
+#endif
+#ifndef USB_INTR_CFG_SET    /* allow user to override our default */
+#   if defined(USB_COUNT_SOF) || defined(USB_SOF_HOOK)
+#       define USB_INTR_CFG_SET (1 << ISC01)                    /* cfg for falling edge */
+        /* If any SOF logic is used, the interrupt must be wired to D- where
+         * we better trigger on falling edge
+         */
+#   else
+#       define USB_INTR_CFG_SET ((1 << ISC00) | (1 << ISC01))   /* cfg for rising edge */
+#   endif
+#endif
+#ifndef USB_INTR_CFG_CLR    /* allow user to override our default */
+#   define USB_INTR_CFG_CLR 0    /* no bits to clear */
+#endif
+
+#ifndef USB_INTR_ENABLE     /* allow user to override our default */
+#   if defined GIMSK
+#       define USB_INTR_ENABLE  GIMSK
+#   elif defined EIMSK
+#       define USB_INTR_ENABLE  EIMSK
+#   else
+#       define USB_INTR_ENABLE  GICR
+#   endif
+#endif
+#ifndef USB_INTR_ENABLE_BIT /* allow user to override our default */
+#   define USB_INTR_ENABLE_BIT  INT0
+#endif
+
+#ifndef USB_INTR_PENDING    /* allow user to override our default */
+#   if defined  EIFR
+#       define USB_INTR_PENDING EIFR
+#   else
+#       define USB_INTR_PENDING GIFR
+#   endif
+#endif
+#ifndef USB_INTR_PENDING_BIT    /* allow user to override our default */
+#   define USB_INTR_PENDING_BIT INTF0
+#endif
+
+/*
+The defines above don't work for the following chips
+at90c8534: no ISC0?, no PORTB, can't find a data sheet
+at86rf401: no PORTB, no MCUCR etc, low clock rate
+atmega103: no ISC0? (maybe omission in header, can't find data sheet)
+atmega603: not defined in avr-libc
+at43usb320, at43usb355, at76c711: have USB anyway
+at94k: is different...
+
+at90s1200, attiny11, attiny12, attiny15, attiny28: these have no RAM
+*/
+
+/* ------------------------------------------------------------------------- */
+/* ----------------- USB Specification Constants and Types ----------------- */
+/* ------------------------------------------------------------------------- */
+
+/* USB Token values */
+#define USBPID_SETUP    0x2d
+#define USBPID_OUT      0xe1
+#define USBPID_IN       0x69
+#define USBPID_DATA0    0xc3
+#define USBPID_DATA1    0x4b
+
+#define USBPID_ACK      0xd2
+#define USBPID_NAK      0x5a
+#define USBPID_STALL    0x1e
+
+#ifndef USB_INITIAL_DATATOKEN
+#define USB_INITIAL_DATATOKEN   USBPID_DATA1
+#endif
+
+#ifndef __ASSEMBLER__
+
+typedef struct usbTxStatus{
+    volatile uchar   len;
+    uchar   buffer[USB_BUFSIZE];
+}usbTxStatus_t;
+
+extern usbTxStatus_t   usbTxStatus1, usbTxStatus3;
+#define usbTxLen1   usbTxStatus1.len
+#define usbTxBuf1   usbTxStatus1.buffer
+#define usbTxLen3   usbTxStatus3.len
+#define usbTxBuf3   usbTxStatus3.buffer
+
+
+typedef union usbWord{
+    unsigned    word;
+    uchar       bytes[2];
+}usbWord_t;
+
+typedef struct usbRequest{
+    uchar       bmRequestType;
+    uchar       bRequest;
+    usbWord_t   wValue;
+    usbWord_t   wIndex;
+    usbWord_t   wLength;
+}usbRequest_t;
+/* This structure matches the 8 byte setup request */
+#endif
+
+/* bmRequestType field in USB setup:
+ * d t t r r r r r, where
+ * d ..... direction: 0=host->device, 1=device->host
+ * t ..... type: 0=standard, 1=class, 2=vendor, 3=reserved
+ * r ..... recipient: 0=device, 1=interface, 2=endpoint, 3=other
+ */
+
+/* USB setup recipient values */
+#define USBRQ_RCPT_MASK         0x1f
+#define USBRQ_RCPT_DEVICE       0
+#define USBRQ_RCPT_INTERFACE    1
+#define USBRQ_RCPT_ENDPOINT     2
+
+/* USB request type values */
+#define USBRQ_TYPE_MASK         0x60
+#define USBRQ_TYPE_STANDARD     (0<<5)
+#define USBRQ_TYPE_CLASS        (1<<5)
+#define USBRQ_TYPE_VENDOR       (2<<5)
+
+/* USB direction values: */
+#define USBRQ_DIR_MASK              0x80
+#define USBRQ_DIR_HOST_TO_DEVICE    (0<<7)
+#define USBRQ_DIR_DEVICE_TO_HOST    (1<<7)
+
+/* USB Standard Requests */
+#define USBRQ_GET_STATUS        0
+#define USBRQ_CLEAR_FEATURE     1
+#define USBRQ_SET_FEATURE       3
+#define USBRQ_SET_ADDRESS       5
+#define USBRQ_GET_DESCRIPTOR    6
+#define USBRQ_SET_DESCRIPTOR    7
+#define USBRQ_GET_CONFIGURATION 8
+#define USBRQ_SET_CONFIGURATION 9
+#define USBRQ_GET_INTERFACE     10
+#define USBRQ_SET_INTERFACE     11
+#define USBRQ_SYNCH_FRAME       12
+
+/* USB descriptor constants */
+#define USBDESCR_DEVICE         1
+#define USBDESCR_CONFIG         2
+#define USBDESCR_STRING         3
+#define USBDESCR_INTERFACE      4
+#define USBDESCR_ENDPOINT       5
+#define USBDESCR_HID            0x21
+#define USBDESCR_HID_REPORT     0x22
+#define USBDESCR_HID_PHYS       0x23
+
+//#define USBATTR_BUSPOWER        0x80  // USB 1.1 does not define this value any more
+#define USBATTR_BUSPOWER        0
+#define USBATTR_SELFPOWER       0x40
+#define USBATTR_REMOTEWAKE      0x20
+
+/* USB HID Requests */
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_GET_IDLE      0x02
+#define USBRQ_HID_GET_PROTOCOL  0x03
+#define USBRQ_HID_SET_REPORT    0x09
+#define USBRQ_HID_SET_IDLE      0x0a
+#define USBRQ_HID_SET_PROTOCOL  0x0b
+
+/* ------------------------------------------------------------------------- */
+
+#endif /* __usbdrv_h_included__ */
Index: vusb-20121206/usbdrv/usbdrvasm.S
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm.S	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm.S	(working copy)
@@ -0,0 +1,392 @@
+/* Name: usbdrvasm.S
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-13
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module is the assembler part of the USB driver. This file contains
+general code (preprocessor acrobatics and CRC computation) and then includes
+the file appropriate for the given clock rate.
+*/
+
+#define __SFR_OFFSET 0      /* used by avr-libc's register definitions */
+#include "usbportability.h"
+#include "usbdrv.h"         /* for common defs */
+
+/* register names */
+#define x1      r16
+#define x2      r17
+#define shift   r18
+#define cnt     r19
+#define x3      r20
+#define x4      r21
+#define x5		r22
+#define bitcnt  x5
+#define phase   x4
+#define leap    x4
+
+/* Some assembler dependent definitions and declarations: */
+
+#ifdef __IAR_SYSTEMS_ASM__
+    extern  usbRxBuf, usbDeviceAddr, usbNewDeviceAddr, usbInputBufOffset
+    extern  usbCurrentTok, usbRxLen, usbRxToken, usbTxLen
+    extern  usbTxBuf, usbTxStatus1, usbTxStatus3
+#   if USB_COUNT_SOF
+        extern usbSofCount
+#   endif
+    public  usbCrc16
+    public  usbCrc16Append
+
+    COMMON  INTVEC
+#   ifndef USB_INTR_VECTOR
+        ORG     INT0_vect
+#   else /* USB_INTR_VECTOR */
+        ORG     USB_INTR_VECTOR
+#       undef   USB_INTR_VECTOR
+#   endif /* USB_INTR_VECTOR */
+#   define  USB_INTR_VECTOR usbInterruptHandler
+    rjmp    USB_INTR_VECTOR
+    RSEG    CODE
+
+#else /* __IAR_SYSTEMS_ASM__ */
+
+#   ifndef USB_INTR_VECTOR /* default to hardware interrupt INT0 */
+#       ifdef INT0_vect
+#           define USB_INTR_VECTOR  INT0_vect       // this is the "new" define for the vector
+#       else
+#           define USB_INTR_VECTOR  SIG_INTERRUPT0  // this is the "old" vector
+#       endif
+#   endif
+    .text
+    .global USB_INTR_VECTOR
+    .type   USB_INTR_VECTOR, @function
+    .global usbCrc16
+    .global usbCrc16Append
+#endif /* __IAR_SYSTEMS_ASM__ */
+
+
+#if USB_INTR_PENDING < 0x40 /* This is an I/O address, use in and out */
+#   define  USB_LOAD_PENDING(reg)   in reg, USB_INTR_PENDING
+#   define  USB_STORE_PENDING(reg)  out USB_INTR_PENDING, reg
+#else   /* It's a memory address, use lds and sts */
+#   define  USB_LOAD_PENDING(reg)   lds reg, USB_INTR_PENDING
+#   define  USB_STORE_PENDING(reg)  sts USB_INTR_PENDING, reg
+#endif
+
+#define usbTxLen1   usbTxStatus1
+#define usbTxBuf1   (usbTxStatus1 + 1)
+#define usbTxLen3   usbTxStatus3
+#define usbTxBuf3   (usbTxStatus3 + 1)
+
+
+;----------------------------------------------------------------------------
+; Utility functions
+;----------------------------------------------------------------------------
+
+#ifdef __IAR_SYSTEMS_ASM__
+/* Register assignments for usbCrc16 on IAR cc */
+/* Calling conventions on IAR:
+ * First parameter passed in r16/r17, second in r18/r19 and so on.
+ * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+ * Result is passed in r16/r17
+ * In case of the "tiny" memory model, pointers are only 8 bit with no
+ * padding. We therefore pass argument 1 as "16 bit unsigned".
+ */
+RTMODEL "__rt_version", "3"
+/* The line above will generate an error if cc calling conventions change.
+ * The value "3" above is valid for IAR 4.10B/W32
+ */
+#   define argLen   r18 /* argument 2 */
+#   define argPtrL  r16 /* argument 1 */
+#   define argPtrH  r17 /* argument 1 */
+
+#   define resCrcL  r16 /* result */
+#   define resCrcH  r17 /* result */
+
+#   define ptrL     ZL
+#   define ptrH     ZH
+#   define ptr      Z
+#   define byte     r22
+#   define bitCnt   r19
+#   define polyL    r20
+#   define polyH    r21
+#   define scratch  r23
+
+#else  /* __IAR_SYSTEMS_ASM__ */ 
+/* Register assignments for usbCrc16 on gcc */
+/* Calling conventions on gcc:
+ * First parameter passed in r24/r25, second in r22/23 and so on.
+ * Callee must preserve r1-r17, r28/r29
+ * Result is passed in r24/r25
+ */
+#   define argLen   r22 /* argument 2 */
+#   define argPtrL  r24 /* argument 1 */
+#   define argPtrH  r25 /* argument 1 */
+
+#   define resCrcL  r24 /* result */
+#   define resCrcH  r25 /* result */
+
+#   define ptrL     XL
+#   define ptrH     XH
+#   define ptr      x
+#   define byte     r18
+#   define bitCnt   r19
+#   define polyL    r20
+#   define polyH    r21
+#   define scratch  r23
+
+#endif
+
+#if USB_USE_FAST_CRC
+
+; This implementation is faster, but has bigger code size
+; Thanks to Slawomir Fras (BoskiDialer) for this code!
+; It implements the following C pseudo-code:
+; unsigned table(unsigned char x)
+; {
+; unsigned    value;
+; 
+;     value = (unsigned)x << 6;
+;     value ^= (unsigned)x << 7;
+;     if(parity(x))
+;         value ^= 0xc001;
+;     return value;
+; }
+; unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen)
+; {
+; unsigned crc = 0xffff;
+; 
+;     while(argLen--)
+;         crc = table(lo8(crc) ^ *argPtr++) ^ hi8(crc);
+;     return ~crc;
+; }
+
+; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+;   argPtr  r24+25 / r16+r17
+;   argLen  r22 / r18
+; temp variables:
+;   byte    r18 / r22
+;   scratch r23
+;   resCrc  r24+r25 / r16+r17
+;   ptr     X / Z
+usbCrc16:
+    mov     ptrL, argPtrL
+    mov     ptrH, argPtrH
+    ldi     resCrcL, 0xFF
+    ldi     resCrcH, 0xFF
+    rjmp    usbCrc16LoopTest
+usbCrc16ByteLoop:
+    ld      byte, ptr+
+    eor     resCrcL, byte   ; resCrcL is now 'x' in table()
+    mov     byte, resCrcL   ; compute parity of 'x'
+    swap    byte
+    eor     byte, resCrcL
+    mov     scratch, byte
+    lsr     byte
+    lsr     byte
+    eor     byte, scratch
+    inc     byte
+    lsr     byte
+    andi    byte, 1         ; byte is now parity(x)
+    mov     scratch, resCrcL
+    mov     resCrcL, resCrcH
+    eor     resCrcL, byte   ; low byte of if(parity(x)) value ^= 0xc001;
+    neg     byte
+    andi    byte, 0xc0
+    mov     resCrcH, byte   ; high byte of if(parity(x)) value ^= 0xc001;
+    clr     byte
+    lsr     scratch
+    ror     byte
+    eor     resCrcH, scratch
+    eor     resCrcL, byte
+    lsr     scratch
+    ror     byte
+    eor     resCrcH, scratch
+    eor     resCrcL, byte
+usbCrc16LoopTest:
+    subi    argLen, 1
+    brsh    usbCrc16ByteLoop
+    com     resCrcL
+    com     resCrcH
+    ret
+
+#else   /* USB_USE_FAST_CRC */
+
+; This implementation is slower, but has less code size
+;
+; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+;   argPtr  r24+25 / r16+r17
+;   argLen  r22 / r18
+; temp variables:
+;   byte    r18 / r22
+;   bitCnt  r19
+;   poly    r20+r21
+;   scratch r23
+;   resCrc  r24+r25 / r16+r17
+;   ptr     X / Z
+usbCrc16:
+    mov     ptrL, argPtrL
+    mov     ptrH, argPtrH
+    ldi     resCrcL, 0
+    ldi     resCrcH, 0
+    ldi     polyL, lo8(0xa001)
+    ldi     polyH, hi8(0xa001)
+    com     argLen      ; argLen = -argLen - 1: modified loop to ensure that carry is set
+    ldi     bitCnt, 0   ; loop counter with starnd condition = end condition
+    rjmp    usbCrcLoopEntry
+usbCrcByteLoop:
+    ld      byte, ptr+
+    eor     resCrcL, byte
+usbCrcBitLoop:
+    ror     resCrcH     ; carry is always set here (see brcs jumps to here)
+    ror     resCrcL
+    brcs    usbCrcNoXor
+    eor     resCrcL, polyL
+    eor     resCrcH, polyH
+usbCrcNoXor:
+    subi    bitCnt, 224 ; (8 * 224) % 256 = 0; this loop iterates 8 times
+    brcs    usbCrcBitLoop
+usbCrcLoopEntry:
+    subi    argLen, -1
+    brcs    usbCrcByteLoop
+usbCrcReady:
+    ret
+; Thanks to Reimar Doeffinger for optimizing this CRC routine!
+
+#endif /* USB_USE_FAST_CRC */
+
+; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
+usbCrc16Append:
+    rcall   usbCrc16
+    st      ptr+, resCrcL
+    st      ptr+, resCrcH
+    ret
+
+#undef argLen
+#undef argPtrL
+#undef argPtrH
+#undef resCrcL
+#undef resCrcH
+#undef ptrL
+#undef ptrH
+#undef ptr
+#undef byte
+#undef bitCnt
+#undef polyL
+#undef polyH
+#undef scratch
+
+
+#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
+#ifdef __IAR_SYSTEMS_ASM__
+/* Register assignments for usbMeasureFrameLength on IAR cc */
+/* Calling conventions on IAR:
+ * First parameter passed in r16/r17, second in r18/r19 and so on.
+ * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+ * Result is passed in r16/r17
+ * In case of the "tiny" memory model, pointers are only 8 bit with no
+ * padding. We therefore pass argument 1 as "16 bit unsigned".
+ */
+#   define resL     r16
+#   define resH     r17
+#   define cnt16L   r30
+#   define cnt16H   r31
+#   define cntH     r18
+
+#else  /* __IAR_SYSTEMS_ASM__ */ 
+/* Register assignments for usbMeasureFrameLength on gcc */
+/* Calling conventions on gcc:
+ * First parameter passed in r24/r25, second in r22/23 and so on.
+ * Callee must preserve r1-r17, r28/r29
+ * Result is passed in r24/r25
+ */
+#   define resL     r24
+#   define resH     r25
+#   define cnt16L   r24
+#   define cnt16H   r25
+#   define cntH     r26
+#endif
+#   define cnt16    cnt16L
+
+; extern unsigned usbMeasurePacketLength(void);
+; returns time between two idle strobes in multiples of 7 CPU clocks
+.global usbMeasureFrameLength
+usbMeasureFrameLength:
+    ldi     cntH, 6         ; wait ~ 10 ms for D- == 0
+    clr     cnt16L
+    clr     cnt16H
+usbMFTime16:
+    dec     cntH
+    breq    usbMFTimeout
+usbMFWaitStrobe:            ; first wait for D- == 0 (idle strobe)
+    sbiw    cnt16, 1        ;[0] [6]
+    breq    usbMFTime16     ;[2]
+    sbic    USBIN, USBMINUS ;[3]
+    rjmp    usbMFWaitStrobe ;[4]
+usbMFWaitIdle:              ; then wait until idle again
+    sbis    USBIN, USBMINUS ;1 wait for D- == 1
+    rjmp    usbMFWaitIdle   ;2
+    ldi     cnt16L, 1       ;1 represents cycles so far
+    clr     cnt16H          ;1
+usbMFWaitLoop:
+    in      cntH, USBIN     ;[0] [7]
+    adiw    cnt16, 1        ;[1]
+    breq    usbMFTimeout    ;[3]
+    andi    cntH, USBMASK   ;[4]
+    brne    usbMFWaitLoop   ;[5]
+usbMFTimeout:
+#if resL != cnt16L
+    mov     resL, cnt16L
+    mov     resH, cnt16H
+#endif
+    ret
+
+#undef resL
+#undef resH
+#undef cnt16
+#undef cnt16L
+#undef cnt16H
+#undef cntH
+
+#endif  /* USB_CFG_HAVE_MEASURE_FRAME_LENGTH */
+
+;----------------------------------------------------------------------------
+; Now include the clock rate specific code
+;----------------------------------------------------------------------------
+
+#ifndef USB_CFG_CLOCK_KHZ
+#   ifdef F_CPU
+#       define USB_CFG_CLOCK_KHZ (F_CPU/1000)
+#   else
+#       error "USB_CFG_CLOCK_KHZ not defined in usbconfig.h and no F_CPU set!"
+#   endif
+#endif
+
+#if USB_CFG_CHECK_CRC   /* separate dispatcher for CRC type modules */
+#   if USB_CFG_CLOCK_KHZ == 18000
+#       include "usbdrvasm18-crc.inc"
+#   else
+#       error "USB_CFG_CLOCK_KHZ is not one of the supported crc-rates!"
+#   endif
+#else   /* USB_CFG_CHECK_CRC */
+#   if USB_CFG_CLOCK_KHZ == 12000
+#       include "usbdrvasm12.inc"
+#   elif USB_CFG_CLOCK_KHZ == 12800
+#       include "usbdrvasm128.inc"
+#   elif USB_CFG_CLOCK_KHZ == 15000
+#       include "usbdrvasm15.inc"
+#   elif USB_CFG_CLOCK_KHZ == 16000
+#       include "usbdrvasm16.inc"
+#   elif USB_CFG_CLOCK_KHZ == 16500
+#       include "usbdrvasm165.inc"
+#   elif USB_CFG_CLOCK_KHZ == 20000
+#       include "usbdrvasm20.inc"
+#   else
+#       error "USB_CFG_CLOCK_KHZ is not one of the supported non-crc-rates!"
+#   endif
+#endif /* USB_CFG_CHECK_CRC */
Index: vusb-20121206/usbdrv/usbdrvasm.asm
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm.asm	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm.asm	(working copy)
@@ -0,0 +1,20 @@
+/* Name: usbdrvasm.asm
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-03-01
+ * Tabsize: 4
+ * Copyright: (c) 2006 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The IAR compiler/assembler system prefers assembler files with file extension
+".asm". We simply provide this file as an alias for usbdrvasm.S.
+
+Thanks to Oleg Semyonov for his help with the IAR tools port!
+*/
+
+#include "usbdrvasm.S"
+
+end
Index: vusb-20121206/usbdrv/usbdrvasm12.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm12.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm12.inc	(working copy)
@@ -0,0 +1,392 @@
+/* Name: usbdrvasm12.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 12 MHz version of the asssembler part of the USB driver. It
+requires a 12 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+
+
+Timing constraints according to spec (in bit times):
+timing subject                                      min max    CPUcycles
+---------------------------------------------------------------------------
+EOP of OUT/SETUP to sync pattern of DATA0 (both rx) 2   16     16-128
+EOP of IN to sync pattern of DATA0 (rx, then tx)    2   7.5    16-60
+DATAx (rx) to ACK/NAK/STALL (tx)                    2   7.5    16-60
+*/
+
+;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
+;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
+;max allowable interrupt latency: 34 cycles -> max 25 cycles interrupt disable
+;max stack usage: [ret(2), YL, SREG, YH, shift, x1, x2, x3, cnt, x4] = 11 bytes
+;Numbers in brackets are maximum cycles since SOF.
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt
+    push    YL              ;2 [35] push only what is necessary to sync with edge ASAP
+    in      YL, SREG        ;1 [37]
+    push    YL              ;2 [39]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    YH                  ;2 [2]
+    lds     YL, usbInputBufOffset;2 [4]
+    clr     YH                  ;1 [5]
+    subi    YL, lo8(-(usbRxBuf));1 [6]
+    sbci    YH, hi8(-(usbRxBuf));1 [7]
+
+    sbis    USBIN, USBMINUS ;1 [8] we want two bits K [sample 1 cycle too early]
+    rjmp    haveTwoBitsK    ;2 [10]
+    pop     YH              ;2 [11] undo the push from before
+    rjmp    waitForK        ;2 [13] this was not the end of sync, retry
+haveTwoBitsK:
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+    push    shift           ;2 [16]
+    push    x1              ;2 [12]
+    push    x2              ;2 [14]
+
+    in      x1, USBIN       ;1 [17] <-- sample bit 0
+    ldi     shift, 0xff     ;1 [18]
+    bst     x1, USBMINUS    ;1 [19]
+    bld     shift, 0        ;1 [20]
+    push    x3              ;2 [22]
+    push    cnt             ;2 [24]
+    
+    in      x2, USBIN       ;1 [25] <-- sample bit 1
+    ser     x3              ;1 [26] [inserted init instruction]
+    eor     x1, x2          ;1 [27]
+    bst     x1, USBMINUS    ;1 [28]
+    bld     shift, 1        ;1 [29]
+    ldi     cnt, USB_BUFSIZE;1 [30] [inserted init instruction]
+    rjmp    rxbit2          ;2 [32]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+
+unstuff0:               ;1 (branch taken)
+    andi    x3, ~0x01   ;1 [15]
+    mov     x1, x2      ;1 [16] x2 contains last sampled (stuffed) bit
+    in      x2, USBIN   ;1 [17] <-- sample bit 1 again
+    ori     shift, 0x01 ;1 [18]
+    rjmp    didUnstuff0 ;2 [20]
+
+unstuff1:               ;1 (branch taken)
+    mov     x2, x1      ;1 [21] x1 contains last sampled (stuffed) bit
+    andi    x3, ~0x02   ;1 [22]
+    ori     shift, 0x02 ;1 [23]
+    nop                 ;1 [24]
+    in      x1, USBIN   ;1 [25] <-- sample bit 2 again
+    rjmp    didUnstuff1 ;2 [27]
+
+unstuff2:               ;1 (branch taken)
+    andi    x3, ~0x04   ;1 [29]
+    ori     shift, 0x04 ;1 [30]
+    mov     x1, x2      ;1 [31] x2 contains last sampled (stuffed) bit
+    nop                 ;1 [32]
+    in      x2, USBIN   ;1 [33] <-- sample bit 3
+    rjmp    didUnstuff2 ;2 [35]
+
+unstuff3:               ;1 (branch taken)
+    in      x2, USBIN   ;1 [34] <-- sample stuffed bit 3 [one cycle too late]
+    andi    x3, ~0x08   ;1 [35]
+    ori     shift, 0x08 ;1 [36]
+    rjmp    didUnstuff3 ;2 [38]
+
+unstuff4:               ;1 (branch taken)
+    andi    x3, ~0x10   ;1 [40]
+    in      x1, USBIN   ;1 [41] <-- sample stuffed bit 4
+    ori     shift, 0x10 ;1 [42]
+    rjmp    didUnstuff4 ;2 [44]
+
+unstuff5:               ;1 (branch taken)
+    andi    x3, ~0x20   ;1 [48]
+    in      x2, USBIN   ;1 [49] <-- sample stuffed bit 5
+    ori     shift, 0x20 ;1 [50]
+    rjmp    didUnstuff5 ;2 [52]
+
+unstuff6:               ;1 (branch taken)
+    andi    x3, ~0x40   ;1 [56]
+    in      x1, USBIN   ;1 [57] <-- sample stuffed bit 6
+    ori     shift, 0x40 ;1 [58]
+    rjmp    didUnstuff6 ;2 [60]
+
+; extra jobs done during bit interval:
+; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs]
+; bit 1:    se0 check
+; bit 2:    overflow check
+; bit 3:    recovery from delay [bit 0 tasks took too long]
+; bit 4:    none
+; bit 5:    none
+; bit 6:    none
+; bit 7:    jump, eor
+rxLoop:
+    eor     x3, shift   ;1 [0] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    in      x1, USBIN   ;1 [1] <-- sample bit 0
+    st      y+, x3      ;2 [3] store data
+    ser     x3          ;1 [4]
+    nop                 ;1 [5]
+    eor     x2, x1      ;1 [6]
+    bst     x2, USBMINUS;1 [7]
+    bld     shift, 0    ;1 [8]
+    in      x2, USBIN   ;1 [9] <-- sample bit 1 (or possibly bit 0 stuffed)
+    andi    x2, USBMASK ;1 [10]
+    breq    se0         ;1 [11] SE0 check for bit 1
+    andi    shift, 0xf9 ;1 [12]
+didUnstuff0:
+    breq    unstuff0    ;1 [13]
+    eor     x1, x2      ;1 [14]
+    bst     x1, USBMINUS;1 [15]
+    bld     shift, 1    ;1 [16]
+rxbit2:
+    in      x1, USBIN   ;1 [17] <-- sample bit 2 (or possibly bit 1 stuffed)
+    andi    shift, 0xf3 ;1 [18]
+    breq    unstuff1    ;1 [19] do remaining work for bit 1
+didUnstuff1:
+    subi    cnt, 1      ;1 [20]
+    brcs    overflow    ;1 [21] loop control
+    eor     x2, x1      ;1 [22]
+    bst     x2, USBMINUS;1 [23]
+    bld     shift, 2    ;1 [24]
+    in      x2, USBIN   ;1 [25] <-- sample bit 3 (or possibly bit 2 stuffed)
+    andi    shift, 0xe7 ;1 [26]
+    breq    unstuff2    ;1 [27]
+didUnstuff2:
+    eor     x1, x2      ;1 [28]
+    bst     x1, USBMINUS;1 [29]
+    bld     shift, 3    ;1 [30]
+didUnstuff3:
+    andi    shift, 0xcf ;1 [31]
+    breq    unstuff3    ;1 [32]
+    in      x1, USBIN   ;1 [33] <-- sample bit 4
+    eor     x2, x1      ;1 [34]
+    bst     x2, USBMINUS;1 [35]
+    bld     shift, 4    ;1 [36]
+didUnstuff4:
+    andi    shift, 0x9f ;1 [37]
+    breq    unstuff4    ;1 [38]
+    nop2                ;2 [40]
+    in      x2, USBIN   ;1 [41] <-- sample bit 5
+    eor     x1, x2      ;1 [42]
+    bst     x1, USBMINUS;1 [43]
+    bld     shift, 5    ;1 [44]
+didUnstuff5:
+    andi    shift, 0x3f ;1 [45]
+    breq    unstuff5    ;1 [46]
+    nop2                ;2 [48]
+    in      x1, USBIN   ;1 [49] <-- sample bit 6
+    eor     x2, x1      ;1 [50]
+    bst     x2, USBMINUS;1 [51]
+    bld     shift, 6    ;1 [52]
+didUnstuff6:
+    cpi     shift, 0x02 ;1 [53]
+    brlo    unstuff6    ;1 [54]
+    nop2                ;2 [56]
+    in      x2, USBIN   ;1 [57] <-- sample bit 7
+    eor     x1, x2      ;1 [58]
+    bst     x1, USBMINUS;1 [59]
+    bld     shift, 7    ;1 [60]
+didUnstuff7:
+    cpi     shift, 0x04 ;1 [61]
+    brsh    rxLoop      ;2 [63] loop control
+unstuff7:
+    andi    x3, ~0x80   ;1 [63]
+    ori     shift, 0x80 ;1 [64]
+    in      x2, USBIN   ;1 [65] <-- sample stuffed bit 7
+    nop                 ;1 [66]
+    rjmp    didUnstuff7 ;2 [68]
+
+macro POP_STANDARD ; 12 cycles
+    pop     cnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;----------------------------------------------------------------------------
+; Transmitting data
+;----------------------------------------------------------------------------
+
+txByteLoop:
+txBitloop:
+stuffN1Delay:                   ;     [03]
+    ror     shift               ;[-5] [11] [59]
+    brcc    doExorN1            ;[-4]      [60]
+    subi    x4, 1               ;[-3]
+    brne    commonN1            ;[-2]
+    lsl     shift               ;[-1] compensate ror after rjmp stuffDelay
+    nop                         ;[00] stuffing consists of just waiting 8 cycles
+    rjmp    stuffN1Delay        ;[01] after ror, C bit is reliably clear
+
+sendNakAndReti:                 ;0 [-19] 19 cycles until SOP
+    ldi     x3, USBPID_NAK      ;1 [-18]
+    rjmp    usbSendX3           ;2 [-16]
+sendAckAndReti:                 ;0 [-19] 19 cycles until SOP
+    ldi     x3, USBPID_ACK      ;1 [-18]
+    rjmp    usbSendX3           ;2 [-16]
+sendCntAndReti:                 ;0 [-17] 17 cycles until SOP
+    mov     x3, cnt             ;1 [-16]
+usbSendX3:                      ;0 [-16]
+    ldi     YL, 20              ;1 [-15] 'x3' is R20
+    ldi     YH, 0               ;1 [-14]
+    ldi     cnt, 2              ;1 [-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
+; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
+; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte
+;uses: x1...x2, x4, shift, cnt, Y [x1 = mirror USBOUT, x2 = USBMASK, x4 = bitstuff cnt]
+;Numbers in brackets are time since first bit of sync pattern is sent (start of instruction)
+usbSendAndReti:
+    in      x2, USBDDR          ;[-12] 12 cycles until SOP
+    ori     x2, USBMASK         ;[-11]
+    sbi     USBOUT, USBMINUS    ;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    out     USBDDR, x2          ;[-8] <--- acquire bus
+    in      x1, USBOUT          ;[-7] port mirror for tx loop
+    ldi     shift, 0x40         ;[-6] sync byte is first byte sent (we enter loop after ror)
+    ldi     x2, USBMASK         ;[-5]
+    push    x4                  ;[-4]
+doExorN1:
+    eor     x1, x2              ;[-2] [06] [62]
+    ldi     x4, 6               ;[-1] [07] [63]
+commonN1:
+stuffN2Delay:
+    out     USBOUT, x1          ;[00] [08] [64] <--- set bit
+    ror     shift               ;[01]
+    brcc    doExorN2            ;[02]
+    subi    x4, 1               ;[03]
+    brne    commonN2            ;[04]
+    lsl     shift               ;[05] compensate ror after rjmp stuffDelay
+    rjmp    stuffN2Delay        ;[06] after ror, C bit is reliably clear
+doExorN2:
+    eor     x1, x2              ;[04] [12]
+    ldi     x4, 6               ;[05] [13]
+commonN2:
+    nop                         ;[06] [14]
+    subi    cnt, 171            ;[07] [15] trick: (3 * 171) & 0xff = 1
+    out     USBOUT, x1          ;[08] [16] <--- set bit
+    brcs    txBitloop           ;[09]      [25] [41]
+
+stuff6Delay:
+    ror     shift               ;[42] [50]
+    brcc    doExor6             ;[43]
+    subi    x4, 1               ;[44]
+    brne    common6             ;[45]
+    lsl     shift               ;[46] compensate ror after rjmp stuffDelay
+    nop                         ;[47] stuffing consists of just waiting 8 cycles
+    rjmp    stuff6Delay         ;[48] after ror, C bit is reliably clear
+doExor6:
+    eor     x1, x2              ;[45] [53]
+    ldi     x4, 6               ;[46]
+common6:
+stuff7Delay:
+    ror     shift               ;[47] [55]
+    out     USBOUT, x1          ;[48] <--- set bit
+    brcc    doExor7             ;[49]
+    subi    x4, 1               ;[50]
+    brne    common7             ;[51]
+    lsl     shift               ;[52] compensate ror after rjmp stuffDelay
+    rjmp    stuff7Delay         ;[53] after ror, C bit is reliably clear
+doExor7:
+    eor     x1, x2              ;[51] [59]
+    ldi     x4, 6               ;[52]
+common7:
+    ld      shift, y+           ;[53]
+    tst     cnt                 ;[55]
+    out     USBOUT, x1          ;[56] <--- set bit
+    brne    txByteLoop          ;[57]
+
+;make SE0:
+    cbr     x1, USBMASK         ;[58] prepare SE0 [spec says EOP may be 15 to 18 cycles]
+    lds     x2, usbNewDeviceAddr;[59]
+    lsl     x2                  ;[61] we compare with left shifted address
+    subi    YL, 2 + 20          ;[62] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0               ;[63]
+    out     USBOUT, x1          ;[00] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign      ;[01]
+    sts     usbDeviceAddr, x2   ; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[03] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)       ;[04]
+    ori     x1, USBIDLE         ;[05]
+    in      x2, USBDDR          ;[06]
+    cbr     x2, USBMASK         ;[07] set both pins to input
+    mov     x3, x1              ;[08]
+    cbr     x3, USBMASK         ;[09] configure no pullup on both pins
+    pop     x4                  ;[10]
+    nop2                        ;[12]
+    nop2                        ;[14]
+    out     USBOUT, x1          ;[16] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2          ;[17] <-- release bus now
+    out     USBOUT, x3          ;[18] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: vusb-20121206/usbdrv/usbdrvasm128.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm128.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm128.inc	(working copy)
@@ -0,0 +1,749 @@
+/* Name: usbdrvasm128.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-10-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 12.8 MHz version of the USB driver. It is intended for use
+with the internal RC oscillator. Although 12.8 MHz is outside the guaranteed
+calibration range of the oscillator, almost all AVRs can reach this frequency.
+This version contains a phase locked loop in the receiver routine to cope with
+slight clock rate deviations of up to +/- 1%.
+
+See usbdrv.h for a description of the entire driver.
+
+LIMITATIONS
+===========
+Although it may seem very handy to save the crystal and use the internal
+RC oscillator of the CPU, this method (and this module) has some serious
+limitations:
+(1) The guaranteed calibration range of the oscillator is only 8.1 MHz.
+They typical range is 14.5 MHz and most AVRs can actually reach this rate.
+(2) Writing EEPROM and Flash may be unreliable (short data lifetime) since
+the write procedure is timed from the RC oscillator.
+(3) End Of Packet detection (SE0) should be in bit 1, bit it is only checked
+if bits 0 and 1 both read as 0 on D- and D+ read as 0 in the middle. This may
+cause problems with old hubs which delay SE0 by up to one cycle.
+(4) Code size is much larger than that of the other modules.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+
+Implementation notes:
+======================
+min frequency: 67 cycles for 8 bit -> 12.5625 MHz
+max frequency: 69.286 cycles for 8 bit -> 12.99 MHz
+nominal frequency: 12.77 MHz ( = sqrt(min * max))
+
+sampling positions: (next even number in range [+/- 0.5])
+cycle index range: 0 ... 66
+bits:
+.5, 8.875, 17.25, 25.625, 34, 42.375, 50.75, 59.125
+[0/1], [9], [17], [25/+26], [34], [+42/43], [51], [59]
+
+bit number:     0   1   2   3   4   5   6   7
+spare cycles    1   2   1   2   1   1   1   0
+
+operations to perform:      duration cycle
+                            ----------------
+    eor     fix, shift          1 -> 00
+    andi    phase, USBMASK      1 -> 08
+    breq    se0                 1 -> 16 (moved to 11)
+    st      y+, data            2 -> 24, 25
+    mov     data, fix           1 -> 33
+    ser     data                1 -> 41
+    subi    cnt, 1              1 -> 49
+    brcs    overflow            1 -> 50
+
+layout of samples and operations:
+[##] = sample bit
+<##> = sample phase
+*##* = operation
+
+0:  *00* [01]  02   03   04  <05>  06   07
+1:  *08* [09]  10   11   12  <13>  14   15  *16*
+2:  [17]  18   19   20  <21>  22   23
+3:  *24* *25* [26]  27   28   29  <30>  31   32
+4:  *33* [34]  35   36   37  <38>  39   40
+5:  *41* [42]  43   44   45  <46>  47   48
+6:  *49* *50* [51]  52   53   54  <55>  56   57   58
+7:  [59]  60   61   62  <63>  64   65   66
+*****************************************************************************/
+
+/* we prefer positive expressions (do if condition) instead of negative
+ * (skip if condition), therefore use defines for skip instructions:
+ */
+#define ifioclr sbis
+#define ifioset sbic
+#define ifrclr  sbrs
+#define ifrset  sbrc
+
+/* The registers "fix" and "data" swap their meaning during the loop. Use
+ * defines to keep their name constant.
+ */
+#define fix     x2
+#define data    x1
+#undef phase        /* phase has a default definition to x4 */
+#define phase   x3
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt, r0
+    push    YL              ;2 push only what is necessary to sync with edge ASAP
+    in      YL, SREG        ;1
+    push    YL              ;2
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS ;[0]
+    rjmp    foundK          ;[1]
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+
+foundK:
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    YH                  ;[2]
+    lds     YL, usbInputBufOffset;[4]
+    clr     YH                  ;[6]
+    subi    YL, lo8(-(usbRxBuf));[7]
+    sbci    YH, hi8(-(usbRxBuf));[8]
+
+    sbis    USBIN, USBMINUS     ;[9] we want two bits K [we want to sample at 8 + 4 - 1.5 = 10.5]
+    rjmp    haveTwoBitsK        ;[10]
+    pop     YH                  ;[11] undo the push from before
+    rjmp    waitForK            ;[13] this was not the end of sync, retry
+haveTwoBitsK:
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+#define fix     x2
+#define data    x1
+
+    push    shift               ;[12]
+    push    x1                  ;[14]
+    push    x2                  ;[16]
+    ldi     shift, 0x80         ;[18] prevent bit-unstuffing but init low bits to 0
+    ifioset USBIN, USBMINUS     ;[19] [01] <--- bit 0 [10.5 + 8 = 18.5]
+    ori     shift, 1<<0         ;[02]
+    push    x3                  ;[03]
+    push    cnt                 ;[05]
+    push    r0                  ;[07]
+    ifioset USBIN, USBMINUS     ;[09] <--- bit 1
+    ori     shift, 1<<1         ;[10]
+    ser     fix                 ;[11]
+    ldi     cnt, USB_BUFSIZE    ;[12]
+    mov     data, shift         ;[13]
+    lsl     shift               ;[14]
+    nop2                        ;[15]
+    ifioset USBIN, USBMINUS     ;[17] <--- bit 2
+    ori     data, 3<<2          ;[18] store in bit 2 AND bit 3
+    eor     shift, data         ;[19] do nrzi decoding
+    andi    data, 1<<3          ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    brne    jumpToEntryAfterSet ;[22] if USBMINS at bit 3 was 1
+    nop                         ;[23]
+    rjmp    entryAfterClr       ;[24]
+jumpToEntryAfterSet:
+    rjmp    entryAfterSet       ;[24]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+#undef  fix
+#define  fix    x1
+#undef  data
+#define data    x2
+
+bit7IsSet:
+    ifrclr  phase, USBMINUS     ;[62] check phase only if D- changed
+    lpm                         ;[63]
+    in      phase, USBIN        ;[64] <- phase (one cycle too late)
+    ori     shift, 1 << 7       ;[65]
+    nop                         ;[66]
+;;;;rjmp    bit0AfterSet        ; -> [00] == [67] moved block up to save jump
+bit0AfterSet:
+    eor     fix, shift          ;[00]
+#undef  fix
+#define fix     x2
+#undef  data
+#define data    x1  /* we now have result in data, fix is reset to 0xff */
+    ifioclr USBIN, USBMINUS     ;[01] <--- sample 0
+    rjmp    bit0IsClr           ;[02]
+    andi    shift, ~(7 << 0)    ;[03]
+    breq    unstuff0s           ;[04]
+    in      phase, USBIN        ;[05] <- phase
+    rjmp    bit1AfterSet        ;[06]
+unstuff0s:
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    andi    fix, ~(1 << 0)      ;[07]
+    ifioclr USBIN, USBMINUS     ;[00]
+    ifioset USBIN, USBPLUS      ;[01]
+    rjmp    bit0IsClr           ;[02] executed if first expr false or second true
+se0AndStore:                    ; executed only if both bits 0
+    st      y+, x1              ;[15/17] cycles after start of byte
+    rjmp    se0                 ;[17/19]
+
+bit0IsClr:
+    ifrset  phase, USBMINUS     ;[04] check phase only if D- changed
+    lpm                         ;[05]
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    ori     shift, 1 << 0       ;[07]
+bit1AfterClr:
+    andi    phase, USBMASK      ;[08]
+    ifioset USBIN, USBMINUS     ;[09] <--- sample 1
+    rjmp    bit1IsSet           ;[10]
+    breq    se0AndStore         ;[11] if D- was 0 in bits 0 AND 1 and D+ was 0 in between, we have SE0
+    andi    shift, ~(7 << 1)    ;[12]
+    in      phase, USBIN        ;[13] <- phase
+    breq    unstuff1c           ;[14]
+    rjmp    bit2AfterClr        ;[15]
+unstuff1c:
+    andi    fix, ~(1 << 1)      ;[16]
+    nop2                        ;[08]
+    nop2                        ;[10]
+bit1IsSet:
+    ifrclr  phase, USBMINUS     ;[12] check phase only if D- changed
+    lpm                         ;[13]
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    ori     shift, 1 << 1       ;[15]
+    nop                         ;[16]
+bit2AfterSet:
+    ifioclr USBIN, USBMINUS     ;[17] <--- sample 2
+    rjmp    bit2IsClr           ;[18]
+    andi    shift, ~(7 << 2)    ;[19]
+    breq    unstuff2s           ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    rjmp    bit3AfterSet        ;[22]
+unstuff2s:
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    andi    fix, ~(1 << 2)      ;[23]
+    nop2                        ;[16]
+    nop2                        ;[18]
+bit2IsClr:
+    ifrset  phase, USBMINUS     ;[20] check phase only if D- changed
+    lpm                         ;[21]
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    ori     shift, 1 << 2       ;[23]
+bit3AfterClr:
+    st      y+, data            ;[24]
+entryAfterClr:
+    ifioset USBIN, USBMINUS     ;[26] <--- sample 3
+    rjmp    bit3IsSet           ;[27]
+    andi    shift, ~(7 << 3)    ;[28]
+    breq    unstuff3c           ;[29]
+    in      phase, USBIN        ;[30] <- phase
+    rjmp    bit4AfterClr        ;[31]
+unstuff3c:
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    andi    fix, ~(1 << 3)      ;[32]
+    nop2                        ;[25]
+    nop2                        ;[27]
+bit3IsSet:
+    ifrclr  phase, USBMINUS     ;[29] check phase only if D- changed
+    lpm                         ;[30]
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    ori     shift, 1 << 3       ;[32]
+bit4AfterSet:
+    mov     data, fix           ;[33] undo this move by swapping defines
+#undef  fix
+#define fix     x1
+#undef  data
+#define data    x2
+    ifioclr USBIN, USBMINUS     ;[34] <--- sample 4
+    rjmp    bit4IsClr           ;[35]
+    andi    shift, ~(7 << 4)    ;[36]
+    breq    unstuff4s           ;[37]
+    in      phase, USBIN        ;[38] <- phase
+    rjmp    bit5AfterSet        ;[39]
+unstuff4s:
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    andi    fix, ~(1 << 4)      ;[40]
+    nop2                        ;[33]
+    nop2                        ;[35]
+bit4IsClr:
+    ifrset  phase, USBMINUS     ;[37] check phase only if D- changed
+    lpm                         ;[38]
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    ori     shift, 1 << 4       ;[40]
+bit5AfterClr:
+    ser     data                ;[41]
+    ifioset USBIN, USBMINUS     ;[42] <--- sample 5
+    rjmp    bit5IsSet           ;[43]
+    andi    shift, ~(7 << 5)    ;[44]
+    breq    unstuff5c           ;[45]
+    in      phase, USBIN        ;[46] <- phase
+    rjmp    bit6AfterClr        ;[47]
+unstuff5c:
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    andi    fix, ~(1 << 5)      ;[48]
+    nop2                        ;[41]
+    nop2                        ;[43]
+bit5IsSet:
+    ifrclr  phase, USBMINUS     ;[45] check phase only if D- changed
+    lpm                         ;[46]
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    ori     shift, 1 << 5       ;[48]
+bit6AfterSet:
+    subi    cnt, 1              ;[49]
+    brcs    jumpToOverflow      ;[50]
+    ifioclr USBIN, USBMINUS     ;[51] <--- sample 6
+    rjmp    bit6IsClr           ;[52]
+    andi    shift, ~(3 << 6)    ;[53]
+    cpi     shift, 2            ;[54]
+    in      phase, USBIN        ;[55] <- phase
+    brlt    unstuff6s           ;[56]
+    rjmp    bit7AfterSet        ;[57]
+
+jumpToOverflow:
+    rjmp    overflow
+
+unstuff6s:
+    andi    fix, ~(1 << 6)      ;[50]
+    lpm                         ;[51]
+bit6IsClr:
+    ifrset  phase, USBMINUS     ;[54] check phase only if D- changed
+    lpm                         ;[55]
+    in      phase, USBIN        ;[56] <- phase (one cycle too late)
+    ori     shift, 1 << 6       ;[57]
+    nop                         ;[58]
+bit7AfterClr:
+    ifioset USBIN, USBMINUS     ;[59] <--- sample 7
+    rjmp    bit7IsSet           ;[60]
+    andi    shift, ~(1 << 7)    ;[61]
+    cpi     shift, 4            ;[62]
+    in      phase, USBIN        ;[63] <- phase
+    brlt    unstuff7c           ;[64]
+    rjmp    bit0AfterClr        ;[65] -> [00] == [67]
+unstuff7c:
+    andi    fix, ~(1 << 7)      ;[58]
+    nop                         ;[59]
+    rjmp    bit7IsSet           ;[60]
+
+bit7IsClr:
+    ifrset  phase, USBMINUS     ;[62] check phase only if D- changed
+    lpm                         ;[63]
+    in      phase, USBIN        ;[64] <- phase (one cycle too late)
+    ori     shift, 1 << 7       ;[65]
+    nop                         ;[66]
+;;;;rjmp    bit0AfterClr        ; -> [00] == [67] moved block up to save jump
+bit0AfterClr:
+    eor     fix, shift          ;[00]
+#undef  fix
+#define fix     x2
+#undef  data
+#define data    x1  /* we now have result in data, fix is reset to 0xff */
+    ifioset USBIN, USBMINUS     ;[01] <--- sample 0
+    rjmp    bit0IsSet           ;[02]
+    andi    shift, ~(7 << 0)    ;[03]
+    breq    unstuff0c           ;[04]
+    in      phase, USBIN        ;[05] <- phase
+    rjmp    bit1AfterClr        ;[06]
+unstuff0c:
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    andi    fix, ~(1 << 0)      ;[07]
+    ifioclr USBIN, USBMINUS     ;[00]
+    ifioset USBIN, USBPLUS      ;[01]
+    rjmp    bit0IsSet           ;[02] executed if first expr false or second true
+    rjmp    se0AndStore         ;[03] executed only if both bits 0
+bit0IsSet:
+    ifrclr  phase, USBMINUS     ;[04] check phase only if D- changed
+    lpm                         ;[05]
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    ori     shift, 1 << 0       ;[07]
+bit1AfterSet:
+    andi    shift, ~(7 << 1)    ;[08] compensated by "ori shift, 1<<1" if bit1IsClr
+    ifioclr USBIN, USBMINUS     ;[09] <--- sample 1
+    rjmp    bit1IsClr           ;[10]
+    breq    unstuff1s           ;[11]
+    nop2                        ;[12] do not check for SE0 if bit 0 was 1
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    rjmp    bit2AfterSet        ;[15]
+unstuff1s:
+    in      phase, USBIN        ;[13] <- phase
+    andi    fix, ~(1 << 1)      ;[14]
+    lpm                         ;[07]
+    nop2                        ;[10]
+bit1IsClr:
+    ifrset  phase, USBMINUS     ;[12] check phase only if D- changed
+    lpm                         ;[13]
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    ori     shift, 1 << 1       ;[15]
+    nop                         ;[16]
+bit2AfterClr:
+    ifioset USBIN, USBMINUS     ;[17] <--- sample 2
+    rjmp    bit2IsSet           ;[18]
+    andi    shift, ~(7 << 2)    ;[19]
+    breq    unstuff2c           ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    rjmp    bit3AfterClr        ;[22]
+unstuff2c:
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    andi    fix, ~(1 << 2)      ;[23]
+    nop2                        ;[16]
+    nop2                        ;[18]
+bit2IsSet:
+    ifrclr  phase, USBMINUS     ;[20] check phase only if D- changed
+    lpm                         ;[21]
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    ori     shift, 1 << 2       ;[23]
+bit3AfterSet:
+    st      y+, data            ;[24]
+entryAfterSet:
+    ifioclr USBIN, USBMINUS     ;[26] <--- sample 3
+    rjmp    bit3IsClr           ;[27]
+    andi    shift, ~(7 << 3)    ;[28]
+    breq    unstuff3s           ;[29]
+    in      phase, USBIN        ;[30] <- phase
+    rjmp    bit4AfterSet        ;[31]
+unstuff3s:
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    andi    fix, ~(1 << 3)      ;[32]
+    nop2                        ;[25]
+    nop2                        ;[27]
+bit3IsClr:
+    ifrset  phase, USBMINUS     ;[29] check phase only if D- changed
+    lpm                         ;[30]
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    ori     shift, 1 << 3       ;[32]
+bit4AfterClr:
+    mov     data, fix           ;[33] undo this move by swapping defines
+#undef  fix
+#define fix     x1
+#undef  data
+#define data    x2
+    ifioset USBIN, USBMINUS     ;[34] <--- sample 4
+    rjmp    bit4IsSet           ;[35]
+    andi    shift, ~(7 << 4)    ;[36]
+    breq    unstuff4c           ;[37]
+    in      phase, USBIN        ;[38] <- phase
+    rjmp    bit5AfterClr        ;[39]
+unstuff4c:
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    andi    fix, ~(1 << 4)      ;[40]
+    nop2                        ;[33]
+    nop2                        ;[35]
+bit4IsSet:
+    ifrclr  phase, USBMINUS     ;[37] check phase only if D- changed
+    lpm                         ;[38]
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    ori     shift, 1 << 4       ;[40]
+bit5AfterSet:
+    ser     data                ;[41]
+    ifioclr USBIN, USBMINUS     ;[42] <--- sample 5
+    rjmp    bit5IsClr           ;[43]
+    andi    shift, ~(7 << 5)    ;[44]
+    breq    unstuff5s           ;[45]
+    in      phase, USBIN        ;[46] <- phase
+    rjmp    bit6AfterSet        ;[47]
+unstuff5s:
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    andi    fix, ~(1 << 5)      ;[48]
+    nop2                        ;[41]
+    nop2                        ;[43]
+bit5IsClr:
+    ifrset  phase, USBMINUS     ;[45] check phase only if D- changed
+    lpm                         ;[46]
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    ori     shift, 1 << 5       ;[48]
+bit6AfterClr:
+    subi    cnt, 1              ;[49]
+    brcs    overflow            ;[50]
+    ifioset USBIN, USBMINUS     ;[51] <--- sample 6
+    rjmp    bit6IsSet           ;[52]
+    andi    shift, ~(3 << 6)    ;[53]
+    cpi     shift, 2            ;[54]
+    in      phase, USBIN        ;[55] <- phase
+    brlt    unstuff6c           ;[56]
+    rjmp    bit7AfterClr        ;[57]
+unstuff6c:
+    andi    fix, ~(1 << 6)      ;[50]
+    lpm                         ;[51]
+bit6IsSet:
+    ifrclr  phase, USBMINUS     ;[54] check phase only if D- changed
+    lpm                         ;[55]
+    in      phase, USBIN        ;[56] <- phase (one cycle too late)
+    ori     shift, 1 << 6       ;[57]
+bit7AfterSet:
+    ifioclr USBIN, USBMINUS     ;[59] <--- sample 7
+    rjmp    bit7IsClr           ;[60]
+    andi    shift, ~(1 << 7)    ;[61]
+    cpi     shift, 4            ;[62]
+    in      phase, USBIN        ;[63] <- phase
+    brlt    unstuff7s           ;[64]
+    rjmp    bit0AfterSet        ;[65] -> [00] == [67]
+unstuff7s:
+    andi    fix, ~(1 << 7)      ;[58]
+    nop                         ;[59]
+    rjmp    bit7IsClr           ;[60]
+
+macro POP_STANDARD ; 14 cycles
+    pop     r0
+    pop     cnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;----------------------------------------------------------------------------
+; Transmitting data
+;----------------------------------------------------------------------------
+
+txByteLoop:
+txBitloop:
+stuffN1Delay:                   ;     [03]
+    ror     shift               ;[-5] [11] [63]
+    brcc    doExorN1            ;[-4]      [64]
+    subi    x3, 1               ;[-3]
+    brne    commonN1            ;[-2]
+    lsl     shift               ;[-1] compensate ror after rjmp stuffDelay
+    nop                         ;[00] stuffing consists of just waiting 8 cycles
+    rjmp    stuffN1Delay        ;[01] after ror, C bit is reliably clear
+
+sendNakAndReti:
+    ldi     cnt, USBPID_NAK ;[-19]
+    rjmp    sendCntAndReti  ;[-18]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     r0, cnt         ;[-16]
+    ldi     YL, 0           ;[-15] R0 address is 0
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
+; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
+; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte
+;uses: x1...x3, shift, cnt, Y [x1 = mirror USBOUT, x2 = USBMASK, x3 = bitstuff cnt]
+;Numbers in brackets are time since first bit of sync pattern is sent (start of instruction)
+usbSendAndReti:
+    in      x2, USBDDR          ;[-10] 10 cycles until SOP
+    ori     x2, USBMASK         ;[-9]
+    sbi     USBOUT, USBMINUS    ;[-8] prepare idle state; D+ and D- must have been 0 (no pullups)
+    out     USBDDR, x2          ;[-6] <--- acquire bus
+    in      x1, USBOUT          ;[-5] port mirror for tx loop
+    ldi     shift, 0x40         ;[-4] sync byte is first byte sent (we enter loop after ror)
+    ldi     x2, USBMASK         ;[-3]
+doExorN1:
+    eor     x1, x2              ;[-2] [06] [62]
+    ldi     x3, 6               ;[-1] [07] [63]
+commonN1:
+stuffN2Delay:
+    out     USBOUT, x1          ;[00] [08] [64] <--- set bit
+    ror     shift               ;[01]
+    brcc    doExorN2            ;[02]
+    subi    x3, 1               ;[03]
+    brne    commonN2            ;[04]
+    lsl     shift               ;[05] compensate ror after rjmp stuffDelay
+    rjmp    stuffN2Delay        ;[06] after ror, C bit is reliably clear
+doExorN2:
+    eor     x1, x2              ;[04] [12]
+    ldi     x3, 6               ;[05] [13]
+commonN2:
+    nop2                        ;[06] [14]
+    subi    cnt, 171            ;[08] [16] trick: (3 * 171) & 0xff = 1
+    out     USBOUT, x1          ;[09] [17] <--- set bit
+    brcs    txBitloop           ;[10]      [27] [44]
+
+stuff6Delay:
+    ror     shift               ;[45] [53]
+    brcc    doExor6             ;[46]
+    subi    x3, 1               ;[47]
+    brne    common6             ;[48]
+    lsl     shift               ;[49] compensate ror after rjmp stuffDelay
+    nop                         ;[50] stuffing consists of just waiting 8 cycles
+    rjmp    stuff6Delay         ;[51] after ror, C bit is reliably clear
+doExor6:
+    eor     x1, x2              ;[48] [56]
+    ldi     x3, 6               ;[49]
+common6:
+stuff7Delay:
+    ror     shift               ;[50] [58]
+    out     USBOUT, x1          ;[51] <--- set bit
+    brcc    doExor7             ;[52]
+    subi    x3, 1               ;[53]
+    brne    common7             ;[54]
+    lsl     shift               ;[55] compensate ror after rjmp stuffDelay
+    rjmp    stuff7Delay         ;[56] after ror, C bit is reliably clear
+doExor7:
+    eor     x1, x2              ;[54] [62]
+    ldi     x3, 6               ;[55]
+common7:
+    ld      shift, y+           ;[56]
+    nop                         ;[58]
+    tst     cnt                 ;[59]
+    out     USBOUT, x1          ;[60] [00]<--- set bit
+    brne    txByteLoop          ;[61] [01]
+;make SE0:
+    cbr     x1, USBMASK         ;[02] prepare SE0 [spec says EOP may be 15 to 18 cycles]
+    lds     x2, usbNewDeviceAddr;[03]
+    lsl     x2                  ;[05] we compare with left shifted address
+    subi    YL, 2 + 0           ;[06] Only assign address on data packets, not ACK/NAK in r0
+    sbci    YH, 0               ;[07]
+    out     USBOUT, x1          ;[00] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign      ;[01]
+    sts     usbDeviceAddr, x2   ; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[03] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)       ;[04]
+    ori     x1, USBIDLE         ;[05]
+    in      x2, USBDDR          ;[06]
+    cbr     x2, USBMASK         ;[07] set both pins to input
+    mov     x3, x1              ;[08]
+    cbr     x3, USBMASK         ;[09] configure no pullup on both pins
+    lpm                         ;[10]
+    lpm                         ;[13]
+    out     USBOUT, x1          ;[16] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2          ;[17] <-- release bus now
+    out     USBOUT, x3          ;[18] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
+
+
+/*****************************************************************************
+The following PHP script generates a code skeleton for the receiver routine:
+
+<?php
+
+function printCmdBuffer($thisBit)
+{
+global $cycle;
+
+    $nextBit = ($thisBit + 1) % 8;
+    $s = ob_get_contents();
+    ob_end_clean();
+    $s = str_replace("#", $thisBit, $s);
+    $s = str_replace("@", $nextBit, $s);
+    $lines = explode("\n", $s);
+    for($i = 0; $i < count($lines); $i++){
+        $s = $lines[$i];
+        if(ereg("\\[([0-9-][0-9])\\]", $s, $regs)){
+            $c = $cycle + (int)$regs[1];
+            $s = ereg_replace("\\[[0-9-][0-9]\\]", sprintf("[%02d]", $c), $s);
+        }
+        if(strlen($s) > 0)
+            echo "$s\n";
+    }
+}
+
+function printBit($isAfterSet, $bitNum)
+{
+    ob_start();
+    if($isAfterSet){
+?>
+    ifioclr USBIN, USBMINUS     ;[00] <--- sample
+    rjmp    bit#IsClr           ;[01]
+    andi    shift, ~(7 << #)    ;[02]
+    breq    unstuff#s           ;[03]
+    in      phase, USBIN        ;[04] <- phase
+    rjmp    bit@AfterSet        ;[05]
+unstuff#s:
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    andi    fix, ~(1 << #)      ;[06]
+    nop2                        ;[-1]
+    nop2                        ;[01]
+bit#IsClr:
+    ifrset  phase, USBMINUS     ;[03] check phase only if D- changed
+    lpm                         ;[04]
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    ori     shift, 1 << #       ;[06]
+<?php
+    }else{
+?>
+    ifioset USBIN, USBMINUS     ;[00] <--- sample
+    rjmp    bit#IsSet           ;[01]
+    andi    shift, ~(7 << #)    ;[02]
+    breq    unstuff#c           ;[03]
+    in      phase, USBIN        ;[04] <- phase
+    rjmp    bit@AfterClr        ;[05]
+unstuff#c:
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    andi    fix, ~(1 << #)      ;[06]
+    nop2                        ;[-1]
+    nop2                        ;[01]
+bit#IsSet:
+    ifrclr  phase, USBMINUS     ;[03] check phase only if D- changed
+    lpm                         ;[04]
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    ori     shift, 1 << #       ;[06]
+<?php
+    }
+    printCmdBuffer($bitNum);
+}
+
+$bitStartCycles = array(1, 9, 17, 26, 34, 42, 51, 59);
+for($i = 0; $i < 16; $i++){
+    $bit = $i % 8;
+    $emitClrCode = ($i + (int)($i / 8)) % 2;
+    $cycle = $bitStartCycles[$bit];
+    if($emitClrCode){
+        printf("bit%dAfterClr:\n", $bit);
+    }else{
+        printf("bit%dAfterSet:\n", $bit);
+    }
+    ob_start();
+    echo "    *****                       ;[-1]\n";
+    printCmdBuffer($bit);
+    printBit(!$emitClrCode, $bit);
+    if($i == 7)
+        echo "\n";
+}
+
+?>
+*****************************************************************************/
Index: vusb-20121206/usbdrv/usbdrvasm15.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm15.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm15.inc	(working copy)
@@ -0,0 +1,422 @@
+/* Name: usbdrvasm15.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: contributed by V. Bosch
+ * Creation Date: 2007-08-06
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 15 MHz version of the asssembler part of the USB driver. It
+requires a 15 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 15 MHz -> 10.0 cycles per bit, 80.0 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+;----------------------------------------------------------------------------
+; order of registers pushed: 
+;	YL, SREG [sofError] YH, shift, x1, x2, x3, bitcnt, cnt, x4
+;----------------------------------------------------------------------------
+USB_INTR_VECTOR:              
+    push    YL                   ;2 	push only what is necessary to sync with edge ASAP
+    in      YL, SREG             ;1 
+    push    YL                   ;2 
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;
+;   sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;   sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+;-------------------------------------------------------------------------------
+; The following code results in a sampling window of < 1/4 bit 
+;	which meets the spec.
+;-------------------------------------------------------------------------------
+waitForK:			 ;- 
+    sbis    USBIN, USBMINUS      ;1 [00] <-- sample
+    rjmp    foundK               ;2 [01]
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+;------------------------------------------------------------------------------
+; {3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for 
+;	center sampling] 
+; 	we have 1 bit time for setup purposes, then sample again. 
+;	Numbers in brackets are cycles from center of first sync (double K) 
+;	bit after the instruction
+;------------------------------------------------------------------------------
+foundK:                          ;- [02]
+    lds     YL, usbInputBufOffset;2 [03+04]	tx loop
+    push    YH                   ;2 [05+06]
+    clr     YH                   ;1 [07]
+    subi    YL, lo8(-(usbRxBuf)) ;1 [08] 	[rx loop init]
+    sbci    YH, hi8(-(usbRxBuf)) ;1 [09] 	[rx loop init]
+    push    shift                ;2 [10+11]
+    ser	    shift		 ;1 [12]
+    sbis    USBIN, USBMINUS      ;1 [-1] [13] <--sample:we want two bits K (sample 1 cycle too early)
+    rjmp    haveTwoBitsK         ;2 [00] [14]
+    pop     shift                ;2 	 [15+16] undo the push from before
+    pop     YH 			 ;2 	 [17+18] undo the push from before
+    rjmp    waitForK             ;2 	 [19+20] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 20 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:			;- [01]
+    push    x1              	;2 [02+03]
+    push    x2              	;2 [04+05]
+    push    x3              	;2 [06+07]
+    push    bitcnt              ;2 [08+09]	
+    in      x1, USBIN       	;1 [00] [10] <-- sample bit 0
+    bst     x1, USBMINUS    	;1 [01]
+    bld     shift, 0        	;1 [02]
+    push    cnt             	;2 [03+04]
+    ldi     cnt, USB_BUFSIZE	;1 [05] 
+    push    x4              	;2 [06+07] tx loop
+    rjmp    rxLoop          	;2 [08]
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+unstuff0:               	;- [07] (branch taken)
+    andi    x3, ~0x01   	;1 [08]
+    mov     x1, x2      	;1 [09] x2 contains last sampled (stuffed) bit
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 1 again
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 1 
+    ori     shift, 0x01 	;1 [03] 0b00000001
+    nop				;1 [04]
+    rjmp    didUnstuff0 	;2 [05]
+;-----------------------------------------------------
+unstuff1:               	;- [05] (branch taken)
+    mov     x2, x1      	;1 [06] x1 contains last sampled (stuffed) bit
+    andi    x3, ~0x02   	;1 [07]
+    ori     shift, 0x02 	;1 [08] 0b00000010
+    nop                 	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 2 again
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 2 
+    rjmp    didUnstuff1 	;2 [03]
+;-----------------------------------------------------
+unstuff2:               	;- [05] (branch taken)
+    andi    x3, ~0x04   	;1 [06]
+    ori     shift, 0x04 	;1 [07] 0b00000100
+    mov     x1, x2      	;1 [08] x2 contains last sampled (stuffed) bit
+    nop                 	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 3
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 3 
+    rjmp    didUnstuff2 	;2 [03]
+;-----------------------------------------------------
+unstuff3:               	;- [00] [10]  (branch taken)
+    in      x2, USBIN   	;1 [01] [11] <-- sample stuffed bit 3 one cycle too late
+    andi    x2, USBMASK 	;1 [02]
+    breq    se0Hop         	;1 [03] SE0 check for stuffed bit 3 
+    andi    x3, ~0x08   	;1 [04]
+    ori     shift, 0x08 	;1 [05] 0b00001000
+    rjmp    didUnstuff3 	;2 [06]
+;----------------------------------------------------------------------------
+; extra jobs done during bit interval:
+;
+; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs], 
+; 		overflow check, jump to the head of rxLoop
+; bit 1:    SE0 check
+; bit 2:    SE0 check, recovery from delay [bit 0 tasks took too long]
+; bit 3:    SE0 check, recovery from delay [bit 0 tasks took too long]
+; bit 4:    SE0 check, none
+; bit 5:    SE0 check, none
+; bit 6:    SE0 check, none
+; bit 7:    SE0 check, reconstruct: x3 is 0 at bit locations we changed, 1 at others
+;----------------------------------------------------------------------------
+rxLoop:				;- [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 1 (or possibly bit 0 stuffed)
+    andi    x2, USBMASK 	;1 [01]
+    brne    SkipSe0Hop		;1 [02]
+se0Hop:				;- [02]
+    rjmp    se0         	;2 [03] SE0 check for bit 1 
+SkipSe0Hop:			;- [03]
+    ser     x3          	;1 [04]
+    andi    shift, 0xf9 	;1 [05] 0b11111001
+    breq    unstuff0    	;1 [06]
+didUnstuff0:			;- [06]
+    eor     x1, x2      	;1 [07]
+    bst     x1, USBMINUS	;1 [08]
+    bld     shift, 1    	;1 [09] 
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 2 (or possibly bit 1 stuffed)
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 2 
+    andi    shift, 0xf3 	;1 [03] 0b11110011
+    breq    unstuff1    	;1 [04] do remaining work for bit 1
+didUnstuff1:			;- [04]
+    eor     x2, x1      	;1 [05]
+    bst     x2, USBMINUS	;1 [06]
+    bld     shift, 2    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 3 (or possibly bit 2 stuffed)
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 3 
+    andi    shift, 0xe7 	;1 [03] 0b11100111
+    breq    unstuff2    	;1 [04]
+didUnstuff2:			;- [04]
+    eor     x1, x2      	;1 [05]
+    bst     x1, USBMINUS	;1 [06]
+    bld     shift, 3    	;1 [07]
+didUnstuff3:			;- [07]
+    andi    shift, 0xcf 	;1 [08] 0b11001111
+    breq    unstuff3    	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 4
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 4
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 4    	;1 [05]
+didUnstuff4:			;- [05]
+    andi    shift, 0x9f 	;1 [06] 0b10011111
+    breq    unstuff4    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 5
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 5
+    eor     x1, x2      	;1 [03]
+    bst     x1, USBMINUS	;1 [04]
+    bld     shift, 5    	;1 [05]
+didUnstuff5:			;- [05]
+    andi    shift, 0x3f 	;1 [06] 0b00111111
+    breq    unstuff5    	;1 [07]
+    nop2			;2 [08+09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 6
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 6
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 6   	 	;1 [05]
+didUnstuff6:			;- [05]
+    cpi     shift, 0x02 	;1 [06] 0b00000010
+    brlo    unstuff6    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 7
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 7
+    eor     x1, x2      	;1 [03]
+    bst     x1, USBMINUS	;1 [04]
+    bld     shift, 7    	;1 [05]
+didUnstuff7:			;- [05] 
+    cpi     shift, 0x04 	;1 [06] 0b00000100
+    brlo    unstuff7		;1 [07]
+    eor     x3, shift   	;1 [08] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    nop				;1 [09]
+    in      x1, USBIN   	;1 [00]	[10] <-- sample bit 0
+    st      y+, x3      	;2 [01+02] store data
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 0    	;1 [05]
+    subi    cnt, 1		;1 [06]
+    brcs    overflow	;1 [07]
+    rjmp    rxLoop		;2 [08]
+;-----------------------------------------------------
+unstuff4:               	;- [08] 
+    andi    x3, ~0x10   	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample stuffed bit 4
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 4
+    ori     shift, 0x10 	;1 [03]
+    rjmp    didUnstuff4 	;2 [04]
+;-----------------------------------------------------
+unstuff5:               	;- [08] 
+    ori     shift, 0x20 	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample stuffed bit 5
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 5
+    andi    x3, ~0x20   	;1 [03]
+    rjmp    didUnstuff5		;2 [04]
+;-----------------------------------------------------
+unstuff6:               	;- [08] 
+    andi    x3, ~0x40   	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample stuffed bit 6
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 6
+    ori     shift, 0x40 	;1 [03]
+    rjmp    didUnstuff6 	;2 [04]
+;-----------------------------------------------------
+unstuff7:			;- [08]
+    andi    x3, ~0x80   	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample stuffed bit 7
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 7
+    ori     shift, 0x80 	;1 [03]
+    rjmp    didUnstuff7 	;2 [04]
+    
+macro POP_STANDARD ; 16 cycles
+    pop     x4    
+    pop     cnt
+    pop     bitcnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;---------------------------------------------------------------------------
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+;---------------------------------------------------------------------------
+bitstuffN:		    	;- [04]
+    eor     x1, x4          	;1 [05]
+    clr	    x2			;1 [06]
+    nop				;1 [07]
+    rjmp    didStuffN       	;1 [08]
+;---------------------------------------------------------------------------    
+bitstuff6:		    	;- [04]
+    eor     x1, x4          	;1 [05]
+    clr	    x2			;1 [06]
+    rjmp    didStuff6       	;1 [07]
+;---------------------------------------------------------------------------
+bitstuff7:		    	;- [02]
+    eor     x1, x4          	;1 [03]
+    clr	    x2			;1 [06]
+    nop			    	;1 [05]
+    rjmp    didStuff7       	;1 [06]
+;---------------------------------------------------------------------------
+sendNakAndReti:			;- [-19]
+    ldi     x3, USBPID_NAK  	;1 [-18]
+    rjmp    sendX3AndReti   	;1 [-17]
+;---------------------------------------------------------------------------
+sendAckAndReti:			;- [-17]
+    ldi     cnt, USBPID_ACK 	;1 [-16]
+sendCntAndReti:			;- [-16]
+    mov     x3, cnt         	;1 [-15]
+sendX3AndReti:			;- [-15]
+    ldi     YL, 20          	;1 [-14] x3==r20 address is 20
+    ldi     YH, 0           	;1 [-13]
+    ldi     cnt, 2          	;1 [-12]
+;   rjmp    usbSendAndReti      fallthrough
+;---------------------------------------------------------------------------
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We need not to match the transfer rate exactly because the spec demands 
+;only 1.5% precision anyway.
+usbSendAndReti:             	;- [-13] 13 cycles until SOP
+    in      x2, USBDDR      	;1 [-12]
+    ori     x2, USBMASK     	;1 [-11]
+    sbi     USBOUT, USBMINUS	;2 [-09-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      	;1 [-08] port mirror for tx loop
+    out     USBDDR, x2      	;1 [-07] <- acquire bus
+	; need not init x2 (bitstuff history) because sync starts with 0 
+    ldi     x4, USBMASK     	;1 [-06] 	exor mask
+    ldi     shift, 0x80     	;1 [-05] 	sync byte is first byte sent
+    ldi     bitcnt, 6    	;1 [-04] 
+txBitLoop:		    	;- [-04] [06]
+    sbrs    shift, 0        	;1 [-03] [07]
+    eor     x1, x4          	;1 [-02] [08] 
+    ror     shift           	;1 [-01] [09]  
+didStuffN:		    	;-       [09]
+    out     USBOUT, x1      	;1 [00]  [10] <-- out N
+    ror     x2              	;1 [01]
+    cpi     x2, 0xfc        	;1 [02]
+    brcc    bitstuffN       	;1 [03]
+    dec     bitcnt          	;1 [04]
+    brne    txBitLoop       	;1 [05]
+    sbrs    shift, 0        	;1 [06]
+    eor     x1, x4          	;1 [07]
+    ror     shift           	;1 [08]
+didStuff6:			;- [08]
+    nop				;1 [09]
+    out     USBOUT, x1      	;1 [00] [10] <-- out 6
+    ror     x2              	;1 [01] 
+    cpi     x2, 0xfc        	;1 [02]
+    brcc    bitstuff6       	;1 [03]
+    sbrs    shift, 0        	;1 [04]
+    eor     x1, x4          	;1 [05]
+    ror     shift           	;1 [06]
+    ror     x2              	;1 [07]
+didStuff7:			;- [07]
+    ldi     bitcnt, 6    	;1 [08]
+    cpi     x2, 0xfc        	;1 [09]
+    out     USBOUT, x1      	;1 [00] [10] <-- out 7
+    brcc    bitstuff7       	;1 [01]
+    ld      shift, y+       	;2 [02+03]
+    dec     cnt             	;1 [04]
+    brne    txBitLoop      	;1 [05]
+makeSE0:
+    cbr     x1, USBMASK     	;1 [06] 	prepare SE0 [spec says EOP may be 19 to 23 cycles]
+    lds     x2, usbNewDeviceAddr;2 [07+08]
+    lsl     x2                  ;1 [09] we compare with left shifted address
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    out     USBOUT, x1      	;1 [00] [10] <-- out SE0-- from now 2 bits==20 cycl. until bus idle
+    subi    YL, 20 + 2          ;1 [01] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           	;1 [02]
+    breq    skipAddrAssign  	;1 [03]
+    sts     usbDeviceAddr, x2	;2 [04+05] if not skipped: SE0 is one cycle longer
+;----------------------------------------------------------------------------
+;end of usbDeviceAddress transfer
+skipAddrAssign:				;- [03/04]
+    ldi     x2, 1<<USB_INTR_PENDING_BIT	;1 [05] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)           ;1 [06]
+    ori     x1, USBIDLE     		;1 [07]
+    in      x2, USBDDR      		;1 [08]
+    cbr     x2, USBMASK     		;1 [09] set both pins to input
+    mov     x3, x1          		;1 [10]
+    cbr     x3, USBMASK     		;1 [11] configure no pullup on both pins
+    ldi     x4, 3           		;1 [12]
+se0Delay:				;- [12] [15] 
+    dec     x4              		;1 [13] [16] 
+    brne    se0Delay        		;1 [14] [17] 
+    nop2				;2      [18+19]
+    out     USBOUT, x1      		;1      [20] <--out J (idle) -- end of SE0 (EOP sig.)
+    out     USBDDR, x2      		;1      [21] <--release bus now
+    out     USBOUT, x3      		;1      [22] <--ensure no pull-up resistors are active
+    rjmp    doReturn			;1	[23]
+;---------------------------------------------------------------------------
Index: vusb-20121206/usbdrv/usbdrvasm16.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm16.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm16.inc	(working copy)
@@ -0,0 +1,345 @@
+/* Name: usbdrvasm16.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-15
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 16 MHz version of the asssembler part of the USB driver. It
+requires a 16 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 16 MHz -> 10.6666666 cycles per bit, 85.333333333 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-25] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-23]
+    push    YL                  ;[-22]
+    push    YH                  ;[-20]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-15]
+    rjmp    foundK              ;[-14]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-12]
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    bitcnt              ;[-12]
+;   [---]                       ;[-11]
+    lds     YL, usbInputBufOffset;[-10]
+;   [---]                       ;[-9]
+    clr     YH                  ;[-8]
+    subi    YL, lo8(-(usbRxBuf));[-7] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-6] [rx loop init]
+    push    shift               ;[-5]
+;   [---]                       ;[-4]
+    ldi     bitcnt, 0x55        ;[-3] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-2] we want two bits K (sample 2 cycles too early)
+    rjmp    haveTwoBitsK        ;[-1]
+    pop     shift               ;[0] undo the push from before
+    pop     bitcnt              ;[2] undo the push from before
+    rjmp    waitForK            ;[4] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 21 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1              ;[1]
+    push    x2              ;[3]
+    push    x3              ;[5]
+    ldi     shift, 0        ;[7]
+    ldi     x3, 1<<4        ;[8] [rx loop init] first sample is inverse bit, compensate that
+    push    x4              ;[9] == leap
+
+    in      x1, USBIN       ;[11] <-- sample bit 0
+    andi    x1, USBMASK     ;[12]
+    bst     x1, USBMINUS    ;[13]
+    bld     shift, 7        ;[14]
+    push    cnt             ;[15]
+    ldi     leap, 0         ;[17] [rx loop init]
+    ldi     cnt, USB_BUFSIZE;[18] [rx loop init]
+    rjmp    rxbit1          ;[19] arrives at [21]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+
+; duration of unstuffing code should be 10.66666667 cycles. We adjust "leap"
+; accordingly to approximate this value in the long run.
+
+unstuff6:
+    andi    x2, USBMASK ;[03]
+    ori     x3, 1<<6    ;[04] will not be shifted any more
+    andi    shift, ~0x80;[05]
+    mov     x1, x2      ;[06] sampled bit 7 is actually re-sampled bit 6
+    subi    leap, -1    ;[07] total duration = 11 bits -> subtract 1/3
+    rjmp    didUnstuff6 ;[08]
+
+unstuff7:
+    ori     x3, 1<<7    ;[09] will not be shifted any more
+    in      x2, USBIN   ;[00] [10]  re-sample bit 7
+    andi    x2, USBMASK ;[01]
+    andi    shift, ~0x80;[02]
+    subi    leap, 2     ;[03] total duration = 10 bits -> add 1/3
+    rjmp    didUnstuff7 ;[04]
+
+unstuffEven:
+    ori     x3, 1<<6    ;[09] will be shifted right 6 times for bit 0
+    in      x1, USBIN   ;[00] [10]
+    andi    shift, ~0x80;[01]
+    andi    x1, USBMASK ;[02]
+    breq    se0         ;[03]
+    subi    leap, -1    ;[04] total duration = 11 bits -> subtract 1/3
+    nop2                ;[05]
+    rjmp    didUnstuffE ;[06]
+
+unstuffOdd:
+    ori     x3, 1<<5    ;[09] will be shifted right 4 times for bit 1
+    in      x2, USBIN   ;[00] [10]
+    andi    shift, ~0x80;[01]
+    andi    x2, USBMASK ;[02]
+    breq    se0         ;[03]
+    subi    leap, -1    ;[04] total duration = 11 bits -> subtract 1/3
+    nop2                ;[05]
+    rjmp    didUnstuffO ;[06]
+
+rxByteLoop:
+    andi    x1, USBMASK ;[03]
+    eor     x2, x1      ;[04]
+    subi    leap, 1     ;[05]
+    brpl    skipLeap    ;[06]
+    subi    leap, -3    ;1 one leap cycle every 3rd byte -> 85 + 1/3 cycles per byte
+    nop                 ;1
+skipLeap:
+    subi    x2, 1       ;[08]
+    ror     shift       ;[09]
+didUnstuff6:
+    cpi     shift, 0xfc ;[10]
+    in      x2, USBIN   ;[00] [11] <-- sample bit 7
+    brcc    unstuff6    ;[01]
+    andi    x2, USBMASK ;[02]
+    eor     x1, x2      ;[03]
+    subi    x1, 1       ;[04]
+    ror     shift       ;[05]
+didUnstuff7:
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuff7    ;[07]
+    eor     x3, shift   ;[08] reconstruct: x3 is 1 at bit locations we changed, 0 at others
+    st      y+, x3      ;[09] store data
+rxBitLoop:
+    in      x1, USBIN   ;[00] [11] <-- sample bit 0/2/4
+    andi    x1, USBMASK ;[01]
+    eor     x2, x1      ;[02]
+    andi    x3, 0x3f    ;[03] topmost two bits reserved for 6 and 7
+    subi    x2, 1       ;[04]
+    ror     shift       ;[05]
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuffEven ;[07]
+didUnstuffE:
+    lsr     x3          ;[08]
+    lsr     x3          ;[09]
+rxbit1:
+    in      x2, USBIN   ;[00] [10] <-- sample bit 1/3/5
+    andi    x2, USBMASK ;[01]
+    breq    se0         ;[02]
+    eor     x1, x2      ;[03]
+    subi    x1, 1       ;[04]
+    ror     shift       ;[05]
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuffOdd  ;[07]
+didUnstuffO:
+    subi    bitcnt, 0xab;[08] == addi 0x55, 0x55 = 0x100/3
+    brcs    rxBitLoop   ;[09]
+
+    subi    cnt, 1      ;[10]
+    in      x1, USBIN   ;[00] [11] <-- sample bit 6
+    brcc    rxByteLoop  ;[01]
+    rjmp    overflow
+
+macro POP_STANDARD ; 14 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     bitcnt
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+
+bitstuffN:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6]
+    nop2                    ;[7]
+    nop                     ;[9]
+    out     USBOUT, x1      ;[10] <-- out
+    rjmp    didStuffN       ;[0]
+    
+bitstuff6:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6] Carry is zero due to brcc
+    rol     shift           ;[7] compensate for ror shift at branch destination
+    rjmp    didStuff6       ;[8]
+
+bitstuff7:
+    ldi     x2, 0           ;[2] Carry is zero due to brcc
+    rjmp    didStuff7       ;[3]
+
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We don't match the transfer rate exactly (don't insert leap cycles every third
+;byte) because the spec demands only 1.5% precision anyway.
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x35    ;[-4] [6] binary 0011 0101
+txBitLoop:
+    sbrs    shift, 0        ;[-3] [7]
+    eor     x1, x4          ;[-2] [8]
+    out     USBOUT, x1      ;[-1] [9] <-- out N
+    ror     shift           ;[0] [10]
+    ror     x2              ;[1]
+didStuffN:
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuffN       ;[3]
+    lsr     bitcnt          ;[4]
+    brcc    txBitLoop       ;[5]
+    brne    txBitLoop       ;[6]
+
+    sbrs    shift, 0        ;[7]
+    eor     x1, x4          ;[8]
+didStuff6:
+    out     USBOUT, x1      ;[-1] [9] <-- out 6
+    ror     shift           ;[0] [10]
+    ror     x2              ;[1]
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuff6       ;[3]
+    ror     shift           ;[4]
+didStuff7:
+    ror     x2              ;[5]
+    sbrs    x2, 7           ;[6]
+    eor     x1, x4          ;[7]
+    nop                     ;[8]
+    cpi     x2, 0xfc        ;[9]
+    out     USBOUT, x1      ;[-1][10] <-- out 7
+    brcc    bitstuff7       ;[0] [11]
+    ld      shift, y+       ;[1]
+    dec     cnt             ;[3]
+    brne    txByteLoop      ;[4]
+;make SE0:
+    cbr     x1, USBMASK     ;[5] prepare SE0 [spec says EOP may be 21 to 25 cycles]
+    lds     x2, usbNewDeviceAddr;[6]
+    lsl     x2              ;[8] we compare with left shifted address
+    subi    YL, 20 + 2      ;[9] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[10]
+    out     USBOUT, x1      ;[11] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[0]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[2] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[3]
+    ori     x1, USBIDLE     ;[4]
+    in      x2, USBDDR      ;[5]
+    cbr     x2, USBMASK     ;[6] set both pins to input
+    mov     x3, x1          ;[7]
+    cbr     x3, USBMASK     ;[8] configure no pullup on both pins
+    ldi     x4, 4           ;[9]
+se0Delay:
+    dec     x4              ;[10] [13] [16] [19]
+    brne    se0Delay        ;[11] [14] [17] [20]
+    out     USBOUT, x1      ;[21] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[22] <-- release bus now
+    out     USBOUT, x3      ;[23] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: vusb-20121206/usbdrv/usbdrvasm165.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm165.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm165.inc	(working copy)
@@ -0,0 +1,452 @@
+/* Name: usbdrvasm165.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-04-22
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 16.5 MHz version of the USB driver. It is intended for the
+ATTiny45 and similar controllers running on 16.5 MHz internal RC oscillator.
+This version contains a phase locked loop in the receiver routine to cope with
+slight clock rate deviations of up to +/- 1%.
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
+;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
+;max allowable interrupt latency: 59 cycles -> max 52 cycles interrupt disable
+;max stack usage: [ret(2), r0, SREG, YL, YH, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 16.5 MHz -> 11 cycles per bit
+; 16.3125 MHz < F_CPU < 16.6875 MHz (+/- 1.1%)
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], r0, YH, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-23] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-21]
+    push    YL                  ;[-20]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-15]
+    rjmp    foundK              ;[-14]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-12]
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    r0                  ;[-12]
+;   [---]                       ;[-11]
+    push    YH                  ;[-10]
+;   [---]                       ;[-9]
+    lds     YL, usbInputBufOffset;[-8]
+;   [---]                       ;[-7]
+    clr     YH                  ;[-6]
+    subi    YL, lo8(-(usbRxBuf));[-5] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-4] [rx loop init]
+    mov     r0, x2              ;[-3] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-2] we want two bits K (sample 2 cycles too early)
+    rjmp    haveTwoBitsK        ;[-1]
+    pop     YH                  ;[0] undo the pushes from before
+    pop     r0                  ;[2]
+    rjmp    waitForK            ;[4] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 22 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:               ;[1]
+    push    shift           ;[1]
+    push    x1              ;[3]
+    push    x2              ;[5]
+    push    x3              ;[7]
+    ldi     shift, 0xff     ;[9] [rx loop init]
+    ori     x3, 0xff        ;[10] [rx loop init] == ser x3, clear zero flag
+
+    in      x1, USBIN       ;[11] <-- sample bit 0
+    bst     x1, USBMINUS    ;[12]
+    bld     shift, 0        ;[13]
+    push    x4              ;[14] == phase
+;   [---]                   ;[15]
+    push    cnt             ;[16]
+;   [---]                   ;[17]
+    ldi     phase, 0        ;[18] [rx loop init]
+    ldi     cnt, USB_BUFSIZE;[19] [rx loop init]
+    rjmp    rxbit1          ;[20]
+;   [---]                   ;[21]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+/*
+byte oriented operations done during loop:
+bit 0: store data
+bit 1: SE0 check
+bit 2: overflow check
+bit 3: catch up
+bit 4: rjmp to achieve conditional jump range
+bit 5: PLL
+bit 6: catch up
+bit 7: jump, fixup bitstuff
+; 87 [+ 2] cycles
+------------------------------------------------------------------
+*/
+continueWithBit5:
+    in      x2, USBIN       ;[055] <-- bit 5
+    eor     r0, x2          ;[056]
+    or      phase, r0       ;[057]
+    sbrc    phase, USBMINUS ;[058]
+    lpm                     ;[059] optional nop3; modifies r0
+    in      phase, USBIN    ;[060] <-- phase
+    eor     x1, x2          ;[061]
+    bst     x1, USBMINUS    ;[062]
+    bld     shift, 5        ;[063]
+    andi    shift, 0x3f     ;[064]
+    in      x1, USBIN       ;[065] <-- bit 6
+    breq    unstuff5        ;[066] *** unstuff escape
+    eor     phase, x1       ;[067]
+    eor     x2, x1          ;[068]
+    bst     x2, USBMINUS    ;[069]
+    bld     shift, 6        ;[070]
+didUnstuff6:                ;[   ]
+    in      r0, USBIN       ;[071] <-- phase
+    cpi     shift, 0x02     ;[072]
+    brlo    unstuff6        ;[073] *** unstuff escape
+didUnstuff5:                ;[   ]
+    nop2                    ;[074]
+;   [---]                   ;[075]
+    in      x2, USBIN       ;[076] <-- bit 7
+    eor     x1, x2          ;[077]
+    bst     x1, USBMINUS    ;[078]
+    bld     shift, 7        ;[079]
+didUnstuff7:                ;[   ]
+    eor     r0, x2          ;[080]
+    or      phase, r0       ;[081]
+    in      r0, USBIN       ;[082] <-- phase
+    cpi     shift, 0x04     ;[083]
+    brsh    rxLoop          ;[084]
+;   [---]                   ;[085]
+unstuff7:                   ;[   ]
+    andi    x3, ~0x80       ;[085]
+    ori     shift, 0x80     ;[086]
+    in      x2, USBIN       ;[087] <-- sample stuffed bit 7
+    nop                     ;[088]
+    rjmp    didUnstuff7     ;[089]
+;   [---]                   ;[090]
+                            ;[080]
+
+unstuff5:                   ;[067]
+    eor     phase, x1       ;[068]
+    andi    x3, ~0x20       ;[069]
+    ori     shift, 0x20     ;[070]
+    in      r0, USBIN       ;[071] <-- phase
+    mov     x2, x1          ;[072]
+    nop                     ;[073]
+    nop2                    ;[074]
+;   [---]                   ;[075]
+    in      x1, USBIN       ;[076] <-- bit 6
+    eor     r0, x1          ;[077]
+    or      phase, r0       ;[078]
+    eor     x2, x1          ;[079]
+    bst     x2, USBMINUS    ;[080]
+    bld     shift, 6        ;[081] no need to check bitstuffing, we just had one
+    in      r0, USBIN       ;[082] <-- phase
+    rjmp    didUnstuff5     ;[083]
+;   [---]                   ;[084]
+                            ;[074]
+
+unstuff6:                   ;[074]
+    andi    x3, ~0x40       ;[075]
+    in      x1, USBIN       ;[076] <-- bit 6 again
+    ori     shift, 0x40     ;[077]
+    nop2                    ;[078]
+;   [---]                   ;[079]
+    rjmp    didUnstuff6     ;[080]
+;   [---]                   ;[081]
+                            ;[071]
+
+unstuff0:                   ;[013]
+    eor     r0, x2          ;[014]
+    or      phase, r0       ;[015]
+    andi    x2, USBMASK     ;[016] check for SE0
+    in      r0, USBIN       ;[017] <-- phase
+    breq    didUnstuff0     ;[018] direct jump to se0 would be too long
+    andi    x3, ~0x01       ;[019]
+    ori     shift, 0x01     ;[020]
+    mov     x1, x2          ;[021] mov existing sample
+    in      x2, USBIN       ;[022] <-- bit 1 again
+    rjmp    didUnstuff0     ;[023]
+;   [---]                   ;[024]
+                            ;[014]
+
+unstuff1:                   ;[024]
+    eor     r0, x1          ;[025]
+    or      phase, r0       ;[026]
+    andi    x3, ~0x02       ;[027]
+    in      r0, USBIN       ;[028] <-- phase
+    ori     shift, 0x02     ;[029]
+    mov     x2, x1          ;[030]
+    rjmp    didUnstuff1     ;[031]
+;   [---]                   ;[032]
+                            ;[022]
+
+unstuff2:                   ;[035]
+    eor     r0, x2          ;[036]
+    or      phase, r0       ;[037]
+    andi    x3, ~0x04       ;[038]
+    in      r0, USBIN       ;[039] <-- phase
+    ori     shift, 0x04     ;[040]
+    mov     x1, x2          ;[041]
+    rjmp    didUnstuff2     ;[042]
+;   [---]                   ;[043]
+                            ;[033]
+
+unstuff3:                   ;[043]
+    in      x2, USBIN       ;[044] <-- bit 3 again
+    eor     r0, x2          ;[045]
+    or      phase, r0       ;[046]
+    andi    x3, ~0x08       ;[047]
+    ori     shift, 0x08     ;[048]
+    nop                     ;[049]
+    in      r0, USBIN       ;[050] <-- phase
+    rjmp    didUnstuff3     ;[051]
+;   [---]                   ;[052]
+                            ;[042]
+
+unstuff4:                   ;[053]
+    andi    x3, ~0x10       ;[054]
+    in      x1, USBIN       ;[055] <-- bit 4 again
+    ori     shift, 0x10     ;[056]
+    rjmp    didUnstuff4     ;[057]
+;   [---]                   ;[058]
+                            ;[048]
+
+rxLoop:                     ;[085]
+    eor     x3, shift       ;[086] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    in      x1, USBIN       ;[000] <-- bit 0
+    st      y+, x3          ;[001]
+;   [---]                   ;[002]
+    eor     r0, x1          ;[003]
+    or      phase, r0       ;[004]
+    eor     x2, x1          ;[005]
+    in      r0, USBIN       ;[006] <-- phase
+    ser     x3              ;[007]
+    bst     x2, USBMINUS    ;[008]
+    bld     shift, 0        ;[009]
+    andi    shift, 0xf9     ;[010]
+rxbit1:                     ;[   ]
+    in      x2, USBIN       ;[011] <-- bit 1
+    breq    unstuff0        ;[012] *** unstuff escape
+    andi    x2, USBMASK     ;[013] SE0 check for bit 1
+didUnstuff0:                ;[   ] Z only set if we detected SE0 in bitstuff
+    breq    se0             ;[014]
+    eor     r0, x2          ;[015]
+    or      phase, r0       ;[016]
+    in      r0, USBIN       ;[017] <-- phase
+    eor     x1, x2          ;[018]
+    bst     x1, USBMINUS    ;[019]
+    bld     shift, 1        ;[020]
+    andi    shift, 0xf3     ;[021]
+didUnstuff1:                ;[   ]
+    in      x1, USBIN       ;[022] <-- bit 2
+    breq    unstuff1        ;[023] *** unstuff escape
+    eor     r0, x1          ;[024]
+    or      phase, r0       ;[025]
+    subi    cnt, 1          ;[026] overflow check
+    brcs    overflow        ;[027]
+    in      r0, USBIN       ;[028] <-- phase
+    eor     x2, x1          ;[029]
+    bst     x2, USBMINUS    ;[030]
+    bld     shift, 2        ;[031]
+    andi    shift, 0xe7     ;[032]
+didUnstuff2:                ;[   ]
+    in      x2, USBIN       ;[033] <-- bit 3
+    breq    unstuff2        ;[034] *** unstuff escape
+    eor     r0, x2          ;[035]
+    or      phase, r0       ;[036]
+    eor     x1, x2          ;[037]
+    bst     x1, USBMINUS    ;[038]
+    in      r0, USBIN       ;[039] <-- phase
+    bld     shift, 3        ;[040]
+    andi    shift, 0xcf     ;[041]
+didUnstuff3:                ;[   ]
+    breq    unstuff3        ;[042] *** unstuff escape
+    nop                     ;[043]
+    in      x1, USBIN       ;[044] <-- bit 4
+    eor     x2, x1          ;[045]
+    bst     x2, USBMINUS    ;[046]
+    bld     shift, 4        ;[047]
+didUnstuff4:                ;[   ]
+    eor     r0, x1          ;[048]
+    or      phase, r0       ;[049]
+    in      r0, USBIN       ;[050] <-- phase
+    andi    shift, 0x9f     ;[051]
+    breq    unstuff4        ;[052] *** unstuff escape
+    rjmp    continueWithBit5;[053]
+;   [---]                   ;[054]
+
+macro POP_STANDARD ; 16 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    pop     r0
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+
+bitstuff7:
+    eor     x1, x4          ;[4]
+    ldi     x2, 0           ;[5]
+    nop2                    ;[6] C is zero (brcc)
+    rjmp    didStuff7       ;[8]
+
+bitstuffN:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6]
+    lpm                     ;[7] 3 cycle NOP, modifies r0
+    out     USBOUT, x1      ;[10] <-- out
+    rjmp    didStuffN       ;[0]
+
+#define bitStatus   x3
+
+sendNakAndReti:
+    ldi     cnt, USBPID_NAK ;[-19]
+    rjmp    sendCntAndReti  ;[-18]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     r0, cnt         ;[-16]
+    ldi     YL, 0           ;[-15] R0 address is 0
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+    ldi     bitStatus, 0xff ;[-4] init bit loop counter, works for up to 12 bytes
+byteloop:
+bitloop:
+    sbrs    shift, 0        ;[8] [-3]
+    eor     x1, x4          ;[9] [-2]
+    out     USBOUT, x1      ;[10] [-1] <-- out
+    ror     shift           ;[0]
+    ror     x2              ;[1]
+didStuffN:
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuffN       ;[3]
+    nop                     ;[4]
+    subi    bitStatus, 37   ;[5] 256 / 7 ~=~ 37
+    brcc    bitloop         ;[6] when we leave the loop, bitStatus has almost the initial value
+    sbrs    shift, 0        ;[7]
+    eor     x1, x4          ;[8]
+    ror     shift           ;[9]
+didStuff7:
+    out     USBOUT, x1      ;[10] <-- out
+    ror     x2              ;[0]
+    cpi     x2, 0xfc        ;[1]
+    brcc    bitstuff7       ;[2]
+    ld      shift, y+       ;[3]
+    dec     cnt             ;[5]
+    brne    byteloop        ;[6]
+;make SE0:
+    cbr     x1, USBMASK     ;[7] prepare SE0 [spec says EOP may be 21 to 25 cycles]
+    lds     x2, usbNewDeviceAddr;[8]
+    lsl     x2              ;[10] we compare with left shifted address
+    out     USBOUT, x1      ;[11] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    subi    YL, 2           ;[0] Only assign address on data packets, not ACK/NAK in r0
+    sbci    YH, 0           ;[1]
+    breq    skipAddrAssign  ;[2]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[5]
+    ori     x1, USBIDLE     ;[6]
+    in      x2, USBDDR      ;[7]
+    cbr     x2, USBMASK     ;[8] set both pins to input
+    mov     x3, x1          ;[9]
+    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
+    ldi     x4, 4           ;[11]
+se0Delay:
+    dec     x4              ;[12] [15] [18] [21]
+    brne    se0Delay        ;[13] [16] [19] [22]
+    out     USBOUT, x1      ;[23] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[24] <-- release bus now
+    out     USBOUT, x3      ;[25] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
Index: vusb-20121206/usbdrv/usbdrvasm18-crc.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm18-crc.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm18-crc.inc	(working copy)
@@ -0,0 +1,706 @@
+/* Name: usbdrvasm18.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Lukas Schrittwieser (based on 20 MHz usbdrvasm20.inc by Jeroen Benschop)
+ * Creation Date: 2009-01-20
+ * Tabsize: 4
+ * Copyright: (c) 2008 by Lukas Schrittwieser and OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 18 MHz version of the asssembler part of the USB driver. It
+requires a 18 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+
+;max stack usage: [ret(2), YL, SREG, YH, [sofError], bitcnt(x5), shift, x1, x2, x3, x4, cnt, ZL, ZH] = 14 bytes
+;nominal frequency: 18 MHz -> 12 cycles per bit
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+;register use in receive loop to receive the data bytes:
+; shift assembles the byte currently being received
+; x1 holds the D+ and D- line state
+; x2 holds the previous line state
+; cnt holds the number of bytes left in the receive buffer
+; x3 holds the higher crc byte (see algorithm below)
+; x4 is used as temporary register for the crc algorithm
+; x5 is used for unstuffing: when unstuffing the last received bit is inverted in shift (to prevent further
+;    unstuffing calls. In the same time the corresponding bit in x5 is cleared to mark the bit as beening iverted
+; zl lower crc value and crc table index
+; zh used for crc table accesses
+
+;--------------------------------------------------------------------------------------------------------------
+; CRC mods:
+;  table driven crc checker, Z points to table in prog space
+;   ZL is the lower crc byte, x3 is the higher crc byte
+;	x4 is used as temp register to store different results
+;	the initialization of the crc register is not 0xFFFF but 0xFE54. This is because during the receipt of the
+;	first data byte an virtual zero data byte is added to the crc register, this results in the correct initial
+;	value of 0xFFFF at beginning of the second data byte before the first data byte is added to the crc.
+;	The magic number 0xFE54 results form the crc table: At tabH[0x54] = 0xFF = crcH (required) and
+;	tabL[0x54] = 0x01  ->  crcL = 0x01 xor 0xFE = 0xFF
+;  bitcnt is renamed to x5 and is used for unstuffing purposes, the unstuffing works like in the 12MHz version
+;--------------------------------------------------------------------------------------------------------------
+; CRC algorithm:
+;	The crc register is formed by x3 (higher byte) and ZL (lower byte). The algorithm uses a 'reversed' form
+;	i.e. that it takes the least significant bit first and shifts to the right. So in fact the highest order
+;	bit seen from the polynomial devision point of view is the lsb of ZL. (If this sounds strange to you i
+;	propose a research on CRC :-) )
+;	Each data byte received is xored to ZL, the lower crc byte. This byte now builds the crc
+;	table index. Next the new high byte is loaded from the table and stored in x4 until we have space in x3
+;	(its destination).
+;	Afterwards the lower table is loaded from the table and stored in ZL (the old index is overwritten as
+;	we don't need it anymore. In fact this is a right shift by 8 bits.) Now the old crc high value is xored
+;	to ZL, this is the second shift of the old crc value. Now x4 (the temp reg) is moved to x3 and the crc
+; 	calculation is done.
+;	Prior to the first byte the two CRC register have to be initialized to 0xFFFF (as defined in usb spec)
+;	however the crc engine also runs during the receipt of the first byte, therefore x3 and zl are initialized
+;	to a magic number which results in a crc value of 0xFFFF after the first complete byte.
+;
+;	This algorithm is split into the extra cycles of the different bits:
+;	bit7:	XOR the received byte to ZL
+;	bit5:	load the new high byte to x4
+;	bit6:	load the lower xor byte from the table, xor zl and x3, store result in zl (=the new crc low value)
+;			move x4 (the new high byte) to x3, the crc value is ready
+;
+
+
+macro POP_STANDARD ; 18 cycles
+    pop		ZH
+    pop		ZL
+	pop     cnt
+    pop     x5
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     x4
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+macro CRC_CLEANUP_AND_CHECK
+	; the last byte has already been xored with the lower crc byte, we have to do the table lookup and xor
+	; x3 is the higher crc byte, zl the lower one
+	ldi		ZH, hi8(usbCrcTableHigh);[+1] get the new high byte from the table
+	lpm		x2, Z				;[+2][+3][+4]
+	ldi		ZH, hi8(usbCrcTableLow);[+5] get the new low xor byte from the table
+	lpm		ZL, Z				;[+6][+7][+8]
+	eor		ZL, x3				;[+7] xor the old high byte with the value from the table, x2:ZL now holds the crc value
+	cpi		ZL, 0x01			;[+8] if the crc is ok we have a fixed remainder value of 0xb001 in x2:ZL (see usb spec)
+	brne	ignorePacket		;[+9] detected a crc fault -> paket is ignored and retransmitted by the host
+	cpi		x2, 0xb0			;[+10]
+	brne	ignorePacket		;[+11] detected a crc fault -> paket is ignored and retransmitted by the host
+    endm
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG, YH, [sofError], x4, shift, x1, x2, x3, x5, cnt, ZL, ZH
+    push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-26]
+    push    YL                  ;[-25]
+    push    YH                  ;[-23]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-17]
+    rjmp    foundK              ;[-16]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-15]
+;{3, 5} after falling D- edge, average delay: 4 cycles
+;bit0 should be at 30  (2.5 bits) for center sampling. Currently at 4 so 26 cylces till bit 0 sample
+;use 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    x4                  ;[-14]
+;   [---]                       ;[-13]
+    lds     YL, usbInputBufOffset;[-12] used to toggle the two usb receive buffers
+;   [---]                       ;[-11]
+    clr     YH                  ;[-10]
+    subi    YL, lo8(-(usbRxBuf));[-9] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-8] [rx loop init]
+    push    shift               ;[-7]
+;   [---]                       ;[-6]
+    ldi		shift, 0x80			;[-5] the last bit is the end of byte marker for the pid receiver loop
+    clc			      	      	;[-4] the carry has to be clear for receipt of pid bit 0
+    sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
+    rjmp    haveTwoBitsK        ;[-2]
+    pop     shift               ;[-1] undo the push from before
+    pop     x4                  ;[1]
+    rjmp    waitForK            ;[3] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 24 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1                  ;[0]
+    push    x2                  ;[2]
+    push    x3                  ;[4] crc high byte
+    ldi     x2, 1<<USBPLUS      ;[6] [rx loop init] current line state is K state. D+=="1", D-=="0"
+    push    x5                  ;[7]
+    push    cnt                 ;[9]
+    ldi     cnt, USB_BUFSIZE    ;[11]
+
+
+;--------------------------------------------------------------------------------------------------------------
+; receives the pid byte
+; there is no real unstuffing algorithm implemented here as a stuffing bit is impossible in the pid byte.
+; That's because the last four bits of the byte are the inverted of the first four bits. If we detect a
+; unstuffing condition something went wrong and abort
+; shift has to be initialized to 0x80
+;--------------------------------------------------------------------------------------------------------------
+
+; pid bit 0 - used for even more register saving (we need the z pointer)
+	in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    eor		x2, x1				;[2] generate inverted of actual bit
+	sbrc	x2, USBMINUS		;[3] if the bit is set we received a zero
+	sec							;[4]
+	ror		shift				;[5] we perform no unstuffing check here as this is the first bit
+	mov		x2, x1				;[6]
+	push	ZL					;[7]
+								;[8]
+	push	ZH					;[9]
+								;[10]
+	ldi		x3, 0xFE			;[11] x3 is the high order crc value
+
+
+bitloopPid:						
+	in      x1, USBIN           ;[0] sample line state
+   	andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    breq    nse0                ;[2] both lines are low so handle se0	
+	eor		x2, x1				;[3] generate inverted of actual bit
+	sbrc	x2, USBMINUS		;[4] set the carry if we received a zero
+	sec							;[5]
+	ror		shift				;[6]
+	ldi		ZL, 0x54			;[7] ZL is the low order crc value
+	ser		x4					;[8] the is no bit stuffing check here as the pid bit can't be stuffed. if so
+								; some error occured. In this case the paket is discarded later on anyway.
+	mov		x2, x1				;[9] prepare for the next cycle
+	brcc	bitloopPid			;[10] while 0s drop out of shift we get the next bit
+	eor		x4, shift			;[11] invert all bits in shift and store result in x4
+
+;--------------------------------------------------------------------------------------------------------------
+; receives data bytes and calculates the crc
+; the last USBIN state has to be in x2
+; this is only the first half, due to branch distanc limitations the second half of the loop is near the end
+; of this asm file
+;--------------------------------------------------------------------------------------------------------------
+
+rxDataStart:
+    in      x1, USBIN           ;[0] sample line state (note: a se0 check is not useful due to bit dribbling)
+    ser		x5					;[1] prepare the unstuff marker register
+    eor		x2, x1             	;[2] generates the inverted of the actual bit
+    bst		x2, USBMINUS       	;[3] copy the bit from x2
+    bld		shift, 0	        ;[4] and store it in shift
+    mov		x2, shift	     	;[5] make a copy of shift for unstuffing check
+    andi	x2, 0xF9	      	;[6] mask the last six bits, if we got six zeros (which are six ones in fact)
+    breq	unstuff0	      	;[7] then Z is set now and we branch to the unstuffing handler
+didunstuff0:
+	subi    cnt, 1         		;[8] cannot use dec because it doesn't affect the carry flag
+    brcs    nOverflow    		;[9] Too many bytes received. Ignore packet							
+    st		Y+, x4				;[10] store the last received byte
+								;[11] st needs two cycles
+
+; bit1							
+	in		x2, USBIN			;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0 during bit 0
+    breq	nse0				;[2]
+    andi	x2, USBMASK			;[3] check se0 during bit 1
+    breq	nse0				;[4]
+	eor		x1, x2				;[5]
+    bst		x1, USBMINUS		;[6]
+    bld 	shift, 1	 		;[7]
+    mov		x1, shift			;[8]
+    andi	x1, 0xF3			;[9]
+    breq	unstuff1			;[10]
+didunstuff1:
+	nop							;[11]	
+
+; bit2
+	in      x1, USBIN           ;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0 (as there is nothing else to do here
+	breq	nOverflow	 		;[2]
+    eor		x2, x1              ;[3] generates the inverted of the actual bit
+    bst		x2, USBMINUS		;[4]
+    bld		shift, 2			;[5] store the bit
+    mov		x2, shift			;[6]
+    andi	x2, 0xE7			;[7] if we have six zeros here (which means six 1 in the stream)
+    breq	unstuff2			;[8] the next bit is a stuffing bit
+didunstuff2:
+	nop2						;[9]
+								;[10]
+	nop							;[11]					
+					
+; bit3							
+	in		x2, USBIN			;[0] sample line state
+    andi	x2, USBMASK			;[1] check for se0
+    breq	nOverflow           ;[2]
+    eor		x1, x2				;[3]
+    bst		x1, USBMINUS		;[4]
+    bld 	shift, 3	 		;[5]
+    mov		x1, shift			;[6]
+    andi	x1, 0xCF			;[7]
+    breq	unstuff3			;[8]
+didunstuff3:
+	nop							;[9]
+	rjmp 	rxDataBit4			;[10]
+								;[11]				
+
+; the avr branch instructions allow an offset of +63 insturction only, so we need this
+; 'local copy' of se0
+nse0:		
+	rjmp	se0					;[4]
+								;[5]
+; the same same as for se0 is needed for overflow and StuffErr
+nOverflow:
+stuffErr:
+	rjmp	overflow
+
+
+unstuff0:						;[8] this is the branch delay of breq unstuffX
+	andi	x1, USBMASK			;[9] do an se0 check here (if the last crc byte ends with 5 one's we might end up here
+	breq	didunstuff0			;[10] event tough the message is complete -> jump back and store the byte
+	ori		shift, 0x01			;[11] invert the last received bit to prevent furhter unstuffing
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	andi	x5, 0xFE			;[1] mark this bit as inverted (will be corrected before storing shift)
+	eor		x1, x2				;[2] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[3] mask the interesting bits
+	breq	stuffErr			;[4] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[5] the next bit expects the last state to be in x1
+	rjmp 	didunstuff0			;[6]
+								;[7] jump delay of rjmp didunstuffX	
+
+unstuff1:						;[11] this is the jump delay of breq unstuffX
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	ori		shift, 0x02			;[1] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xFD			;[2] mark this bit as inverted (will be corrected before storing shift)
+	eor		x2, x1				;[3] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[4] mask the interesting bits
+	breq	stuffErr			;[5] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[6] the next bit expects the last state to be in x2
+	nop2						;[7]
+								;[8]
+	rjmp 	didunstuff1			;[9]
+								;[10] jump delay of rjmp didunstuffX		
+
+unstuff2:						;[9] this is the jump delay of breq unstuffX
+	ori		shift, 0x04			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xFB			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff2			;[7]
+								;[8] jump delay of rjmp didunstuffX	
+
+unstuff3:						;[9] this is the jump delay of breq unstuffX
+	ori		shift, 0x08			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xF7			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff3			;[7]
+								;[8] jump delay of rjmp didunstuffX			
+
+
+
+; the include has to be here due to branch distance restirctions
+#define __USE_CRC__
+#include "asmcommon.inc"
+
+	
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+; 7.5 bit times is 90 cycles. ...there is plenty of time
+
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-6] <- acquire bus
+	ldi		x2, 0			;[-6] init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-5] exor mask
+    ldi     shift, 0x80     ;[-4] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x40    ;[-3]=[9]     binary 01000000
+txBitLoop:					; the loop sends the first 7 bits of the byte
+    sbrs    shift, 0        ;[-2]=[10] if we have to send a 1 don't change the line state
+    eor     x1, x4          ;[-1]=[11]
+    out     USBOUT, x1      ;[0]
+    ror     shift           ;[1]
+    ror     x2              ;[2] transfers the last sent bit to the stuffing history
+didStuffN:
+    nop	                    ;[3]
+    nop                     ;[4]
+    cpi     x2, 0xfc        ;[5] if we sent six consecutive ones
+    brcc    bitstuffN       ;[6]
+    lsr     bitcnt          ;[7]
+    brne    txBitLoop       ;[8] restart the loop while the 1 is still in the bitcount
+
+; transmit bit 7
+    sbrs    shift, 0        ;[9]
+    eor     x1, x4          ;[10]
+didStuff7:
+    ror     shift           ;[11]
+	out     USBOUT, x1      ;[0] transfer bit 7 to the pins
+    ror     x2              ;[1] move the bit into the stuffing history	
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuff7       ;[3]
+    ld      shift, y+       ;[4] get next byte to transmit
+    dec     cnt             ;[5] decrement byte counter
+    brne    txByteLoop      ;[7] if we have more bytes start next one
+    						;[8] branch delay
+    						
+;make SE0:
+    cbr     x1, USBMASK     ;[8] 		prepare SE0 [spec says EOP may be 25 to 30 cycles]
+    lds     x2, usbNewDeviceAddr;[9]
+    lsl     x2              ;[11] 		we compare with left shifted address
+    out     USBOUT, x1      ;[0] 		<-- out SE0 -- from now 2 bits = 24 cycles until bus idle
+    subi    YL, 20 + 2      ;[1] 		Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[2]
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[3]
+    sts     usbDeviceAddr, x2		; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[5] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[6]
+    ori     x1, USBIDLE     ;[7]
+    in      x2, USBDDR      ;[8]
+    cbr     x2, USBMASK     ;[9] set both pins to input
+    mov     x3, x1          ;[10]
+    cbr     x3, USBMASK     ;[11] configure no pullup on both pins
+    ldi     x4, 4           ;[12]
+se0Delay:
+    dec     x4              ;[13] [16] [19] [22]
+    brne    se0Delay        ;[14] [17] [20] [23]
+    out     USBOUT, x1      ;[24] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[25] <-- release bus now
+    out     USBOUT, x3      ;[26] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
+bitstuffN:
+    eor     x1, x4          ;[8] generate a zero
+    ldi     x2, 0           ;[9] reset the bit stuffing history
+    nop2                    ;[10]
+    out     USBOUT, x1      ;[0] <-- send the stuffing bit
+    rjmp    didStuffN       ;[1]
+
+bitstuff7:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6] reset bit stuffing history
+    clc						;[7] fill a zero into the shift register
+    rol     shift           ;[8] compensate for ror shift at branch destination
+    rjmp    didStuff7       ;[9]
+    						;[10] jump delay
+
+;--------------------------------------------------------------------------------------------------------------
+; receives data bytes and calculates the crc
+; second half of the data byte receiver loop
+; most parts of the crc algorithm are here
+;--------------------------------------------------------------------------------------------------------------
+
+nOverflow2:
+	rjmp overflow
+
+rxDataBit4:
+	in      x1, USBIN           ;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0
+    breq	nOverflow2			;[2]
+    eor		x2, x1              ;[3]
+    bst		x2, USBMINUS		;[4]
+    bld		shift, 4			;[5]
+    mov		x2, shift			;[6]
+    andi	x2, 0x9F			;[7]
+    breq	unstuff4			;[8]
+didunstuff4:
+	nop2						;[9][10]
+	nop							;[11]
+
+; bit5							
+	in		x2, USBIN			;[0] sample line state
+    ldi		ZH, hi8(usbCrcTableHigh);[1] use the table for the higher byte
+    eor		x1, x2				;[2]
+    bst		x1, USBMINUS		;[3]
+    bld 	shift, 5	 		;[4]
+    mov		x1, shift			;[5]
+    andi	x1, 0x3F			;[6]
+    breq	unstuff5			;[7]
+didunstuff5:
+	lpm		x4, Z				;[8] load the higher crc xor-byte and store it for later use
+								;[9] lpm needs 3 cycles
+								;[10]			
+	ldi		ZH, hi8(usbCrcTableLow);[11] load the lower crc xor byte adress
+
+; bit6	    					
+	in      x1, USBIN           ;[0] sample line state
+    eor		x2, x1              ;[1]
+    bst		x2, USBMINUS		;[2]
+    bld		shift, 6			;[3]
+    mov		x2, shift			;[4]
+    andi	x2, 0x7E			;[5]
+    breq	unstuff6			;[6]
+didunstuff6:
+	lpm		ZL, Z				;[7] load the lower xor crc byte
+								;[8] lpm needs 3 cycles
+	    						;[9]
+	eor		ZL, x3				;[10] xor the old high crc byte with the low xor-byte
+	mov		x3, x4				;[11] move the new high order crc value from temp to its destination
+			
+; bit7							
+	in		x2, USBIN			;[0] sample line state
+    eor		x1, x2				;[1]
+    bst		x1, USBMINUS		;[2]
+    bld 	shift, 7	 		;[3] now shift holds the complete but inverted data byte
+    mov		x1, shift			;[4]
+    andi	x1, 0xFC			;[5]
+    breq	unstuff7			;[6]
+didunstuff7:
+	eor		x5, shift			;[7] x5 marks all bits which have not been inverted by the unstuffing subs
+	mov		x4, x5				;[8] keep a copy of the data byte it will be stored during next bit0
+	eor		ZL, x4				;[9] feed the actual byte into the crc algorithm
+	rjmp	rxDataStart			;[10] next byte
+								;[11] during the reception of the next byte this one will be fed int the crc algorithm
+
+unstuff4:						;[9] this is the jump delay of rjmp unstuffX
+	ori		shift, 0x10			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xEF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff4			;[7]
+								;[8] jump delay of rjmp didunstuffX	
+
+unstuff5:						;[8] this is the jump delay of rjmp unstuffX
+	nop							;[9]
+	ori		shift, 0x20			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xDF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	nop							;[5]
+	rjmp 	didunstuff5			;[6]
+								;[7] jump delay of rjmp didunstuffX													
+
+unstuff6:						;[7] this is the jump delay of rjmp unstuffX
+	nop2						;[8]
+								;[9]
+	ori		shift, 0x40			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xBF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	rjmp 	didunstuff6			;[5]
+								;[6] jump delay of rjmp didunstuffX	
+
+unstuff7:						;[7] this is the jump delay of rjmp unstuffX
+	nop							;[8]
+	nop							;[9]
+	ori		shift, 0x80			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0x7F			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	rjmp 	didunstuff7			;[5]
+								;[6] jump delay of rjmp didunstuff7
+
+; local copy of the stuffErr desitnation for the second half of the receiver loop
+stuffErr2:
+	rjmp	stuffErr
+
+;--------------------------------------------------------------------------------------------------------------
+; The crc table follows. It has to be aligned to enable a fast loading of the needed bytes.
+; There are two tables of 256 entries each, the low and the high byte table.
+; Table values were generated with the following C code:
+/*
+#include <stdio.h>
+int main (int argc, char **argv)
+{
+	int i, j;
+	for (i=0; i<512; i++){
+		unsigned short crc = i & 0xff;
+		for(j=0; j<8; j++) crc = (crc >> 1) ^ ((crc & 1) ? 0xa001 : 0);
+		if((i & 7) == 0) printf("\n.byte ");
+		printf("0x%02x, ", (i > 0xff ? (crc >> 8) : crc) & 0xff);
+		if(i == 255) printf("\n");
+	}
+	return 0;
+}
+
+// Use the following algorithm to compute CRC values:
+ushort computeCrc(uchar *msg, uchar msgLen)
+{
+    uchar i;
+	ushort crc = 0xffff;
+	for(i = 0; i < msgLen; i++)
+		crc = usbCrcTable16[lo8(crc) ^ msg[i]] ^ hi8(crc);
+    return crc;
+}
+*/
+
+.balign 256
+usbCrcTableLow:	
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+
+; .balign 256
+usbCrcTableHigh:
+.byte 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2
+.byte 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04
+.byte 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E
+.byte 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8
+.byte 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A
+.byte 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC
+.byte 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6
+.byte 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10
+.byte 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32
+.byte 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4
+.byte 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE
+.byte 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38
+.byte 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA
+.byte 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C
+.byte 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26
+.byte 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0
+.byte 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62
+.byte 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4
+.byte 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE
+.byte 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68
+.byte 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA
+.byte 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C
+.byte 0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76
+.byte 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0
+.byte 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92
+.byte 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54
+.byte 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E
+.byte 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98
+.byte 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A
+.byte 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C
+.byte 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86
+.byte 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40	
+
Index: vusb-20121206/usbdrv/usbdrvasm20.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm20.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm20.inc	(working copy)
@@ -0,0 +1,359 @@
+/* Name: usbdrvasm20.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Jeroen Benschop
+ * Based on usbdrvasm16.inc from Christian Starkjohann
+ * Creation Date: 2008-03-05
+ * Tabsize: 4
+ * Copyright: (c) 2008 by Jeroen Benschop and OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 20 MHz version of the asssembler part of the USB driver. It
+requires a 20 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+#define leap2   x3
+#ifdef __IAR_SYSTEMS_ASM__
+#define nextInst    $+2
+#else
+#define nextInst    .+0
+#endif
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 20 MHz -> 13.333333 cycles per bit, 106.666667 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+;register use in receive loop:
+; shift assembles the byte currently being received
+; x1 holds the D+ and D- line state
+; x2 holds the previous line state
+; x4 (leap)  is used to add a leap cycle once every three bytes received
+; X3 (leap2) is used to add a leap cycle once every three stuff bits received
+; bitcnt is used to determine when a stuff bit is due
+; cnt holds the number of bytes left in the receive buffer
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-26]
+    push    YL                  ;[-25]
+    push    YH                  ;[-23]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-19]
+    rjmp    foundK              ;[-18]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-16]
+;{3, 5} after falling D- edge, average delay: 4 cycles
+;bit0 should be at 34 for center sampling. Currently at 4 so 30 cylces till bit 0 sample
+;use 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    bitcnt              ;[-16]
+;   [---]                       ;[-15]
+    lds     YL, usbInputBufOffset;[-14]
+;   [---]                       ;[-13]
+    clr     YH                  ;[-12]
+    subi    YL, lo8(-(usbRxBuf));[-11] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-10] [rx loop init]
+    push    shift               ;[-9]
+;   [---]                       ;[-8]
+    ldi     shift,0x40          ;[-7] set msb to "1" so processing bit7 can be detected
+    nop2                        ;[-6]
+;   [---]                       ;[-5]
+    ldi     bitcnt, 5           ;[-4] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
+    rjmp    haveTwoBitsK        ;[-2]
+    pop     shift               ;[-1] undo the push from before
+    pop     bitcnt              ;[1] 
+    rjmp    waitForK            ;[3] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 27 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1                  ;[0]
+    push    x2                  ;[2]
+    push    x3                  ;[4] (leap2)
+    ldi     leap2, 0x55         ;[6] add leap cycle on 2nd,5th,8th,... stuff bit
+    push    x4                  ;[7] == leap
+    ldi     leap, 0x55          ;[9] skip leap cycle on 2nd,5th,8th,... byte received
+    push    cnt                 ;[10]
+    ldi     cnt, USB_BUFSIZE    ;[12] [rx loop init]
+    ldi     x2, 1<<USBPLUS      ;[13] current line state is K state. D+=="1", D-=="0"
+bit0:       
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    rjmp    handleBit           ;[2] make bit0 14 cycles long
+
+;----------------------------------------------------------------------------
+; Process bit7. However, bit 6 still may need unstuffing.
+;----------------------------------------------------------------------------
+
+b6checkUnstuff:
+    dec     bitcnt              ;[9]
+    breq    unstuff6            ;[10]
+bit7:
+    subi    cnt, 1              ;[11] cannot use dec becaus it does not affect the carry flag
+    brcs    overflow            ;[12] Too many bytes received. Ignore packet
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    cpse    x1, x2              ;[2] when previous line state equals current line state, handle "1"
+    rjmp    b7handle0           ;[3] when line state differs, handle "0"
+    sec                         ;[4]
+    ror     shift               ;[5] shift "1" into the data
+    st      y+, shift           ;[6] store the data into the buffer
+    ldi     shift, 0x40         ;[7] reset data for receiving the next byte
+    subi    leap, 0x55          ;[9] trick to introduce a leap cycle every 3 bytes
+    brcc    nextInst            ;[10 or 11] it will fail after 85 bytes. However low speed can only receive 11
+    dec     bitcnt              ;[11 or 12]
+    brne    bit0                ;[12 or 13]
+    ldi     x1, 1               ;[13 or 14] unstuffing bit 7
+    in      bitcnt, USBIN       ;[0] sample stuff bit
+    rjmp    unstuff             ;[1]
+
+b7handle0:
+    mov     x2,x1               ;[5] Set x2 to current line state
+    ldi     bitcnt, 6           ;[6]
+    lsr     shift               ;[7] shift "0" into the data
+    st      y+, shift           ;[8] store data into the buffer
+    ldi     shift, 0x40         ;[10] reset data for receiving the next byte
+    subi    leap, 0x55          ;[11] trick to introduce a leap cycle every 3 bytes
+    brcs    bit0                ;[12] it will fail after 85 bytes. However low speed can only receive 11
+    rjmp    bit0                ;[13]
+
+
+;----------------------------------------------------------------------------
+; Handle unstuff
+; x1==0xFF indicate unstuffing bit6
+;----------------------------------------------------------------------------
+
+unstuff6:
+    ldi     x1,0xFF             ;[12] indicate unstuffing bit 6
+    in      bitcnt, USBIN       ;[0]  sample stuff bit
+    nop                         ;[1]  fix timing
+unstuff:                        ;b0-5  b6   b7
+    mov     x2,bitcnt           ;[3]  [2]  [3]  Set x2 to match line state
+    subi    leap2, 0x55         ;[4]  [3]  [4]  delay loop
+    brcs    nextInst            ;[5]  [4]  [5]  add one cycle every three stuff bits
+    sbci    leap2,0             ;[6]  [5]  [6]
+    ldi     bitcnt,6            ;[7]  [6]  [7]  reset bit stuff counter
+    andi    x2, USBMASK         ;[8]  [7]  [8] only keep D+ and D-
+    cpi     x1,0                ;[9]  [8]  [9]
+    brmi    bit7                ;[10] [9]  [10] finished unstuffing bit6 When x1<0
+    breq    bitloop             ;[11] ---  [11] finished unstuffing bit0-5 when x1=0
+    nop                         ;---  ---  [12]
+    in      x1, USBIN           ;---  ---  [0] sample line state for bit0
+    andi    x1, USBMASK         ;---  ---  [1] filter only D+ and D- bits
+    rjmp    handleBit           ;---  ---  [2] make bit0 14 cycles long
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+bitloop:
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    breq    se0                 ;[2] both lines are low so handle se0
+handleBit:
+    cpse    x1, x2              ;[3] when previous line state equals current line state, handle "1"
+    rjmp    handle0             ;[4] when line state differs, handle "0"
+    sec                         ;[5]
+    ror     shift               ;[6] shift "1" into the data
+    brcs    b6checkUnstuff      ;[7] When after shift C is set, next bit is bit7
+    nop2                        ;[8]
+    dec     bitcnt              ;[10]
+    brne    bitloop             ;[11]
+    ldi     x1,0                ;[12] indicate unstuff for bit other than bit6 or bit7
+    in      bitcnt, USBIN       ;[0] sample stuff bit
+    rjmp    unstuff             ;[1]
+
+handle0:
+    mov     x2, x1              ;[6] Set x2 to current line state
+    ldi     bitcnt, 6           ;[7] reset unstuff counter. 
+    lsr     shift               ;[8] shift "0" into the data
+    brcs    bit7                ;[9] When after shift C is set, next bit is bit7
+    nop                         ;[10]
+    rjmp    bitloop             ;[11] 
+    
+;----------------------------------------------------------------------------
+; End of receive loop. Now start handling EOP
+;----------------------------------------------------------------------------
+
+macro POP_STANDARD ; 14 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     bitcnt
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+
+
+#include "asmcommon.inc"
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+; 7.5 bit times is 100 cycles. This implementation arrives a bit later at se0
+; then specified in the include file but there is plenty of time
+
+bitstuffN:
+    eor     x1, x4          ;[8]
+    ldi     x2, 0           ;[9]
+    nop2                    ;[10]
+    out     USBOUT, x1      ;[12] <-- out
+    rjmp    didStuffN       ;[0]
+    
+bitstuff7:
+    eor     x1, x4          ;[6]
+    ldi     x2, 0           ;[7] Carry is zero due to brcc
+    rol     shift           ;[8] compensate for ror shift at branch destination
+    nop2                    ;[9]
+    rjmp    didStuff7       ;[11]
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We don't match the transfer rate exactly (don't insert leap cycles every third
+;byte) because the spec demands only 1.5% precision anyway.
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x49    ;[-4]        [10] binary 01001001
+txBitLoop:
+    sbrs    shift, 0        ;[-3] [10]   [11]
+    eor     x1, x4          ;[-2] [11]   [12]
+    out     USBOUT, x1      ;[-1] [12]   [13]   <-- out N
+    ror     shift           ;[0]  [13]   [14]
+    ror     x2              ;[1]
+didStuffN:
+    nop2                    ;[2]
+    nop                     ;[4]
+    cpi     x2, 0xfc        ;[5]
+    brcc    bitstuffN       ;[6]
+    lsr     bitcnt          ;[7]
+    brcc    txBitLoop       ;[8]
+    brne    txBitLoop       ;[9]
+
+    sbrs    shift, 0        ;[10]
+    eor     x1, x4          ;[11]
+didStuff7:
+    out     USBOUT, x1      ;[-1] [13] <-- out 7
+    ror     shift           ;[0] [14]
+    ror     x2              ;[1]
+    nop                     ;[2]
+    cpi     x2, 0xfc        ;[3]
+    brcc    bitstuff7       ;[4]
+    ld      shift, y+       ;[5]
+    dec     cnt             ;[7]
+    brne    txByteLoop      ;[8]
+;make SE0:
+    cbr     x1, USBMASK     ;[9] prepare SE0 [spec says EOP may be 25 to 30 cycles]
+    lds     x2, usbNewDeviceAddr;[10]
+    lsl     x2              ;[12] we compare with left shifted address
+    out     USBOUT, x1      ;[13] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+    subi    YL, 20 + 2      ;[0] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[1]
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[2]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[5]
+    ori     x1, USBIDLE     ;[6]
+    in      x2, USBDDR      ;[7]
+    cbr     x2, USBMASK     ;[8] set both pins to input
+    mov     x3, x1          ;[9]
+    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
+    ldi     x4, 5           ;[11]
+se0Delay:
+    dec     x4              ;[12] [15] [18] [21] [24]
+    brne    se0Delay        ;[13] [16] [19] [22] [25]
+    out     USBOUT, x1      ;[26] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[27] <-- release bus now
+    out     USBOUT, x3      ;[28] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: vusb-20121206/usbdrv/usbportability.h
===================================================================
--- vusb-20121206/usbdrv/usbportability.h	(nonexistent)
+++ vusb-20121206/usbdrv/usbportability.h	(working copy)
@@ -0,0 +1,143 @@
+/* Name: usbportability.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-06-17
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This header is intended to contain all (or at least most of) the compiler
+and library dependent stuff. The C code is written for avr-gcc and avr-libc.
+The API of other development environments is converted to gcc's and avr-libc's
+API by means of defines.
+
+This header also contains all system includes since they depend on the
+development environment.
+
+Thanks to Oleg Semyonov for his help with the IAR tools port!
+*/
+
+#ifndef __usbportability_h_INCLUDED__
+#define __usbportability_h_INCLUDED__
+
+/* We check explicitly for IAR and CodeVision. Default is avr-gcc/avr-libc. */
+
+/* ------------------------------------------------------------------------- */
+#if defined __IAR_SYSTEMS_ICC__ || defined __IAR_SYSTEMS_ASM__  /* check for IAR */
+/* ------------------------------------------------------------------------- */
+
+#ifndef ENABLE_BIT_DEFINITIONS
+#   define ENABLE_BIT_DEFINITIONS	1   /* Enable bit definitions */
+#endif
+
+/* Include IAR headers */
+#include <ioavr.h>
+#ifndef __IAR_SYSTEMS_ASM__
+#   include <inavr.h>
+#endif
+
+#define __attribute__(arg)  /* not supported on IAR */
+
+#ifdef __IAR_SYSTEMS_ASM__
+#   define __ASSEMBLER__    /* IAR does not define standard macro for asm */
+#endif
+
+#ifdef __HAS_ELPM__
+#   define PROGMEM __farflash
+#else
+#   define PROGMEM __flash
+#endif
+
+#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+
+/* The following definitions are not needed by the driver, but may be of some
+ * help if you port a gcc based project to IAR.
+ */
+#define cli()       __disable_interrupt()
+#define sei()       __enable_interrupt()
+#define wdt_reset() __watchdog_reset()
+#define _BV(x)      (1 << (x))
+
+/* assembler compatibility macros */
+#define nop2    rjmp    $+2 /* jump to next instruction */
+#define XL      r26
+#define XH      r27
+#define YL      r28
+#define YH      r29
+#define ZL      r30
+#define ZH      r31
+#define lo8(x)  LOW(x)
+#define hi8(x)  (((x)>>8) & 0xff)   /* not HIGH to allow XLINK to make a proper range check */
+
+/* Depending on the device you use, you may get problems with the way usbdrv.h
+ * handles the differences between devices. Since IAR does not use #defines
+ * for MCU registers, we can't check for the existence of a particular
+ * register with an #ifdef. If the autodetection mechanism fails, include
+ * definitions for the required USB_INTR_* macros in your usbconfig.h. See
+ * usbconfig-prototype.h and usbdrv.h for details.
+ */
+
+/* ------------------------------------------------------------------------- */
+#elif __CODEVISIONAVR__ /* check for CodeVision AVR */
+/* ------------------------------------------------------------------------- */
+/* This port is not working (yet) */
+
+/* #define F_CPU   _MCU_CLOCK_FREQUENCY_    seems to be defined automatically */
+
+#include <io.h>
+#include <delay.h>
+
+#define __attribute__(arg)  /* not supported on IAR */
+
+#define PROGMEM                 __flash
+#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+
+#ifndef __ASSEMBLER__
+static inline void  cli(void)
+{
+    #asm("cli");
+}
+static inline void  sei(void)
+{
+    #asm("sei");
+}
+#endif
+#define _delay_ms(t)    delay_ms(t)
+#define _BV(x)          (1 << (x))
+#define USB_CFG_USE_SWITCH_STATEMENT 1  /* macro for if() cascase fails for unknown reason */
+
+#define macro   .macro
+#define endm    .endmacro
+#define nop2    rjmp    .+0 /* jump to next instruction */
+
+/* ------------------------------------------------------------------------- */
+#else   /* default development environment is avr-gcc/avr-libc */
+/* ------------------------------------------------------------------------- */
+
+#include <avr/io.h>
+#ifdef __ASSEMBLER__
+#   define _VECTOR(N)   __vector_ ## N   /* io.h does not define this for asm */
+#else
+#   include <avr/pgmspace.h>
+#endif
+
+#if USB_CFG_DRIVER_FLASH_PAGE
+#   define USB_READ_FLASH(addr)    pgm_read_byte_far(((long)USB_CFG_DRIVER_FLASH_PAGE << 16) | (long)(addr))
+#else
+#   define USB_READ_FLASH(addr)    pgm_read_byte(addr)
+#endif
+
+#define macro   .macro
+#define endm    .endm
+#define nop2    rjmp    .+0 /* jump to next instruction */
+
+#endif  /* development environment */
+
+/* for conveniecne, ensure that PRG_RDB exists */
+#ifndef PRG_RDB
+#   define PRG_RDB(addr)    USB_READ_FLASH(addr)
+#endif
+#endif  /* __usbportability_h_INCLUDED__ */
Index: vusb-20121206/Changelog.txt
===================================================================
--- vusb-20121206/Changelog.txt	(nonexistent)
+++ vusb-20121206/Changelog.txt	(working copy)
@@ -0,0 +1,329 @@
+This file documents changes in the firmware-only USB driver for atmel's AVR
+microcontrollers. New entries are always appended to the end of the file.
+Scroll down to the bottom to see the most recent changes.
+
+2005-04-01:
+  - Implemented endpoint 1 as interrupt-in endpoint.
+  - Moved all configuration options to usbconfig.h which is not part of the
+    driver.
+  - Changed interface for usbVendorSetup().
+  - Fixed compatibility with ATMega8 device.
+  - Various minor optimizations.
+
+2005-04-11:
+  - Changed interface to application: Use usbFunctionSetup(), usbFunctionRead()
+    and usbFunctionWrite() now. Added configuration options to choose which
+    of these functions to compile in.
+  - Assembler module delivers receive data non-inverted now.
+  - Made register and bit names compatible with more AVR devices.
+
+2005-05-03:
+  - Allow address of usbRxBuf on any memory page as long as the buffer does
+    not cross 256 byte page boundaries.
+  - Better device compatibility: works with Mega88 now.
+  - Code optimization in debugging module.
+  - Documentation updates.
+
+2006-01-02:
+  - Added (free) default Vendor- and Product-IDs bought from voti.nl.
+  - Added USBID-License.txt file which defines the rules for using the free
+    shared VID/PID pair.
+  - Added Readme.txt to the usbdrv directory which clarifies administrative
+    issues.
+
+2006-01-25:
+  - Added "configured state" to become more standards compliant.
+  - Added "HALT" state for interrupt endpoint.
+  - Driver passes the "USB Command Verifier" test from usb.org now.
+  - Made "serial number" a configuration option.
+  - Minor optimizations, we now recommend compiler option "-Os" for best
+    results.
+  - Added a version number to usbdrv.h
+
+2006-02-03:
+  - New configuration variable USB_BUFFER_SECTION for the memory section where
+    the USB rx buffer will go. This defaults to ".bss" if not defined. Since
+    this buffer MUST NOT cross 256 byte pages (not even touch a page at the
+    end), the user may want to pass a linker option similar to
+    "-Wl,--section-start=.mybuffer=0x800060".
+  - Provide structure for usbRequest_t.
+  - New defines for USB constants.
+  - Prepared for HID implementations.
+  - Increased data size limit for interrupt transfers to 8 bytes.
+  - New macro usbInterruptIsReady() to query interrupt buffer state.
+
+2006-02-18:
+  - Ensure that the data token which is sent as an ack to an OUT transfer is
+    always zero sized. This fixes a bug where the host reports an error after
+    sending an out transfer to the device, although all data arrived at the
+    device.
+  - Updated docs in usbdrv.h to reflect changed API in usbFunctionWrite().
+
+* Release 2006-02-20
+
+  - Give a compiler warning when compiling with debugging turned on.
+  - Added Oleg Semyonov's changes for IAR-cc compatibility.
+  - Added new (optional) functions usbDeviceConnect() and usbDeviceDisconnect()
+    (also thanks to Oleg!).
+  - Rearranged tests in usbPoll() to save a couple of instructions in the most
+    likely case that no actions are pending.
+  - We need a delay between the SET ADDRESS request until the new address
+    becomes active. This delay was handled in usbPoll() until now. Since the
+    spec says that the delay must not exceed 2ms, previous versions required
+    aggressive polling during the enumeration phase. We have now moved the
+    handling of the delay into the interrupt routine.
+  - We must not reply with NAK to a SETUP transaction. We can only achieve this
+    by making sure that the rx buffer is empty when SETUP tokens are expected.
+    We therefore don't pass zero sized data packets from the status phase of
+    a transfer to usbPoll(). This change MAY cause troubles if you rely on
+    receiving a less than 8 bytes long packet in usbFunctionWrite() to
+    identify the end of a transfer. usbFunctionWrite() will NEVER be called
+    with a zero length.
+
+* Release 2006-03-14
+
+  - Improved IAR C support: tiny memory model, more devices
+  - Added template usbconfig.h file under the name usbconfig-prototype.h
+
+* Release 2006-03-26
+
+  - Added provision for one more interrupt-in endpoint (endpoint 3).
+  - Added provision for one interrupt-out endpoint (endpoint 1).
+  - Added flowcontrol macros for USB.
+  - Added provision for custom configuration descriptor.
+  - Allow ANY two port bits for D+ and D-.
+  - Merged (optional) receive endpoint number into global usbRxToken variable.
+  - Use USB_CFG_IOPORTNAME instead of USB_CFG_IOPORT. We now construct the
+    variable name from the single port letter instead of computing the address
+    of related ports from the output-port address.
+
+* Release 2006-06-26
+
+  - Updated documentation in usbdrv.h and usbconfig-prototype.h to reflect the
+    new features.
+  - Removed "#warning" directives because IAR does not understand them. Use
+    unused static variables instead to generate a warning.
+  - Do not include <avr/io.h> when compiling with IAR.
+  - Introduced USB_CFG_DESCR_PROPS_* in usbconfig.h to configure how each
+    USB descriptor should be handled. It is now possible to provide descriptor
+    data in Flash, RAM or dynamically at runtime.
+  - STALL is now a status in usbTxLen* instead of a message. We can now conform
+    to the spec and leave the stall status pending until it is cleared.
+  - Made usbTxPacketCnt1 and usbTxPacketCnt3 public. This allows the
+    application code to reset data toggling on interrupt pipes.
+
+* Release 2006-07-18
+
+  - Added an #if !defined __ASSEMBLER__ to the warning in usbdrv.h. This fixes
+    an assembler error.
+  - usbDeviceDisconnect() takes pull-up resistor to high impedance now.
+
+* Release 2007-02-01
+
+  - Merged in some code size improvements from usbtiny (thanks to Dick
+    Streefland for these optimizations!)
+  - Special alignment requirement for usbRxBuf not required any more. Thanks
+    again to Dick Streefland for this hint!
+  - Reverted to "#warning" instead of unused static variables -- new versions
+    of IAR CC should handle this directive.
+  - Changed Open Source license to GNU GPL v2 in order to make linking against
+    other free libraries easier. We no longer require publication of the
+    circuit diagrams, but we STRONGLY encourage it. If you improve the driver
+    itself, PLEASE grant us a royalty free license to your changes for our
+    commercial license.
+
+* Release 2007-03-29
+
+  - New configuration option "USB_PUBLIC" in usbconfig.h.
+  - Set USB version number to 1.10 instead of 1.01.
+  - Code used USB_CFG_DESCR_PROPS_STRING_DEVICE and
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT inconsistently. Changed all occurrences
+    to USB_CFG_DESCR_PROPS_STRING_PRODUCT.
+  - New assembler module for 16.5 MHz RC oscillator clock with PLL in receiver
+    code.
+  - New assembler module for 16 MHz crystal.
+  - usbdrvasm.S contains common code only, clock-specific parts have been moved
+    to usbdrvasm12.S, usbdrvasm16.S and usbdrvasm165.S respectively.
+
+* Release 2007-06-25
+
+  - 16 MHz module: Do SE0 check in stuffed bits as well.
+
+* Release 2007-07-07
+
+  - Define hi8(x) for IAR compiler to limit result to 8 bits. This is necessary
+    for negative values.
+  - Added 15 MHz module contributed by V. Bosch.
+  - Interrupt vector name can now be configured. This is useful if somebody
+    wants to use a different hardware interrupt than INT0.
+
+* Release 2007-08-07
+
+  - Moved handleIn3 routine in usbdrvasm16.S so that relative jump range is
+    not exceeded.
+  - More config options: USB_RX_USER_HOOK(), USB_INITIAL_DATATOKEN,
+    USB_COUNT_SOF
+  - USB_INTR_PENDING can now be a memory address, not just I/O
+
+* Release 2007-09-19
+
+  - Split out common parts of assembler modules into separate include file
+  - Made endpoint numbers configurable so that given interface definitions
+    can be matched. See USB_CFG_EP3_NUMBER in usbconfig-prototype.h.
+  - Store endpoint number for interrupt/bulk-out so that usbFunctionWriteOut()
+    can handle any number of endpoints.
+  - Define usbDeviceConnect() and usbDeviceDisconnect() even if no
+    USB_CFG_PULLUP_IOPORTNAME is defined. Directly set D+ and D- to 0 in this
+    case.
+
+* Release 2007-12-01
+
+  - Optimize usbDeviceConnect() and usbDeviceDisconnect() for less code size
+    when USB_CFG_PULLUP_IOPORTNAME is not defined.
+
+* Release 2007-12-13
+
+  - Renamed all include-only assembler modules from *.S to *.inc so that
+    people don't add them to their project sources.
+  - Distribute leap bits in tx loop more evenly for 16 MHz module.
+  - Use "macro" and "endm" instead of ".macro" and ".endm" for IAR
+  - Avoid compiler warnings for constant expr range by casting some values in
+    USB descriptors.
+
+* Release 2008-01-21
+
+  - Fixed bug in 15 and 16 MHz module where the new address set with
+    SET_ADDRESS was already accepted at the next NAK or ACK we send, not at
+    the next data packet we send. This caused problems when the host polled
+    too fast. Thanks to Alexander Neumann for his help and patience debugging
+    this issue!
+
+* Release 2008-02-05
+
+  - Fixed bug in 16.5 MHz module where a register was used in the interrupt
+    handler before it was pushed. This bug was introduced with version
+    2007-09-19 when common parts were moved to a separate file.
+  - Optimized CRC routine (thanks to Reimar Doeffinger).
+
+* Release 2008-02-16
+
+  - Removed outdated IAR compatibility stuff (code sections).
+  - Added hook macros for USB_RESET_HOOK() and USB_SET_ADDRESS_HOOK().
+  - Added optional routine usbMeasureFrameLength() for calibration of the
+    internal RC oscillator.
+
+* Release 2008-02-28
+
+  - USB_INITIAL_DATATOKEN defaults to USBPID_DATA1 now, which means that we
+    start with sending USBPID_DATA0.
+  - Changed defaults in usbconfig-prototype.h
+  - Added free USB VID/PID pair for MIDI class devices
+  - Restructured AVR-USB as separate package, not part of PowerSwitch any more.
+
+* Release 2008-04-18
+
+  - Restructured usbdrv.c so that it is easier to read and understand.
+  - Better code optimization with gcc 4.
+  - If a second interrupt in endpoint is enabled, also add it to config
+    descriptor.
+  - Added config option for long transfers (above 254 bytes), see
+    USB_CFG_LONG_TRANSFERS in usbconfig.h.
+  - Added 20 MHz module contributed by Jeroen Benschop.
+
+* Release 2008-05-13
+
+  - Fixed bug in libs-host/hiddata.c function usbhidGetReport(): length
+    was not incremented, pointer to length was incremented instead.
+  - Added code to command line tool(s) which claims an interface. This code
+    is disabled by default, but may be necessary on newer Linux kernels.
+  - Added usbconfig.h option "USB_CFG_CHECK_DATA_TOGGLING".
+  - New header "usbportability.h" prepares ports to other development
+    environments.
+  - Long transfers (above 254 bytes) did not work when usbFunctionRead() was
+    used to supply the data. Fixed this bug. [Thanks to Alexander Neumann!]
+  - In hiddata.c (example code for sending/receiving data over HID), use
+    USB_RECIP_DEVICE instead of USB_RECIP_INTERFACE for control transfers so
+    that we need not claim the interface.
+  - in usbPoll() loop 20 times polling for RESET state instead of 10 times.
+    This accounts for the higher clock rates we now support.
+  - Added a module for 12.8 MHz RC oscillator with PLL in receiver loop.
+  - Added hook to SOF code so that oscillator can be tuned to USB frame clock.
+  - Added timeout to waitForJ loop. Helps preventing unexpected hangs.
+  - Added example code for oscillator tuning to libs-device (thanks to
+    Henrik Haftmann for the idea to this routine).
+  - Implemented option USB_CFG_SUPPRESS_INTR_CODE.
+
+* Release 2008-10-22
+
+  - Fixed libs-device/osctune.h: OSCCAL is memory address on ATMega88 and
+    similar, not offset of 0x20 needs to be added.
+  - Allow distribution under GPLv3 for those who have to link against other
+    code distributed under GPLv3.
+
+* Release 2008-11-26
+
+  - Removed libusb-win32 dependency for hid-data example in Makefile.windows.
+    It was never required and confused many people.
+  - Added extern uchar usbRxToken to usbdrv.h.
+  - Integrated a module with CRC checks at 18 MHz by Lukas Schrittwieser.
+
+* Release 2009-03-23
+
+  - Hid-mouse example used settings from hid-data example, fixed that.
+  - Renamed project to V-USB due to a trademark issue with Atmel(r).
+  - Changed CommercialLicense.txt and USBID-License.txt to make the
+    background of USB ID registration clearer.
+
+* Release 2009-04-15
+
+  - Changed CommercialLicense.txt to reflect the new range of PIDs from
+    Jason Kotzin.
+  - Removed USBID-License.txt in favor of USB-IDs-for-free.txt and
+    USB-ID-FAQ.txt
+  - Fixed a bug in the 12.8 MHz module: End Of Packet decection was made in
+    the center between bit 0 and 1 of each byte. This is where the data lines
+    are expected to change and the sampled data may therefore be nonsense.
+    We therefore check EOP ONLY if bits 0 AND 1 have both been read as 0 on D-.
+  - Fixed a bitstuffing problem in the 16 MHz module: If bit 6 was stuffed,
+    the unstuffing code in the receiver routine was 1 cycle too long. If
+    multiple bytes had the unstuffing in bit 6, the error summed up until the
+    receiver was out of sync.
+  - Included option for faster CRC routine.
+    Thanks to Slawomir Fras (BoskiDialer) for this code!
+  - Updated bits in Configuration Descriptor's bmAttributes according to
+    USB 1.1 (in particular bit 7, it is a must-be-set bit now).
+
+* Release 2009-08-22
+
+  - Moved first DBG1() after odDebugInit() in all examples.
+  - Use vector INT0_vect instead of SIG_INTERRUPT0 if defined. This makes
+    V-USB compatible with the new "p" suffix devices (e.g. ATMega328p).
+  - USB_CFG_CLOCK_KHZ setting is now required in usbconfig.h (no default any
+    more).
+  - New option USB_CFG_DRIVER_FLASH_PAGE allows boot loaders on devices with
+    more than 64 kB flash.
+  - Built-in configuration descriptor allows custom definition for second
+    endpoint now.
+
+* Release 2010-07-15
+
+  - Fixed bug in usbDriverSetup() which prevented descriptor sizes above 255
+    bytes.
+  - Avoid a compiler warning for unused parameter in usbHandleResetHook() when
+    compiler option -Wextra is enabled.
+  - Fixed wrong hex value for some IDs in USB-IDs-for-free.txt.
+  - Keep a define for USBATTR_BUSPOWER, although the flag does not exist
+    in USB 1.1 any more. Set it to 0. This is for backward compatibility.
+
+* Release 2012-01-09
+
+  - Define a separate (defined) type for usbMsgPtr so that projects using a
+    tiny memory model can define it to an 8 bit type in usbconfig.h. This
+    change also saves a couple of bytes when using a scalar 16 bit type.
+  - Inserted "const" keyword for all PROGMEM declarations because new GCC
+    requires it.
+  - Fixed problem with dependence of usbportability.h on usbconfig.h. This
+    problem occurred with IAR CC only.
+  - Prepared repository for github.com.
+
+* Release 2012-12-06
\ No newline at end of file
Index: vusb-20121206/circuits/Readme.txt
===================================================================
--- vusb-20121206/circuits/Readme.txt	(nonexistent)
+++ vusb-20121206/circuits/Readme.txt	(working copy)
@@ -0,0 +1,79 @@
+This is the Readme file for the V-USB example circuits directory.
+
+
+CIRCUITS IN THIS DIRECTORY
+==========================
+Since USB requires 3.3 V levels on D+ and D- but delivers a power supply of
+ca. 5 V, some kind of level conversion must be performed. There are several
+ways to implement this level conversion, see the example circuits below.
+
+with-vreg.png and with-vreg.sch (EAGLE schematics):
+  This circuit uses a low drop voltage regulator to reduce the USB supply to
+  3.3 V. You MUST use a low drop regulator because standard regulators such
+  as the LM317 require at least ca. 2 V drop. The advantage of this approach
+  is that it comes closest to the voltage levels required by the USB
+  specification and that the circuit is powered from a regulated supply. If
+  no USB cable is used (connector directly soldered on PCB), you can even
+  omit the 68 Ohm series resistors. The disadvantage is that you may want to
+  use other chips in your design which require 5 V. Please check that the AVR
+  used in your design allows the chosen clock rate at 3.3 V.
+
+with-zener.png and with-zener.sch (EAGLE schematics):
+  This circuit enforces lower voltage levels on D+ and D- with zener diodes.
+  The zener diodes MUST be low power / low current types to ensure that the
+  1k5 pull-up resistor on D- generates a voltage of well above 2.5 V (but
+  below 3.6 V). The advantage of this circuit is its simplicity and that the
+  circuit can be powered at 5 V (usually precise enough if the cable drop is
+  neglected). The disadvantage is that some zener diodes have a lower voltage
+  than 3 V when powered through 1k5 and the choice of components becomes
+  relevant. In addition to that, the power consumption during USB data
+  transfer is increased because the current is only limited by the 68 Ohm
+  series resistor. The zeners may even distort the signal waveforms due to
+  their capacity.
+
+with-series-diodes.png and with-series-diodes.sch (EAGLE schematics):
+  This is a simplified low-cost version of the voltage regulator approach.
+  Instead of using a voltage regulator, we reduce the voltage by the forward
+  voltage of two silicon diodes (roughly 1.4 V). This gives ca. 3.6 V which
+  is practically inside the allowed range. The big disadvantage is that the
+  supply is not regulated -- it even depends strongly on the power
+  consumption. This cannot be tolerated for analog circuits.
+
+tiny45-rc.png and tiny45-rc.sch (EAGLE schematics):
+  This is mostly an example for connecting an 8 pin device using the internal
+  RC oscillator for system clock. This example uses series diodes to limit
+  the supply, but you may choose any other method. Please note that you must
+  choose a clock rate of 12.8 or 16.5 MHz because only the receiver modules
+  for these frequencies have a PLL to allow higher clock rate tolerances.
+
+
+GENERAL DESIGN NOTES
+====================
+All examples have D+ on hardware interrupt INT0 because this is the highest
+priority interrupt on AVRs. You may use other hardware interrupts (and
+configure the options at the end of usbconfig.h accordingly) if you make sure
+that no higher priority interrupt is used.
+
+If you use USB_SOF_HOOK or USB_COUNT_SOF in usbconfig.h, you must wire D- to
+the interrupt instead. This way the interrupt is triggered on USB Start Of
+Frame pulses as well.
+
+Most examples have a 1M pull-down resistor at D+. This pull-up ensures that
+in self-powered designs no interrupts occur while USB is not connected. You
+may omit this resistor in bus-powered designs. Older examples had a pull-up
+resistor instead. This is not compatible with the zener diode approach to
+level conversion: 1M pull-up in conjunction with a 3.6 V zener diode give an
+invalid logic level.
+
+All examples with ATMega8/88/168 have D+ at port D bit 2 (because this is
+hardware interrupt 0) and D- on port D bit 4 because it is also a clock input
+for timer/counter 0. This way the firmware can easily check for activity on
+D- (USB frame pulses) by checking the counter value in regular intervals. If
+no activity is found, the firmware should (according to the USB
+specification) put the system into a low power suspend mode.
+
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/circuits/tiny45-rc.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/tiny45-rc.png
===================================================================
--- vusb-20121206/circuits/tiny45-rc.png	(nonexistent)
+++ vusb-20121206/circuits/tiny45-rc.png	(working copy)

Property changes on: vusb-20121206/circuits/tiny45-rc.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/tiny45-rc.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/tiny45-rc.sch
===================================================================
--- vusb-20121206/circuits/tiny45-rc.sch	(nonexistent)
+++ vusb-20121206/circuits/tiny45-rc.sch	(working copy)

Property changes on: vusb-20121206/circuits/tiny45-rc.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-series-diodes.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-series-diodes.png
===================================================================
--- vusb-20121206/circuits/with-series-diodes.png	(nonexistent)
+++ vusb-20121206/circuits/with-series-diodes.png	(working copy)

Property changes on: vusb-20121206/circuits/with-series-diodes.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-series-diodes.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-series-diodes.sch
===================================================================
--- vusb-20121206/circuits/with-series-diodes.sch	(nonexistent)
+++ vusb-20121206/circuits/with-series-diodes.sch	(working copy)

Property changes on: vusb-20121206/circuits/with-series-diodes.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-vreg.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-vreg.png
===================================================================
--- vusb-20121206/circuits/with-vreg.png	(nonexistent)
+++ vusb-20121206/circuits/with-vreg.png	(working copy)

Property changes on: vusb-20121206/circuits/with-vreg.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-vreg.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-vreg.sch
===================================================================
--- vusb-20121206/circuits/with-vreg.sch	(nonexistent)
+++ vusb-20121206/circuits/with-vreg.sch	(working copy)

Property changes on: vusb-20121206/circuits/with-vreg.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-zener.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-zener.png
===================================================================
--- vusb-20121206/circuits/with-zener.png	(nonexistent)
+++ vusb-20121206/circuits/with-zener.png	(working copy)

Property changes on: vusb-20121206/circuits/with-zener.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-zener.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-zener.sch
===================================================================
--- vusb-20121206/circuits/with-zener.sch	(nonexistent)
+++ vusb-20121206/circuits/with-zener.sch	(working copy)

Property changes on: vusb-20121206/circuits/with-zener.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/Readme.txt
===================================================================
--- vusb-20121206/circuits/Readme.txt	(nonexistent)
+++ vusb-20121206/circuits/Readme.txt	(working copy)
@@ -0,0 +1,79 @@
+This is the Readme file for the V-USB example circuits directory.
+
+
+CIRCUITS IN THIS DIRECTORY
+==========================
+Since USB requires 3.3 V levels on D+ and D- but delivers a power supply of
+ca. 5 V, some kind of level conversion must be performed. There are several
+ways to implement this level conversion, see the example circuits below.
+
+with-vreg.png and with-vreg.sch (EAGLE schematics):
+  This circuit uses a low drop voltage regulator to reduce the USB supply to
+  3.3 V. You MUST use a low drop regulator because standard regulators such
+  as the LM317 require at least ca. 2 V drop. The advantage of this approach
+  is that it comes closest to the voltage levels required by the USB
+  specification and that the circuit is powered from a regulated supply. If
+  no USB cable is used (connector directly soldered on PCB), you can even
+  omit the 68 Ohm series resistors. The disadvantage is that you may want to
+  use other chips in your design which require 5 V. Please check that the AVR
+  used in your design allows the chosen clock rate at 3.3 V.
+
+with-zener.png and with-zener.sch (EAGLE schematics):
+  This circuit enforces lower voltage levels on D+ and D- with zener diodes.
+  The zener diodes MUST be low power / low current types to ensure that the
+  1k5 pull-up resistor on D- generates a voltage of well above 2.5 V (but
+  below 3.6 V). The advantage of this circuit is its simplicity and that the
+  circuit can be powered at 5 V (usually precise enough if the cable drop is
+  neglected). The disadvantage is that some zener diodes have a lower voltage
+  than 3 V when powered through 1k5 and the choice of components becomes
+  relevant. In addition to that, the power consumption during USB data
+  transfer is increased because the current is only limited by the 68 Ohm
+  series resistor. The zeners may even distort the signal waveforms due to
+  their capacity.
+
+with-series-diodes.png and with-series-diodes.sch (EAGLE schematics):
+  This is a simplified low-cost version of the voltage regulator approach.
+  Instead of using a voltage regulator, we reduce the voltage by the forward
+  voltage of two silicon diodes (roughly 1.4 V). This gives ca. 3.6 V which
+  is practically inside the allowed range. The big disadvantage is that the
+  supply is not regulated -- it even depends strongly on the power
+  consumption. This cannot be tolerated for analog circuits.
+
+tiny45-rc.png and tiny45-rc.sch (EAGLE schematics):
+  This is mostly an example for connecting an 8 pin device using the internal
+  RC oscillator for system clock. This example uses series diodes to limit
+  the supply, but you may choose any other method. Please note that you must
+  choose a clock rate of 12.8 or 16.5 MHz because only the receiver modules
+  for these frequencies have a PLL to allow higher clock rate tolerances.
+
+
+GENERAL DESIGN NOTES
+====================
+All examples have D+ on hardware interrupt INT0 because this is the highest
+priority interrupt on AVRs. You may use other hardware interrupts (and
+configure the options at the end of usbconfig.h accordingly) if you make sure
+that no higher priority interrupt is used.
+
+If you use USB_SOF_HOOK or USB_COUNT_SOF in usbconfig.h, you must wire D- to
+the interrupt instead. This way the interrupt is triggered on USB Start Of
+Frame pulses as well.
+
+Most examples have a 1M pull-down resistor at D+. This pull-up ensures that
+in self-powered designs no interrupts occur while USB is not connected. You
+may omit this resistor in bus-powered designs. Older examples had a pull-up
+resistor instead. This is not compatible with the zener diode approach to
+level conversion: 1M pull-up in conjunction with a 3.6 V zener diode give an
+invalid logic level.
+
+All examples with ATMega8/88/168 have D+ at port D bit 2 (because this is
+hardware interrupt 0) and D- on port D bit 4 because it is also a clock input
+for timer/counter 0. This way the firmware can easily check for activity on
+D- (USB frame pulses) by checking the counter value in regular intervals. If
+no activity is found, the firmware should (according to the USB
+specification) put the system into a low power suspend mode.
+
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/circuits/tiny45-rc.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/tiny45-rc.png
===================================================================
--- vusb-20121206/circuits/tiny45-rc.png	(nonexistent)
+++ vusb-20121206/circuits/tiny45-rc.png	(working copy)

Property changes on: vusb-20121206/circuits/tiny45-rc.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/tiny45-rc.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/tiny45-rc.sch
===================================================================
--- vusb-20121206/circuits/tiny45-rc.sch	(nonexistent)
+++ vusb-20121206/circuits/tiny45-rc.sch	(working copy)

Property changes on: vusb-20121206/circuits/tiny45-rc.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-series-diodes.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-series-diodes.png
===================================================================
--- vusb-20121206/circuits/with-series-diodes.png	(nonexistent)
+++ vusb-20121206/circuits/with-series-diodes.png	(working copy)

Property changes on: vusb-20121206/circuits/with-series-diodes.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-series-diodes.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-series-diodes.sch
===================================================================
--- vusb-20121206/circuits/with-series-diodes.sch	(nonexistent)
+++ vusb-20121206/circuits/with-series-diodes.sch	(working copy)

Property changes on: vusb-20121206/circuits/with-series-diodes.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-vreg.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-vreg.png
===================================================================
--- vusb-20121206/circuits/with-vreg.png	(nonexistent)
+++ vusb-20121206/circuits/with-vreg.png	(working copy)

Property changes on: vusb-20121206/circuits/with-vreg.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-vreg.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-vreg.sch
===================================================================
--- vusb-20121206/circuits/with-vreg.sch	(nonexistent)
+++ vusb-20121206/circuits/with-vreg.sch	(working copy)

Property changes on: vusb-20121206/circuits/with-vreg.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-zener.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-zener.png
===================================================================
--- vusb-20121206/circuits/with-zener.png	(nonexistent)
+++ vusb-20121206/circuits/with-zener.png	(working copy)

Property changes on: vusb-20121206/circuits/with-zener.png
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/circuits/with-zener.sch
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: vusb-20121206/circuits/with-zener.sch
===================================================================
--- vusb-20121206/circuits/with-zener.sch	(nonexistent)
+++ vusb-20121206/circuits/with-zener.sch	(working copy)

Property changes on: vusb-20121206/circuits/with-zener.sch
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: vusb-20121206/CommercialLicense.txt
===================================================================
--- vusb-20121206/CommercialLicense.txt	(nonexistent)
+++ vusb-20121206/CommercialLicense.txt	(working copy)
@@ -0,0 +1,166 @@
+V-USB Driver Software License Agreement
+Version 2012-07-09
+
+THIS LICENSE AGREEMENT GRANTS YOU CERTAIN RIGHTS IN A SOFTWARE. YOU CAN
+ENTER INTO THIS AGREEMENT AND ACQUIRE THE RIGHTS OUTLINED BELOW BY PAYING
+THE AMOUNT ACCORDING TO SECTION 4 ("PAYMENT") TO OBJECTIVE DEVELOPMENT.
+
+
+1 DEFINITIONS
+
+1.1 "OBJECTIVE DEVELOPMENT" shall mean OBJECTIVE DEVELOPMENT Software GmbH,
+Grosse Schiffgasse 1A/7, 1020 Wien, AUSTRIA.
+
+1.2 "You" shall mean the Licensee.
+
+1.3 "V-USB" shall mean all files included in the package distributed under
+the name "vusb" by OBJECTIVE DEVELOPMENT (http://www.obdev.at/vusb/)
+unless otherwise noted. This includes the firmware-only USB device
+implementation for Atmel AVR microcontrollers, some simple device examples
+and host side software examples and libraries.
+
+
+2 LICENSE GRANTS
+
+2.1 Source Code. OBJECTIVE DEVELOPMENT shall furnish you with the source
+code of V-USB.
+
+2.2 Distribution and Use. OBJECTIVE DEVELOPMENT grants you the
+non-exclusive right to use, copy and distribute V-USB with your hardware
+product(s), restricted by the limitations in section 3 below.
+
+2.3 Modifications. OBJECTIVE DEVELOPMENT grants you the right to modify
+the source code and your copy of V-USB according to your needs.
+
+2.4 USB IDs. OBJECTIVE DEVELOPMENT furnishes you with one or two USB
+Product ID(s), sent to you in e-mail. These Product IDs are reserved
+exclusively for you. OBJECTIVE DEVELOPMENT has obtained USB Product ID
+ranges under the Vendor ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under the Vendor ID 8352 from
+Jason Kotzin (now flirc.tv, Inc.). Both owners of the Vendor IDs have
+obtained these IDs from the USB Implementers Forum, Inc. (www.usb.org).
+OBJECTIVE DEVELOPMENT disclaims all liability which might arise from the
+assignment of USB IDs.
+
+2.5 USB Certification. Although not part of this agreement, we want to make
+it clear that you cannot become USB certified when you use V-USB or a USB
+Product ID assigned by OBJECTIVE DEVELOPMENT. AVR microcontrollers don't
+meet the electrical specifications required by the USB specification and
+the USB Implementers Forum certifies only members who bought a Vendor ID of
+their own.
+
+
+3 LICENSE RESTRICTIONS
+
+3.1 Number of Units. Only one of the following three definitions is
+applicable. Which one is determined by the amount you pay to OBJECTIVE
+DEVELOPMENT, see section 4 ("Payment") below.
+
+Hobby License: You may use V-USB according to section 2 above in no more
+than 5 hardware units. These units must not be sold for profit.
+
+Entry Level License: You may use V-USB according to section 2 above in no
+more than 150 hardware units.
+
+Professional License: You may use V-USB according to section 2 above in
+any number of hardware units, except for large scale production ("unlimited
+fair use"). Quantities below 10,000 units are not considered large scale
+production. If your reach quantities which are obviously large scale
+production, you must pay a license fee of 0.10 EUR per unit for all units
+above 10,000.
+
+3.2 Rental. You may not rent, lease, or lend V-USB or otherwise encumber
+any copy of V-USB, or any of the rights granted herein.
+
+3.3 Transfer. You may not transfer your rights under this Agreement to
+another party without OBJECTIVE DEVELOPMENT's prior written consent. If
+such consent is obtained, you may permanently transfer this License to
+another party. The recipient of such transfer must agree to all terms and
+conditions of this Agreement.
+
+3.4 Reservation of Rights. OBJECTIVE DEVELOPMENT retains all rights not
+expressly granted.
+
+3.5 Non-Exclusive Rights. Your license rights under this Agreement are
+non-exclusive.
+
+3.6 Third Party Rights. This Agreement cannot grant you rights controlled
+by third parties. In particular, you are not allowed to use the USB logo or
+other trademarks owned by the USB Implementers Forum, Inc. without their
+consent. Since such consent depends on USB certification, it should be
+noted that V-USB will not pass certification because it does not
+implement checksum verification and the microcontroller ports do not meet
+the electrical specifications.
+
+
+4 PAYMENT
+
+The payment amount depends on the variation of this agreement (according to
+section 3.1) into which you want to enter. Concrete prices are listed on
+OBJECTIVE DEVELOPMENT's web site, usually at
+http://www.obdev.at/vusb/license.html. You agree to pay the amount listed
+there to OBJECTIVE DEVELOPMENT or OBJECTIVE DEVELOPMENT's payment processor
+or reseller.
+
+
+5 COPYRIGHT AND OWNERSHIP
+
+V-USB is protected by copyright laws and international copyright
+treaties, as well as other intellectual property laws and treaties. V-USB
+is licensed, not sold.
+
+
+6 TERM AND TERMINATION
+
+6.1 Term. This Agreement shall continue indefinitely. However, OBJECTIVE
+DEVELOPMENT may terminate this Agreement and revoke the granted license and
+USB-IDs if you fail to comply with any of its terms and conditions.
+
+6.2 Survival of Terms. All provisions regarding secrecy, confidentiality
+and limitation of liability shall survive termination of this agreement.
+
+
+7 DISCLAIMER OF WARRANTY AND LIABILITY
+
+LIMITED WARRANTY. V-USB IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
+KIND. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, OBJECTIVE
+DEVELOPMENT AND ITS SUPPLIERS HEREBY DISCLAIM ALL WARRANTIES, EITHER
+EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND
+NON-INFRINGEMENT, WITH REGARD TO V-USB, AND THE PROVISION OF OR FAILURE
+TO PROVIDE SUPPORT SERVICES. THIS LIMITED WARRANTY GIVES YOU SPECIFIC LEGAL
+RIGHTS. YOU MAY HAVE OTHERS, WHICH VARY FROM STATE/JURISDICTION TO
+STATE/JURISDICTION.
+
+LIMITATION OF LIABILITY. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW,
+IN NO EVENT SHALL OBJECTIVE DEVELOPMENT OR ITS SUPPLIERS BE LIABLE FOR ANY
+SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER
+(INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
+BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY
+LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE V-USB OR THE
+PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES, EVEN IF OBJECTIVE
+DEVELOPMENT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY
+CASE, OBJECTIVE DEVELOPMENT'S ENTIRE LIABILITY UNDER ANY PROVISION OF THIS
+AGREEMENT SHALL BE LIMITED TO THE AMOUNT ACTUALLY PAID BY YOU FOR V-USB.
+
+
+8 MISCELLANEOUS TERMS
+
+8.1 Marketing. OBJECTIVE DEVELOPMENT has the right to mention for marketing
+purposes that you entered into this agreement.
+
+8.2 Entire Agreement. This document represents the entire agreement between
+OBJECTIVE DEVELOPMENT and you. It may only be modified in writing signed by
+an authorized representative of both, OBJECTIVE DEVELOPMENT and you.
+
+8.3 Severability. In case a provision of these terms and conditions should
+be or become partly or entirely invalid, ineffective, or not executable,
+the validity of all other provisions shall not be affected.
+
+8.4 Applicable Law. This agreement is governed by the laws of the Republic
+of Austria.
+
+8.5 Responsible Courts. The responsible courts in Vienna/Austria will have
+exclusive jurisdiction regarding all disputes in connection with this
+agreement.
+
Index: vusb-20121206/examples/Readme.txt
===================================================================
--- vusb-20121206/examples/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/Readme.txt	(working copy)
@@ -0,0 +1,102 @@
+This is the Readme file for the directory "examples" of V-USB, a firmware-
+only USB driver for AVR microcontrollers.
+
+WHAT IS IN THIS DIRECTORY?
+==========================
+This directory contains examples which are mostly for educational purposes.
+Examples can be device firmware only, host software only or both. Here is
+a summary:
+
+custom-class
+  A custom class device with host software based on libusb. It demonstrates
+  the straight forward way of sending small amounts of data to a device and
+  receiving data from the device. It does NOT demonstrate how to send large
+  amounts of data to the device or how to receive data generated on the fly
+  by the device (how to use usbFunctionWrite() and usbFunctionRead()). See
+  the hid-data example for how usbFunctionWrite() and usbFunctionRead() are
+  used.
+
+hid-custom-rq
+  This example implements the same functionality as the custom-class example
+  above, but declares the device as HID. This prevents the "give me a driver
+  CD" dialog on Windows. The device can still be controlled with libusb as in
+  the previous example (on Windows, the filter version of libusb-win32 must
+  be installed). In addition to the features presented in custom-class, this
+  example demonstrates how a HID class device is defined.
+
+hid-mouse
+  This example implements a mouse device. No host driver is required since
+  today's operating systems have drivers for USB mice built-in. It
+  demonstrates how a real-world HID class device is implemented and how
+  interrupt-in endpoints are used.
+
+hid-data
+  This example demonstrates how the HID class can be misused to transfer
+  arbitrary data over HID feature reports. This technique is of great value
+  on Windows because no driver DLLs are needed (the hid-custom-rq example
+  still requires the libusb-win32 DLL, although it may be in the program's
+  directory). The host side application requires no installation, it can
+  even be started directly from a CD. This example also demonstrates how
+  to transfer data using usbFunctionWrite() and usbFunctionRead().
+
+usbtool
+  This is a general purpose development and debugging tool for USB devices.
+  You can use it during development of your device to test various requests
+  without special test programs. But it is also an example how all the
+  libusb API functions are used.
+
+More information about each example can be found in the Readme file in the
+respective directory.
+
+Hardware dependencies of AVR code has been kept at a minimum. All examples
+should work on any AVR chip which has enough resources to run the driver.
+Makefile and usbconfig.h have been configured for the metaboard hardware (see
+http://www.obdev.at/goto.php?t=metaboard for details). Edit the target
+device, fuse values, clock rate and programmer in Makefile and the I/O pins
+dedicated to USB in usbconfig.h.
+
+
+WHAT IS NOT DEMONSTRATED IN THESE EXAMPLES?
+===========================================
+These examples show only the most basic functionality. More elaborate
+examples and real world applications showing more features of the driver are
+available at http://www.obdev.at/vusb/projects.html. Most of these
+features are described in our documentation wiki at
+http://www.obdev.at/goto.php?t=vusb-wiki.
+
+To mention just a few:
+
+Using RC oscillator for system clock
+  The 12.8 MHz and 16.5 MHz modules of V-USB have been designed to cope
+  with clock rate deviations up to 1%. This allows an RC oscillator to be
+  used. Since the AVR's RC oscillator has a factory precision of only 10%,
+  it must be calibrated to an external reference. The EasyLogger example
+  shows how this can be done.
+
+Dynamically generated descriptors
+  Sometimes you want to implement different typtes of USB device depending
+  on a jumper or other condition. V-USB has a very flexible interface for
+  providing USB descriptors. See AVR-Doper for how to provide descriptors
+  at runtime.
+
+Virtual COM port
+  Some people prefer a virtual serial interface to communicate with their
+  device. We strongly discourage this method because it does things
+  forbidden by the USB specification. If you still want to go this route,
+  see AVR-CDC.
+
+Implementing suspend mode
+  V-USB does not implement suspend mode. This means that the device does
+  not reduce power consumption when the host goes into sleep mode. Device
+  firmware is free to implement suspend mode, though. See USB2LPT for an
+  example.
+
+The projects mentioned above can best be found on
+
+    http://www.obdev.at/vusb/prjall.html
+
+where all projects are listed.
+
+----------------------------------------------------------------------------
+(c) 2009 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/custom-class/Readme.txt
===================================================================
--- vusb-20121206/examples/custom-class/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/custom-class/Readme.txt	(working copy)
@@ -0,0 +1,64 @@
+This is the Readme file for the custom-class example. In this example, we
+show how an LED can be controlled via USB.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example shows how small amounts of data (several bytes) can be
+transferred between the device and the host. In addition to a very basic
+USB device, it demonstrates how to build a host side driver application
+using libusb or libusb-win32. It does NOT show how usbFunctionWrite() and
+usbFunctionRead() are used. See the hid-data example if you want to learn
+about these functions.
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+Host development environment: A C compiler and libusb. See the top level
+Readme file, section Prerequisites for more information.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware. You should have wired an LED with a
+current limiting resistor of ca. 270 Ohm to a free I/O pin. Change the
+defines in main.c to match the port and bit number.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+BUILDING THE HOST SOFTWARE
+==========================
+Since the host software is based on libusb or libusb-win32, make sure that
+this library is installed. On Unix, ensure that libusb-config is in your
+search PATH. On Windows, edit Makefile.windows and set the library path
+appropriately. Then type "make" on Unix or "make -f Makefile.windows" on
+Windows to build the command line tool.
+
+
+USING THE COMMAND LINE TOOL
+===========================
+The command line tool has three valid arguments: "status" to query the
+current LED status, "on" to turn on the LED and "off" to turn it off.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/custom-class/commandline/Makefile
===================================================================
--- vusb-20121206/examples/custom-class/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = set-led
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/custom-class/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/custom-class/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/custom-class/commandline/opendevice.c
===================================================================
--- vusb-20121206/examples/custom-class/commandline/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/custom-class/commandline/opendevice.h
===================================================================
--- vusb-20121206/examples/custom-class/commandline/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/custom-class/commandline/set-led.c
===================================================================
--- vusb-20121206/examples/custom-class/commandline/set-led.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/set-led.c	(working copy)
@@ -0,0 +1,134 @@
+/* Name: set-led.c
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This is the host-side driver for the custom-class example device. It searches
+the USB for the LEDControl device and sends the requests understood by this
+device.
+This program must be linked with libusb on Unix and libusb-win32 on Windows.
+See http://libusb.sourceforge.net/ or http://libusb-win32.sourceforge.net/
+respectively.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <usb.h>        /* this is libusb */
+#include "opendevice.h" /* common code moved to separate module */
+
+#include "../firmware/requests.h"   /* custom request numbers */
+#include "../firmware/usbconfig.h"  /* device's VID/PID and names */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s on ....... turn on LED\n", name);
+    fprintf(stderr, "  %s off ...... turn off LED\n", name);
+    fprintf(stderr, "  %s status ... ask current status of LED\n", name);
+#if ENABLE_TEST
+    fprintf(stderr, "  %s test ..... run driver reliability test\n", name);
+#endif /* ENABLE_TEST */
+}
+
+int main(int argc, char **argv)
+{
+usb_dev_handle      *handle = NULL;
+const unsigned char rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char                vendor[] = {USB_CFG_VENDOR_NAME, 0}, product[] = {USB_CFG_DEVICE_NAME, 0};
+char                buffer[4];
+int                 cnt, vid, pid, isOn;
+
+    usb_init();
+    if(argc < 2){   /* we need at least one argument */
+        usage(argv[0]);
+        exit(1);
+    }
+    /* compute VID/PID from usbconfig.h so that there is a central source of information */
+    vid = rawVid[1] * 256 + rawVid[0];
+    pid = rawPid[1] * 256 + rawPid[0];
+    /* The following function is in opendevice.c: */
+    if(usbOpenDevice(&handle, vid, vendor, pid, product, NULL, NULL, NULL) != 0){
+        fprintf(stderr, "Could not find USB device \"%s\" with vid=0x%x pid=0x%x\n", product, vid, pid);
+        exit(1);
+    }
+    /* Since we use only control endpoint 0, we don't need to choose a
+     * configuration and interface. Reading device descriptor and setting a
+     * configuration and interface is done through endpoint 0 after all.
+     * However, newer versions of Linux require that we claim an interface
+     * even for endpoint 0. Enable the following code if your operating system
+     * needs it: */
+#if 0
+    int retries = 1, usbConfiguration = 1, usbInterface = 0;
+    if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+        fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+    }
+    /* now try to claim the interface and detach the kernel HID driver on
+     * Linux and other operating systems which support the call. */
+    while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+        if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+            fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+        }
+#endif
+    }
+#endif
+
+    if(strcasecmp(argv[1], "status") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_GET_STATUS, 0, 0, buffer, sizeof(buffer), 5000);
+        if(cnt < 1){
+            if(cnt < 0){
+                fprintf(stderr, "USB error: %s\n", usb_strerror());
+            }else{
+                fprintf(stderr, "only %d bytes received.\n", cnt);
+            }
+        }else{
+            printf("LED is %s\n", buffer[0] ? "on" : "off");
+        }
+    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
+        if(cnt < 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+#if ENABLE_TEST
+    }else if(strcasecmp(argv[1], "test") == 0){
+        int i;
+        srandomdev();
+        for(i = 0; i < 50000; i++){
+            int value = random() & 0xffff, index = random() & 0xffff;
+            int rxValue, rxIndex;
+            if((i+1) % 100 == 0){
+                fprintf(stderr, "\r%05d", i+1);
+                fflush(stderr);
+            }
+            cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_ECHO, value, index, buffer, sizeof(buffer), 5000);
+            if(cnt < 0){
+                fprintf(stderr, "\nUSB error in iteration %d: %s\n", i, usb_strerror());
+                break;
+            }else if(cnt != 4){
+                fprintf(stderr, "\nerror in iteration %d: %d bytes received instead of 4\n", i, cnt);
+                break;
+            }
+            rxValue = ((int)buffer[0] & 0xff) | (((int)buffer[1] & 0xff) << 8);
+            rxIndex = ((int)buffer[2] & 0xff) | (((int)buffer[3] & 0xff) << 8);
+            if(rxValue != value || rxIndex != index){
+                fprintf(stderr, "\ndata error in iteration %d:\n", i);
+                fprintf(stderr, "rxValue = 0x%04x value = 0x%04x\n", rxValue, value);
+                fprintf(stderr, "rxIndex = 0x%04x index = 0x%04x\n", rxIndex, index);
+            }
+        }
+        fprintf(stderr, "\nTest completed.\n");
+#endif /* ENABLE_TEST */
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usb_close(handle);
+    return 0;
+}
Index: vusb-20121206/examples/custom-class/firmware/Makefile
===================================================================
--- vusb-20121206/examples/custom-class/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/custom-class/firmware/main.c
===================================================================
--- vusb-20121206/examples/custom-class/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/main.c	(working copy)
@@ -0,0 +1,96 @@
+/* Name: main.c
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+We assume that an LED is connected to port B bit 0. If you connect it to a
+different port or bit, change the macros below:
+*/
+#define LED_PORT_DDR        DDRB
+#define LED_PORT_OUTPUT     PORTB
+#define LED_BIT             0
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+#include "requests.h"       /* The custom request numbers we use */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+static uchar    dataBuffer[4];  /* buffer must stay valid when usbFunctionSetup returns */
+
+    if(rq->bRequest == CUSTOM_RQ_ECHO){ /* echo -- used for reliability tests */
+        dataBuffer[0] = rq->wValue.bytes[0];
+        dataBuffer[1] = rq->wValue.bytes[1];
+        dataBuffer[2] = rq->wIndex.bytes[0];
+        dataBuffer[3] = rq->wIndex.bytes[1];
+        usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+        return 4;
+    }else if(rq->bRequest == CUSTOM_RQ_SET_STATUS){
+        if(rq->wValue.bytes[0] & 1){    /* set LED */
+            LED_PORT_OUTPUT |= _BV(LED_BIT);
+        }else{                          /* clear LED */
+            LED_PORT_OUTPUT &= ~_BV(LED_BIT);
+        }
+    }else if(rq->bRequest == CUSTOM_RQ_GET_STATUS){
+        dataBuffer[0] = ((LED_PORT_OUTPUT & _BV(LED_BIT)) != 0);
+        usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+        return 1;                       /* tell the driver to send 1 byte */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    LED_PORT_DDR |= _BV(LED_BIT);   /* make the LED bit an output */
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/custom-class/firmware/requests.h
===================================================================
--- vusb-20121206/examples/custom-class/firmware/requests.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/requests.h	(working copy)
@@ -0,0 +1,35 @@
+/* Name: requests.h
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* This header is shared between the firmware and the host software. It
+ * defines the USB request numbers (and optionally data types) used to
+ * communicate between the host and the device.
+ */
+
+#ifndef __REQUESTS_H_INCLUDED__
+#define __REQUESTS_H_INCLUDED__
+
+#define CUSTOM_RQ_ECHO          0
+/* Request that the device sends back wValue and wIndex. This is used with
+ * random data to test the reliability of the communication.
+ */
+#define CUSTOM_RQ_SET_STATUS    1
+/* Set the LED status. Control-OUT.
+ * The requested status is passed in the "wValue" field of the control
+ * transfer. No OUT data is sent. Bit 0 of the low byte of wValue controls
+ * the LED.
+ */
+
+#define CUSTOM_RQ_GET_STATUS    2
+/* Get the current LED status. Control-IN.
+ * This control transfer involves a 1 byte data phase where the device sends
+ * the current status to the host. The status is in bit 0 of the byte.
+ */
+
+#endif /* __REQUESTS_H_INCLUDED__ */
Index: vusb-20121206/examples/custom-class/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/custom-class/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    0
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdc, 0x05 /* = 0x05dc = 1500 */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'L', 'E', 'D', 'C', 'o', 'n', 't', 'r', 'o', 'l'
+#define USB_CFG_DEVICE_NAME_LEN 10
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-custom-rq/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-custom-rq/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/Readme.txt	(working copy)
@@ -0,0 +1,28 @@
+This is the Readme file for the hid-custom-rq example. This is basically the
+same as the custom-class example, except that the device conforms to the USB
+HID class.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how custom requests can be sent to devices which
+are otherwise HID compliant. This mechanism can be used to prevent the
+"driver CD" dialog on Windows and still control the device with libusb-win32.
+It can also be used to extend the functionality of the USB class, e.g. by
+setting parameters.
+
+Please note that you should install the filter version of libusb-win32 to
+take full advantage or this mode. The device driver version only has access
+to devices which have been registered for it with a *.inf file. The filter
+version has access to all devices.
+
+
+MORE INFORMATION
+================
+For information about how to build this example and how to use the command
+line tool see the Readme file in the custom-class example.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-custom-rq/commandline/Makefile
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = set-led
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-custom-rq/commandline/set-led.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/set-led.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/set-led.c	(working copy)
@@ -0,0 +1,134 @@
+/* Name: set-led.c
+ * Project: hid-custom-rq example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This is the host-side driver for the custom-class example device. It searches
+the USB for the LEDControl device and sends the requests understood by this
+device.
+This program must be linked with libusb on Unix and libusb-win32 on Windows.
+See http://libusb.sourceforge.net/ or http://libusb-win32.sourceforge.net/
+respectively.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <usb.h>        /* this is libusb */
+#include "opendevice.h" /* common code moved to separate module */
+
+#include "../firmware/requests.h"   /* custom request numbers */
+#include "../firmware/usbconfig.h"  /* device's VID/PID and names */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s on ....... turn on LED\n", name);
+    fprintf(stderr, "  %s off ...... turn off LED\n", name);
+    fprintf(stderr, "  %s status ... ask current status of LED\n", name);
+#if ENABLE_TEST
+    fprintf(stderr, "  %s test ..... run driver reliability test\n", name);
+#endif /* ENABLE_TEST */
+}
+
+int main(int argc, char **argv)
+{
+usb_dev_handle      *handle = NULL;
+const unsigned char rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char                vendor[] = {USB_CFG_VENDOR_NAME, 0}, product[] = {USB_CFG_DEVICE_NAME, 0};
+char                buffer[4];
+int                 cnt, vid, pid, isOn;
+
+    usb_init();
+    if(argc < 2){   /* we need at least one argument */
+        usage(argv[0]);
+        exit(1);
+    }
+    /* compute VID/PID from usbconfig.h so that there is a central source of information */
+    vid = rawVid[1] * 256 + rawVid[0];
+    pid = rawPid[1] * 256 + rawPid[0];
+    /* The following function is in opendevice.c: */
+    if(usbOpenDevice(&handle, vid, vendor, pid, product, NULL, NULL, NULL) != 0){
+        fprintf(stderr, "Could not find USB device \"%s\" with vid=0x%x pid=0x%x\n", product, vid, pid);
+        exit(1);
+    }
+    /* Since we use only control endpoint 0, we don't need to choose a
+     * configuration and interface. Reading device descriptor and setting a
+     * configuration and interface is done through endpoint 0 after all.
+     * However, newer versions of Linux require that we claim an interface
+     * even for endpoint 0. Enable the following code if your operating system
+     * needs it: */
+#if 0
+    int retries = 1, usbConfiguration = 1, usbInterface = 0;
+    if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+        fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+    }
+    /* now try to claim the interface and detach the kernel HID driver on
+     * Linux and other operating systems which support the call. */
+    while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+        if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+            fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+        }
+#endif
+    }
+#endif
+
+    if(strcasecmp(argv[1], "status") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_GET_STATUS, 0, 0, buffer, sizeof(buffer), 5000);
+        if(cnt < 1){
+            if(cnt < 0){
+                fprintf(stderr, "USB error: %s\n", usb_strerror());
+            }else{
+                fprintf(stderr, "only %d bytes received.\n", cnt);
+            }
+        }else{
+            printf("LED is %s\n", buffer[0] ? "on" : "off");
+        }
+    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
+        if(cnt < 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+#if ENABLE_TEST
+    }else if(strcasecmp(argv[1], "test") == 0){
+        int i;
+        srandomdev();
+        for(i = 0; i < 50000; i++){
+            int value = random() & 0xffff, index = random() & 0xffff;
+            int rxValue, rxIndex;
+            if((i+1) % 100 == 0){
+                fprintf(stderr, "\r%05d", i+1);
+                fflush(stderr);
+            }
+            cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_ECHO, value, index, buffer, sizeof(buffer), 5000);
+            if(cnt < 0){
+                fprintf(stderr, "\nUSB error in iteration %d: %s\n", i, usb_strerror());
+                break;
+            }else if(cnt != 4){
+                fprintf(stderr, "\nerror in iteration %d: %d bytes received instead of 4\n", i, cnt);
+                break;
+            }
+            rxValue = ((int)buffer[0] & 0xff) | (((int)buffer[1] & 0xff) << 8);
+            rxIndex = ((int)buffer[2] & 0xff) | (((int)buffer[3] & 0xff) << 8);
+            if(rxValue != value || rxIndex != index){
+                fprintf(stderr, "\ndata error in iteration %d:\n", i);
+                fprintf(stderr, "rxValue = 0x%04x value = 0x%04x\n", rxValue, value);
+                fprintf(stderr, "rxIndex = 0x%04x index = 0x%04x\n", rxIndex, index);
+            }
+        }
+        fprintf(stderr, "\nTest completed.\n");
+#endif /* ENABLE_TEST */
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usb_close(handle);
+    return 0;
+}
Index: vusb-20121206/examples/hid-custom-rq/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-custom-rq/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/main.c	(working copy)
@@ -0,0 +1,119 @@
+/* Name: main.c
+ * Project: hid-custom-rq example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-07
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+We assume that an LED is connected to port B bit 0. If you connect it to a
+different port or bit, change the macros below:
+*/
+#define LED_PORT_DDR        DDRB
+#define LED_PORT_OUTPUT     PORTB
+#define LED_BIT             0
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+#include "requests.h"       /* The custom request numbers we use */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[22] = {   /* USB report descriptor */
+    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
+    0x09, 0x01,                    // USAGE (Vendor Usage 1)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x09, 0x00,                    //   USAGE (Undefined)
+    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)
+    0xc0                           // END_COLLECTION
+};
+/* The descriptor above is a dummy only, it silences the drivers. The report
+ * it describes consists of one byte of undefined data.
+ * We don't transfer our data through HID reports, we use custom requests
+ * instead.
+ */
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_VENDOR){
+        DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
+        if(rq->bRequest == CUSTOM_RQ_SET_STATUS){
+            if(rq->wValue.bytes[0] & 1){    /* set LED */
+                LED_PORT_OUTPUT |= _BV(LED_BIT);
+            }else{                          /* clear LED */
+                LED_PORT_OUTPUT &= ~_BV(LED_BIT);
+            }
+        }else if(rq->bRequest == CUSTOM_RQ_GET_STATUS){
+            static uchar dataBuffer[1];     /* buffer must stay valid when usbFunctionSetup returns */
+            dataBuffer[0] = ((LED_PORT_OUTPUT & _BV(LED_BIT)) != 0);
+            usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+            return 1;                       /* tell the driver to send 1 byte */
+        }
+    }else{
+        /* calss requests USBRQ_HID_GET_REPORT and USBRQ_HID_SET_REPORT are
+         * not implemented since we never call them. The operating system
+         * won't call them either because our descriptor defines no meaning.
+         */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    LED_PORT_DDR |= _BV(LED_BIT);   /* make the LED bit an output */
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+#if 0   /* this is a bit too aggressive for a debug output */
+        DBG2(0x02, 0, 0);   /* debug output: main loop iterates */
+#endif
+        wdt_reset();
+        usbPoll();
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-custom-rq/firmware/requests.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/requests.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/requests.h	(working copy)
@@ -0,0 +1,31 @@
+/* Name: requests.h
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* This header is shared between the firmware and the host software. It
+ * defines the USB request numbers (and optionally data types) used to
+ * communicate between the host and the device.
+ */
+
+#ifndef __REQUESTS_H_INCLUDED__
+#define __REQUESTS_H_INCLUDED__
+
+#define CUSTOM_RQ_SET_STATUS    1
+/* Set the LED status. Control-OUT.
+ * The requested status is passed in the "wValue" field of the control
+ * transfer. No OUT data is sent. Bit 0 of the low byte of wValue controls
+ * the LED.
+ */
+
+#define CUSTOM_RQ_GET_STATUS    2
+/* Get the current LED status. Control-IN.
+ * This control transfer involves a 1 byte data phase where the device sends
+ * the current status to the host. The status is in bit 0 of the byte.
+ */
+
+#endif /* __REQUESTS_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdf, 0x05 /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'L', 'E', 'D', 'C', 't', 'l', 'H', 'I', 'D'
+#define USB_CFG_DEVICE_NAME_LEN 9
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    22
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-data/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-data/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-data/Readme.txt	(working copy)
@@ -0,0 +1,75 @@
+This is the Readme file for the hid-data example. In this example, we show
+how blocks of data can be exchanged with the device using only functionality
+compliant to the HID class. Since class drivers for HID are included with
+Windows, you don't need to install drivers on Windows.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how the HID class can be misused to transfer fixed
+size blocks of data (up to the driver's transfer size limit) over HID feature
+reports. This technique is of great value on Windows because no driver DLLs
+are needed (the hid-custom-rq example still requires the libusb-win32 DLL,
+although it may be in the program's directory). The host side application
+requires no installation, it can even be started directly from a CD. This
+example also demonstrates how to transfer data using usbFunctionWrite() and
+usbFunctionRead().
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+Host development environment: A C compiler and libusb on Unix. On Windows
+you need the Driver Development Kit (DDK) Instead of libusb. MinGW ships
+with a free version of the DDK.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+BUILDING THE HOST SOFTWARE
+==========================
+Make sure that you have libusb (on Unix) or the DDK (on Windows) installed.
+We recommend MinGW on Windows since it includes a free version of the DDK.
+Then change to directory "commandline" and run "make" on Unix or
+"make -f Makefile.windows" on Windows.
+
+
+USING THE COMMAND LINE TOOL
+===========================
+The device implements a data store of 128 bytes in EEPROM. You can send a
+block of 128 bytes to the device or read the block using the command line
+tool.
+
+To send a block to the device, use e.g.
+
+    hidtool write 0x01,0x02,0x03,0x04,...
+
+and to receive the block, use
+
+    hidtool read
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-data/commandline/Makefile
===================================================================
--- vusb-20121206/examples/hid-data/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/Makefile	(working copy)
@@ -0,0 +1,41 @@
+# Name: Makefile
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-11
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# Please read the definitions below and edit them as appropriate for your
+# system:
+
+# Use the following 3 lines on Unix and Mac OS X:
+USBFLAGS=   `libusb-config --cflags`
+USBLIBS=    `libusb-config --libs`
+EXE_SUFFIX=
+
+# Use the following 3 lines on Windows and comment out the 3 above:
+#USBFLAGS=
+#USBLIBS=    -lhid -lusb -lsetupapi
+#EXE_SUFFIX= .exe
+
+CC=				gcc
+CFLAGS=			-O -Wall $(USBFLAGS)
+LIBS=			$(USBLIBS)
+
+OBJ=		hidtool.o hiddata.o
+PROGRAM=	hidtool$(EXE_SUFFIX)
+
+all: $(PROGRAM)
+
+$(PROGRAM): $(OBJ)
+	$(CC) -o $(PROGRAM) $(OBJ) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f $(OBJ) $(PROGRAM)
+
+.c.o:
+	$(CC) $(ARCH_COMPILE) $(CFLAGS) -c $*.c -o $*.o
Index: vusb-20121206/examples/hid-data/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/hid-data/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-11
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS=
+USBLIBS=    -lhid -lsetupapi
+EXE_SUFFIX= .exe
Index: vusb-20121206/examples/hid-data/commandline/hiddata.c
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hiddata.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hiddata.c	(working copy)
@@ -0,0 +1,323 @@
+/* Name: hiddata.c
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include "hiddata.h"
+
+/* ######################################################################## */
+#if defined(WIN32) /* ##################################################### */
+/* ######################################################################## */
+
+#include <windows.h>
+#include <setupapi.h>
+#include "hidsdi.h"
+#include <ddk/hidpi.h>
+
+#ifdef DEBUG
+#define DEBUG_PRINT(arg)    printf arg
+#else
+#define DEBUG_PRINT(arg)
+#endif
+
+/* ------------------------------------------------------------------------ */
+
+static void convertUniToAscii(char *buffer)
+{
+unsigned short  *uni = (void *)buffer;
+char            *ascii = buffer;
+
+    while(*uni != 0){
+        if(*uni >= 256){
+            *ascii++ = '?';
+        }else{
+            *ascii++ = *uni++;
+        }
+    }
+    *ascii++ = 0;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int usesReportIDs)
+{
+GUID                                hidGuid;        /* GUID for HID driver */
+HDEVINFO                            deviceInfoList;
+SP_DEVICE_INTERFACE_DATA            deviceInfo;
+SP_DEVICE_INTERFACE_DETAIL_DATA     *deviceDetails = NULL;
+DWORD                               size;
+int                                 i, openFlag = 0;  /* may be FILE_FLAG_OVERLAPPED */
+int                                 errorCode = USBOPEN_ERR_NOTFOUND;
+HANDLE                              handle = INVALID_HANDLE_VALUE;
+HIDD_ATTRIBUTES                     deviceAttributes;
+				
+    HidD_GetHidGuid(&hidGuid);
+    deviceInfoList = SetupDiGetClassDevs(&hidGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
+    deviceInfo.cbSize = sizeof(deviceInfo);
+    for(i=0;;i++){
+        if(handle != INVALID_HANDLE_VALUE){
+            CloseHandle(handle);
+            handle = INVALID_HANDLE_VALUE;
+        }
+        if(!SetupDiEnumDeviceInterfaces(deviceInfoList, 0, &hidGuid, i, &deviceInfo))
+            break;  /* no more entries */
+        /* first do a dummy call just to determine the actual size required */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, NULL, 0, &size, NULL);
+        if(deviceDetails != NULL)
+            free(deviceDetails);
+        deviceDetails = malloc(size);
+        deviceDetails->cbSize = sizeof(*deviceDetails);
+        /* this call is for real: */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, deviceDetails, size, &size, NULL);
+        DEBUG_PRINT(("checking HID path \"%s\"\n", deviceDetails->DevicePath));
+#if 0
+        /* If we want to access a mouse our keyboard, we can only use feature
+         * requests as the device is locked by Windows. It must be opened
+         * with ACCESS_TYPE_NONE.
+         */
+        handle = CreateFile(deviceDetails->DevicePath, ACCESS_TYPE_NONE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+#endif
+        /* attempt opening for R/W -- we don't care about devices which can't be accessed */
+        handle = CreateFile(deviceDetails->DevicePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+        if(handle == INVALID_HANDLE_VALUE){
+            DEBUG_PRINT(("opening failed: %d\n", (int)GetLastError()));
+            /* errorCode = USBOPEN_ERR_ACCESS; opening will always fail for mouse -- ignore */
+            continue;
+        }
+        deviceAttributes.Size = sizeof(deviceAttributes);
+        HidD_GetAttributes(handle, &deviceAttributes);
+        DEBUG_PRINT(("device attributes: vid=%d pid=%d\n", deviceAttributes.VendorID, deviceAttributes.ProductID));
+        if(deviceAttributes.VendorID != vendor || deviceAttributes.ProductID != product)
+            continue;   /* ignore this device */
+        errorCode = USBOPEN_ERR_NOTFOUND;
+        if(vendorName != NULL && productName != NULL){
+            char    buffer[512];
+            if(!HidD_GetManufacturerString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining vendor name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("vendorName = \"%s\"\n", buffer));
+            if(strcmp(vendorName, buffer) != 0)
+                continue;
+            if(!HidD_GetProductString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining product name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("productName = \"%s\"\n", buffer));
+            if(strcmp(productName, buffer) != 0)
+                continue;
+        }
+        break;  /* we have found the device we are looking for! */
+    }
+    SetupDiDestroyDeviceInfoList(deviceInfoList);
+    if(deviceDetails != NULL)
+        free(deviceDetails);
+    if(handle != INVALID_HANDLE_VALUE){
+        *device = (usbDevice_t *)handle;
+        errorCode = 0;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------ */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    CloseHandle((HANDLE)device);
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+BOOLEAN rval;
+
+    rval = HidD_SetFeature((HANDLE)device, buffer, len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+BOOLEAN rval = 0;
+
+    buffer[0] = reportNumber;
+    rval = HidD_GetFeature((HANDLE)device, buffer, *len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+/* ######################################################################## */
+#else /* defined WIN32 #################################################### */
+/* ######################################################################## */
+
+#include <string.h>
+#include <usb.h>
+
+#define usbDevice   usb_dev_handle  /* use libusb's device structure */
+
+/* ------------------------------------------------------------------------- */
+
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_SET_REPORT    0x09
+
+#define USB_HID_REPORT_TYPE_FEATURE 3
+
+
+static int  usesReportIDs;
+
+/* ------------------------------------------------------------------------- */
+
+static int usbhidGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int _usesReportIDs)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+static int          didUsbInit = 0;
+
+    if(!didUsbInit){
+        usb_init();
+        didUsbInit = 1;
+    }
+    usb_find_busses();
+    usb_find_devices();
+    for(bus=usb_get_busses(); bus; bus=bus->next){
+        for(dev=bus->devices; dev; dev=dev->next){
+            if(dev->descriptor.idVendor == vendor && dev->descriptor.idProduct == product){
+                char    string[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    fprintf(stderr, "Warning: cannot open USB device: %s\n", usb_strerror());
+                    continue;
+                }
+                if(vendorName == NULL && productName == NULL){  /* name does not matter */
+                    break;
+                }
+                /* now check whether the names match: */
+                len = usbhidGetStringAscii(handle, dev->descriptor.iManufacturer, string, sizeof(string));
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_IO;
+                    fprintf(stderr, "Warning: cannot query manufacturer for device: %s\n", usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* fprintf(stderr, "seen device from vendor ->%s<-\n", string); */
+                    if(strcmp(string, vendorName) == 0){
+                        len = usbhidGetStringAscii(handle, dev->descriptor.iProduct, string, sizeof(string));
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_IO;
+                            fprintf(stderr, "Warning: cannot query product for device: %s\n", usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* fprintf(stderr, "seen product ->%s<-\n", string); */
+                            if(strcmp(string, productName) == 0)
+                                break;
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = (void *)handle;
+        usesReportIDs = _usesReportIDs;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    if(device != NULL)
+        usb_close((void *)device);
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+int bytesSent, reportId = buffer[0];
+
+    if(!usesReportIDs){
+        buffer++;   /* skip dummy report ID */
+        len--;
+    }
+    bytesSent = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, USBRQ_HID_SET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | (reportId & 0xff), 0, buffer, len, 5000);
+    if(bytesSent != len){
+        if(bytesSent < 0)
+            fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+int bytesReceived, maxLen = *len;
+
+    if(!usesReportIDs){
+        buffer++;   /* make room for dummy report ID */
+        maxLen--;
+    }
+    bytesReceived = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_IN, USBRQ_HID_GET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | reportNumber, 0, buffer, maxLen, 5000);
+    if(bytesReceived < 0){
+        fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    *len = bytesReceived;
+    if(!usesReportIDs){
+        buffer[-1] = reportNumber;  /* add dummy report ID */
+        (*len)++;
+    }
+    return 0;
+}
+
+/* ######################################################################## */
+#endif /* defined WIN32 ################################################### */
+/* ######################################################################## */
Index: vusb-20121206/examples/hid-data/commandline/hiddata.h
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hiddata.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hiddata.h	(working copy)
@@ -0,0 +1,70 @@
+/* Name: hiddata.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __HIDDATA_H_INCLUDED__
+#define __HIDDATA_H_INCLUDED__
+
+/*
+General Description:
+This module implements an abstraction layer for data transfer over HID feature
+requests. The implementation uses native Windows functions on Windows so that
+no driver installation is required and libusb on Unix. You must link the
+appropriate libraries in either case: "-lhid -lusb -lsetupapi" on Windows and
+`libusb-config --libs` on Unix.
+*/
+
+/* ------------------------------------------------------------------------ */
+
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+/* ------------------------------------------------------------------------ */
+
+typedef struct usbDevice    usbDevice_t;
+/* Opaque data type representing the USB device. This can be a Windows handle
+ * or a libusb handle, depending on the backend implementation.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidOpenDevice(usbDevice_t **device, int vendorID, char *vendorName, int productID, char *productName, int usesReportIDs);
+/* This function opens a USB device. 'vendorID' and 'productID' are the numeric
+ * Vendor-ID and Product-ID of the device we want to open. If 'vendorName' and
+ * 'productName' are both not NULL, only devices with matching manufacturer-
+ * and product name strings are accepted. If the device uses report IDs,
+ * 'usesReportIDs' must be set to a non-zero value.
+ * Returns: If a matching device has been found, USBOPEN_SUCCESS is returned
+ * and '*device' is set to an opaque pointer representing the device. The
+ * device must be closed with usbhidCloseDevice(). If the device has not been
+ * found or opening failed, an error code is returned.
+ */
+void    usbhidCloseDevice(usbDevice_t *device);
+/* Every device opened with usbhidOpenDevice() must be closed with this function.
+ */
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len);
+/* This function sends a feature report to the device. The report ID must be
+ * in the first byte of buffer and the length 'len' of the report is specified
+ * including this report ID. If no report IDs are used, buffer[0] must be set
+ * to 0 (dummy report ID).
+ * Returns: 0 on success, an error code otherwise.
+ */
+int usbhidGetReport(usbDevice_t *device, int reportID, char *buffer, int *len);
+/* This function obtains a feature report from the device. The requested
+ * report-ID is passed in 'reportID'. The caller must pass a buffer of the size
+ * of the expected report in 'buffer' and initialize the variable pointed to by
+ * 'len' to the total size of this buffer. Upon successful return, the report
+ * (prefixed with the report-ID) is in 'buffer' and the actual length of the
+ * report is returned in '*len'.
+ * Returns: 0 on success, an error code otherwise.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+#endif /* __HIDDATA_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-data/commandline/hidsdi.h
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hidsdi.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hidsdi.h	(working copy)
@@ -0,0 +1,48 @@
+/* Name: hidsdi.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-02-02
+ * Tabsize: 4
+ * Copyright: (c) 2006-2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description
+This file is a replacement for hidsdi.h from the Windows DDK. It defines some
+of the types and function prototypes of this header for our project. If you
+have the Windows DDK version of this file or a version shipped with MinGW, use
+that instead.
+*/
+
+#ifndef _HIDSDI_H
+#define _HIDSDI_H
+
+#include <pshpack4.h>
+
+#include <ddk/hidusage.h>
+#include <ddk/hidpi.h>
+
+typedef struct{
+    ULONG   Size;
+    USHORT  VendorID;
+    USHORT  ProductID;
+    USHORT  VersionNumber;
+}HIDD_ATTRIBUTES;
+
+void __stdcall      HidD_GetHidGuid(OUT LPGUID hidGuid);
+
+BOOLEAN __stdcall   HidD_GetAttributes(IN HANDLE device, OUT HIDD_ATTRIBUTES *attributes);
+
+BOOLEAN __stdcall   HidD_GetManufacturerString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetProductString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetSerialNumberString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetFeature(IN HANDLE device, OUT void *reportBuffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_SetFeature(IN HANDLE device, IN void *reportBuffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetNumInputBuffers(IN HANDLE device, OUT ULONG *numBuffers);
+BOOLEAN __stdcall   HidD_SetNumInputBuffers(IN HANDLE device, OUT ULONG numBuffers);
+
+#include <poppack.h>
+
+#endif
Index: vusb-20121206/examples/hid-data/commandline/hidtool.c
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hidtool.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hidtool.c	(working copy)
@@ -0,0 +1,126 @@
+/* Name: hidtool.c
+ * Project: hid-data example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "hiddata.h"
+#include "../firmware/usbconfig.h"  /* for device VID, PID, vendor name and product name */
+
+/* ------------------------------------------------------------------------- */
+
+static char *usbErrorMessage(int errCode)
+{
+static char buffer[80];
+
+    switch(errCode){
+        case USBOPEN_ERR_ACCESS:      return "Access to device denied";
+        case USBOPEN_ERR_NOTFOUND:    return "The specified device was not found";
+        case USBOPEN_ERR_IO:          return "Communication error with device";
+        default:
+            sprintf(buffer, "Unknown USB error %d", errCode);
+            return buffer;
+    }
+    return NULL;    /* not reached */
+}
+
+static usbDevice_t  *openDevice(void)
+{
+usbDevice_t     *dev = NULL;
+unsigned char   rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char            vendorName[] = {USB_CFG_VENDOR_NAME, 0}, productName[] = {USB_CFG_DEVICE_NAME, 0};
+int             vid = rawVid[0] + 256 * rawVid[1];
+int             pid = rawPid[0] + 256 * rawPid[1];
+int             err;
+
+    if((err = usbhidOpenDevice(&dev, vid, vendorName, pid, productName, 0)) != 0){
+        fprintf(stderr, "error finding %s: %s\n", productName, usbErrorMessage(err));
+        return NULL;
+    }
+    return dev;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void hexdump(char *buffer, int len)
+{
+int     i;
+FILE    *fp = stdout;
+
+    for(i = 0; i < len; i++){
+        if(i != 0){
+            if(i % 16 == 0){
+                fprintf(fp, "\n");
+            }else{
+                fprintf(fp, " ");
+            }
+        }
+        fprintf(fp, "0x%02x", buffer[i] & 0xff);
+    }
+    if(i != 0)
+        fprintf(fp, "\n");
+}
+
+static int  hexread(char *buffer, char *string, int buflen)
+{
+char    *s;
+int     pos = 0;
+
+    while((s = strtok(string, ", ")) != NULL && pos < buflen){
+        string = NULL;
+        buffer[pos++] = (char)strtol(s, NULL, 0);
+    }
+    return pos;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void usage(char *myName)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s read\n", myName);
+    fprintf(stderr, "  %s write <listofbytes>\n", myName);
+}
+
+int main(int argc, char **argv)
+{
+usbDevice_t *dev;
+char        buffer[129];    /* room for dummy report ID */
+int         err;
+
+    if(argc < 2){
+        usage(argv[0]);
+        exit(1);
+    }
+    if((dev = openDevice()) == NULL)
+        exit(1);
+    if(strcasecmp(argv[1], "read") == 0){
+        int len = sizeof(buffer);
+        if((err = usbhidGetReport(dev, 0, buffer, &len)) != 0){
+            fprintf(stderr, "error reading data: %s\n", usbErrorMessage(err));
+        }else{
+            hexdump(buffer + 1, sizeof(buffer) - 1);
+        }
+    }else if(strcasecmp(argv[1], "write") == 0){
+        int i, pos;
+        memset(buffer, 0, sizeof(buffer));
+        for(pos = 1, i = 2; i < argc && pos < sizeof(buffer); i++){
+            pos += hexread(buffer + pos, argv[i], sizeof(buffer) - pos);
+        }
+        if((err = usbhidSetReport(dev, buffer, sizeof(buffer))) != 0)   /* add a dummy report ID */
+            fprintf(stderr, "error writing data: %s\n", usbErrorMessage(err));
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usbhidCloseDevice(dev);
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-data/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-data/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-data/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-data/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/main.c	(working copy)
@@ -0,0 +1,140 @@
+/* Name: main.c
+ * Project: hid-data, example how to use HID for data transfer
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+*/
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+#include <avr/eeprom.h>
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[22] = {    /* USB report descriptor */
+    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
+    0x09, 0x01,                    // USAGE (Vendor Usage 1)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x95, 0x80,                    //   REPORT_COUNT (128)
+    0x09, 0x00,                    //   USAGE (Undefined)
+    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)
+    0xc0                           // END_COLLECTION
+};
+/* Since we define only one feature report, we don't use report-IDs (which
+ * would be the first byte of the report). The entire report consists of 128
+ * opaque data bytes.
+ */
+
+/* The following variables store the status of the current data transfer */
+static uchar    currentAddress;
+static uchar    bytesRemaining;
+
+/* ------------------------------------------------------------------------- */
+
+/* usbFunctionRead() is called when the host requests a chunk of data from
+ * the device. For more information see the documentation in usbdrv/usbdrv.h.
+ */
+uchar   usbFunctionRead(uchar *data, uchar len)
+{
+    if(len > bytesRemaining)
+        len = bytesRemaining;
+    eeprom_read_block(data, (uchar *)0 + currentAddress, len);
+    currentAddress += len;
+    bytesRemaining -= len;
+    return len;
+}
+
+/* usbFunctionWrite() is called when the host sends a chunk of data to the
+ * device. For more information see the documentation in usbdrv/usbdrv.h.
+ */
+uchar   usbFunctionWrite(uchar *data, uchar len)
+{
+    if(bytesRemaining == 0)
+        return 1;               /* end of transfer */
+    if(len > bytesRemaining)
+        len = bytesRemaining;
+    eeprom_write_block(data, (uchar *)0 + currentAddress, len);
+    currentAddress += len;
+    bytesRemaining -= len;
+    return bytesRemaining == 0; /* return 1 if this was the last chunk */
+}
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* HID class request */
+        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
+            /* since we have only one report type, we can ignore the report-ID */
+            bytesRemaining = 128;
+            currentAddress = 0;
+            return USB_NO_MSG;  /* use usbFunctionRead() to obtain data */
+        }else if(rq->bRequest == USBRQ_HID_SET_REPORT){
+            /* since we have only one report type, we can ignore the report-ID */
+            bytesRemaining = 128;
+            currentAddress = 0;
+            return USB_NO_MSG;  /* use usbFunctionWrite() to receive data from host */
+        }
+    }else{
+        /* ignore vendor type requests, we don't use any */
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-data/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-data/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      1
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       1
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdf, 0x05 /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'D', 'a', 't', 'a', 'S', 't', 'o', 'r', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 9
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    22
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-mouse/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-mouse/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/Readme.txt	(working copy)
@@ -0,0 +1,48 @@
+This is the Readme file for hid-mouse, an example of a USB mouse device. In
+order to have as little dependencies on hardware and architecture as
+possible, mouse movements are computed internally so that the mouse pointer
+moves in a circle.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how HID class devices are implemented. The example
+is kept as simple as possible, except the report descriptor which is taken
+from a real-world mouse.
+
+It does NOT include a host side driver because all modern operating systems
+include one. It does NOT implement USBRQ_HID_SET_REPORT and report-IDs. See
+the "hid-data" example for this topic. It does NOT implement any special
+features such as suspend mode etc.
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-mouse/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-mouse example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-mouse/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/main.c	(working copy)
@@ -0,0 +1,163 @@
+/* Name: main.c
+ * Project: hid-mouse, a very simple HID example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-07
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+
+We use VID/PID 0x046D/0xC00E which is taken from a Logitech mouse. Don't
+publish any hardware using these IDs! This is for demonstration only!
+*/
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[52] = { /* USB report descriptor, size must match usbconfig.h */
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
+    0x09, 0x02,                    // USAGE (Mouse)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x09, 0x01,                    //   USAGE (Pointer)
+    0xA1, 0x00,                    //   COLLECTION (Physical)
+    0x05, 0x09,                    //     USAGE_PAGE (Button)
+    0x19, 0x01,                    //     USAGE_MINIMUM
+    0x29, 0x03,                    //     USAGE_MAXIMUM
+    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x75, 0x01,                    //     REPORT_SIZE (1)
+    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
+    0x95, 0x01,                    //     REPORT_COUNT (1)
+    0x75, 0x05,                    //     REPORT_SIZE (5)
+    0x81, 0x03,                    //     INPUT (Const,Var,Abs)
+    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
+    0x09, 0x30,                    //     USAGE (X)
+    0x09, 0x31,                    //     USAGE (Y)
+    0x09, 0x38,                    //     USAGE (Wheel)
+    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
+    0x25, 0x7F,                    //     LOGICAL_MAXIMUM (127)
+    0x75, 0x08,                    //     REPORT_SIZE (8)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
+    0xC0,                          //   END_COLLECTION
+    0xC0,                          // END COLLECTION
+};
+/* This is the same report descriptor as seen in a Logitech mouse. The data
+ * described by this descriptor consists of 4 bytes:
+ *      .  .  .  .  . B2 B1 B0 .... one byte with mouse button states
+ *     X7 X6 X5 X4 X3 X2 X1 X0 .... 8 bit signed relative coordinate x
+ *     Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 .... 8 bit signed relative coordinate y
+ *     W7 W6 W5 W4 W3 W2 W1 W0 .... 8 bit signed relative coordinate wheel
+ */
+typedef struct{
+    uchar   buttonMask;
+    char    dx;
+    char    dy;
+    char    dWheel;
+}report_t;
+
+static report_t reportBuffer;
+static int      sinus = 7 << 6, cosinus = 0;
+static uchar    idleRate;   /* repeat rate for keyboards, never used for mice */
+
+
+/* The following function advances sin/cos by a fixed angle
+ * and stores the difference to the previous coordinates in the report
+ * descriptor.
+ * The algorithm is the simulation of a second order differential equation.
+ */
+static void advanceCircleByFixedAngle(void)
+{
+char    d;
+
+#define DIVIDE_BY_64(val)  (val + (val > 0 ? 32 : -32)) >> 6    /* rounding divide */
+    reportBuffer.dx = d = DIVIDE_BY_64(cosinus);
+    sinus += d;
+    reportBuffer.dy = d = DIVIDE_BY_64(sinus);
+    cosinus -= d;
+}
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    /* The following requests are never used. But since they are required by
+     * the specification, we implement them in this example.
+     */
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
+        DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
+        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
+            /* we only have one report type, so don't look at wValue */
+            usbMsgPtr = (void *)&reportBuffer;
+            return sizeof(reportBuffer);
+        }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
+            usbMsgPtr = &idleRate;
+            return 1;
+        }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
+            idleRate = rq->wValue.bytes[1];
+        }
+    }else{
+        /* no vendor specific requests implemented */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+        if(usbInterruptIsReady()){
+            /* called after every poll of the interrupt endpoint */
+            advanceCircleByFixedAngle();
+            DBG1(0x03, 0, 0);   /* debug output: interrupt report prepared */
+            usbSetInterrupt((void *)&reportBuffer, sizeof(reportBuffer));
+        }
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-mouse/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xe8, 0x03 /* VOTI's lab use PID */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'M', 'o', 'u', 's', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 5
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    52
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/usbtool/Makefile
===================================================================
--- vusb-20121206/examples/usbtool/Makefile	(nonexistent)
+++ vusb-20121206/examples/usbtool/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: usbtool
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = usbtool
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/usbtool/Makefile.windows
===================================================================
--- vusb-20121206/examples/usbtool/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/usbtool/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: usbtool
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/usbtool/Readme.txt
===================================================================
--- vusb-20121206/examples/usbtool/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/usbtool/Readme.txt	(working copy)
@@ -0,0 +1,209 @@
+This is the Readme file for usbtool, a general purpose command line utility
+which can send USB requests to arbitrary devices. Usbtool is based on libusb.
+
+
+WHAT IS USBTOOL GOOD FOR?
+=========================
+When you implement a communication protocol like USB, you must usually write
+two programs: one on each end of the communication. For USB, this means that
+you must write a firmware for the device and driver software for the host.
+
+Usbtool can save you the work of writing the host software, at least during
+firmware development and testing. Usbtool can send control-in and -out
+requests to arbitrary devices and send and receive data on interrupt- and
+bulk-endpoints.
+
+Usbtool is not only a useful developer tool, it's also an example for using
+libusb for communication with the device.
+
+
+SYNOPSIS
+========
+  usbtool [options] <command>
+
+
+COMMANDS
+========
+  list
+    This command prints a list of devices found on all available USB busses.
+    Options -v, -V, -p and -P can be used to filter the list.
+
+  control in|out <type> <recipient> <request> <value> <index>
+    Sends a control-in or control-out request to the device. The request
+    parameters are:
+      type ........ Type of request, can be "standard", "class", "vendor" or
+                    "reserved". The type determines which software module in
+                    the device is responsible for answering the request:
+                    Standard requests are answered by the driver, class
+                    requests by the class implementation (e.g. HID, CDC) and
+                    vendor requests by custom code.
+      recipient ... Recipient of the request in the device. Can be "device",
+                    "interface", "endpoint" or "other". For standard and
+                    class requests, the specification defines a recipient for
+                    each request. For vendor requests, choose whatever your
+                    code expects.
+      request ..... 8 bit numeric value identifying the request.
+      value ....... 16 bit numeric value passed to the device.
+      index ....... another 16 bit numeric value passed to the device.
+    Use options -v, -V, -p and -P to single out a particular device. Use
+    options -d or -D to to send data in an OUT request. Use options -n, -O
+    and -b to determine what to do with data received in an IN request.
+
+  interrupt in|out
+    Sends or receives data on an interrupt-out resp. -in endpoint.
+    Use options -v, -V, -p and -P to single out a particular device. Use
+    options -d or -D to to send data to an OUT endpoint. Use options -n, -O
+    and -b to determine what to do with data received from an IN endpoint.
+    Use option -e to set the endpoint number, -c to choose a configuration
+    -i to claim a particular interface.
+
+  bulk in|out
+    Same as "interrupt in" and "interrupt out", but for bulk endpoints.
+
+
+OPTIONS
+=======
+Most options have already been mentioned at the commands which use them.
+here is a complete list:
+
+  -h or -?
+    Prints a short help.
+
+  -v <vendor-id>
+    Numeric vendor ID, can be "*" to allow any VID. Take only devices with
+    matching vendor ID into account.
+
+  -p <product-id>
+    Numeric product ID, can be "*" to allow any PID. Take only devices with
+    matching product ID into account.
+
+  -V <vendor-name-pattern>
+    Shell style matching pattern for vendor name. Take only devices into
+    account which have a vendor name that matches this pattern.
+
+  -P <product-name-pattern>
+    Shell style matching pattern for product name. Take only devices into
+    account which have a product name that matches this pattern.
+
+  -S <serial-pattern>
+    Shell style matching pattern for serial number. Take only devices into
+    account which have a serial number that matches this pattern.
+
+  -d <databytes>
+    Data bytes to send to the device, comma separated list of numeric values.
+    E.g.: "1,2,3,4,5".
+
+  -D <file>
+    Binary data sent to the device should be taken from this file.
+
+  -O <file>
+    Write received data bytes to the given file. Format is either hex or
+    binary, depending on the -b flag. By default, received data is printed
+    to standard output.
+
+  -b
+    Request binary output format for files and standard output. Default is
+    a hexadecimal listing.
+
+  -n <count>
+    Numeric value: Maximum number of bytes to receive. This value is passed
+    directly to the libusb API functions.
+
+  -e <endpoint>
+    Numeric value: Endpoint number for interrupt and bulk commands.
+
+  -t <timeout>
+    Numeric value: Timeout in milliseconds for the request. This value is
+    passed directly to the libusb API functions.
+
+  -c <configuration>
+    Numeric value: Interrupt and bulk endpoints can usually only be used if
+    a configuration and an interface has been chosen. Use -c and -i to
+    specify configuration and interface values.
+
+  -i <interface>
+    Numeric value: Interrupt and bulk endpoints can usually only be used if
+    a configuration and an interface has been chosen. Use -c and -i to
+    specify configuration and interface values.
+
+  -w
+    Usbtool may be too verbose with warnings for some applications. Use this
+    option to suppress USB warnings.
+
+
+NUMERIC VALUES
+==============
+All numeric values can be given in hexadecimal, decimal or octal. Hex values
+are identified by their 0x or 0X prefix, octal values by a leading "0" (the
+digit zero) and decimal values because they start with a non-zero digit. An
+optional sign character is allowed. The special value "*" is translated to
+zero and stands for "any value" in some contexts.
+
+
+SHELL STYLE MATCHING PATTERNS
+=============================
+Some options take shell style matching patterns as an argument. This refers
+to Unix shells and their file wildcard operations:
+  + "*" (asterisk character) matches any number (0 to infinite) of any
+    characters.
+  + "?" matches exactly one arbitrary character.
+  + A list of characters in square brackets (e.g. "[abc]") matches any of the
+    characters in the list. If a dash ("-") is in the list, it must be the
+    first or the last character. If a caret ("^") is in the list, it must
+    not be the first character. A closing square bracket ("]") must be the
+    first character in the list. A range of characters can be specified in
+    the way "[a-z]". This matches all characters with numeric representation
+    (usually ASCII) starting with "a" and ending with "z". The entire
+    construct matches only one character.
+  + A list of characters in square brackets starting with a caret ("^"), e.g.
+    ("[^abc]") matches any character NOT in the list. The other rules are as
+    above.
+  + "\" (backslash) followed by any character matches that following
+    character. This can be used to escape "*", "?", "[" and "\".
+
+
+BUILDING USBTOOL
+================
+Usbtool uses libusb on Unix and libusb-win32 on Windows. These libraries can
+be obtained from http://libusb.sourceforge.net/ and
+http://libusb-win32.sourceforge.net/ respectively. On Unix, a simple "make"
+should compile the sources (although you may have to edit Makefile to
+include or remove additional libraries). On Windows, we recommend that you
+use MinGW and MSYS. See the top level Readme file for details. Edit
+Makefile.windows according to your library installation paths and build with
+"make -f Makefile.windows".
+
+
+EXAMPLES
+========
+To list all devices connected to your computer, do
+
+    usbtool -w list
+
+To check whether our selection options single out the desired device, use eg.
+
+    usbtool -w -P LEDControl list
+
+This command shows all LEDControl devices connected or prints nothing if
+none is found. LEDControl is the device from the "custom-class" example.
+
+You can also send commands to the LEDControl device using usbtool. From
+the file requests.h in custom-class/firmware, we know that the set-status
+request has numeric value 1 and the get-status request is 2. See this file
+for details of the protocol used. We can therefore query the status with
+
+    usbtool -w -P LEDControl control in vendor device 2 0 0
+
+This command prints 0x00 if the LED is off or 0x01 if it is on. To turn the
+LED on, use
+
+    usbtool -w -P LEDControl control out vendor device 1 1 0
+
+and to turn it off, use
+
+    usbtool -w -P LEDControl control out vendor device 1 0 0
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/usbtool/opendevice.c
===================================================================
--- vusb-20121206/examples/usbtool/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/usbtool/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/usbtool/opendevice.h
===================================================================
--- vusb-20121206/examples/usbtool/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/usbtool/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/usbtool/usbtool.c
===================================================================
--- vusb-20121206/examples/usbtool/usbtool.c	(nonexistent)
+++ vusb-20121206/examples/usbtool/usbtool.c	(working copy)
@@ -0,0 +1,355 @@
+/* Name: usbtool.c
+ * Project: V-USB examples, host side
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-06
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This command line tool can perform various USB requests at arbitrary
+USB devices. It is intended as universal host side tool for experimentation
+and debugging purposes. It must be linked with libusb, a library for accessing
+the USB bus from Linux, FreeBSD, Mac OS X and other Unix operating systems.
+Libusb can be obtained from http://libusb.sourceforge.net/.
+On Windows use libusb-win32 from http://libusb-win32.sourceforge.net/.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include <usb.h>        /* this is libusb, see http://libusb.sourceforge.net/ */
+#include "opendevice.h" /* common code moved to separate module */
+
+#define DEFAULT_USB_VID         0   /* any */
+#define DEFAULT_USB_PID         0   /* any */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage: %s [options] <command>\n", name);
+    fprintf(stderr,
+        "Options are:\n"
+        "  -h or -? (print this help and exit)\n"
+        "  -v <vendor-id> (defaults to 0x%x, can be '*' for any VID)\n"
+        "  -p <product-id> (defaults to 0x%x, can be '*' for any PID)\n"
+        "  -V <vendor-name-pattern> (shell style matching, defaults to '*')\n"
+        "  -P <product-name-pattern> (shell style matching, defaults to '*')\n"
+        "  -S <serial-pattern> (shell style matching, defaults to '*')\n"
+        "  -d <databytes> (data byte for request, comma separated list)\n"
+        "  -D <file> (binary data for request taken from file)\n"
+        "  -O <file> (write received data bytes to file)\n"
+        "  -b (binary output format, default is hex)\n"
+        "  -n <count> (maximum number of bytes to receive)\n"
+        "  -e <endpoint> (specify endpoint for some commands)\n"
+        "  -t <timeout> (specify USB timeout in milliseconds)\n"
+        "  -c <configuration> (device configuration to choose)\n"
+        "  -i <interface> (configuration interface to claim)\n"
+        "  -w (suppress USB warnings, default is verbose)\n"
+        "\n"
+        "Commands are:\n"
+        "  list (list all matching devices by name)\n"
+        "  control in|out <type> <recipient> <request> <value> <index> (send control request)\n"
+        "  interrupt in|out (send or receive interrupt data)\n"
+        "  bulk in|out (send or receive bulk data)\n"
+        "For valid enum values for <type> and <recipient> pass \"x\" for the value.\n"
+        "Objective Development's free VID/PID pairs are:\n"
+        "  5824/1500 for vendor class devices\n"
+        "  5824/1503 for HID class devices excluding mice and keyboards\n"
+        "  5824/1505 for CDC-ACM class devices\n"
+        "  5824/1508 for MIDI class devices\n"
+        , DEFAULT_USB_VID, DEFAULT_USB_PID
+    );
+
+
+}
+
+static int  vendorID = DEFAULT_USB_VID;
+static int  productID = DEFAULT_USB_PID;
+static char *vendorNamePattern = "*";
+static char *productNamePattern = "*";
+static char *serialPattern = "*";
+static char *sendBytes = NULL;
+static int  sendByteCount;
+static char *outputFile = NULL;
+static int  endpoint = 0;
+static int  outputFormatIsBinary = 0;
+static int  showWarnings = 1;
+static int  usbTimeout = 5000;
+static int  usbCount = 128;
+static int  usbConfiguration = 1;
+static int  usbInterface = 0;
+
+static int  usbDirection, usbType, usbRecipient, usbRequest, usbValue, usbIndex; /* arguments of control transfer */
+
+/* ------------------------------------------------------------------------- */
+
+/* ASCII to integer (number parsing) which allows hex (0x prefix),
+ * octal (0 prefix) and decimal (1-9 prefix) input.
+ */
+static int  myAtoi(char *text)
+{
+long    l;
+char    *endPtr;
+
+    if(strcmp(text, "*") == 0)
+        return 0;
+    l = strtol(text, &endPtr, 0);
+    if(endPtr == text){
+        fprintf(stderr, "warning: can't parse numeric parameter ->%s<-, defaults to 0.\n", text);
+        l = 0;
+    }else if(*endPtr != 0){
+        fprintf(stderr, "warning: numeric parameter ->%s<- only partially parsed.\n", text);
+    }
+    return l;
+}
+
+static int  parseEnum(char *text, ...)
+{
+va_list vlist;
+char    *entries[64];
+int     i, numEntries;
+
+    va_start(vlist, text);
+    for(i = 0; i < 64; i++){
+        entries[i] = va_arg(vlist, char *);
+        if(entries[i] == NULL)
+            break;
+    }
+    numEntries = i;
+    va_end(vlist);
+    for(i = 0; i < numEntries; i++){
+        if(strcasecmp(text, entries[i]) == 0)
+            return i;
+    }
+    if(isdigit(*text)){
+        return myAtoi(text);
+    }
+    fprintf(stderr, "Enum value \"%s\" not allowed. Allowed values are:\n", text);
+    for(i = 0; i < numEntries; i++){
+        fprintf(stderr, "  %s\n", entries[i]);
+    }
+    exit(1);
+}
+
+/* ------------------------------------------------------------------------- */
+
+#define ACTION_LIST         0
+#define ACTION_CONTROL      1
+#define ACTION_INTERRUPT    2
+#define ACTION_BULK         3
+
+int main(int argc, char **argv)
+{
+usb_dev_handle  *handle = NULL;
+int             opt, len, action, argcnt;
+char            *myName = argv[0], *s, *rxBuffer = NULL;
+FILE            *fp;
+
+    while((opt = getopt(argc, argv, "?hv:p:V:P:S:d:D:O:e:n:tbw")) != -1){
+        switch(opt){
+        case 'h':
+        case '?':   /* -h or -? (print this help and exit) */
+            usage(myName);
+            exit(1);
+        case 'v':   /* -v <vendor-id> (defaults to 0x%x, can be '*' for any VID) */
+            vendorID = myAtoi(optarg);
+            break;
+        case 'p':   /* -p <product-id> (defaults to 0x%x, can be '*' for any PID) */
+            productID = myAtoi(optarg);
+            break;
+        case 'V':   /* -V <vendor-name-pattern> (shell style matching, defaults to '*') */
+            vendorNamePattern = optarg;
+            break;
+        case 'P':   /* -P <product-name-pattern> (shell style matching, defaults to '*') */
+            productNamePattern = optarg;
+            break;
+        case 'S':   /* -S <serial-pattern> (shell style matching, defaults to '*') */
+            serialPattern = optarg;
+            break;
+        case 'd':   /* -d <databytes> (data bytes for requests given on command line) */
+            while((s = strtok(optarg, ", ")) != NULL){
+                optarg = NULL;
+                if(sendBytes != NULL){
+                    sendBytes = realloc(sendBytes, sendByteCount + 1);
+                }else{
+                    sendBytes = malloc(sendByteCount + 1);
+                }
+                sendBytes[sendByteCount++] = myAtoi(s);
+            }
+            break;
+        case 'D':   /* -D <file> (data bytes for request taken from file) */
+            if((fp = fopen(optarg, "rb")) == NULL){
+                fprintf(stderr, "error opening %s: %s\n", optarg, strerror(errno));
+                exit(1);
+            }
+            fseek(fp, 0, SEEK_END);
+            len = ftell(fp);
+            fseek(fp, 0, SEEK_SET);
+            if(sendBytes != NULL){
+                sendBytes = realloc(sendBytes, sendByteCount + len);
+            }else{
+                sendBytes = malloc(sendByteCount + len);
+            }
+            fread(sendBytes + sendByteCount, 1, len, fp);   /* would need error checking */
+            sendByteCount += len;
+            fclose(fp);
+            break;
+        case 'O':   /* -O <file> (write received data bytes to file) */
+            outputFile = optarg;
+            break;
+        case 'e':   /* -e <endpoint> (specify endpoint for some commands) */
+            endpoint = myAtoi(optarg);
+            break;
+        case 't':   /* -t <timeout> (specify USB timeout in milliseconds) */
+            usbTimeout = myAtoi(optarg);
+            break;
+        case 'b':   /* -b (binary output format, default is hex) */
+            outputFormatIsBinary = 1;
+            break;
+        case 'n':   /* -n <count> (maximum number of bytes to receive) */
+            usbCount = myAtoi(optarg);
+            break;
+        case 'c':   /* -c <configuration> (device configuration to choose) */
+            usbConfiguration = myAtoi(optarg);
+            break;
+        case 'i':   /* -i <interface> (configuration interface to claim) */
+            usbInterface = myAtoi(optarg);
+            break;
+        case 'w':   /* -w (suppress USB warnings, default is verbose) */
+            showWarnings = 0;
+            break;
+        default:
+            fprintf(stderr, "Option -%c unknown\n", opt);
+            exit(1);
+        }
+    }
+    argc -= optind;
+    argv += optind;
+    if(argc < 1){
+        usage(myName);
+        exit(1);
+    }
+    argcnt = 2;
+    if(strcasecmp(argv[0], "list") == 0){
+        action = ACTION_LIST;
+        argcnt = 1;
+    }else if(strcasecmp(argv[0], "control") == 0){
+        action = ACTION_CONTROL;
+        argcnt = 7;
+    }else if(strcasecmp(argv[0], "interrupt") == 0){
+        action = ACTION_INTERRUPT;
+    }else if(strcasecmp(argv[0], "bulk") == 0){
+        action = ACTION_BULK;
+    }else{
+        fprintf(stderr, "command %s not known\n", argv[0]);
+        usage(myName);
+        exit(1);
+    }
+    if(argc < argcnt){
+        fprintf(stderr, "Not enough arguments.\n");
+        usage(myName);
+        exit(1);
+    }
+    if(argc > argcnt){
+        fprintf(stderr, "Warning: only %d arguments expected, rest ignored.\n", argcnt);
+    }
+    usb_init();
+    if(usbOpenDevice(&handle, vendorID, vendorNamePattern, productID, productNamePattern, serialPattern, action == ACTION_LIST ? stdout : NULL, showWarnings ? stderr : NULL) != 0){
+        fprintf(stderr, "Could not find USB device with VID=0x%x PID=0x%x Vname=%s Pname=%s Serial=%s\n", vendorID, productID, vendorNamePattern, productNamePattern, serialPattern);
+        exit(1);
+    }
+    if(action == ACTION_LIST)
+        exit(0);                /* we've done what we were asked to do already */
+    usbDirection = parseEnum(argv[1], "out", "in", NULL);
+    if(usbDirection){   /* IN transfer */
+        rxBuffer = malloc(usbCount);
+    }
+    if(action == ACTION_CONTROL){
+        int requestType;
+        usbType = parseEnum(argv[2], "standard", "class", "vendor", "reserved", NULL);
+        usbRecipient = parseEnum(argv[3], "device", "interface", "endpoint", "other", NULL);
+        usbRequest = myAtoi(argv[4]);
+        usbValue = myAtoi(argv[5]);
+        usbIndex = myAtoi(argv[6]);
+        requestType = ((usbDirection & 1) << 7) | ((usbType & 3) << 5) | (usbRecipient & 0x1f);
+        if(usbDirection){   /* IN transfer */
+            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, rxBuffer, usbCount, usbTimeout);
+        }else{              /* OUT transfer */
+            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, sendBytes, sendByteCount, usbTimeout);
+        }
+    }else{  /* must be ACTION_INTERRUPT or ACTION_BULK */
+        int retries = 1;
+        if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+            fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+        }
+        /* now try to claim the interface and detach the kernel HID driver on
+         * linux and other operating systems which support the call.
+         */
+        while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+            if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+                fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+            }
+#endif
+        }
+        if(len != 0 && showWarnings)
+            fprintf(stderr, "Warning: could not claim interface: %s\n", usb_strerror());
+        if(action == ACTION_INTERRUPT){
+            if(usbDirection){   /* IN transfer */
+                len = usb_interrupt_read(handle, endpoint, rxBuffer, usbCount, usbTimeout);
+            }else{
+                len = usb_interrupt_write(handle, endpoint, sendBytes, sendByteCount, usbTimeout);
+            }
+        }else{
+            if(usbDirection){   /* IN transfer */
+                len = usb_bulk_read(handle, endpoint, rxBuffer, usbCount, usbTimeout);
+            }else{
+                len = usb_bulk_write(handle, endpoint, sendBytes, sendByteCount, usbTimeout);
+            }
+        }
+    }
+    if(len < 0){
+        fprintf(stderr, "USB error: %s\n", usb_strerror());
+        exit(1);
+    }
+    if(usbDirection == 0)   /* OUT */
+        printf("%d bytes sent.\n", len);
+    if(rxBuffer != NULL){
+        FILE *fp = stdout;
+        if(outputFile != NULL){
+            fp = fopen(outputFile, outputFormatIsBinary ? "wb" : "w");
+            if(fp == NULL){
+                fprintf(stderr, "Error writing \"%s\": %s\n", outputFile, strerror(errno));
+                exit(1);
+            }
+        }
+        if(outputFormatIsBinary){
+            fwrite(rxBuffer, 1, len, fp);
+        }else{
+            int i;
+            for(i = 0; i < len; i++){
+                if(i != 0){
+                    if(i % 16 == 0){
+                        fprintf(fp, "\n");
+                    }else{
+                        fprintf(fp, " ");
+                    }
+                }
+                fprintf(fp, "0x%02x", rxBuffer[i] & 0xff);
+            }
+            if(i != 0)
+                fprintf(fp, "\n");
+        }
+    }
+    usb_close(handle);
+    if(rxBuffer != NULL)
+        free(rxBuffer);
+    return 0;
+}
Index: vusb-20121206/examples/custom-class/Readme.txt
===================================================================
--- vusb-20121206/examples/custom-class/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/custom-class/Readme.txt	(working copy)
@@ -0,0 +1,64 @@
+This is the Readme file for the custom-class example. In this example, we
+show how an LED can be controlled via USB.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example shows how small amounts of data (several bytes) can be
+transferred between the device and the host. In addition to a very basic
+USB device, it demonstrates how to build a host side driver application
+using libusb or libusb-win32. It does NOT show how usbFunctionWrite() and
+usbFunctionRead() are used. See the hid-data example if you want to learn
+about these functions.
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+Host development environment: A C compiler and libusb. See the top level
+Readme file, section Prerequisites for more information.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware. You should have wired an LED with a
+current limiting resistor of ca. 270 Ohm to a free I/O pin. Change the
+defines in main.c to match the port and bit number.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+BUILDING THE HOST SOFTWARE
+==========================
+Since the host software is based on libusb or libusb-win32, make sure that
+this library is installed. On Unix, ensure that libusb-config is in your
+search PATH. On Windows, edit Makefile.windows and set the library path
+appropriately. Then type "make" on Unix or "make -f Makefile.windows" on
+Windows to build the command line tool.
+
+
+USING THE COMMAND LINE TOOL
+===========================
+The command line tool has three valid arguments: "status" to query the
+current LED status, "on" to turn on the LED and "off" to turn it off.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/custom-class/commandline/Makefile
===================================================================
--- vusb-20121206/examples/custom-class/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = set-led
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/custom-class/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/custom-class/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/custom-class/commandline/opendevice.c
===================================================================
--- vusb-20121206/examples/custom-class/commandline/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/custom-class/commandline/opendevice.h
===================================================================
--- vusb-20121206/examples/custom-class/commandline/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/custom-class/commandline/set-led.c
===================================================================
--- vusb-20121206/examples/custom-class/commandline/set-led.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/set-led.c	(working copy)
@@ -0,0 +1,134 @@
+/* Name: set-led.c
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This is the host-side driver for the custom-class example device. It searches
+the USB for the LEDControl device and sends the requests understood by this
+device.
+This program must be linked with libusb on Unix and libusb-win32 on Windows.
+See http://libusb.sourceforge.net/ or http://libusb-win32.sourceforge.net/
+respectively.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <usb.h>        /* this is libusb */
+#include "opendevice.h" /* common code moved to separate module */
+
+#include "../firmware/requests.h"   /* custom request numbers */
+#include "../firmware/usbconfig.h"  /* device's VID/PID and names */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s on ....... turn on LED\n", name);
+    fprintf(stderr, "  %s off ...... turn off LED\n", name);
+    fprintf(stderr, "  %s status ... ask current status of LED\n", name);
+#if ENABLE_TEST
+    fprintf(stderr, "  %s test ..... run driver reliability test\n", name);
+#endif /* ENABLE_TEST */
+}
+
+int main(int argc, char **argv)
+{
+usb_dev_handle      *handle = NULL;
+const unsigned char rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char                vendor[] = {USB_CFG_VENDOR_NAME, 0}, product[] = {USB_CFG_DEVICE_NAME, 0};
+char                buffer[4];
+int                 cnt, vid, pid, isOn;
+
+    usb_init();
+    if(argc < 2){   /* we need at least one argument */
+        usage(argv[0]);
+        exit(1);
+    }
+    /* compute VID/PID from usbconfig.h so that there is a central source of information */
+    vid = rawVid[1] * 256 + rawVid[0];
+    pid = rawPid[1] * 256 + rawPid[0];
+    /* The following function is in opendevice.c: */
+    if(usbOpenDevice(&handle, vid, vendor, pid, product, NULL, NULL, NULL) != 0){
+        fprintf(stderr, "Could not find USB device \"%s\" with vid=0x%x pid=0x%x\n", product, vid, pid);
+        exit(1);
+    }
+    /* Since we use only control endpoint 0, we don't need to choose a
+     * configuration and interface. Reading device descriptor and setting a
+     * configuration and interface is done through endpoint 0 after all.
+     * However, newer versions of Linux require that we claim an interface
+     * even for endpoint 0. Enable the following code if your operating system
+     * needs it: */
+#if 0
+    int retries = 1, usbConfiguration = 1, usbInterface = 0;
+    if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+        fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+    }
+    /* now try to claim the interface and detach the kernel HID driver on
+     * Linux and other operating systems which support the call. */
+    while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+        if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+            fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+        }
+#endif
+    }
+#endif
+
+    if(strcasecmp(argv[1], "status") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_GET_STATUS, 0, 0, buffer, sizeof(buffer), 5000);
+        if(cnt < 1){
+            if(cnt < 0){
+                fprintf(stderr, "USB error: %s\n", usb_strerror());
+            }else{
+                fprintf(stderr, "only %d bytes received.\n", cnt);
+            }
+        }else{
+            printf("LED is %s\n", buffer[0] ? "on" : "off");
+        }
+    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
+        if(cnt < 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+#if ENABLE_TEST
+    }else if(strcasecmp(argv[1], "test") == 0){
+        int i;
+        srandomdev();
+        for(i = 0; i < 50000; i++){
+            int value = random() & 0xffff, index = random() & 0xffff;
+            int rxValue, rxIndex;
+            if((i+1) % 100 == 0){
+                fprintf(stderr, "\r%05d", i+1);
+                fflush(stderr);
+            }
+            cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_ECHO, value, index, buffer, sizeof(buffer), 5000);
+            if(cnt < 0){
+                fprintf(stderr, "\nUSB error in iteration %d: %s\n", i, usb_strerror());
+                break;
+            }else if(cnt != 4){
+                fprintf(stderr, "\nerror in iteration %d: %d bytes received instead of 4\n", i, cnt);
+                break;
+            }
+            rxValue = ((int)buffer[0] & 0xff) | (((int)buffer[1] & 0xff) << 8);
+            rxIndex = ((int)buffer[2] & 0xff) | (((int)buffer[3] & 0xff) << 8);
+            if(rxValue != value || rxIndex != index){
+                fprintf(stderr, "\ndata error in iteration %d:\n", i);
+                fprintf(stderr, "rxValue = 0x%04x value = 0x%04x\n", rxValue, value);
+                fprintf(stderr, "rxIndex = 0x%04x index = 0x%04x\n", rxIndex, index);
+            }
+        }
+        fprintf(stderr, "\nTest completed.\n");
+#endif /* ENABLE_TEST */
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usb_close(handle);
+    return 0;
+}
Index: vusb-20121206/examples/custom-class/firmware/Makefile
===================================================================
--- vusb-20121206/examples/custom-class/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/custom-class/firmware/main.c
===================================================================
--- vusb-20121206/examples/custom-class/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/main.c	(working copy)
@@ -0,0 +1,96 @@
+/* Name: main.c
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+We assume that an LED is connected to port B bit 0. If you connect it to a
+different port or bit, change the macros below:
+*/
+#define LED_PORT_DDR        DDRB
+#define LED_PORT_OUTPUT     PORTB
+#define LED_BIT             0
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+#include "requests.h"       /* The custom request numbers we use */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+static uchar    dataBuffer[4];  /* buffer must stay valid when usbFunctionSetup returns */
+
+    if(rq->bRequest == CUSTOM_RQ_ECHO){ /* echo -- used for reliability tests */
+        dataBuffer[0] = rq->wValue.bytes[0];
+        dataBuffer[1] = rq->wValue.bytes[1];
+        dataBuffer[2] = rq->wIndex.bytes[0];
+        dataBuffer[3] = rq->wIndex.bytes[1];
+        usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+        return 4;
+    }else if(rq->bRequest == CUSTOM_RQ_SET_STATUS){
+        if(rq->wValue.bytes[0] & 1){    /* set LED */
+            LED_PORT_OUTPUT |= _BV(LED_BIT);
+        }else{                          /* clear LED */
+            LED_PORT_OUTPUT &= ~_BV(LED_BIT);
+        }
+    }else if(rq->bRequest == CUSTOM_RQ_GET_STATUS){
+        dataBuffer[0] = ((LED_PORT_OUTPUT & _BV(LED_BIT)) != 0);
+        usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+        return 1;                       /* tell the driver to send 1 byte */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    LED_PORT_DDR |= _BV(LED_BIT);   /* make the LED bit an output */
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/custom-class/firmware/requests.h
===================================================================
--- vusb-20121206/examples/custom-class/firmware/requests.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/requests.h	(working copy)
@@ -0,0 +1,35 @@
+/* Name: requests.h
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* This header is shared between the firmware and the host software. It
+ * defines the USB request numbers (and optionally data types) used to
+ * communicate between the host and the device.
+ */
+
+#ifndef __REQUESTS_H_INCLUDED__
+#define __REQUESTS_H_INCLUDED__
+
+#define CUSTOM_RQ_ECHO          0
+/* Request that the device sends back wValue and wIndex. This is used with
+ * random data to test the reliability of the communication.
+ */
+#define CUSTOM_RQ_SET_STATUS    1
+/* Set the LED status. Control-OUT.
+ * The requested status is passed in the "wValue" field of the control
+ * transfer. No OUT data is sent. Bit 0 of the low byte of wValue controls
+ * the LED.
+ */
+
+#define CUSTOM_RQ_GET_STATUS    2
+/* Get the current LED status. Control-IN.
+ * This control transfer involves a 1 byte data phase where the device sends
+ * the current status to the host. The status is in bit 0 of the byte.
+ */
+
+#endif /* __REQUESTS_H_INCLUDED__ */
Index: vusb-20121206/examples/custom-class/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/custom-class/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    0
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdc, 0x05 /* = 0x05dc = 1500 */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'L', 'E', 'D', 'C', 'o', 'n', 't', 'r', 'o', 'l'
+#define USB_CFG_DEVICE_NAME_LEN 10
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/custom-class/commandline/Makefile
===================================================================
--- vusb-20121206/examples/custom-class/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = set-led
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/custom-class/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/custom-class/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/custom-class/commandline/opendevice.c
===================================================================
--- vusb-20121206/examples/custom-class/commandline/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/custom-class/commandline/opendevice.h
===================================================================
--- vusb-20121206/examples/custom-class/commandline/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/custom-class/commandline/set-led.c
===================================================================
--- vusb-20121206/examples/custom-class/commandline/set-led.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/set-led.c	(working copy)
@@ -0,0 +1,134 @@
+/* Name: set-led.c
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This is the host-side driver for the custom-class example device. It searches
+the USB for the LEDControl device and sends the requests understood by this
+device.
+This program must be linked with libusb on Unix and libusb-win32 on Windows.
+See http://libusb.sourceforge.net/ or http://libusb-win32.sourceforge.net/
+respectively.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <usb.h>        /* this is libusb */
+#include "opendevice.h" /* common code moved to separate module */
+
+#include "../firmware/requests.h"   /* custom request numbers */
+#include "../firmware/usbconfig.h"  /* device's VID/PID and names */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s on ....... turn on LED\n", name);
+    fprintf(stderr, "  %s off ...... turn off LED\n", name);
+    fprintf(stderr, "  %s status ... ask current status of LED\n", name);
+#if ENABLE_TEST
+    fprintf(stderr, "  %s test ..... run driver reliability test\n", name);
+#endif /* ENABLE_TEST */
+}
+
+int main(int argc, char **argv)
+{
+usb_dev_handle      *handle = NULL;
+const unsigned char rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char                vendor[] = {USB_CFG_VENDOR_NAME, 0}, product[] = {USB_CFG_DEVICE_NAME, 0};
+char                buffer[4];
+int                 cnt, vid, pid, isOn;
+
+    usb_init();
+    if(argc < 2){   /* we need at least one argument */
+        usage(argv[0]);
+        exit(1);
+    }
+    /* compute VID/PID from usbconfig.h so that there is a central source of information */
+    vid = rawVid[1] * 256 + rawVid[0];
+    pid = rawPid[1] * 256 + rawPid[0];
+    /* The following function is in opendevice.c: */
+    if(usbOpenDevice(&handle, vid, vendor, pid, product, NULL, NULL, NULL) != 0){
+        fprintf(stderr, "Could not find USB device \"%s\" with vid=0x%x pid=0x%x\n", product, vid, pid);
+        exit(1);
+    }
+    /* Since we use only control endpoint 0, we don't need to choose a
+     * configuration and interface. Reading device descriptor and setting a
+     * configuration and interface is done through endpoint 0 after all.
+     * However, newer versions of Linux require that we claim an interface
+     * even for endpoint 0. Enable the following code if your operating system
+     * needs it: */
+#if 0
+    int retries = 1, usbConfiguration = 1, usbInterface = 0;
+    if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+        fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+    }
+    /* now try to claim the interface and detach the kernel HID driver on
+     * Linux and other operating systems which support the call. */
+    while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+        if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+            fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+        }
+#endif
+    }
+#endif
+
+    if(strcasecmp(argv[1], "status") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_GET_STATUS, 0, 0, buffer, sizeof(buffer), 5000);
+        if(cnt < 1){
+            if(cnt < 0){
+                fprintf(stderr, "USB error: %s\n", usb_strerror());
+            }else{
+                fprintf(stderr, "only %d bytes received.\n", cnt);
+            }
+        }else{
+            printf("LED is %s\n", buffer[0] ? "on" : "off");
+        }
+    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
+        if(cnt < 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+#if ENABLE_TEST
+    }else if(strcasecmp(argv[1], "test") == 0){
+        int i;
+        srandomdev();
+        for(i = 0; i < 50000; i++){
+            int value = random() & 0xffff, index = random() & 0xffff;
+            int rxValue, rxIndex;
+            if((i+1) % 100 == 0){
+                fprintf(stderr, "\r%05d", i+1);
+                fflush(stderr);
+            }
+            cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_ECHO, value, index, buffer, sizeof(buffer), 5000);
+            if(cnt < 0){
+                fprintf(stderr, "\nUSB error in iteration %d: %s\n", i, usb_strerror());
+                break;
+            }else if(cnt != 4){
+                fprintf(stderr, "\nerror in iteration %d: %d bytes received instead of 4\n", i, cnt);
+                break;
+            }
+            rxValue = ((int)buffer[0] & 0xff) | (((int)buffer[1] & 0xff) << 8);
+            rxIndex = ((int)buffer[2] & 0xff) | (((int)buffer[3] & 0xff) << 8);
+            if(rxValue != value || rxIndex != index){
+                fprintf(stderr, "\ndata error in iteration %d:\n", i);
+                fprintf(stderr, "rxValue = 0x%04x value = 0x%04x\n", rxValue, value);
+                fprintf(stderr, "rxIndex = 0x%04x index = 0x%04x\n", rxIndex, index);
+            }
+        }
+        fprintf(stderr, "\nTest completed.\n");
+#endif /* ENABLE_TEST */
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usb_close(handle);
+    return 0;
+}
Index: vusb-20121206/examples/custom-class/commandline/Makefile
===================================================================
--- vusb-20121206/examples/custom-class/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = set-led
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/custom-class/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/custom-class/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/custom-class/commandline/opendevice.c
===================================================================
--- vusb-20121206/examples/custom-class/commandline/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/custom-class/commandline/opendevice.h
===================================================================
--- vusb-20121206/examples/custom-class/commandline/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/custom-class/commandline/set-led.c
===================================================================
--- vusb-20121206/examples/custom-class/commandline/set-led.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/commandline/set-led.c	(working copy)
@@ -0,0 +1,134 @@
+/* Name: set-led.c
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This is the host-side driver for the custom-class example device. It searches
+the USB for the LEDControl device and sends the requests understood by this
+device.
+This program must be linked with libusb on Unix and libusb-win32 on Windows.
+See http://libusb.sourceforge.net/ or http://libusb-win32.sourceforge.net/
+respectively.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <usb.h>        /* this is libusb */
+#include "opendevice.h" /* common code moved to separate module */
+
+#include "../firmware/requests.h"   /* custom request numbers */
+#include "../firmware/usbconfig.h"  /* device's VID/PID and names */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s on ....... turn on LED\n", name);
+    fprintf(stderr, "  %s off ...... turn off LED\n", name);
+    fprintf(stderr, "  %s status ... ask current status of LED\n", name);
+#if ENABLE_TEST
+    fprintf(stderr, "  %s test ..... run driver reliability test\n", name);
+#endif /* ENABLE_TEST */
+}
+
+int main(int argc, char **argv)
+{
+usb_dev_handle      *handle = NULL;
+const unsigned char rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char                vendor[] = {USB_CFG_VENDOR_NAME, 0}, product[] = {USB_CFG_DEVICE_NAME, 0};
+char                buffer[4];
+int                 cnt, vid, pid, isOn;
+
+    usb_init();
+    if(argc < 2){   /* we need at least one argument */
+        usage(argv[0]);
+        exit(1);
+    }
+    /* compute VID/PID from usbconfig.h so that there is a central source of information */
+    vid = rawVid[1] * 256 + rawVid[0];
+    pid = rawPid[1] * 256 + rawPid[0];
+    /* The following function is in opendevice.c: */
+    if(usbOpenDevice(&handle, vid, vendor, pid, product, NULL, NULL, NULL) != 0){
+        fprintf(stderr, "Could not find USB device \"%s\" with vid=0x%x pid=0x%x\n", product, vid, pid);
+        exit(1);
+    }
+    /* Since we use only control endpoint 0, we don't need to choose a
+     * configuration and interface. Reading device descriptor and setting a
+     * configuration and interface is done through endpoint 0 after all.
+     * However, newer versions of Linux require that we claim an interface
+     * even for endpoint 0. Enable the following code if your operating system
+     * needs it: */
+#if 0
+    int retries = 1, usbConfiguration = 1, usbInterface = 0;
+    if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+        fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+    }
+    /* now try to claim the interface and detach the kernel HID driver on
+     * Linux and other operating systems which support the call. */
+    while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+        if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+            fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+        }
+#endif
+    }
+#endif
+
+    if(strcasecmp(argv[1], "status") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_GET_STATUS, 0, 0, buffer, sizeof(buffer), 5000);
+        if(cnt < 1){
+            if(cnt < 0){
+                fprintf(stderr, "USB error: %s\n", usb_strerror());
+            }else{
+                fprintf(stderr, "only %d bytes received.\n", cnt);
+            }
+        }else{
+            printf("LED is %s\n", buffer[0] ? "on" : "off");
+        }
+    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
+        if(cnt < 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+#if ENABLE_TEST
+    }else if(strcasecmp(argv[1], "test") == 0){
+        int i;
+        srandomdev();
+        for(i = 0; i < 50000; i++){
+            int value = random() & 0xffff, index = random() & 0xffff;
+            int rxValue, rxIndex;
+            if((i+1) % 100 == 0){
+                fprintf(stderr, "\r%05d", i+1);
+                fflush(stderr);
+            }
+            cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_ECHO, value, index, buffer, sizeof(buffer), 5000);
+            if(cnt < 0){
+                fprintf(stderr, "\nUSB error in iteration %d: %s\n", i, usb_strerror());
+                break;
+            }else if(cnt != 4){
+                fprintf(stderr, "\nerror in iteration %d: %d bytes received instead of 4\n", i, cnt);
+                break;
+            }
+            rxValue = ((int)buffer[0] & 0xff) | (((int)buffer[1] & 0xff) << 8);
+            rxIndex = ((int)buffer[2] & 0xff) | (((int)buffer[3] & 0xff) << 8);
+            if(rxValue != value || rxIndex != index){
+                fprintf(stderr, "\ndata error in iteration %d:\n", i);
+                fprintf(stderr, "rxValue = 0x%04x value = 0x%04x\n", rxValue, value);
+                fprintf(stderr, "rxIndex = 0x%04x index = 0x%04x\n", rxIndex, index);
+            }
+        }
+        fprintf(stderr, "\nTest completed.\n");
+#endif /* ENABLE_TEST */
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usb_close(handle);
+    return 0;
+}
Index: vusb-20121206/examples/custom-class/firmware/Makefile
===================================================================
--- vusb-20121206/examples/custom-class/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/custom-class/firmware/main.c
===================================================================
--- vusb-20121206/examples/custom-class/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/main.c	(working copy)
@@ -0,0 +1,96 @@
+/* Name: main.c
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+We assume that an LED is connected to port B bit 0. If you connect it to a
+different port or bit, change the macros below:
+*/
+#define LED_PORT_DDR        DDRB
+#define LED_PORT_OUTPUT     PORTB
+#define LED_BIT             0
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+#include "requests.h"       /* The custom request numbers we use */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+static uchar    dataBuffer[4];  /* buffer must stay valid when usbFunctionSetup returns */
+
+    if(rq->bRequest == CUSTOM_RQ_ECHO){ /* echo -- used for reliability tests */
+        dataBuffer[0] = rq->wValue.bytes[0];
+        dataBuffer[1] = rq->wValue.bytes[1];
+        dataBuffer[2] = rq->wIndex.bytes[0];
+        dataBuffer[3] = rq->wIndex.bytes[1];
+        usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+        return 4;
+    }else if(rq->bRequest == CUSTOM_RQ_SET_STATUS){
+        if(rq->wValue.bytes[0] & 1){    /* set LED */
+            LED_PORT_OUTPUT |= _BV(LED_BIT);
+        }else{                          /* clear LED */
+            LED_PORT_OUTPUT &= ~_BV(LED_BIT);
+        }
+    }else if(rq->bRequest == CUSTOM_RQ_GET_STATUS){
+        dataBuffer[0] = ((LED_PORT_OUTPUT & _BV(LED_BIT)) != 0);
+        usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+        return 1;                       /* tell the driver to send 1 byte */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    LED_PORT_DDR |= _BV(LED_BIT);   /* make the LED bit an output */
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/custom-class/firmware/requests.h
===================================================================
--- vusb-20121206/examples/custom-class/firmware/requests.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/requests.h	(working copy)
@@ -0,0 +1,35 @@
+/* Name: requests.h
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* This header is shared between the firmware and the host software. It
+ * defines the USB request numbers (and optionally data types) used to
+ * communicate between the host and the device.
+ */
+
+#ifndef __REQUESTS_H_INCLUDED__
+#define __REQUESTS_H_INCLUDED__
+
+#define CUSTOM_RQ_ECHO          0
+/* Request that the device sends back wValue and wIndex. This is used with
+ * random data to test the reliability of the communication.
+ */
+#define CUSTOM_RQ_SET_STATUS    1
+/* Set the LED status. Control-OUT.
+ * The requested status is passed in the "wValue" field of the control
+ * transfer. No OUT data is sent. Bit 0 of the low byte of wValue controls
+ * the LED.
+ */
+
+#define CUSTOM_RQ_GET_STATUS    2
+/* Get the current LED status. Control-IN.
+ * This control transfer involves a 1 byte data phase where the device sends
+ * the current status to the host. The status is in bit 0 of the byte.
+ */
+
+#endif /* __REQUESTS_H_INCLUDED__ */
Index: vusb-20121206/examples/custom-class/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/custom-class/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    0
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdc, 0x05 /* = 0x05dc = 1500 */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'L', 'E', 'D', 'C', 'o', 'n', 't', 'r', 'o', 'l'
+#define USB_CFG_DEVICE_NAME_LEN 10
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/custom-class/firmware/main.c
===================================================================
--- vusb-20121206/examples/custom-class/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/main.c	(working copy)
@@ -0,0 +1,96 @@
+/* Name: main.c
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+We assume that an LED is connected to port B bit 0. If you connect it to a
+different port or bit, change the macros below:
+*/
+#define LED_PORT_DDR        DDRB
+#define LED_PORT_OUTPUT     PORTB
+#define LED_BIT             0
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+#include "requests.h"       /* The custom request numbers we use */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+static uchar    dataBuffer[4];  /* buffer must stay valid when usbFunctionSetup returns */
+
+    if(rq->bRequest == CUSTOM_RQ_ECHO){ /* echo -- used for reliability tests */
+        dataBuffer[0] = rq->wValue.bytes[0];
+        dataBuffer[1] = rq->wValue.bytes[1];
+        dataBuffer[2] = rq->wIndex.bytes[0];
+        dataBuffer[3] = rq->wIndex.bytes[1];
+        usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+        return 4;
+    }else if(rq->bRequest == CUSTOM_RQ_SET_STATUS){
+        if(rq->wValue.bytes[0] & 1){    /* set LED */
+            LED_PORT_OUTPUT |= _BV(LED_BIT);
+        }else{                          /* clear LED */
+            LED_PORT_OUTPUT &= ~_BV(LED_BIT);
+        }
+    }else if(rq->bRequest == CUSTOM_RQ_GET_STATUS){
+        dataBuffer[0] = ((LED_PORT_OUTPUT & _BV(LED_BIT)) != 0);
+        usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+        return 1;                       /* tell the driver to send 1 byte */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    LED_PORT_DDR |= _BV(LED_BIT);   /* make the LED bit an output */
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/custom-class/firmware/Makefile
===================================================================
--- vusb-20121206/examples/custom-class/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/custom-class/firmware/requests.h
===================================================================
--- vusb-20121206/examples/custom-class/firmware/requests.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/requests.h	(working copy)
@@ -0,0 +1,35 @@
+/* Name: requests.h
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* This header is shared between the firmware and the host software. It
+ * defines the USB request numbers (and optionally data types) used to
+ * communicate between the host and the device.
+ */
+
+#ifndef __REQUESTS_H_INCLUDED__
+#define __REQUESTS_H_INCLUDED__
+
+#define CUSTOM_RQ_ECHO          0
+/* Request that the device sends back wValue and wIndex. This is used with
+ * random data to test the reliability of the communication.
+ */
+#define CUSTOM_RQ_SET_STATUS    1
+/* Set the LED status. Control-OUT.
+ * The requested status is passed in the "wValue" field of the control
+ * transfer. No OUT data is sent. Bit 0 of the low byte of wValue controls
+ * the LED.
+ */
+
+#define CUSTOM_RQ_GET_STATUS    2
+/* Get the current LED status. Control-IN.
+ * This control transfer involves a 1 byte data phase where the device sends
+ * the current status to the host. The status is in bit 0 of the byte.
+ */
+
+#endif /* __REQUESTS_H_INCLUDED__ */
Index: vusb-20121206/examples/custom-class/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/custom-class/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/custom-class/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    0
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdc, 0x05 /* = 0x05dc = 1500 */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'L', 'E', 'D', 'C', 'o', 'n', 't', 'r', 'o', 'l'
+#define USB_CFG_DEVICE_NAME_LEN 10
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/custom-class/Readme.txt
===================================================================
--- vusb-20121206/examples/custom-class/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/custom-class/Readme.txt	(working copy)
@@ -0,0 +1,64 @@
+This is the Readme file for the custom-class example. In this example, we
+show how an LED can be controlled via USB.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example shows how small amounts of data (several bytes) can be
+transferred between the device and the host. In addition to a very basic
+USB device, it demonstrates how to build a host side driver application
+using libusb or libusb-win32. It does NOT show how usbFunctionWrite() and
+usbFunctionRead() are used. See the hid-data example if you want to learn
+about these functions.
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+Host development environment: A C compiler and libusb. See the top level
+Readme file, section Prerequisites for more information.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware. You should have wired an LED with a
+current limiting resistor of ca. 270 Ohm to a free I/O pin. Change the
+defines in main.c to match the port and bit number.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+BUILDING THE HOST SOFTWARE
+==========================
+Since the host software is based on libusb or libusb-win32, make sure that
+this library is installed. On Unix, ensure that libusb-config is in your
+search PATH. On Windows, edit Makefile.windows and set the library path
+appropriately. Then type "make" on Unix or "make -f Makefile.windows" on
+Windows to build the command line tool.
+
+
+USING THE COMMAND LINE TOOL
+===========================
+The command line tool has three valid arguments: "status" to query the
+current LED status, "on" to turn on the LED and "off" to turn it off.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-custom-rq/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-custom-rq/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/Readme.txt	(working copy)
@@ -0,0 +1,28 @@
+This is the Readme file for the hid-custom-rq example. This is basically the
+same as the custom-class example, except that the device conforms to the USB
+HID class.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how custom requests can be sent to devices which
+are otherwise HID compliant. This mechanism can be used to prevent the
+"driver CD" dialog on Windows and still control the device with libusb-win32.
+It can also be used to extend the functionality of the USB class, e.g. by
+setting parameters.
+
+Please note that you should install the filter version of libusb-win32 to
+take full advantage or this mode. The device driver version only has access
+to devices which have been registered for it with a *.inf file. The filter
+version has access to all devices.
+
+
+MORE INFORMATION
+================
+For information about how to build this example and how to use the command
+line tool see the Readme file in the custom-class example.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-custom-rq/commandline/Makefile
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = set-led
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-custom-rq/commandline/set-led.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/set-led.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/set-led.c	(working copy)
@@ -0,0 +1,134 @@
+/* Name: set-led.c
+ * Project: hid-custom-rq example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This is the host-side driver for the custom-class example device. It searches
+the USB for the LEDControl device and sends the requests understood by this
+device.
+This program must be linked with libusb on Unix and libusb-win32 on Windows.
+See http://libusb.sourceforge.net/ or http://libusb-win32.sourceforge.net/
+respectively.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <usb.h>        /* this is libusb */
+#include "opendevice.h" /* common code moved to separate module */
+
+#include "../firmware/requests.h"   /* custom request numbers */
+#include "../firmware/usbconfig.h"  /* device's VID/PID and names */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s on ....... turn on LED\n", name);
+    fprintf(stderr, "  %s off ...... turn off LED\n", name);
+    fprintf(stderr, "  %s status ... ask current status of LED\n", name);
+#if ENABLE_TEST
+    fprintf(stderr, "  %s test ..... run driver reliability test\n", name);
+#endif /* ENABLE_TEST */
+}
+
+int main(int argc, char **argv)
+{
+usb_dev_handle      *handle = NULL;
+const unsigned char rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char                vendor[] = {USB_CFG_VENDOR_NAME, 0}, product[] = {USB_CFG_DEVICE_NAME, 0};
+char                buffer[4];
+int                 cnt, vid, pid, isOn;
+
+    usb_init();
+    if(argc < 2){   /* we need at least one argument */
+        usage(argv[0]);
+        exit(1);
+    }
+    /* compute VID/PID from usbconfig.h so that there is a central source of information */
+    vid = rawVid[1] * 256 + rawVid[0];
+    pid = rawPid[1] * 256 + rawPid[0];
+    /* The following function is in opendevice.c: */
+    if(usbOpenDevice(&handle, vid, vendor, pid, product, NULL, NULL, NULL) != 0){
+        fprintf(stderr, "Could not find USB device \"%s\" with vid=0x%x pid=0x%x\n", product, vid, pid);
+        exit(1);
+    }
+    /* Since we use only control endpoint 0, we don't need to choose a
+     * configuration and interface. Reading device descriptor and setting a
+     * configuration and interface is done through endpoint 0 after all.
+     * However, newer versions of Linux require that we claim an interface
+     * even for endpoint 0. Enable the following code if your operating system
+     * needs it: */
+#if 0
+    int retries = 1, usbConfiguration = 1, usbInterface = 0;
+    if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+        fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+    }
+    /* now try to claim the interface and detach the kernel HID driver on
+     * Linux and other operating systems which support the call. */
+    while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+        if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+            fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+        }
+#endif
+    }
+#endif
+
+    if(strcasecmp(argv[1], "status") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_GET_STATUS, 0, 0, buffer, sizeof(buffer), 5000);
+        if(cnt < 1){
+            if(cnt < 0){
+                fprintf(stderr, "USB error: %s\n", usb_strerror());
+            }else{
+                fprintf(stderr, "only %d bytes received.\n", cnt);
+            }
+        }else{
+            printf("LED is %s\n", buffer[0] ? "on" : "off");
+        }
+    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
+        if(cnt < 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+#if ENABLE_TEST
+    }else if(strcasecmp(argv[1], "test") == 0){
+        int i;
+        srandomdev();
+        for(i = 0; i < 50000; i++){
+            int value = random() & 0xffff, index = random() & 0xffff;
+            int rxValue, rxIndex;
+            if((i+1) % 100 == 0){
+                fprintf(stderr, "\r%05d", i+1);
+                fflush(stderr);
+            }
+            cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_ECHO, value, index, buffer, sizeof(buffer), 5000);
+            if(cnt < 0){
+                fprintf(stderr, "\nUSB error in iteration %d: %s\n", i, usb_strerror());
+                break;
+            }else if(cnt != 4){
+                fprintf(stderr, "\nerror in iteration %d: %d bytes received instead of 4\n", i, cnt);
+                break;
+            }
+            rxValue = ((int)buffer[0] & 0xff) | (((int)buffer[1] & 0xff) << 8);
+            rxIndex = ((int)buffer[2] & 0xff) | (((int)buffer[3] & 0xff) << 8);
+            if(rxValue != value || rxIndex != index){
+                fprintf(stderr, "\ndata error in iteration %d:\n", i);
+                fprintf(stderr, "rxValue = 0x%04x value = 0x%04x\n", rxValue, value);
+                fprintf(stderr, "rxIndex = 0x%04x index = 0x%04x\n", rxIndex, index);
+            }
+        }
+        fprintf(stderr, "\nTest completed.\n");
+#endif /* ENABLE_TEST */
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usb_close(handle);
+    return 0;
+}
Index: vusb-20121206/examples/hid-custom-rq/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-custom-rq/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/main.c	(working copy)
@@ -0,0 +1,119 @@
+/* Name: main.c
+ * Project: hid-custom-rq example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-07
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+We assume that an LED is connected to port B bit 0. If you connect it to a
+different port or bit, change the macros below:
+*/
+#define LED_PORT_DDR        DDRB
+#define LED_PORT_OUTPUT     PORTB
+#define LED_BIT             0
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+#include "requests.h"       /* The custom request numbers we use */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[22] = {   /* USB report descriptor */
+    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
+    0x09, 0x01,                    // USAGE (Vendor Usage 1)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x09, 0x00,                    //   USAGE (Undefined)
+    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)
+    0xc0                           // END_COLLECTION
+};
+/* The descriptor above is a dummy only, it silences the drivers. The report
+ * it describes consists of one byte of undefined data.
+ * We don't transfer our data through HID reports, we use custom requests
+ * instead.
+ */
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_VENDOR){
+        DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
+        if(rq->bRequest == CUSTOM_RQ_SET_STATUS){
+            if(rq->wValue.bytes[0] & 1){    /* set LED */
+                LED_PORT_OUTPUT |= _BV(LED_BIT);
+            }else{                          /* clear LED */
+                LED_PORT_OUTPUT &= ~_BV(LED_BIT);
+            }
+        }else if(rq->bRequest == CUSTOM_RQ_GET_STATUS){
+            static uchar dataBuffer[1];     /* buffer must stay valid when usbFunctionSetup returns */
+            dataBuffer[0] = ((LED_PORT_OUTPUT & _BV(LED_BIT)) != 0);
+            usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+            return 1;                       /* tell the driver to send 1 byte */
+        }
+    }else{
+        /* calss requests USBRQ_HID_GET_REPORT and USBRQ_HID_SET_REPORT are
+         * not implemented since we never call them. The operating system
+         * won't call them either because our descriptor defines no meaning.
+         */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    LED_PORT_DDR |= _BV(LED_BIT);   /* make the LED bit an output */
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+#if 0   /* this is a bit too aggressive for a debug output */
+        DBG2(0x02, 0, 0);   /* debug output: main loop iterates */
+#endif
+        wdt_reset();
+        usbPoll();
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-custom-rq/firmware/requests.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/requests.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/requests.h	(working copy)
@@ -0,0 +1,31 @@
+/* Name: requests.h
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* This header is shared between the firmware and the host software. It
+ * defines the USB request numbers (and optionally data types) used to
+ * communicate between the host and the device.
+ */
+
+#ifndef __REQUESTS_H_INCLUDED__
+#define __REQUESTS_H_INCLUDED__
+
+#define CUSTOM_RQ_SET_STATUS    1
+/* Set the LED status. Control-OUT.
+ * The requested status is passed in the "wValue" field of the control
+ * transfer. No OUT data is sent. Bit 0 of the low byte of wValue controls
+ * the LED.
+ */
+
+#define CUSTOM_RQ_GET_STATUS    2
+/* Get the current LED status. Control-IN.
+ * This control transfer involves a 1 byte data phase where the device sends
+ * the current status to the host. The status is in bit 0 of the byte.
+ */
+
+#endif /* __REQUESTS_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdf, 0x05 /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'L', 'E', 'D', 'C', 't', 'l', 'H', 'I', 'D'
+#define USB_CFG_DEVICE_NAME_LEN 9
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    22
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-custom-rq/commandline/Makefile
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = set-led
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-custom-rq/commandline/set-led.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/set-led.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/set-led.c	(working copy)
@@ -0,0 +1,134 @@
+/* Name: set-led.c
+ * Project: hid-custom-rq example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This is the host-side driver for the custom-class example device. It searches
+the USB for the LEDControl device and sends the requests understood by this
+device.
+This program must be linked with libusb on Unix and libusb-win32 on Windows.
+See http://libusb.sourceforge.net/ or http://libusb-win32.sourceforge.net/
+respectively.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <usb.h>        /* this is libusb */
+#include "opendevice.h" /* common code moved to separate module */
+
+#include "../firmware/requests.h"   /* custom request numbers */
+#include "../firmware/usbconfig.h"  /* device's VID/PID and names */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s on ....... turn on LED\n", name);
+    fprintf(stderr, "  %s off ...... turn off LED\n", name);
+    fprintf(stderr, "  %s status ... ask current status of LED\n", name);
+#if ENABLE_TEST
+    fprintf(stderr, "  %s test ..... run driver reliability test\n", name);
+#endif /* ENABLE_TEST */
+}
+
+int main(int argc, char **argv)
+{
+usb_dev_handle      *handle = NULL;
+const unsigned char rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char                vendor[] = {USB_CFG_VENDOR_NAME, 0}, product[] = {USB_CFG_DEVICE_NAME, 0};
+char                buffer[4];
+int                 cnt, vid, pid, isOn;
+
+    usb_init();
+    if(argc < 2){   /* we need at least one argument */
+        usage(argv[0]);
+        exit(1);
+    }
+    /* compute VID/PID from usbconfig.h so that there is a central source of information */
+    vid = rawVid[1] * 256 + rawVid[0];
+    pid = rawPid[1] * 256 + rawPid[0];
+    /* The following function is in opendevice.c: */
+    if(usbOpenDevice(&handle, vid, vendor, pid, product, NULL, NULL, NULL) != 0){
+        fprintf(stderr, "Could not find USB device \"%s\" with vid=0x%x pid=0x%x\n", product, vid, pid);
+        exit(1);
+    }
+    /* Since we use only control endpoint 0, we don't need to choose a
+     * configuration and interface. Reading device descriptor and setting a
+     * configuration and interface is done through endpoint 0 after all.
+     * However, newer versions of Linux require that we claim an interface
+     * even for endpoint 0. Enable the following code if your operating system
+     * needs it: */
+#if 0
+    int retries = 1, usbConfiguration = 1, usbInterface = 0;
+    if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+        fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+    }
+    /* now try to claim the interface and detach the kernel HID driver on
+     * Linux and other operating systems which support the call. */
+    while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+        if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+            fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+        }
+#endif
+    }
+#endif
+
+    if(strcasecmp(argv[1], "status") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_GET_STATUS, 0, 0, buffer, sizeof(buffer), 5000);
+        if(cnt < 1){
+            if(cnt < 0){
+                fprintf(stderr, "USB error: %s\n", usb_strerror());
+            }else{
+                fprintf(stderr, "only %d bytes received.\n", cnt);
+            }
+        }else{
+            printf("LED is %s\n", buffer[0] ? "on" : "off");
+        }
+    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
+        if(cnt < 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+#if ENABLE_TEST
+    }else if(strcasecmp(argv[1], "test") == 0){
+        int i;
+        srandomdev();
+        for(i = 0; i < 50000; i++){
+            int value = random() & 0xffff, index = random() & 0xffff;
+            int rxValue, rxIndex;
+            if((i+1) % 100 == 0){
+                fprintf(stderr, "\r%05d", i+1);
+                fflush(stderr);
+            }
+            cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_ECHO, value, index, buffer, sizeof(buffer), 5000);
+            if(cnt < 0){
+                fprintf(stderr, "\nUSB error in iteration %d: %s\n", i, usb_strerror());
+                break;
+            }else if(cnt != 4){
+                fprintf(stderr, "\nerror in iteration %d: %d bytes received instead of 4\n", i, cnt);
+                break;
+            }
+            rxValue = ((int)buffer[0] & 0xff) | (((int)buffer[1] & 0xff) << 8);
+            rxIndex = ((int)buffer[2] & 0xff) | (((int)buffer[3] & 0xff) << 8);
+            if(rxValue != value || rxIndex != index){
+                fprintf(stderr, "\ndata error in iteration %d:\n", i);
+                fprintf(stderr, "rxValue = 0x%04x value = 0x%04x\n", rxValue, value);
+                fprintf(stderr, "rxIndex = 0x%04x index = 0x%04x\n", rxIndex, index);
+            }
+        }
+        fprintf(stderr, "\nTest completed.\n");
+#endif /* ENABLE_TEST */
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usb_close(handle);
+    return 0;
+}
Index: vusb-20121206/examples/hid-custom-rq/commandline/Makefile
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = set-led
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-custom-rq/commandline/set-led.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/commandline/set-led.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/commandline/set-led.c	(working copy)
@@ -0,0 +1,134 @@
+/* Name: set-led.c
+ * Project: hid-custom-rq example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This is the host-side driver for the custom-class example device. It searches
+the USB for the LEDControl device and sends the requests understood by this
+device.
+This program must be linked with libusb on Unix and libusb-win32 on Windows.
+See http://libusb.sourceforge.net/ or http://libusb-win32.sourceforge.net/
+respectively.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <usb.h>        /* this is libusb */
+#include "opendevice.h" /* common code moved to separate module */
+
+#include "../firmware/requests.h"   /* custom request numbers */
+#include "../firmware/usbconfig.h"  /* device's VID/PID and names */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s on ....... turn on LED\n", name);
+    fprintf(stderr, "  %s off ...... turn off LED\n", name);
+    fprintf(stderr, "  %s status ... ask current status of LED\n", name);
+#if ENABLE_TEST
+    fprintf(stderr, "  %s test ..... run driver reliability test\n", name);
+#endif /* ENABLE_TEST */
+}
+
+int main(int argc, char **argv)
+{
+usb_dev_handle      *handle = NULL;
+const unsigned char rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char                vendor[] = {USB_CFG_VENDOR_NAME, 0}, product[] = {USB_CFG_DEVICE_NAME, 0};
+char                buffer[4];
+int                 cnt, vid, pid, isOn;
+
+    usb_init();
+    if(argc < 2){   /* we need at least one argument */
+        usage(argv[0]);
+        exit(1);
+    }
+    /* compute VID/PID from usbconfig.h so that there is a central source of information */
+    vid = rawVid[1] * 256 + rawVid[0];
+    pid = rawPid[1] * 256 + rawPid[0];
+    /* The following function is in opendevice.c: */
+    if(usbOpenDevice(&handle, vid, vendor, pid, product, NULL, NULL, NULL) != 0){
+        fprintf(stderr, "Could not find USB device \"%s\" with vid=0x%x pid=0x%x\n", product, vid, pid);
+        exit(1);
+    }
+    /* Since we use only control endpoint 0, we don't need to choose a
+     * configuration and interface. Reading device descriptor and setting a
+     * configuration and interface is done through endpoint 0 after all.
+     * However, newer versions of Linux require that we claim an interface
+     * even for endpoint 0. Enable the following code if your operating system
+     * needs it: */
+#if 0
+    int retries = 1, usbConfiguration = 1, usbInterface = 0;
+    if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+        fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+    }
+    /* now try to claim the interface and detach the kernel HID driver on
+     * Linux and other operating systems which support the call. */
+    while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+        if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+            fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+        }
+#endif
+    }
+#endif
+
+    if(strcasecmp(argv[1], "status") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_GET_STATUS, 0, 0, buffer, sizeof(buffer), 5000);
+        if(cnt < 1){
+            if(cnt < 0){
+                fprintf(stderr, "USB error: %s\n", usb_strerror());
+            }else{
+                fprintf(stderr, "only %d bytes received.\n", cnt);
+            }
+        }else{
+            printf("LED is %s\n", buffer[0] ? "on" : "off");
+        }
+    }else if((isOn = (strcasecmp(argv[1], "on") == 0)) || strcasecmp(argv[1], "off") == 0){
+        cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, CUSTOM_RQ_SET_STATUS, isOn, 0, buffer, 0, 5000);
+        if(cnt < 0){
+            fprintf(stderr, "USB error: %s\n", usb_strerror());
+        }
+#if ENABLE_TEST
+    }else if(strcasecmp(argv[1], "test") == 0){
+        int i;
+        srandomdev();
+        for(i = 0; i < 50000; i++){
+            int value = random() & 0xffff, index = random() & 0xffff;
+            int rxValue, rxIndex;
+            if((i+1) % 100 == 0){
+                fprintf(stderr, "\r%05d", i+1);
+                fflush(stderr);
+            }
+            cnt = usb_control_msg(handle, USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN, CUSTOM_RQ_ECHO, value, index, buffer, sizeof(buffer), 5000);
+            if(cnt < 0){
+                fprintf(stderr, "\nUSB error in iteration %d: %s\n", i, usb_strerror());
+                break;
+            }else if(cnt != 4){
+                fprintf(stderr, "\nerror in iteration %d: %d bytes received instead of 4\n", i, cnt);
+                break;
+            }
+            rxValue = ((int)buffer[0] & 0xff) | (((int)buffer[1] & 0xff) << 8);
+            rxIndex = ((int)buffer[2] & 0xff) | (((int)buffer[3] & 0xff) << 8);
+            if(rxValue != value || rxIndex != index){
+                fprintf(stderr, "\ndata error in iteration %d:\n", i);
+                fprintf(stderr, "rxValue = 0x%04x value = 0x%04x\n", rxValue, value);
+                fprintf(stderr, "rxIndex = 0x%04x index = 0x%04x\n", rxIndex, index);
+            }
+        }
+        fprintf(stderr, "\nTest completed.\n");
+#endif /* ENABLE_TEST */
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usb_close(handle);
+    return 0;
+}
Index: vusb-20121206/examples/hid-custom-rq/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-custom-rq/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/main.c	(working copy)
@@ -0,0 +1,119 @@
+/* Name: main.c
+ * Project: hid-custom-rq example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-07
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+We assume that an LED is connected to port B bit 0. If you connect it to a
+different port or bit, change the macros below:
+*/
+#define LED_PORT_DDR        DDRB
+#define LED_PORT_OUTPUT     PORTB
+#define LED_BIT             0
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+#include "requests.h"       /* The custom request numbers we use */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[22] = {   /* USB report descriptor */
+    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
+    0x09, 0x01,                    // USAGE (Vendor Usage 1)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x09, 0x00,                    //   USAGE (Undefined)
+    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)
+    0xc0                           // END_COLLECTION
+};
+/* The descriptor above is a dummy only, it silences the drivers. The report
+ * it describes consists of one byte of undefined data.
+ * We don't transfer our data through HID reports, we use custom requests
+ * instead.
+ */
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_VENDOR){
+        DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
+        if(rq->bRequest == CUSTOM_RQ_SET_STATUS){
+            if(rq->wValue.bytes[0] & 1){    /* set LED */
+                LED_PORT_OUTPUT |= _BV(LED_BIT);
+            }else{                          /* clear LED */
+                LED_PORT_OUTPUT &= ~_BV(LED_BIT);
+            }
+        }else if(rq->bRequest == CUSTOM_RQ_GET_STATUS){
+            static uchar dataBuffer[1];     /* buffer must stay valid when usbFunctionSetup returns */
+            dataBuffer[0] = ((LED_PORT_OUTPUT & _BV(LED_BIT)) != 0);
+            usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+            return 1;                       /* tell the driver to send 1 byte */
+        }
+    }else{
+        /* calss requests USBRQ_HID_GET_REPORT and USBRQ_HID_SET_REPORT are
+         * not implemented since we never call them. The operating system
+         * won't call them either because our descriptor defines no meaning.
+         */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    LED_PORT_DDR |= _BV(LED_BIT);   /* make the LED bit an output */
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+#if 0   /* this is a bit too aggressive for a debug output */
+        DBG2(0x02, 0, 0);   /* debug output: main loop iterates */
+#endif
+        wdt_reset();
+        usbPoll();
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-custom-rq/firmware/requests.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/requests.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/requests.h	(working copy)
@@ -0,0 +1,31 @@
+/* Name: requests.h
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* This header is shared between the firmware and the host software. It
+ * defines the USB request numbers (and optionally data types) used to
+ * communicate between the host and the device.
+ */
+
+#ifndef __REQUESTS_H_INCLUDED__
+#define __REQUESTS_H_INCLUDED__
+
+#define CUSTOM_RQ_SET_STATUS    1
+/* Set the LED status. Control-OUT.
+ * The requested status is passed in the "wValue" field of the control
+ * transfer. No OUT data is sent. Bit 0 of the low byte of wValue controls
+ * the LED.
+ */
+
+#define CUSTOM_RQ_GET_STATUS    2
+/* Get the current LED status. Control-IN.
+ * This control transfer involves a 1 byte data phase where the device sends
+ * the current status to the host. The status is in bit 0 of the byte.
+ */
+
+#endif /* __REQUESTS_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdf, 0x05 /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'L', 'E', 'D', 'C', 't', 'l', 'H', 'I', 'D'
+#define USB_CFG_DEVICE_NAME_LEN 9
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    22
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-custom-rq/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/main.c	(working copy)
@@ -0,0 +1,119 @@
+/* Name: main.c
+ * Project: hid-custom-rq example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-07
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+We assume that an LED is connected to port B bit 0. If you connect it to a
+different port or bit, change the macros below:
+*/
+#define LED_PORT_DDR        DDRB
+#define LED_PORT_OUTPUT     PORTB
+#define LED_BIT             0
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+#include "requests.h"       /* The custom request numbers we use */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[22] = {   /* USB report descriptor */
+    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
+    0x09, 0x01,                    // USAGE (Vendor Usage 1)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x09, 0x00,                    //   USAGE (Undefined)
+    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)
+    0xc0                           // END_COLLECTION
+};
+/* The descriptor above is a dummy only, it silences the drivers. The report
+ * it describes consists of one byte of undefined data.
+ * We don't transfer our data through HID reports, we use custom requests
+ * instead.
+ */
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_VENDOR){
+        DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
+        if(rq->bRequest == CUSTOM_RQ_SET_STATUS){
+            if(rq->wValue.bytes[0] & 1){    /* set LED */
+                LED_PORT_OUTPUT |= _BV(LED_BIT);
+            }else{                          /* clear LED */
+                LED_PORT_OUTPUT &= ~_BV(LED_BIT);
+            }
+        }else if(rq->bRequest == CUSTOM_RQ_GET_STATUS){
+            static uchar dataBuffer[1];     /* buffer must stay valid when usbFunctionSetup returns */
+            dataBuffer[0] = ((LED_PORT_OUTPUT & _BV(LED_BIT)) != 0);
+            usbMsgPtr = dataBuffer;         /* tell the driver which data to return */
+            return 1;                       /* tell the driver to send 1 byte */
+        }
+    }else{
+        /* calss requests USBRQ_HID_GET_REPORT and USBRQ_HID_SET_REPORT are
+         * not implemented since we never call them. The operating system
+         * won't call them either because our descriptor defines no meaning.
+         */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    LED_PORT_DDR |= _BV(LED_BIT);   /* make the LED bit an output */
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+#if 0   /* this is a bit too aggressive for a debug output */
+        DBG2(0x02, 0, 0);   /* debug output: main loop iterates */
+#endif
+        wdt_reset();
+        usbPoll();
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-custom-rq/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-custom-rq example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-custom-rq/firmware/requests.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/requests.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/requests.h	(working copy)
@@ -0,0 +1,31 @@
+/* Name: requests.h
+ * Project: custom-class, a basic USB example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-09
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* This header is shared between the firmware and the host software. It
+ * defines the USB request numbers (and optionally data types) used to
+ * communicate between the host and the device.
+ */
+
+#ifndef __REQUESTS_H_INCLUDED__
+#define __REQUESTS_H_INCLUDED__
+
+#define CUSTOM_RQ_SET_STATUS    1
+/* Set the LED status. Control-OUT.
+ * The requested status is passed in the "wValue" field of the control
+ * transfer. No OUT data is sent. Bit 0 of the low byte of wValue controls
+ * the LED.
+ */
+
+#define CUSTOM_RQ_GET_STATUS    2
+/* Get the current LED status. Control-IN.
+ * This control transfer involves a 1 byte data phase where the device sends
+ * the current status to the host. The status is in bit 0 of the byte.
+ */
+
+#endif /* __REQUESTS_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdf, 0x05 /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'L', 'E', 'D', 'C', 't', 'l', 'H', 'I', 'D'
+#define USB_CFG_DEVICE_NAME_LEN 9
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    22
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-custom-rq/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-custom-rq/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-custom-rq/Readme.txt	(working copy)
@@ -0,0 +1,28 @@
+This is the Readme file for the hid-custom-rq example. This is basically the
+same as the custom-class example, except that the device conforms to the USB
+HID class.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how custom requests can be sent to devices which
+are otherwise HID compliant. This mechanism can be used to prevent the
+"driver CD" dialog on Windows and still control the device with libusb-win32.
+It can also be used to extend the functionality of the USB class, e.g. by
+setting parameters.
+
+Please note that you should install the filter version of libusb-win32 to
+take full advantage or this mode. The device driver version only has access
+to devices which have been registered for it with a *.inf file. The filter
+version has access to all devices.
+
+
+MORE INFORMATION
+================
+For information about how to build this example and how to use the command
+line tool see the Readme file in the custom-class example.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-data/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-data/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-data/Readme.txt	(working copy)
@@ -0,0 +1,75 @@
+This is the Readme file for the hid-data example. In this example, we show
+how blocks of data can be exchanged with the device using only functionality
+compliant to the HID class. Since class drivers for HID are included with
+Windows, you don't need to install drivers on Windows.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how the HID class can be misused to transfer fixed
+size blocks of data (up to the driver's transfer size limit) over HID feature
+reports. This technique is of great value on Windows because no driver DLLs
+are needed (the hid-custom-rq example still requires the libusb-win32 DLL,
+although it may be in the program's directory). The host side application
+requires no installation, it can even be started directly from a CD. This
+example also demonstrates how to transfer data using usbFunctionWrite() and
+usbFunctionRead().
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+Host development environment: A C compiler and libusb on Unix. On Windows
+you need the Driver Development Kit (DDK) Instead of libusb. MinGW ships
+with a free version of the DDK.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+BUILDING THE HOST SOFTWARE
+==========================
+Make sure that you have libusb (on Unix) or the DDK (on Windows) installed.
+We recommend MinGW on Windows since it includes a free version of the DDK.
+Then change to directory "commandline" and run "make" on Unix or
+"make -f Makefile.windows" on Windows.
+
+
+USING THE COMMAND LINE TOOL
+===========================
+The device implements a data store of 128 bytes in EEPROM. You can send a
+block of 128 bytes to the device or read the block using the command line
+tool.
+
+To send a block to the device, use e.g.
+
+    hidtool write 0x01,0x02,0x03,0x04,...
+
+and to receive the block, use
+
+    hidtool read
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-data/commandline/Makefile
===================================================================
--- vusb-20121206/examples/hid-data/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/Makefile	(working copy)
@@ -0,0 +1,41 @@
+# Name: Makefile
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-11
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# Please read the definitions below and edit them as appropriate for your
+# system:
+
+# Use the following 3 lines on Unix and Mac OS X:
+USBFLAGS=   `libusb-config --cflags`
+USBLIBS=    `libusb-config --libs`
+EXE_SUFFIX=
+
+# Use the following 3 lines on Windows and comment out the 3 above:
+#USBFLAGS=
+#USBLIBS=    -lhid -lusb -lsetupapi
+#EXE_SUFFIX= .exe
+
+CC=				gcc
+CFLAGS=			-O -Wall $(USBFLAGS)
+LIBS=			$(USBLIBS)
+
+OBJ=		hidtool.o hiddata.o
+PROGRAM=	hidtool$(EXE_SUFFIX)
+
+all: $(PROGRAM)
+
+$(PROGRAM): $(OBJ)
+	$(CC) -o $(PROGRAM) $(OBJ) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f $(OBJ) $(PROGRAM)
+
+.c.o:
+	$(CC) $(ARCH_COMPILE) $(CFLAGS) -c $*.c -o $*.o
Index: vusb-20121206/examples/hid-data/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/hid-data/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-11
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS=
+USBLIBS=    -lhid -lsetupapi
+EXE_SUFFIX= .exe
Index: vusb-20121206/examples/hid-data/commandline/hiddata.c
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hiddata.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hiddata.c	(working copy)
@@ -0,0 +1,323 @@
+/* Name: hiddata.c
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include "hiddata.h"
+
+/* ######################################################################## */
+#if defined(WIN32) /* ##################################################### */
+/* ######################################################################## */
+
+#include <windows.h>
+#include <setupapi.h>
+#include "hidsdi.h"
+#include <ddk/hidpi.h>
+
+#ifdef DEBUG
+#define DEBUG_PRINT(arg)    printf arg
+#else
+#define DEBUG_PRINT(arg)
+#endif
+
+/* ------------------------------------------------------------------------ */
+
+static void convertUniToAscii(char *buffer)
+{
+unsigned short  *uni = (void *)buffer;
+char            *ascii = buffer;
+
+    while(*uni != 0){
+        if(*uni >= 256){
+            *ascii++ = '?';
+        }else{
+            *ascii++ = *uni++;
+        }
+    }
+    *ascii++ = 0;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int usesReportIDs)
+{
+GUID                                hidGuid;        /* GUID for HID driver */
+HDEVINFO                            deviceInfoList;
+SP_DEVICE_INTERFACE_DATA            deviceInfo;
+SP_DEVICE_INTERFACE_DETAIL_DATA     *deviceDetails = NULL;
+DWORD                               size;
+int                                 i, openFlag = 0;  /* may be FILE_FLAG_OVERLAPPED */
+int                                 errorCode = USBOPEN_ERR_NOTFOUND;
+HANDLE                              handle = INVALID_HANDLE_VALUE;
+HIDD_ATTRIBUTES                     deviceAttributes;
+				
+    HidD_GetHidGuid(&hidGuid);
+    deviceInfoList = SetupDiGetClassDevs(&hidGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
+    deviceInfo.cbSize = sizeof(deviceInfo);
+    for(i=0;;i++){
+        if(handle != INVALID_HANDLE_VALUE){
+            CloseHandle(handle);
+            handle = INVALID_HANDLE_VALUE;
+        }
+        if(!SetupDiEnumDeviceInterfaces(deviceInfoList, 0, &hidGuid, i, &deviceInfo))
+            break;  /* no more entries */
+        /* first do a dummy call just to determine the actual size required */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, NULL, 0, &size, NULL);
+        if(deviceDetails != NULL)
+            free(deviceDetails);
+        deviceDetails = malloc(size);
+        deviceDetails->cbSize = sizeof(*deviceDetails);
+        /* this call is for real: */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, deviceDetails, size, &size, NULL);
+        DEBUG_PRINT(("checking HID path \"%s\"\n", deviceDetails->DevicePath));
+#if 0
+        /* If we want to access a mouse our keyboard, we can only use feature
+         * requests as the device is locked by Windows. It must be opened
+         * with ACCESS_TYPE_NONE.
+         */
+        handle = CreateFile(deviceDetails->DevicePath, ACCESS_TYPE_NONE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+#endif
+        /* attempt opening for R/W -- we don't care about devices which can't be accessed */
+        handle = CreateFile(deviceDetails->DevicePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+        if(handle == INVALID_HANDLE_VALUE){
+            DEBUG_PRINT(("opening failed: %d\n", (int)GetLastError()));
+            /* errorCode = USBOPEN_ERR_ACCESS; opening will always fail for mouse -- ignore */
+            continue;
+        }
+        deviceAttributes.Size = sizeof(deviceAttributes);
+        HidD_GetAttributes(handle, &deviceAttributes);
+        DEBUG_PRINT(("device attributes: vid=%d pid=%d\n", deviceAttributes.VendorID, deviceAttributes.ProductID));
+        if(deviceAttributes.VendorID != vendor || deviceAttributes.ProductID != product)
+            continue;   /* ignore this device */
+        errorCode = USBOPEN_ERR_NOTFOUND;
+        if(vendorName != NULL && productName != NULL){
+            char    buffer[512];
+            if(!HidD_GetManufacturerString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining vendor name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("vendorName = \"%s\"\n", buffer));
+            if(strcmp(vendorName, buffer) != 0)
+                continue;
+            if(!HidD_GetProductString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining product name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("productName = \"%s\"\n", buffer));
+            if(strcmp(productName, buffer) != 0)
+                continue;
+        }
+        break;  /* we have found the device we are looking for! */
+    }
+    SetupDiDestroyDeviceInfoList(deviceInfoList);
+    if(deviceDetails != NULL)
+        free(deviceDetails);
+    if(handle != INVALID_HANDLE_VALUE){
+        *device = (usbDevice_t *)handle;
+        errorCode = 0;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------ */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    CloseHandle((HANDLE)device);
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+BOOLEAN rval;
+
+    rval = HidD_SetFeature((HANDLE)device, buffer, len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+BOOLEAN rval = 0;
+
+    buffer[0] = reportNumber;
+    rval = HidD_GetFeature((HANDLE)device, buffer, *len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+/* ######################################################################## */
+#else /* defined WIN32 #################################################### */
+/* ######################################################################## */
+
+#include <string.h>
+#include <usb.h>
+
+#define usbDevice   usb_dev_handle  /* use libusb's device structure */
+
+/* ------------------------------------------------------------------------- */
+
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_SET_REPORT    0x09
+
+#define USB_HID_REPORT_TYPE_FEATURE 3
+
+
+static int  usesReportIDs;
+
+/* ------------------------------------------------------------------------- */
+
+static int usbhidGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int _usesReportIDs)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+static int          didUsbInit = 0;
+
+    if(!didUsbInit){
+        usb_init();
+        didUsbInit = 1;
+    }
+    usb_find_busses();
+    usb_find_devices();
+    for(bus=usb_get_busses(); bus; bus=bus->next){
+        for(dev=bus->devices; dev; dev=dev->next){
+            if(dev->descriptor.idVendor == vendor && dev->descriptor.idProduct == product){
+                char    string[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    fprintf(stderr, "Warning: cannot open USB device: %s\n", usb_strerror());
+                    continue;
+                }
+                if(vendorName == NULL && productName == NULL){  /* name does not matter */
+                    break;
+                }
+                /* now check whether the names match: */
+                len = usbhidGetStringAscii(handle, dev->descriptor.iManufacturer, string, sizeof(string));
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_IO;
+                    fprintf(stderr, "Warning: cannot query manufacturer for device: %s\n", usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* fprintf(stderr, "seen device from vendor ->%s<-\n", string); */
+                    if(strcmp(string, vendorName) == 0){
+                        len = usbhidGetStringAscii(handle, dev->descriptor.iProduct, string, sizeof(string));
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_IO;
+                            fprintf(stderr, "Warning: cannot query product for device: %s\n", usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* fprintf(stderr, "seen product ->%s<-\n", string); */
+                            if(strcmp(string, productName) == 0)
+                                break;
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = (void *)handle;
+        usesReportIDs = _usesReportIDs;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    if(device != NULL)
+        usb_close((void *)device);
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+int bytesSent, reportId = buffer[0];
+
+    if(!usesReportIDs){
+        buffer++;   /* skip dummy report ID */
+        len--;
+    }
+    bytesSent = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, USBRQ_HID_SET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | (reportId & 0xff), 0, buffer, len, 5000);
+    if(bytesSent != len){
+        if(bytesSent < 0)
+            fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+int bytesReceived, maxLen = *len;
+
+    if(!usesReportIDs){
+        buffer++;   /* make room for dummy report ID */
+        maxLen--;
+    }
+    bytesReceived = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_IN, USBRQ_HID_GET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | reportNumber, 0, buffer, maxLen, 5000);
+    if(bytesReceived < 0){
+        fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    *len = bytesReceived;
+    if(!usesReportIDs){
+        buffer[-1] = reportNumber;  /* add dummy report ID */
+        (*len)++;
+    }
+    return 0;
+}
+
+/* ######################################################################## */
+#endif /* defined WIN32 ################################################### */
+/* ######################################################################## */
Index: vusb-20121206/examples/hid-data/commandline/hiddata.h
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hiddata.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hiddata.h	(working copy)
@@ -0,0 +1,70 @@
+/* Name: hiddata.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __HIDDATA_H_INCLUDED__
+#define __HIDDATA_H_INCLUDED__
+
+/*
+General Description:
+This module implements an abstraction layer for data transfer over HID feature
+requests. The implementation uses native Windows functions on Windows so that
+no driver installation is required and libusb on Unix. You must link the
+appropriate libraries in either case: "-lhid -lusb -lsetupapi" on Windows and
+`libusb-config --libs` on Unix.
+*/
+
+/* ------------------------------------------------------------------------ */
+
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+/* ------------------------------------------------------------------------ */
+
+typedef struct usbDevice    usbDevice_t;
+/* Opaque data type representing the USB device. This can be a Windows handle
+ * or a libusb handle, depending on the backend implementation.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidOpenDevice(usbDevice_t **device, int vendorID, char *vendorName, int productID, char *productName, int usesReportIDs);
+/* This function opens a USB device. 'vendorID' and 'productID' are the numeric
+ * Vendor-ID and Product-ID of the device we want to open. If 'vendorName' and
+ * 'productName' are both not NULL, only devices with matching manufacturer-
+ * and product name strings are accepted. If the device uses report IDs,
+ * 'usesReportIDs' must be set to a non-zero value.
+ * Returns: If a matching device has been found, USBOPEN_SUCCESS is returned
+ * and '*device' is set to an opaque pointer representing the device. The
+ * device must be closed with usbhidCloseDevice(). If the device has not been
+ * found or opening failed, an error code is returned.
+ */
+void    usbhidCloseDevice(usbDevice_t *device);
+/* Every device opened with usbhidOpenDevice() must be closed with this function.
+ */
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len);
+/* This function sends a feature report to the device. The report ID must be
+ * in the first byte of buffer and the length 'len' of the report is specified
+ * including this report ID. If no report IDs are used, buffer[0] must be set
+ * to 0 (dummy report ID).
+ * Returns: 0 on success, an error code otherwise.
+ */
+int usbhidGetReport(usbDevice_t *device, int reportID, char *buffer, int *len);
+/* This function obtains a feature report from the device. The requested
+ * report-ID is passed in 'reportID'. The caller must pass a buffer of the size
+ * of the expected report in 'buffer' and initialize the variable pointed to by
+ * 'len' to the total size of this buffer. Upon successful return, the report
+ * (prefixed with the report-ID) is in 'buffer' and the actual length of the
+ * report is returned in '*len'.
+ * Returns: 0 on success, an error code otherwise.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+#endif /* __HIDDATA_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-data/commandline/hidsdi.h
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hidsdi.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hidsdi.h	(working copy)
@@ -0,0 +1,48 @@
+/* Name: hidsdi.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-02-02
+ * Tabsize: 4
+ * Copyright: (c) 2006-2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description
+This file is a replacement for hidsdi.h from the Windows DDK. It defines some
+of the types and function prototypes of this header for our project. If you
+have the Windows DDK version of this file or a version shipped with MinGW, use
+that instead.
+*/
+
+#ifndef _HIDSDI_H
+#define _HIDSDI_H
+
+#include <pshpack4.h>
+
+#include <ddk/hidusage.h>
+#include <ddk/hidpi.h>
+
+typedef struct{
+    ULONG   Size;
+    USHORT  VendorID;
+    USHORT  ProductID;
+    USHORT  VersionNumber;
+}HIDD_ATTRIBUTES;
+
+void __stdcall      HidD_GetHidGuid(OUT LPGUID hidGuid);
+
+BOOLEAN __stdcall   HidD_GetAttributes(IN HANDLE device, OUT HIDD_ATTRIBUTES *attributes);
+
+BOOLEAN __stdcall   HidD_GetManufacturerString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetProductString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetSerialNumberString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetFeature(IN HANDLE device, OUT void *reportBuffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_SetFeature(IN HANDLE device, IN void *reportBuffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetNumInputBuffers(IN HANDLE device, OUT ULONG *numBuffers);
+BOOLEAN __stdcall   HidD_SetNumInputBuffers(IN HANDLE device, OUT ULONG numBuffers);
+
+#include <poppack.h>
+
+#endif
Index: vusb-20121206/examples/hid-data/commandline/hidtool.c
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hidtool.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hidtool.c	(working copy)
@@ -0,0 +1,126 @@
+/* Name: hidtool.c
+ * Project: hid-data example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "hiddata.h"
+#include "../firmware/usbconfig.h"  /* for device VID, PID, vendor name and product name */
+
+/* ------------------------------------------------------------------------- */
+
+static char *usbErrorMessage(int errCode)
+{
+static char buffer[80];
+
+    switch(errCode){
+        case USBOPEN_ERR_ACCESS:      return "Access to device denied";
+        case USBOPEN_ERR_NOTFOUND:    return "The specified device was not found";
+        case USBOPEN_ERR_IO:          return "Communication error with device";
+        default:
+            sprintf(buffer, "Unknown USB error %d", errCode);
+            return buffer;
+    }
+    return NULL;    /* not reached */
+}
+
+static usbDevice_t  *openDevice(void)
+{
+usbDevice_t     *dev = NULL;
+unsigned char   rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char            vendorName[] = {USB_CFG_VENDOR_NAME, 0}, productName[] = {USB_CFG_DEVICE_NAME, 0};
+int             vid = rawVid[0] + 256 * rawVid[1];
+int             pid = rawPid[0] + 256 * rawPid[1];
+int             err;
+
+    if((err = usbhidOpenDevice(&dev, vid, vendorName, pid, productName, 0)) != 0){
+        fprintf(stderr, "error finding %s: %s\n", productName, usbErrorMessage(err));
+        return NULL;
+    }
+    return dev;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void hexdump(char *buffer, int len)
+{
+int     i;
+FILE    *fp = stdout;
+
+    for(i = 0; i < len; i++){
+        if(i != 0){
+            if(i % 16 == 0){
+                fprintf(fp, "\n");
+            }else{
+                fprintf(fp, " ");
+            }
+        }
+        fprintf(fp, "0x%02x", buffer[i] & 0xff);
+    }
+    if(i != 0)
+        fprintf(fp, "\n");
+}
+
+static int  hexread(char *buffer, char *string, int buflen)
+{
+char    *s;
+int     pos = 0;
+
+    while((s = strtok(string, ", ")) != NULL && pos < buflen){
+        string = NULL;
+        buffer[pos++] = (char)strtol(s, NULL, 0);
+    }
+    return pos;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void usage(char *myName)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s read\n", myName);
+    fprintf(stderr, "  %s write <listofbytes>\n", myName);
+}
+
+int main(int argc, char **argv)
+{
+usbDevice_t *dev;
+char        buffer[129];    /* room for dummy report ID */
+int         err;
+
+    if(argc < 2){
+        usage(argv[0]);
+        exit(1);
+    }
+    if((dev = openDevice()) == NULL)
+        exit(1);
+    if(strcasecmp(argv[1], "read") == 0){
+        int len = sizeof(buffer);
+        if((err = usbhidGetReport(dev, 0, buffer, &len)) != 0){
+            fprintf(stderr, "error reading data: %s\n", usbErrorMessage(err));
+        }else{
+            hexdump(buffer + 1, sizeof(buffer) - 1);
+        }
+    }else if(strcasecmp(argv[1], "write") == 0){
+        int i, pos;
+        memset(buffer, 0, sizeof(buffer));
+        for(pos = 1, i = 2; i < argc && pos < sizeof(buffer); i++){
+            pos += hexread(buffer + pos, argv[i], sizeof(buffer) - pos);
+        }
+        if((err = usbhidSetReport(dev, buffer, sizeof(buffer))) != 0)   /* add a dummy report ID */
+            fprintf(stderr, "error writing data: %s\n", usbErrorMessage(err));
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usbhidCloseDevice(dev);
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-data/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-data/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-data/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-data/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/main.c	(working copy)
@@ -0,0 +1,140 @@
+/* Name: main.c
+ * Project: hid-data, example how to use HID for data transfer
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+*/
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+#include <avr/eeprom.h>
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[22] = {    /* USB report descriptor */
+    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
+    0x09, 0x01,                    // USAGE (Vendor Usage 1)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x95, 0x80,                    //   REPORT_COUNT (128)
+    0x09, 0x00,                    //   USAGE (Undefined)
+    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)
+    0xc0                           // END_COLLECTION
+};
+/* Since we define only one feature report, we don't use report-IDs (which
+ * would be the first byte of the report). The entire report consists of 128
+ * opaque data bytes.
+ */
+
+/* The following variables store the status of the current data transfer */
+static uchar    currentAddress;
+static uchar    bytesRemaining;
+
+/* ------------------------------------------------------------------------- */
+
+/* usbFunctionRead() is called when the host requests a chunk of data from
+ * the device. For more information see the documentation in usbdrv/usbdrv.h.
+ */
+uchar   usbFunctionRead(uchar *data, uchar len)
+{
+    if(len > bytesRemaining)
+        len = bytesRemaining;
+    eeprom_read_block(data, (uchar *)0 + currentAddress, len);
+    currentAddress += len;
+    bytesRemaining -= len;
+    return len;
+}
+
+/* usbFunctionWrite() is called when the host sends a chunk of data to the
+ * device. For more information see the documentation in usbdrv/usbdrv.h.
+ */
+uchar   usbFunctionWrite(uchar *data, uchar len)
+{
+    if(bytesRemaining == 0)
+        return 1;               /* end of transfer */
+    if(len > bytesRemaining)
+        len = bytesRemaining;
+    eeprom_write_block(data, (uchar *)0 + currentAddress, len);
+    currentAddress += len;
+    bytesRemaining -= len;
+    return bytesRemaining == 0; /* return 1 if this was the last chunk */
+}
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* HID class request */
+        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
+            /* since we have only one report type, we can ignore the report-ID */
+            bytesRemaining = 128;
+            currentAddress = 0;
+            return USB_NO_MSG;  /* use usbFunctionRead() to obtain data */
+        }else if(rq->bRequest == USBRQ_HID_SET_REPORT){
+            /* since we have only one report type, we can ignore the report-ID */
+            bytesRemaining = 128;
+            currentAddress = 0;
+            return USB_NO_MSG;  /* use usbFunctionWrite() to receive data from host */
+        }
+    }else{
+        /* ignore vendor type requests, we don't use any */
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-data/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-data/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      1
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       1
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdf, 0x05 /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'D', 'a', 't', 'a', 'S', 't', 'o', 'r', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 9
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    22
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-data/commandline/Makefile
===================================================================
--- vusb-20121206/examples/hid-data/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/Makefile	(working copy)
@@ -0,0 +1,41 @@
+# Name: Makefile
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-11
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# Please read the definitions below and edit them as appropriate for your
+# system:
+
+# Use the following 3 lines on Unix and Mac OS X:
+USBFLAGS=   `libusb-config --cflags`
+USBLIBS=    `libusb-config --libs`
+EXE_SUFFIX=
+
+# Use the following 3 lines on Windows and comment out the 3 above:
+#USBFLAGS=
+#USBLIBS=    -lhid -lusb -lsetupapi
+#EXE_SUFFIX= .exe
+
+CC=				gcc
+CFLAGS=			-O -Wall $(USBFLAGS)
+LIBS=			$(USBLIBS)
+
+OBJ=		hidtool.o hiddata.o
+PROGRAM=	hidtool$(EXE_SUFFIX)
+
+all: $(PROGRAM)
+
+$(PROGRAM): $(OBJ)
+	$(CC) -o $(PROGRAM) $(OBJ) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f $(OBJ) $(PROGRAM)
+
+.c.o:
+	$(CC) $(ARCH_COMPILE) $(CFLAGS) -c $*.c -o $*.o
Index: vusb-20121206/examples/hid-data/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/hid-data/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-11
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS=
+USBLIBS=    -lhid -lsetupapi
+EXE_SUFFIX= .exe
Index: vusb-20121206/examples/hid-data/commandline/hiddata.c
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hiddata.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hiddata.c	(working copy)
@@ -0,0 +1,323 @@
+/* Name: hiddata.c
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include "hiddata.h"
+
+/* ######################################################################## */
+#if defined(WIN32) /* ##################################################### */
+/* ######################################################################## */
+
+#include <windows.h>
+#include <setupapi.h>
+#include "hidsdi.h"
+#include <ddk/hidpi.h>
+
+#ifdef DEBUG
+#define DEBUG_PRINT(arg)    printf arg
+#else
+#define DEBUG_PRINT(arg)
+#endif
+
+/* ------------------------------------------------------------------------ */
+
+static void convertUniToAscii(char *buffer)
+{
+unsigned short  *uni = (void *)buffer;
+char            *ascii = buffer;
+
+    while(*uni != 0){
+        if(*uni >= 256){
+            *ascii++ = '?';
+        }else{
+            *ascii++ = *uni++;
+        }
+    }
+    *ascii++ = 0;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int usesReportIDs)
+{
+GUID                                hidGuid;        /* GUID for HID driver */
+HDEVINFO                            deviceInfoList;
+SP_DEVICE_INTERFACE_DATA            deviceInfo;
+SP_DEVICE_INTERFACE_DETAIL_DATA     *deviceDetails = NULL;
+DWORD                               size;
+int                                 i, openFlag = 0;  /* may be FILE_FLAG_OVERLAPPED */
+int                                 errorCode = USBOPEN_ERR_NOTFOUND;
+HANDLE                              handle = INVALID_HANDLE_VALUE;
+HIDD_ATTRIBUTES                     deviceAttributes;
+				
+    HidD_GetHidGuid(&hidGuid);
+    deviceInfoList = SetupDiGetClassDevs(&hidGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
+    deviceInfo.cbSize = sizeof(deviceInfo);
+    for(i=0;;i++){
+        if(handle != INVALID_HANDLE_VALUE){
+            CloseHandle(handle);
+            handle = INVALID_HANDLE_VALUE;
+        }
+        if(!SetupDiEnumDeviceInterfaces(deviceInfoList, 0, &hidGuid, i, &deviceInfo))
+            break;  /* no more entries */
+        /* first do a dummy call just to determine the actual size required */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, NULL, 0, &size, NULL);
+        if(deviceDetails != NULL)
+            free(deviceDetails);
+        deviceDetails = malloc(size);
+        deviceDetails->cbSize = sizeof(*deviceDetails);
+        /* this call is for real: */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, deviceDetails, size, &size, NULL);
+        DEBUG_PRINT(("checking HID path \"%s\"\n", deviceDetails->DevicePath));
+#if 0
+        /* If we want to access a mouse our keyboard, we can only use feature
+         * requests as the device is locked by Windows. It must be opened
+         * with ACCESS_TYPE_NONE.
+         */
+        handle = CreateFile(deviceDetails->DevicePath, ACCESS_TYPE_NONE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+#endif
+        /* attempt opening for R/W -- we don't care about devices which can't be accessed */
+        handle = CreateFile(deviceDetails->DevicePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+        if(handle == INVALID_HANDLE_VALUE){
+            DEBUG_PRINT(("opening failed: %d\n", (int)GetLastError()));
+            /* errorCode = USBOPEN_ERR_ACCESS; opening will always fail for mouse -- ignore */
+            continue;
+        }
+        deviceAttributes.Size = sizeof(deviceAttributes);
+        HidD_GetAttributes(handle, &deviceAttributes);
+        DEBUG_PRINT(("device attributes: vid=%d pid=%d\n", deviceAttributes.VendorID, deviceAttributes.ProductID));
+        if(deviceAttributes.VendorID != vendor || deviceAttributes.ProductID != product)
+            continue;   /* ignore this device */
+        errorCode = USBOPEN_ERR_NOTFOUND;
+        if(vendorName != NULL && productName != NULL){
+            char    buffer[512];
+            if(!HidD_GetManufacturerString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining vendor name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("vendorName = \"%s\"\n", buffer));
+            if(strcmp(vendorName, buffer) != 0)
+                continue;
+            if(!HidD_GetProductString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining product name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("productName = \"%s\"\n", buffer));
+            if(strcmp(productName, buffer) != 0)
+                continue;
+        }
+        break;  /* we have found the device we are looking for! */
+    }
+    SetupDiDestroyDeviceInfoList(deviceInfoList);
+    if(deviceDetails != NULL)
+        free(deviceDetails);
+    if(handle != INVALID_HANDLE_VALUE){
+        *device = (usbDevice_t *)handle;
+        errorCode = 0;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------ */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    CloseHandle((HANDLE)device);
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+BOOLEAN rval;
+
+    rval = HidD_SetFeature((HANDLE)device, buffer, len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+BOOLEAN rval = 0;
+
+    buffer[0] = reportNumber;
+    rval = HidD_GetFeature((HANDLE)device, buffer, *len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+/* ######################################################################## */
+#else /* defined WIN32 #################################################### */
+/* ######################################################################## */
+
+#include <string.h>
+#include <usb.h>
+
+#define usbDevice   usb_dev_handle  /* use libusb's device structure */
+
+/* ------------------------------------------------------------------------- */
+
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_SET_REPORT    0x09
+
+#define USB_HID_REPORT_TYPE_FEATURE 3
+
+
+static int  usesReportIDs;
+
+/* ------------------------------------------------------------------------- */
+
+static int usbhidGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int _usesReportIDs)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+static int          didUsbInit = 0;
+
+    if(!didUsbInit){
+        usb_init();
+        didUsbInit = 1;
+    }
+    usb_find_busses();
+    usb_find_devices();
+    for(bus=usb_get_busses(); bus; bus=bus->next){
+        for(dev=bus->devices; dev; dev=dev->next){
+            if(dev->descriptor.idVendor == vendor && dev->descriptor.idProduct == product){
+                char    string[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    fprintf(stderr, "Warning: cannot open USB device: %s\n", usb_strerror());
+                    continue;
+                }
+                if(vendorName == NULL && productName == NULL){  /* name does not matter */
+                    break;
+                }
+                /* now check whether the names match: */
+                len = usbhidGetStringAscii(handle, dev->descriptor.iManufacturer, string, sizeof(string));
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_IO;
+                    fprintf(stderr, "Warning: cannot query manufacturer for device: %s\n", usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* fprintf(stderr, "seen device from vendor ->%s<-\n", string); */
+                    if(strcmp(string, vendorName) == 0){
+                        len = usbhidGetStringAscii(handle, dev->descriptor.iProduct, string, sizeof(string));
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_IO;
+                            fprintf(stderr, "Warning: cannot query product for device: %s\n", usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* fprintf(stderr, "seen product ->%s<-\n", string); */
+                            if(strcmp(string, productName) == 0)
+                                break;
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = (void *)handle;
+        usesReportIDs = _usesReportIDs;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    if(device != NULL)
+        usb_close((void *)device);
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+int bytesSent, reportId = buffer[0];
+
+    if(!usesReportIDs){
+        buffer++;   /* skip dummy report ID */
+        len--;
+    }
+    bytesSent = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, USBRQ_HID_SET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | (reportId & 0xff), 0, buffer, len, 5000);
+    if(bytesSent != len){
+        if(bytesSent < 0)
+            fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+int bytesReceived, maxLen = *len;
+
+    if(!usesReportIDs){
+        buffer++;   /* make room for dummy report ID */
+        maxLen--;
+    }
+    bytesReceived = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_IN, USBRQ_HID_GET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | reportNumber, 0, buffer, maxLen, 5000);
+    if(bytesReceived < 0){
+        fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    *len = bytesReceived;
+    if(!usesReportIDs){
+        buffer[-1] = reportNumber;  /* add dummy report ID */
+        (*len)++;
+    }
+    return 0;
+}
+
+/* ######################################################################## */
+#endif /* defined WIN32 ################################################### */
+/* ######################################################################## */
Index: vusb-20121206/examples/hid-data/commandline/hiddata.h
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hiddata.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hiddata.h	(working copy)
@@ -0,0 +1,70 @@
+/* Name: hiddata.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __HIDDATA_H_INCLUDED__
+#define __HIDDATA_H_INCLUDED__
+
+/*
+General Description:
+This module implements an abstraction layer for data transfer over HID feature
+requests. The implementation uses native Windows functions on Windows so that
+no driver installation is required and libusb on Unix. You must link the
+appropriate libraries in either case: "-lhid -lusb -lsetupapi" on Windows and
+`libusb-config --libs` on Unix.
+*/
+
+/* ------------------------------------------------------------------------ */
+
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+/* ------------------------------------------------------------------------ */
+
+typedef struct usbDevice    usbDevice_t;
+/* Opaque data type representing the USB device. This can be a Windows handle
+ * or a libusb handle, depending on the backend implementation.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidOpenDevice(usbDevice_t **device, int vendorID, char *vendorName, int productID, char *productName, int usesReportIDs);
+/* This function opens a USB device. 'vendorID' and 'productID' are the numeric
+ * Vendor-ID and Product-ID of the device we want to open. If 'vendorName' and
+ * 'productName' are both not NULL, only devices with matching manufacturer-
+ * and product name strings are accepted. If the device uses report IDs,
+ * 'usesReportIDs' must be set to a non-zero value.
+ * Returns: If a matching device has been found, USBOPEN_SUCCESS is returned
+ * and '*device' is set to an opaque pointer representing the device. The
+ * device must be closed with usbhidCloseDevice(). If the device has not been
+ * found or opening failed, an error code is returned.
+ */
+void    usbhidCloseDevice(usbDevice_t *device);
+/* Every device opened with usbhidOpenDevice() must be closed with this function.
+ */
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len);
+/* This function sends a feature report to the device. The report ID must be
+ * in the first byte of buffer and the length 'len' of the report is specified
+ * including this report ID. If no report IDs are used, buffer[0] must be set
+ * to 0 (dummy report ID).
+ * Returns: 0 on success, an error code otherwise.
+ */
+int usbhidGetReport(usbDevice_t *device, int reportID, char *buffer, int *len);
+/* This function obtains a feature report from the device. The requested
+ * report-ID is passed in 'reportID'. The caller must pass a buffer of the size
+ * of the expected report in 'buffer' and initialize the variable pointed to by
+ * 'len' to the total size of this buffer. Upon successful return, the report
+ * (prefixed with the report-ID) is in 'buffer' and the actual length of the
+ * report is returned in '*len'.
+ * Returns: 0 on success, an error code otherwise.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+#endif /* __HIDDATA_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-data/commandline/hidsdi.h
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hidsdi.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hidsdi.h	(working copy)
@@ -0,0 +1,48 @@
+/* Name: hidsdi.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-02-02
+ * Tabsize: 4
+ * Copyright: (c) 2006-2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description
+This file is a replacement for hidsdi.h from the Windows DDK. It defines some
+of the types and function prototypes of this header for our project. If you
+have the Windows DDK version of this file or a version shipped with MinGW, use
+that instead.
+*/
+
+#ifndef _HIDSDI_H
+#define _HIDSDI_H
+
+#include <pshpack4.h>
+
+#include <ddk/hidusage.h>
+#include <ddk/hidpi.h>
+
+typedef struct{
+    ULONG   Size;
+    USHORT  VendorID;
+    USHORT  ProductID;
+    USHORT  VersionNumber;
+}HIDD_ATTRIBUTES;
+
+void __stdcall      HidD_GetHidGuid(OUT LPGUID hidGuid);
+
+BOOLEAN __stdcall   HidD_GetAttributes(IN HANDLE device, OUT HIDD_ATTRIBUTES *attributes);
+
+BOOLEAN __stdcall   HidD_GetManufacturerString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetProductString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetSerialNumberString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetFeature(IN HANDLE device, OUT void *reportBuffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_SetFeature(IN HANDLE device, IN void *reportBuffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetNumInputBuffers(IN HANDLE device, OUT ULONG *numBuffers);
+BOOLEAN __stdcall   HidD_SetNumInputBuffers(IN HANDLE device, OUT ULONG numBuffers);
+
+#include <poppack.h>
+
+#endif
Index: vusb-20121206/examples/hid-data/commandline/hidtool.c
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hidtool.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hidtool.c	(working copy)
@@ -0,0 +1,126 @@
+/* Name: hidtool.c
+ * Project: hid-data example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "hiddata.h"
+#include "../firmware/usbconfig.h"  /* for device VID, PID, vendor name and product name */
+
+/* ------------------------------------------------------------------------- */
+
+static char *usbErrorMessage(int errCode)
+{
+static char buffer[80];
+
+    switch(errCode){
+        case USBOPEN_ERR_ACCESS:      return "Access to device denied";
+        case USBOPEN_ERR_NOTFOUND:    return "The specified device was not found";
+        case USBOPEN_ERR_IO:          return "Communication error with device";
+        default:
+            sprintf(buffer, "Unknown USB error %d", errCode);
+            return buffer;
+    }
+    return NULL;    /* not reached */
+}
+
+static usbDevice_t  *openDevice(void)
+{
+usbDevice_t     *dev = NULL;
+unsigned char   rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char            vendorName[] = {USB_CFG_VENDOR_NAME, 0}, productName[] = {USB_CFG_DEVICE_NAME, 0};
+int             vid = rawVid[0] + 256 * rawVid[1];
+int             pid = rawPid[0] + 256 * rawPid[1];
+int             err;
+
+    if((err = usbhidOpenDevice(&dev, vid, vendorName, pid, productName, 0)) != 0){
+        fprintf(stderr, "error finding %s: %s\n", productName, usbErrorMessage(err));
+        return NULL;
+    }
+    return dev;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void hexdump(char *buffer, int len)
+{
+int     i;
+FILE    *fp = stdout;
+
+    for(i = 0; i < len; i++){
+        if(i != 0){
+            if(i % 16 == 0){
+                fprintf(fp, "\n");
+            }else{
+                fprintf(fp, " ");
+            }
+        }
+        fprintf(fp, "0x%02x", buffer[i] & 0xff);
+    }
+    if(i != 0)
+        fprintf(fp, "\n");
+}
+
+static int  hexread(char *buffer, char *string, int buflen)
+{
+char    *s;
+int     pos = 0;
+
+    while((s = strtok(string, ", ")) != NULL && pos < buflen){
+        string = NULL;
+        buffer[pos++] = (char)strtol(s, NULL, 0);
+    }
+    return pos;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void usage(char *myName)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s read\n", myName);
+    fprintf(stderr, "  %s write <listofbytes>\n", myName);
+}
+
+int main(int argc, char **argv)
+{
+usbDevice_t *dev;
+char        buffer[129];    /* room for dummy report ID */
+int         err;
+
+    if(argc < 2){
+        usage(argv[0]);
+        exit(1);
+    }
+    if((dev = openDevice()) == NULL)
+        exit(1);
+    if(strcasecmp(argv[1], "read") == 0){
+        int len = sizeof(buffer);
+        if((err = usbhidGetReport(dev, 0, buffer, &len)) != 0){
+            fprintf(stderr, "error reading data: %s\n", usbErrorMessage(err));
+        }else{
+            hexdump(buffer + 1, sizeof(buffer) - 1);
+        }
+    }else if(strcasecmp(argv[1], "write") == 0){
+        int i, pos;
+        memset(buffer, 0, sizeof(buffer));
+        for(pos = 1, i = 2; i < argc && pos < sizeof(buffer); i++){
+            pos += hexread(buffer + pos, argv[i], sizeof(buffer) - pos);
+        }
+        if((err = usbhidSetReport(dev, buffer, sizeof(buffer))) != 0)   /* add a dummy report ID */
+            fprintf(stderr, "error writing data: %s\n", usbErrorMessage(err));
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usbhidCloseDevice(dev);
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-data/commandline/hiddata.c
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hiddata.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hiddata.c	(working copy)
@@ -0,0 +1,323 @@
+/* Name: hiddata.c
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include "hiddata.h"
+
+/* ######################################################################## */
+#if defined(WIN32) /* ##################################################### */
+/* ######################################################################## */
+
+#include <windows.h>
+#include <setupapi.h>
+#include "hidsdi.h"
+#include <ddk/hidpi.h>
+
+#ifdef DEBUG
+#define DEBUG_PRINT(arg)    printf arg
+#else
+#define DEBUG_PRINT(arg)
+#endif
+
+/* ------------------------------------------------------------------------ */
+
+static void convertUniToAscii(char *buffer)
+{
+unsigned short  *uni = (void *)buffer;
+char            *ascii = buffer;
+
+    while(*uni != 0){
+        if(*uni >= 256){
+            *ascii++ = '?';
+        }else{
+            *ascii++ = *uni++;
+        }
+    }
+    *ascii++ = 0;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int usesReportIDs)
+{
+GUID                                hidGuid;        /* GUID for HID driver */
+HDEVINFO                            deviceInfoList;
+SP_DEVICE_INTERFACE_DATA            deviceInfo;
+SP_DEVICE_INTERFACE_DETAIL_DATA     *deviceDetails = NULL;
+DWORD                               size;
+int                                 i, openFlag = 0;  /* may be FILE_FLAG_OVERLAPPED */
+int                                 errorCode = USBOPEN_ERR_NOTFOUND;
+HANDLE                              handle = INVALID_HANDLE_VALUE;
+HIDD_ATTRIBUTES                     deviceAttributes;
+				
+    HidD_GetHidGuid(&hidGuid);
+    deviceInfoList = SetupDiGetClassDevs(&hidGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
+    deviceInfo.cbSize = sizeof(deviceInfo);
+    for(i=0;;i++){
+        if(handle != INVALID_HANDLE_VALUE){
+            CloseHandle(handle);
+            handle = INVALID_HANDLE_VALUE;
+        }
+        if(!SetupDiEnumDeviceInterfaces(deviceInfoList, 0, &hidGuid, i, &deviceInfo))
+            break;  /* no more entries */
+        /* first do a dummy call just to determine the actual size required */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, NULL, 0, &size, NULL);
+        if(deviceDetails != NULL)
+            free(deviceDetails);
+        deviceDetails = malloc(size);
+        deviceDetails->cbSize = sizeof(*deviceDetails);
+        /* this call is for real: */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, deviceDetails, size, &size, NULL);
+        DEBUG_PRINT(("checking HID path \"%s\"\n", deviceDetails->DevicePath));
+#if 0
+        /* If we want to access a mouse our keyboard, we can only use feature
+         * requests as the device is locked by Windows. It must be opened
+         * with ACCESS_TYPE_NONE.
+         */
+        handle = CreateFile(deviceDetails->DevicePath, ACCESS_TYPE_NONE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+#endif
+        /* attempt opening for R/W -- we don't care about devices which can't be accessed */
+        handle = CreateFile(deviceDetails->DevicePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+        if(handle == INVALID_HANDLE_VALUE){
+            DEBUG_PRINT(("opening failed: %d\n", (int)GetLastError()));
+            /* errorCode = USBOPEN_ERR_ACCESS; opening will always fail for mouse -- ignore */
+            continue;
+        }
+        deviceAttributes.Size = sizeof(deviceAttributes);
+        HidD_GetAttributes(handle, &deviceAttributes);
+        DEBUG_PRINT(("device attributes: vid=%d pid=%d\n", deviceAttributes.VendorID, deviceAttributes.ProductID));
+        if(deviceAttributes.VendorID != vendor || deviceAttributes.ProductID != product)
+            continue;   /* ignore this device */
+        errorCode = USBOPEN_ERR_NOTFOUND;
+        if(vendorName != NULL && productName != NULL){
+            char    buffer[512];
+            if(!HidD_GetManufacturerString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining vendor name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("vendorName = \"%s\"\n", buffer));
+            if(strcmp(vendorName, buffer) != 0)
+                continue;
+            if(!HidD_GetProductString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining product name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("productName = \"%s\"\n", buffer));
+            if(strcmp(productName, buffer) != 0)
+                continue;
+        }
+        break;  /* we have found the device we are looking for! */
+    }
+    SetupDiDestroyDeviceInfoList(deviceInfoList);
+    if(deviceDetails != NULL)
+        free(deviceDetails);
+    if(handle != INVALID_HANDLE_VALUE){
+        *device = (usbDevice_t *)handle;
+        errorCode = 0;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------ */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    CloseHandle((HANDLE)device);
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+BOOLEAN rval;
+
+    rval = HidD_SetFeature((HANDLE)device, buffer, len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+BOOLEAN rval = 0;
+
+    buffer[0] = reportNumber;
+    rval = HidD_GetFeature((HANDLE)device, buffer, *len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+/* ######################################################################## */
+#else /* defined WIN32 #################################################### */
+/* ######################################################################## */
+
+#include <string.h>
+#include <usb.h>
+
+#define usbDevice   usb_dev_handle  /* use libusb's device structure */
+
+/* ------------------------------------------------------------------------- */
+
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_SET_REPORT    0x09
+
+#define USB_HID_REPORT_TYPE_FEATURE 3
+
+
+static int  usesReportIDs;
+
+/* ------------------------------------------------------------------------- */
+
+static int usbhidGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int _usesReportIDs)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+static int          didUsbInit = 0;
+
+    if(!didUsbInit){
+        usb_init();
+        didUsbInit = 1;
+    }
+    usb_find_busses();
+    usb_find_devices();
+    for(bus=usb_get_busses(); bus; bus=bus->next){
+        for(dev=bus->devices; dev; dev=dev->next){
+            if(dev->descriptor.idVendor == vendor && dev->descriptor.idProduct == product){
+                char    string[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    fprintf(stderr, "Warning: cannot open USB device: %s\n", usb_strerror());
+                    continue;
+                }
+                if(vendorName == NULL && productName == NULL){  /* name does not matter */
+                    break;
+                }
+                /* now check whether the names match: */
+                len = usbhidGetStringAscii(handle, dev->descriptor.iManufacturer, string, sizeof(string));
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_IO;
+                    fprintf(stderr, "Warning: cannot query manufacturer for device: %s\n", usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* fprintf(stderr, "seen device from vendor ->%s<-\n", string); */
+                    if(strcmp(string, vendorName) == 0){
+                        len = usbhidGetStringAscii(handle, dev->descriptor.iProduct, string, sizeof(string));
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_IO;
+                            fprintf(stderr, "Warning: cannot query product for device: %s\n", usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* fprintf(stderr, "seen product ->%s<-\n", string); */
+                            if(strcmp(string, productName) == 0)
+                                break;
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = (void *)handle;
+        usesReportIDs = _usesReportIDs;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    if(device != NULL)
+        usb_close((void *)device);
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+int bytesSent, reportId = buffer[0];
+
+    if(!usesReportIDs){
+        buffer++;   /* skip dummy report ID */
+        len--;
+    }
+    bytesSent = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, USBRQ_HID_SET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | (reportId & 0xff), 0, buffer, len, 5000);
+    if(bytesSent != len){
+        if(bytesSent < 0)
+            fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+int bytesReceived, maxLen = *len;
+
+    if(!usesReportIDs){
+        buffer++;   /* make room for dummy report ID */
+        maxLen--;
+    }
+    bytesReceived = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_IN, USBRQ_HID_GET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | reportNumber, 0, buffer, maxLen, 5000);
+    if(bytesReceived < 0){
+        fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    *len = bytesReceived;
+    if(!usesReportIDs){
+        buffer[-1] = reportNumber;  /* add dummy report ID */
+        (*len)++;
+    }
+    return 0;
+}
+
+/* ######################################################################## */
+#endif /* defined WIN32 ################################################### */
+/* ######################################################################## */
Index: vusb-20121206/examples/hid-data/commandline/hiddata.h
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hiddata.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hiddata.h	(working copy)
@@ -0,0 +1,70 @@
+/* Name: hiddata.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __HIDDATA_H_INCLUDED__
+#define __HIDDATA_H_INCLUDED__
+
+/*
+General Description:
+This module implements an abstraction layer for data transfer over HID feature
+requests. The implementation uses native Windows functions on Windows so that
+no driver installation is required and libusb on Unix. You must link the
+appropriate libraries in either case: "-lhid -lusb -lsetupapi" on Windows and
+`libusb-config --libs` on Unix.
+*/
+
+/* ------------------------------------------------------------------------ */
+
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+/* ------------------------------------------------------------------------ */
+
+typedef struct usbDevice    usbDevice_t;
+/* Opaque data type representing the USB device. This can be a Windows handle
+ * or a libusb handle, depending on the backend implementation.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidOpenDevice(usbDevice_t **device, int vendorID, char *vendorName, int productID, char *productName, int usesReportIDs);
+/* This function opens a USB device. 'vendorID' and 'productID' are the numeric
+ * Vendor-ID and Product-ID of the device we want to open. If 'vendorName' and
+ * 'productName' are both not NULL, only devices with matching manufacturer-
+ * and product name strings are accepted. If the device uses report IDs,
+ * 'usesReportIDs' must be set to a non-zero value.
+ * Returns: If a matching device has been found, USBOPEN_SUCCESS is returned
+ * and '*device' is set to an opaque pointer representing the device. The
+ * device must be closed with usbhidCloseDevice(). If the device has not been
+ * found or opening failed, an error code is returned.
+ */
+void    usbhidCloseDevice(usbDevice_t *device);
+/* Every device opened with usbhidOpenDevice() must be closed with this function.
+ */
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len);
+/* This function sends a feature report to the device. The report ID must be
+ * in the first byte of buffer and the length 'len' of the report is specified
+ * including this report ID. If no report IDs are used, buffer[0] must be set
+ * to 0 (dummy report ID).
+ * Returns: 0 on success, an error code otherwise.
+ */
+int usbhidGetReport(usbDevice_t *device, int reportID, char *buffer, int *len);
+/* This function obtains a feature report from the device. The requested
+ * report-ID is passed in 'reportID'. The caller must pass a buffer of the size
+ * of the expected report in 'buffer' and initialize the variable pointed to by
+ * 'len' to the total size of this buffer. Upon successful return, the report
+ * (prefixed with the report-ID) is in 'buffer' and the actual length of the
+ * report is returned in '*len'.
+ * Returns: 0 on success, an error code otherwise.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+#endif /* __HIDDATA_H_INCLUDED__ */
Index: vusb-20121206/examples/hid-data/commandline/hidsdi.h
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hidsdi.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hidsdi.h	(working copy)
@@ -0,0 +1,48 @@
+/* Name: hidsdi.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-02-02
+ * Tabsize: 4
+ * Copyright: (c) 2006-2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description
+This file is a replacement for hidsdi.h from the Windows DDK. It defines some
+of the types and function prototypes of this header for our project. If you
+have the Windows DDK version of this file or a version shipped with MinGW, use
+that instead.
+*/
+
+#ifndef _HIDSDI_H
+#define _HIDSDI_H
+
+#include <pshpack4.h>
+
+#include <ddk/hidusage.h>
+#include <ddk/hidpi.h>
+
+typedef struct{
+    ULONG   Size;
+    USHORT  VendorID;
+    USHORT  ProductID;
+    USHORT  VersionNumber;
+}HIDD_ATTRIBUTES;
+
+void __stdcall      HidD_GetHidGuid(OUT LPGUID hidGuid);
+
+BOOLEAN __stdcall   HidD_GetAttributes(IN HANDLE device, OUT HIDD_ATTRIBUTES *attributes);
+
+BOOLEAN __stdcall   HidD_GetManufacturerString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetProductString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetSerialNumberString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetFeature(IN HANDLE device, OUT void *reportBuffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_SetFeature(IN HANDLE device, IN void *reportBuffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetNumInputBuffers(IN HANDLE device, OUT ULONG *numBuffers);
+BOOLEAN __stdcall   HidD_SetNumInputBuffers(IN HANDLE device, OUT ULONG numBuffers);
+
+#include <poppack.h>
+
+#endif
Index: vusb-20121206/examples/hid-data/commandline/hidtool.c
===================================================================
--- vusb-20121206/examples/hid-data/commandline/hidtool.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/hidtool.c	(working copy)
@@ -0,0 +1,126 @@
+/* Name: hidtool.c
+ * Project: hid-data example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "hiddata.h"
+#include "../firmware/usbconfig.h"  /* for device VID, PID, vendor name and product name */
+
+/* ------------------------------------------------------------------------- */
+
+static char *usbErrorMessage(int errCode)
+{
+static char buffer[80];
+
+    switch(errCode){
+        case USBOPEN_ERR_ACCESS:      return "Access to device denied";
+        case USBOPEN_ERR_NOTFOUND:    return "The specified device was not found";
+        case USBOPEN_ERR_IO:          return "Communication error with device";
+        default:
+            sprintf(buffer, "Unknown USB error %d", errCode);
+            return buffer;
+    }
+    return NULL;    /* not reached */
+}
+
+static usbDevice_t  *openDevice(void)
+{
+usbDevice_t     *dev = NULL;
+unsigned char   rawVid[2] = {USB_CFG_VENDOR_ID}, rawPid[2] = {USB_CFG_DEVICE_ID};
+char            vendorName[] = {USB_CFG_VENDOR_NAME, 0}, productName[] = {USB_CFG_DEVICE_NAME, 0};
+int             vid = rawVid[0] + 256 * rawVid[1];
+int             pid = rawPid[0] + 256 * rawPid[1];
+int             err;
+
+    if((err = usbhidOpenDevice(&dev, vid, vendorName, pid, productName, 0)) != 0){
+        fprintf(stderr, "error finding %s: %s\n", productName, usbErrorMessage(err));
+        return NULL;
+    }
+    return dev;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void hexdump(char *buffer, int len)
+{
+int     i;
+FILE    *fp = stdout;
+
+    for(i = 0; i < len; i++){
+        if(i != 0){
+            if(i % 16 == 0){
+                fprintf(fp, "\n");
+            }else{
+                fprintf(fp, " ");
+            }
+        }
+        fprintf(fp, "0x%02x", buffer[i] & 0xff);
+    }
+    if(i != 0)
+        fprintf(fp, "\n");
+}
+
+static int  hexread(char *buffer, char *string, int buflen)
+{
+char    *s;
+int     pos = 0;
+
+    while((s = strtok(string, ", ")) != NULL && pos < buflen){
+        string = NULL;
+        buffer[pos++] = (char)strtol(s, NULL, 0);
+    }
+    return pos;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static void usage(char *myName)
+{
+    fprintf(stderr, "usage:\n");
+    fprintf(stderr, "  %s read\n", myName);
+    fprintf(stderr, "  %s write <listofbytes>\n", myName);
+}
+
+int main(int argc, char **argv)
+{
+usbDevice_t *dev;
+char        buffer[129];    /* room for dummy report ID */
+int         err;
+
+    if(argc < 2){
+        usage(argv[0]);
+        exit(1);
+    }
+    if((dev = openDevice()) == NULL)
+        exit(1);
+    if(strcasecmp(argv[1], "read") == 0){
+        int len = sizeof(buffer);
+        if((err = usbhidGetReport(dev, 0, buffer, &len)) != 0){
+            fprintf(stderr, "error reading data: %s\n", usbErrorMessage(err));
+        }else{
+            hexdump(buffer + 1, sizeof(buffer) - 1);
+        }
+    }else if(strcasecmp(argv[1], "write") == 0){
+        int i, pos;
+        memset(buffer, 0, sizeof(buffer));
+        for(pos = 1, i = 2; i < argc && pos < sizeof(buffer); i++){
+            pos += hexread(buffer + pos, argv[i], sizeof(buffer) - pos);
+        }
+        if((err = usbhidSetReport(dev, buffer, sizeof(buffer))) != 0)   /* add a dummy report ID */
+            fprintf(stderr, "error writing data: %s\n", usbErrorMessage(err));
+    }else{
+        usage(argv[0]);
+        exit(1);
+    }
+    usbhidCloseDevice(dev);
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-data/commandline/Makefile
===================================================================
--- vusb-20121206/examples/hid-data/commandline/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/Makefile	(working copy)
@@ -0,0 +1,41 @@
+# Name: Makefile
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-11
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# Please read the definitions below and edit them as appropriate for your
+# system:
+
+# Use the following 3 lines on Unix and Mac OS X:
+USBFLAGS=   `libusb-config --cflags`
+USBLIBS=    `libusb-config --libs`
+EXE_SUFFIX=
+
+# Use the following 3 lines on Windows and comment out the 3 above:
+#USBFLAGS=
+#USBLIBS=    -lhid -lusb -lsetupapi
+#EXE_SUFFIX= .exe
+
+CC=				gcc
+CFLAGS=			-O -Wall $(USBFLAGS)
+LIBS=			$(USBLIBS)
+
+OBJ=		hidtool.o hiddata.o
+PROGRAM=	hidtool$(EXE_SUFFIX)
+
+all: $(PROGRAM)
+
+$(PROGRAM): $(OBJ)
+	$(CC) -o $(PROGRAM) $(OBJ) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f $(OBJ) $(PROGRAM)
+
+.c.o:
+	$(CC) $(ARCH_COMPILE) $(CFLAGS) -c $*.c -o $*.o
Index: vusb-20121206/examples/hid-data/commandline/Makefile.windows
===================================================================
--- vusb-20121206/examples/hid-data/commandline/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/hid-data/commandline/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-11
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS=
+USBLIBS=    -lhid -lsetupapi
+EXE_SUFFIX= .exe
Index: vusb-20121206/examples/hid-data/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-data/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-data/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-data/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/main.c	(working copy)
@@ -0,0 +1,140 @@
+/* Name: main.c
+ * Project: hid-data, example how to use HID for data transfer
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+*/
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+#include <avr/eeprom.h>
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[22] = {    /* USB report descriptor */
+    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
+    0x09, 0x01,                    // USAGE (Vendor Usage 1)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x95, 0x80,                    //   REPORT_COUNT (128)
+    0x09, 0x00,                    //   USAGE (Undefined)
+    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)
+    0xc0                           // END_COLLECTION
+};
+/* Since we define only one feature report, we don't use report-IDs (which
+ * would be the first byte of the report). The entire report consists of 128
+ * opaque data bytes.
+ */
+
+/* The following variables store the status of the current data transfer */
+static uchar    currentAddress;
+static uchar    bytesRemaining;
+
+/* ------------------------------------------------------------------------- */
+
+/* usbFunctionRead() is called when the host requests a chunk of data from
+ * the device. For more information see the documentation in usbdrv/usbdrv.h.
+ */
+uchar   usbFunctionRead(uchar *data, uchar len)
+{
+    if(len > bytesRemaining)
+        len = bytesRemaining;
+    eeprom_read_block(data, (uchar *)0 + currentAddress, len);
+    currentAddress += len;
+    bytesRemaining -= len;
+    return len;
+}
+
+/* usbFunctionWrite() is called when the host sends a chunk of data to the
+ * device. For more information see the documentation in usbdrv/usbdrv.h.
+ */
+uchar   usbFunctionWrite(uchar *data, uchar len)
+{
+    if(bytesRemaining == 0)
+        return 1;               /* end of transfer */
+    if(len > bytesRemaining)
+        len = bytesRemaining;
+    eeprom_write_block(data, (uchar *)0 + currentAddress, len);
+    currentAddress += len;
+    bytesRemaining -= len;
+    return bytesRemaining == 0; /* return 1 if this was the last chunk */
+}
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* HID class request */
+        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
+            /* since we have only one report type, we can ignore the report-ID */
+            bytesRemaining = 128;
+            currentAddress = 0;
+            return USB_NO_MSG;  /* use usbFunctionRead() to obtain data */
+        }else if(rq->bRequest == USBRQ_HID_SET_REPORT){
+            /* since we have only one report type, we can ignore the report-ID */
+            bytesRemaining = 128;
+            currentAddress = 0;
+            return USB_NO_MSG;  /* use usbFunctionWrite() to receive data from host */
+        }
+    }else{
+        /* ignore vendor type requests, we don't use any */
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-data/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-data/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      1
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       1
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdf, 0x05 /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'D', 'a', 't', 'a', 'S', 't', 'o', 'r', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 9
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    22
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-data/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-data/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/main.c	(working copy)
@@ -0,0 +1,140 @@
+/* Name: main.c
+ * Project: hid-data, example how to use HID for data transfer
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+*/
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+#include <avr/eeprom.h>
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[22] = {    /* USB report descriptor */
+    0x06, 0x00, 0xff,              // USAGE_PAGE (Generic Desktop)
+    0x09, 0x01,                    // USAGE (Vendor Usage 1)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x95, 0x80,                    //   REPORT_COUNT (128)
+    0x09, 0x00,                    //   USAGE (Undefined)
+    0xb2, 0x02, 0x01,              //   FEATURE (Data,Var,Abs,Buf)
+    0xc0                           // END_COLLECTION
+};
+/* Since we define only one feature report, we don't use report-IDs (which
+ * would be the first byte of the report). The entire report consists of 128
+ * opaque data bytes.
+ */
+
+/* The following variables store the status of the current data transfer */
+static uchar    currentAddress;
+static uchar    bytesRemaining;
+
+/* ------------------------------------------------------------------------- */
+
+/* usbFunctionRead() is called when the host requests a chunk of data from
+ * the device. For more information see the documentation in usbdrv/usbdrv.h.
+ */
+uchar   usbFunctionRead(uchar *data, uchar len)
+{
+    if(len > bytesRemaining)
+        len = bytesRemaining;
+    eeprom_read_block(data, (uchar *)0 + currentAddress, len);
+    currentAddress += len;
+    bytesRemaining -= len;
+    return len;
+}
+
+/* usbFunctionWrite() is called when the host sends a chunk of data to the
+ * device. For more information see the documentation in usbdrv/usbdrv.h.
+ */
+uchar   usbFunctionWrite(uchar *data, uchar len)
+{
+    if(bytesRemaining == 0)
+        return 1;               /* end of transfer */
+    if(len > bytesRemaining)
+        len = bytesRemaining;
+    eeprom_write_block(data, (uchar *)0 + currentAddress, len);
+    currentAddress += len;
+    bytesRemaining -= len;
+    return bytesRemaining == 0; /* return 1 if this was the last chunk */
+}
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* HID class request */
+        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
+            /* since we have only one report type, we can ignore the report-ID */
+            bytesRemaining = 128;
+            currentAddress = 0;
+            return USB_NO_MSG;  /* use usbFunctionRead() to obtain data */
+        }else if(rq->bRequest == USBRQ_HID_SET_REPORT){
+            /* since we have only one report type, we can ignore the report-ID */
+            bytesRemaining = 128;
+            currentAddress = 0;
+            return USB_NO_MSG;  /* use usbFunctionWrite() to receive data from host */
+        }
+    }else{
+        /* ignore vendor type requests, we don't use any */
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-data/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-data/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-data example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-data/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-data/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-data/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      1
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       1
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdf, 0x05 /* obdev's shared PID for HIDs */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'D', 'a', 't', 'a', 'S', 't', 'o', 'r', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 9
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    22
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-data/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-data/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-data/Readme.txt	(working copy)
@@ -0,0 +1,75 @@
+This is the Readme file for the hid-data example. In this example, we show
+how blocks of data can be exchanged with the device using only functionality
+compliant to the HID class. Since class drivers for HID are included with
+Windows, you don't need to install drivers on Windows.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how the HID class can be misused to transfer fixed
+size blocks of data (up to the driver's transfer size limit) over HID feature
+reports. This technique is of great value on Windows because no driver DLLs
+are needed (the hid-custom-rq example still requires the libusb-win32 DLL,
+although it may be in the program's directory). The host side application
+requires no installation, it can even be started directly from a CD. This
+example also demonstrates how to transfer data using usbFunctionWrite() and
+usbFunctionRead().
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+Host development environment: A C compiler and libusb on Unix. On Windows
+you need the Driver Development Kit (DDK) Instead of libusb. MinGW ships
+with a free version of the DDK.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+BUILDING THE HOST SOFTWARE
+==========================
+Make sure that you have libusb (on Unix) or the DDK (on Windows) installed.
+We recommend MinGW on Windows since it includes a free version of the DDK.
+Then change to directory "commandline" and run "make" on Unix or
+"make -f Makefile.windows" on Windows.
+
+
+USING THE COMMAND LINE TOOL
+===========================
+The device implements a data store of 128 bytes in EEPROM. You can send a
+block of 128 bytes to the device or read the block using the command line
+tool.
+
+To send a block to the device, use e.g.
+
+    hidtool write 0x01,0x02,0x03,0x04,...
+
+and to receive the block, use
+
+    hidtool read
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-mouse/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-mouse/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/Readme.txt	(working copy)
@@ -0,0 +1,48 @@
+This is the Readme file for hid-mouse, an example of a USB mouse device. In
+order to have as little dependencies on hardware and architecture as
+possible, mouse movements are computed internally so that the mouse pointer
+moves in a circle.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how HID class devices are implemented. The example
+is kept as simple as possible, except the report descriptor which is taken
+from a real-world mouse.
+
+It does NOT include a host side driver because all modern operating systems
+include one. It does NOT implement USBRQ_HID_SET_REPORT and report-IDs. See
+the "hid-data" example for this topic. It does NOT implement any special
+features such as suspend mode etc.
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/hid-mouse/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-mouse example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-mouse/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/main.c	(working copy)
@@ -0,0 +1,163 @@
+/* Name: main.c
+ * Project: hid-mouse, a very simple HID example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-07
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+
+We use VID/PID 0x046D/0xC00E which is taken from a Logitech mouse. Don't
+publish any hardware using these IDs! This is for demonstration only!
+*/
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[52] = { /* USB report descriptor, size must match usbconfig.h */
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
+    0x09, 0x02,                    // USAGE (Mouse)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x09, 0x01,                    //   USAGE (Pointer)
+    0xA1, 0x00,                    //   COLLECTION (Physical)
+    0x05, 0x09,                    //     USAGE_PAGE (Button)
+    0x19, 0x01,                    //     USAGE_MINIMUM
+    0x29, 0x03,                    //     USAGE_MAXIMUM
+    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x75, 0x01,                    //     REPORT_SIZE (1)
+    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
+    0x95, 0x01,                    //     REPORT_COUNT (1)
+    0x75, 0x05,                    //     REPORT_SIZE (5)
+    0x81, 0x03,                    //     INPUT (Const,Var,Abs)
+    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
+    0x09, 0x30,                    //     USAGE (X)
+    0x09, 0x31,                    //     USAGE (Y)
+    0x09, 0x38,                    //     USAGE (Wheel)
+    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
+    0x25, 0x7F,                    //     LOGICAL_MAXIMUM (127)
+    0x75, 0x08,                    //     REPORT_SIZE (8)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
+    0xC0,                          //   END_COLLECTION
+    0xC0,                          // END COLLECTION
+};
+/* This is the same report descriptor as seen in a Logitech mouse. The data
+ * described by this descriptor consists of 4 bytes:
+ *      .  .  .  .  . B2 B1 B0 .... one byte with mouse button states
+ *     X7 X6 X5 X4 X3 X2 X1 X0 .... 8 bit signed relative coordinate x
+ *     Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 .... 8 bit signed relative coordinate y
+ *     W7 W6 W5 W4 W3 W2 W1 W0 .... 8 bit signed relative coordinate wheel
+ */
+typedef struct{
+    uchar   buttonMask;
+    char    dx;
+    char    dy;
+    char    dWheel;
+}report_t;
+
+static report_t reportBuffer;
+static int      sinus = 7 << 6, cosinus = 0;
+static uchar    idleRate;   /* repeat rate for keyboards, never used for mice */
+
+
+/* The following function advances sin/cos by a fixed angle
+ * and stores the difference to the previous coordinates in the report
+ * descriptor.
+ * The algorithm is the simulation of a second order differential equation.
+ */
+static void advanceCircleByFixedAngle(void)
+{
+char    d;
+
+#define DIVIDE_BY_64(val)  (val + (val > 0 ? 32 : -32)) >> 6    /* rounding divide */
+    reportBuffer.dx = d = DIVIDE_BY_64(cosinus);
+    sinus += d;
+    reportBuffer.dy = d = DIVIDE_BY_64(sinus);
+    cosinus -= d;
+}
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    /* The following requests are never used. But since they are required by
+     * the specification, we implement them in this example.
+     */
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
+        DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
+        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
+            /* we only have one report type, so don't look at wValue */
+            usbMsgPtr = (void *)&reportBuffer;
+            return sizeof(reportBuffer);
+        }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
+            usbMsgPtr = &idleRate;
+            return 1;
+        }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
+            idleRate = rq->wValue.bytes[1];
+        }
+    }else{
+        /* no vendor specific requests implemented */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+        if(usbInterruptIsReady()){
+            /* called after every poll of the interrupt endpoint */
+            advanceCircleByFixedAngle();
+            DBG1(0x03, 0, 0);   /* debug output: interrupt report prepared */
+            usbSetInterrupt((void *)&reportBuffer, sizeof(reportBuffer));
+        }
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-mouse/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xe8, 0x03 /* VOTI's lab use PID */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'M', 'o', 'u', 's', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 5
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    52
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-mouse/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-mouse example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-mouse/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/main.c	(working copy)
@@ -0,0 +1,163 @@
+/* Name: main.c
+ * Project: hid-mouse, a very simple HID example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-07
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+
+We use VID/PID 0x046D/0xC00E which is taken from a Logitech mouse. Don't
+publish any hardware using these IDs! This is for demonstration only!
+*/
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[52] = { /* USB report descriptor, size must match usbconfig.h */
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
+    0x09, 0x02,                    // USAGE (Mouse)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x09, 0x01,                    //   USAGE (Pointer)
+    0xA1, 0x00,                    //   COLLECTION (Physical)
+    0x05, 0x09,                    //     USAGE_PAGE (Button)
+    0x19, 0x01,                    //     USAGE_MINIMUM
+    0x29, 0x03,                    //     USAGE_MAXIMUM
+    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x75, 0x01,                    //     REPORT_SIZE (1)
+    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
+    0x95, 0x01,                    //     REPORT_COUNT (1)
+    0x75, 0x05,                    //     REPORT_SIZE (5)
+    0x81, 0x03,                    //     INPUT (Const,Var,Abs)
+    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
+    0x09, 0x30,                    //     USAGE (X)
+    0x09, 0x31,                    //     USAGE (Y)
+    0x09, 0x38,                    //     USAGE (Wheel)
+    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
+    0x25, 0x7F,                    //     LOGICAL_MAXIMUM (127)
+    0x75, 0x08,                    //     REPORT_SIZE (8)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
+    0xC0,                          //   END_COLLECTION
+    0xC0,                          // END COLLECTION
+};
+/* This is the same report descriptor as seen in a Logitech mouse. The data
+ * described by this descriptor consists of 4 bytes:
+ *      .  .  .  .  . B2 B1 B0 .... one byte with mouse button states
+ *     X7 X6 X5 X4 X3 X2 X1 X0 .... 8 bit signed relative coordinate x
+ *     Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 .... 8 bit signed relative coordinate y
+ *     W7 W6 W5 W4 W3 W2 W1 W0 .... 8 bit signed relative coordinate wheel
+ */
+typedef struct{
+    uchar   buttonMask;
+    char    dx;
+    char    dy;
+    char    dWheel;
+}report_t;
+
+static report_t reportBuffer;
+static int      sinus = 7 << 6, cosinus = 0;
+static uchar    idleRate;   /* repeat rate for keyboards, never used for mice */
+
+
+/* The following function advances sin/cos by a fixed angle
+ * and stores the difference to the previous coordinates in the report
+ * descriptor.
+ * The algorithm is the simulation of a second order differential equation.
+ */
+static void advanceCircleByFixedAngle(void)
+{
+char    d;
+
+#define DIVIDE_BY_64(val)  (val + (val > 0 ? 32 : -32)) >> 6    /* rounding divide */
+    reportBuffer.dx = d = DIVIDE_BY_64(cosinus);
+    sinus += d;
+    reportBuffer.dy = d = DIVIDE_BY_64(sinus);
+    cosinus -= d;
+}
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    /* The following requests are never used. But since they are required by
+     * the specification, we implement them in this example.
+     */
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
+        DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
+        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
+            /* we only have one report type, so don't look at wValue */
+            usbMsgPtr = (void *)&reportBuffer;
+            return sizeof(reportBuffer);
+        }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
+            usbMsgPtr = &idleRate;
+            return 1;
+        }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
+            idleRate = rq->wValue.bytes[1];
+        }
+    }else{
+        /* no vendor specific requests implemented */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+        if(usbInterruptIsReady()){
+            /* called after every poll of the interrupt endpoint */
+            advanceCircleByFixedAngle();
+            DBG1(0x03, 0, 0);   /* debug output: interrupt report prepared */
+            usbSetInterrupt((void *)&reportBuffer, sizeof(reportBuffer));
+        }
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-mouse/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xe8, 0x03 /* VOTI's lab use PID */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'M', 'o', 'u', 's', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 5
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    52
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-mouse/firmware/main.c
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/main.c	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/main.c	(working copy)
@@ -0,0 +1,163 @@
+/* Name: main.c
+ * Project: hid-mouse, a very simple HID example
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-07
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This example should run on most AVRs with only little changes. No special
+hardware resources except INT0 are used. You may have to change usbconfig.h for
+different I/O pins for USB. Please note that USB D+ must be the INT0 pin, or
+at least be connected to INT0 as well.
+
+We use VID/PID 0x046D/0xC00E which is taken from a Logitech mouse. Don't
+publish any hardware using these IDs! This is for demonstration only!
+*/
+
+#include <avr/io.h>
+#include <avr/wdt.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <util/delay.h>     /* for _delay_ms() */
+
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include "usbdrv.h"
+#include "oddebug.h"        /* This is also an example for using debug macros */
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+PROGMEM const char usbHidReportDescriptor[52] = { /* USB report descriptor, size must match usbconfig.h */
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
+    0x09, 0x02,                    // USAGE (Mouse)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x09, 0x01,                    //   USAGE (Pointer)
+    0xA1, 0x00,                    //   COLLECTION (Physical)
+    0x05, 0x09,                    //     USAGE_PAGE (Button)
+    0x19, 0x01,                    //     USAGE_MINIMUM
+    0x29, 0x03,                    //     USAGE_MAXIMUM
+    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x75, 0x01,                    //     REPORT_SIZE (1)
+    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
+    0x95, 0x01,                    //     REPORT_COUNT (1)
+    0x75, 0x05,                    //     REPORT_SIZE (5)
+    0x81, 0x03,                    //     INPUT (Const,Var,Abs)
+    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
+    0x09, 0x30,                    //     USAGE (X)
+    0x09, 0x31,                    //     USAGE (Y)
+    0x09, 0x38,                    //     USAGE (Wheel)
+    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
+    0x25, 0x7F,                    //     LOGICAL_MAXIMUM (127)
+    0x75, 0x08,                    //     REPORT_SIZE (8)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
+    0xC0,                          //   END_COLLECTION
+    0xC0,                          // END COLLECTION
+};
+/* This is the same report descriptor as seen in a Logitech mouse. The data
+ * described by this descriptor consists of 4 bytes:
+ *      .  .  .  .  . B2 B1 B0 .... one byte with mouse button states
+ *     X7 X6 X5 X4 X3 X2 X1 X0 .... 8 bit signed relative coordinate x
+ *     Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 .... 8 bit signed relative coordinate y
+ *     W7 W6 W5 W4 W3 W2 W1 W0 .... 8 bit signed relative coordinate wheel
+ */
+typedef struct{
+    uchar   buttonMask;
+    char    dx;
+    char    dy;
+    char    dWheel;
+}report_t;
+
+static report_t reportBuffer;
+static int      sinus = 7 << 6, cosinus = 0;
+static uchar    idleRate;   /* repeat rate for keyboards, never used for mice */
+
+
+/* The following function advances sin/cos by a fixed angle
+ * and stores the difference to the previous coordinates in the report
+ * descriptor.
+ * The algorithm is the simulation of a second order differential equation.
+ */
+static void advanceCircleByFixedAngle(void)
+{
+char    d;
+
+#define DIVIDE_BY_64(val)  (val + (val > 0 ? 32 : -32)) >> 6    /* rounding divide */
+    reportBuffer.dx = d = DIVIDE_BY_64(cosinus);
+    sinus += d;
+    reportBuffer.dy = d = DIVIDE_BY_64(sinus);
+    cosinus -= d;
+}
+
+/* ------------------------------------------------------------------------- */
+
+usbMsgLen_t usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    /* The following requests are never used. But since they are required by
+     * the specification, we implement them in this example.
+     */
+    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
+        DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
+        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
+            /* we only have one report type, so don't look at wValue */
+            usbMsgPtr = (void *)&reportBuffer;
+            return sizeof(reportBuffer);
+        }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
+            usbMsgPtr = &idleRate;
+            return 1;
+        }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
+            idleRate = rq->wValue.bytes[1];
+        }
+    }else{
+        /* no vendor specific requests implemented */
+    }
+    return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int __attribute__((noreturn)) main(void)
+{
+uchar   i;
+
+    wdt_enable(WDTO_1S);
+    /* Even if you don't use the watchdog, turn it off here. On newer devices,
+     * the status of the watchdog (on/off, period) is PRESERVED OVER RESET!
+     */
+    /* RESET status: all port bits are inputs without pull-up.
+     * That's the way we need D+ and D-. Therefore we don't need any
+     * additional hardware initialization.
+     */
+    odDebugInit();
+    DBG1(0x00, 0, 0);       /* debug output: main starts */
+    usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        wdt_reset();
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+    sei();
+    DBG1(0x01, 0, 0);       /* debug output: main loop starts */
+    for(;;){                /* main event loop */
+        DBG1(0x02, 0, 0);   /* debug output: main loop iterates */
+        wdt_reset();
+        usbPoll();
+        if(usbInterruptIsReady()){
+            /* called after every poll of the interrupt endpoint */
+            advanceCircleByFixedAngle();
+            DBG1(0x03, 0, 0);   /* debug output: interrupt report prepared */
+            usbSetInterrupt((void *)&reportBuffer, sizeof(reportBuffer));
+        }
+    }
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/hid-mouse/firmware/Makefile
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/Makefile	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/Makefile	(working copy)
@@ -0,0 +1,163 @@
+# Name: Makefile
+# Project: hid-mouse example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = atmega168
+F_CPU   = 16000000	# in Hz
+FUSE_L  = # see below for fuse values for particular devices
+FUSE_H  = 
+AVRDUDE = avrdude -c usbasp -p $(DEVICE) # edit this line for your programmer
+
+CFLAGS  = -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+##############################################################################
+# Fuse values for particular devices
+##############################################################################
+# If your device is not listed here, go to
+# http://palmavr.sourceforge.net/cgi-bin/fc.cgi
+# and choose options for external crystal clock and no clock divider
+#
+################################## ATMega8 ##################################
+# ATMega8 FUSE_L (Fuse low byte):
+# 0x9f = 1 0 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ BODEN (BrownOut Detector enabled)
+#        +-------------------- BODLEVEL (2.7V)
+# ATMega8 FUSE_H (Fuse high byte):
+# 0xc9 = 1 1 0 0   1 0 0 1 <-- BOOTRST (boot reset vector at 0x0000)
+#        ^ ^ ^ ^   ^ ^ ^------ BOOTSZ0
+#        | | | |   | +-------- BOOTSZ1
+#        | | | |   + --------- EESAVE (don't preserve EEPROM over chip erase)
+#        | | | +-------------- CKOPT (full output swing)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ WDTON (WDT not always on)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATMega48/88/168 ##############################
+# ATMega*8 FUSE_L (Fuse low byte):
+# 0xdf = 1 1 0 1   1 1 1 1
+#        ^ ^ \ /   \--+--/
+#        | |  |       +------- CKSEL 3..0 (external >8M crystal)
+#        | |  +--------------- SUT 1..0 (crystal osc, BOD enabled)
+#        | +------------------ CKOUT (if 0: Clock output enabled)
+#        +-------------------- CKDIV8 (if 0: divide by 8)
+# ATMega*8 FUSE_H (Fuse high byte):
+# 0xde = 1 1 0 1   1 1 1 0
+#        ^ ^ ^ ^   ^ \-+-/
+#        | | | |   |   +------ BODLEVEL 0..2 (110 = 1.8 V)
+#        | | | |   + --------- EESAVE (preserve EEPROM over chip erase)
+#        | | | +-------------- WDTON (if 0: watchdog always on)
+#        | | +---------------- SPIEN (allow serial programming)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (reset pin is enabled)
+#
+############################## ATTiny25/45/85 ###############################
+# ATMega*5 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATMega*5 FUSE_H (Fuse high byte):
+# 0xdd = 1 1 0 1   1 1 0 1
+#        ^ ^ ^ ^   ^ \-+-/ 
+#        | | | |   |   +------ BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | |   +---------- EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ DWEN (debug wire enable)
+#        +-------------------- RSTDISBL (disable external reset -> enabled)
+#
+################################ ATTiny2313 #################################
+# ATTiny2313 FUSE_L (Fuse low byte):
+# 0xef = 1 1 1 0   1 1 1 1
+#        ^ ^ \+/   \--+--/
+#        | |  |       +------- CKSEL 3..0 (clock selection -> crystal @ 12 MHz)
+#        | |  +--------------- SUT 1..0 (BOD enabled, fast rising power)
+#        | +------------------ CKOUT (clock output on CKOUT pin -> disabled)
+#        +-------------------- CKDIV8 (divide clock by 8 -> don't divide)
+# ATTiny2313 FUSE_H (Fuse high byte):
+# 0xdb = 1 1 0 1   1 0 1 1
+#        ^ ^ ^ ^   \-+-/ ^
+#        | | | |     |   +---- RSTDISBL (disable external reset -> enabled)
+#        | | | |     +-------- BODLEVEL 2..0 (brownout trigger level -> 2.7V)
+#        | | | +-------------- WDTON (watchdog timer always on -> disable)
+#        | | +---------------- SPIEN (enable serial programming -> enabled)
+#        | +------------------ EESAVE (preserve EEPROM on Chip Erase -> not preserved)
+#        +-------------------- DWEN (debug wire enable)
+
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make hex ....... to build main.hex"
+	@echo "make program ... to flash fuses and firmware"
+	@echo "make fuse ...... to flash the fuses"
+	@echo "make flash ..... to flash the firmware (use this on metaboard)"
+	@echo "make clean ..... to delete objects and hex file"
+
+hex: main.hex
+
+program: flash fuse
+
+# rule for programming fuse bits:
+fuse:
+	@[ "$(FUSE_H)" != "" -a "$(FUSE_L)" != "" ] || \
+		{ echo "*** Edit Makefile and choose values for FUSE_L and FUSE_H!"; exit 1; }
+	$(AVRDUDE) -U hfuse:w:$(FUSE_H):m -U lfuse:w:$(FUSE_L):m
+
+# rule for uploading firmware:
+flash: main.hex
+	$(AVRDUDE) -U flash:w:main.hex:i
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f main.hex main.lst main.obj main.cof main.list main.map main.eep.hex main.elf *.o usbdrv/*.o main.s usbdrv/oddebug.s usbdrv/usbdrv.s
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../../../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main.hex: main.elf
+	rm -f main.hex main.eep.hex
+	avr-objcopy -j .text -j .data -O ihex main.elf main.hex
+	avr-size main.hex
+
+# debugging targets:
+
+disasm:	main.elf
+	avr-objdump -d main.elf
+
+cpp:
+	$(COMPILE) -E main.c
Index: vusb-20121206/examples/hid-mouse/firmware/usbconfig.h
===================================================================
--- vusb-20121206/examples/hid-mouse/firmware/usbconfig.h	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/firmware/usbconfig.h	(working copy)
@@ -0,0 +1,381 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    1
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      100
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           20
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xe8, 0x03 /* VOTI's lab use PID */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'M', 'o', 'u', 's', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 5
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     3
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+#define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    52
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/examples/hid-mouse/Readme.txt
===================================================================
--- vusb-20121206/examples/hid-mouse/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/hid-mouse/Readme.txt	(working copy)
@@ -0,0 +1,48 @@
+This is the Readme file for hid-mouse, an example of a USB mouse device. In
+order to have as little dependencies on hardware and architecture as
+possible, mouse movements are computed internally so that the mouse pointer
+moves in a circle.
+
+
+WHAT IS DEMONSTRATED?
+=====================
+This example demonstrates how HID class devices are implemented. The example
+is kept as simple as possible, except the report descriptor which is taken
+from a real-world mouse.
+
+It does NOT include a host side driver because all modern operating systems
+include one. It does NOT implement USBRQ_HID_SET_REPORT and report-IDs. See
+the "hid-data" example for this topic. It does NOT implement any special
+features such as suspend mode etc.
+
+
+PREREQUISITES
+=============
+Target hardware: You need an AVR based circuit based on one of the examples
+(see the "circuits" directory at the top level of this package), e.g. the
+metaboard (http://www.obdev.at/goto.php?t=metaboard).
+
+AVR development environment: You need the gcc tool chain for the AVR, see
+the Prerequisites section in the top level Readme file for how to obtain it.
+
+
+BUILDING THE FIRMWARE
+=====================
+Change to the "firmware" directory and modify Makefile according to your
+architecture (CPU clock, target device, fuse values) and ISP programmer. Then
+edit usbconfig.h according to your pin assignments for D+ and D-. The default
+settings are for the metaboard hardware.
+
+Type "make hex" to build main.hex, then "make flash" to upload the firmware
+to the device. Don't forget to run "make fuse" once to program the fuses. If
+you use a prototyping board with boot loader, follow the instructions of the
+boot loader instead.
+
+Please note that the first "make hex" copies the driver from the top level
+into the firmware directory. If you use a different build system than our
+Makefile, you must copy the driver by hand.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/Readme.txt
===================================================================
--- vusb-20121206/examples/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/Readme.txt	(working copy)
@@ -0,0 +1,102 @@
+This is the Readme file for the directory "examples" of V-USB, a firmware-
+only USB driver for AVR microcontrollers.
+
+WHAT IS IN THIS DIRECTORY?
+==========================
+This directory contains examples which are mostly for educational purposes.
+Examples can be device firmware only, host software only or both. Here is
+a summary:
+
+custom-class
+  A custom class device with host software based on libusb. It demonstrates
+  the straight forward way of sending small amounts of data to a device and
+  receiving data from the device. It does NOT demonstrate how to send large
+  amounts of data to the device or how to receive data generated on the fly
+  by the device (how to use usbFunctionWrite() and usbFunctionRead()). See
+  the hid-data example for how usbFunctionWrite() and usbFunctionRead() are
+  used.
+
+hid-custom-rq
+  This example implements the same functionality as the custom-class example
+  above, but declares the device as HID. This prevents the "give me a driver
+  CD" dialog on Windows. The device can still be controlled with libusb as in
+  the previous example (on Windows, the filter version of libusb-win32 must
+  be installed). In addition to the features presented in custom-class, this
+  example demonstrates how a HID class device is defined.
+
+hid-mouse
+  This example implements a mouse device. No host driver is required since
+  today's operating systems have drivers for USB mice built-in. It
+  demonstrates how a real-world HID class device is implemented and how
+  interrupt-in endpoints are used.
+
+hid-data
+  This example demonstrates how the HID class can be misused to transfer
+  arbitrary data over HID feature reports. This technique is of great value
+  on Windows because no driver DLLs are needed (the hid-custom-rq example
+  still requires the libusb-win32 DLL, although it may be in the program's
+  directory). The host side application requires no installation, it can
+  even be started directly from a CD. This example also demonstrates how
+  to transfer data using usbFunctionWrite() and usbFunctionRead().
+
+usbtool
+  This is a general purpose development and debugging tool for USB devices.
+  You can use it during development of your device to test various requests
+  without special test programs. But it is also an example how all the
+  libusb API functions are used.
+
+More information about each example can be found in the Readme file in the
+respective directory.
+
+Hardware dependencies of AVR code has been kept at a minimum. All examples
+should work on any AVR chip which has enough resources to run the driver.
+Makefile and usbconfig.h have been configured for the metaboard hardware (see
+http://www.obdev.at/goto.php?t=metaboard for details). Edit the target
+device, fuse values, clock rate and programmer in Makefile and the I/O pins
+dedicated to USB in usbconfig.h.
+
+
+WHAT IS NOT DEMONSTRATED IN THESE EXAMPLES?
+===========================================
+These examples show only the most basic functionality. More elaborate
+examples and real world applications showing more features of the driver are
+available at http://www.obdev.at/vusb/projects.html. Most of these
+features are described in our documentation wiki at
+http://www.obdev.at/goto.php?t=vusb-wiki.
+
+To mention just a few:
+
+Using RC oscillator for system clock
+  The 12.8 MHz and 16.5 MHz modules of V-USB have been designed to cope
+  with clock rate deviations up to 1%. This allows an RC oscillator to be
+  used. Since the AVR's RC oscillator has a factory precision of only 10%,
+  it must be calibrated to an external reference. The EasyLogger example
+  shows how this can be done.
+
+Dynamically generated descriptors
+  Sometimes you want to implement different typtes of USB device depending
+  on a jumper or other condition. V-USB has a very flexible interface for
+  providing USB descriptors. See AVR-Doper for how to provide descriptors
+  at runtime.
+
+Virtual COM port
+  Some people prefer a virtual serial interface to communicate with their
+  device. We strongly discourage this method because it does things
+  forbidden by the USB specification. If you still want to go this route,
+  see AVR-CDC.
+
+Implementing suspend mode
+  V-USB does not implement suspend mode. This means that the device does
+  not reduce power consumption when the host goes into sleep mode. Device
+  firmware is free to implement suspend mode, though. See USB2LPT for an
+  example.
+
+The projects mentioned above can best be found on
+
+    http://www.obdev.at/vusb/prjall.html
+
+where all projects are listed.
+
+----------------------------------------------------------------------------
+(c) 2009 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/usbtool/Makefile
===================================================================
--- vusb-20121206/examples/usbtool/Makefile	(nonexistent)
+++ vusb-20121206/examples/usbtool/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: usbtool
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = usbtool
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/usbtool/Makefile.windows
===================================================================
--- vusb-20121206/examples/usbtool/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/usbtool/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: usbtool
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/usbtool/Readme.txt
===================================================================
--- vusb-20121206/examples/usbtool/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/usbtool/Readme.txt	(working copy)
@@ -0,0 +1,209 @@
+This is the Readme file for usbtool, a general purpose command line utility
+which can send USB requests to arbitrary devices. Usbtool is based on libusb.
+
+
+WHAT IS USBTOOL GOOD FOR?
+=========================
+When you implement a communication protocol like USB, you must usually write
+two programs: one on each end of the communication. For USB, this means that
+you must write a firmware for the device and driver software for the host.
+
+Usbtool can save you the work of writing the host software, at least during
+firmware development and testing. Usbtool can send control-in and -out
+requests to arbitrary devices and send and receive data on interrupt- and
+bulk-endpoints.
+
+Usbtool is not only a useful developer tool, it's also an example for using
+libusb for communication with the device.
+
+
+SYNOPSIS
+========
+  usbtool [options] <command>
+
+
+COMMANDS
+========
+  list
+    This command prints a list of devices found on all available USB busses.
+    Options -v, -V, -p and -P can be used to filter the list.
+
+  control in|out <type> <recipient> <request> <value> <index>
+    Sends a control-in or control-out request to the device. The request
+    parameters are:
+      type ........ Type of request, can be "standard", "class", "vendor" or
+                    "reserved". The type determines which software module in
+                    the device is responsible for answering the request:
+                    Standard requests are answered by the driver, class
+                    requests by the class implementation (e.g. HID, CDC) and
+                    vendor requests by custom code.
+      recipient ... Recipient of the request in the device. Can be "device",
+                    "interface", "endpoint" or "other". For standard and
+                    class requests, the specification defines a recipient for
+                    each request. For vendor requests, choose whatever your
+                    code expects.
+      request ..... 8 bit numeric value identifying the request.
+      value ....... 16 bit numeric value passed to the device.
+      index ....... another 16 bit numeric value passed to the device.
+    Use options -v, -V, -p and -P to single out a particular device. Use
+    options -d or -D to to send data in an OUT request. Use options -n, -O
+    and -b to determine what to do with data received in an IN request.
+
+  interrupt in|out
+    Sends or receives data on an interrupt-out resp. -in endpoint.
+    Use options -v, -V, -p and -P to single out a particular device. Use
+    options -d or -D to to send data to an OUT endpoint. Use options -n, -O
+    and -b to determine what to do with data received from an IN endpoint.
+    Use option -e to set the endpoint number, -c to choose a configuration
+    -i to claim a particular interface.
+
+  bulk in|out
+    Same as "interrupt in" and "interrupt out", but for bulk endpoints.
+
+
+OPTIONS
+=======
+Most options have already been mentioned at the commands which use them.
+here is a complete list:
+
+  -h or -?
+    Prints a short help.
+
+  -v <vendor-id>
+    Numeric vendor ID, can be "*" to allow any VID. Take only devices with
+    matching vendor ID into account.
+
+  -p <product-id>
+    Numeric product ID, can be "*" to allow any PID. Take only devices with
+    matching product ID into account.
+
+  -V <vendor-name-pattern>
+    Shell style matching pattern for vendor name. Take only devices into
+    account which have a vendor name that matches this pattern.
+
+  -P <product-name-pattern>
+    Shell style matching pattern for product name. Take only devices into
+    account which have a product name that matches this pattern.
+
+  -S <serial-pattern>
+    Shell style matching pattern for serial number. Take only devices into
+    account which have a serial number that matches this pattern.
+
+  -d <databytes>
+    Data bytes to send to the device, comma separated list of numeric values.
+    E.g.: "1,2,3,4,5".
+
+  -D <file>
+    Binary data sent to the device should be taken from this file.
+
+  -O <file>
+    Write received data bytes to the given file. Format is either hex or
+    binary, depending on the -b flag. By default, received data is printed
+    to standard output.
+
+  -b
+    Request binary output format for files and standard output. Default is
+    a hexadecimal listing.
+
+  -n <count>
+    Numeric value: Maximum number of bytes to receive. This value is passed
+    directly to the libusb API functions.
+
+  -e <endpoint>
+    Numeric value: Endpoint number for interrupt and bulk commands.
+
+  -t <timeout>
+    Numeric value: Timeout in milliseconds for the request. This value is
+    passed directly to the libusb API functions.
+
+  -c <configuration>
+    Numeric value: Interrupt and bulk endpoints can usually only be used if
+    a configuration and an interface has been chosen. Use -c and -i to
+    specify configuration and interface values.
+
+  -i <interface>
+    Numeric value: Interrupt and bulk endpoints can usually only be used if
+    a configuration and an interface has been chosen. Use -c and -i to
+    specify configuration and interface values.
+
+  -w
+    Usbtool may be too verbose with warnings for some applications. Use this
+    option to suppress USB warnings.
+
+
+NUMERIC VALUES
+==============
+All numeric values can be given in hexadecimal, decimal or octal. Hex values
+are identified by their 0x or 0X prefix, octal values by a leading "0" (the
+digit zero) and decimal values because they start with a non-zero digit. An
+optional sign character is allowed. The special value "*" is translated to
+zero and stands for "any value" in some contexts.
+
+
+SHELL STYLE MATCHING PATTERNS
+=============================
+Some options take shell style matching patterns as an argument. This refers
+to Unix shells and their file wildcard operations:
+  + "*" (asterisk character) matches any number (0 to infinite) of any
+    characters.
+  + "?" matches exactly one arbitrary character.
+  + A list of characters in square brackets (e.g. "[abc]") matches any of the
+    characters in the list. If a dash ("-") is in the list, it must be the
+    first or the last character. If a caret ("^") is in the list, it must
+    not be the first character. A closing square bracket ("]") must be the
+    first character in the list. A range of characters can be specified in
+    the way "[a-z]". This matches all characters with numeric representation
+    (usually ASCII) starting with "a" and ending with "z". The entire
+    construct matches only one character.
+  + A list of characters in square brackets starting with a caret ("^"), e.g.
+    ("[^abc]") matches any character NOT in the list. The other rules are as
+    above.
+  + "\" (backslash) followed by any character matches that following
+    character. This can be used to escape "*", "?", "[" and "\".
+
+
+BUILDING USBTOOL
+================
+Usbtool uses libusb on Unix and libusb-win32 on Windows. These libraries can
+be obtained from http://libusb.sourceforge.net/ and
+http://libusb-win32.sourceforge.net/ respectively. On Unix, a simple "make"
+should compile the sources (although you may have to edit Makefile to
+include or remove additional libraries). On Windows, we recommend that you
+use MinGW and MSYS. See the top level Readme file for details. Edit
+Makefile.windows according to your library installation paths and build with
+"make -f Makefile.windows".
+
+
+EXAMPLES
+========
+To list all devices connected to your computer, do
+
+    usbtool -w list
+
+To check whether our selection options single out the desired device, use eg.
+
+    usbtool -w -P LEDControl list
+
+This command shows all LEDControl devices connected or prints nothing if
+none is found. LEDControl is the device from the "custom-class" example.
+
+You can also send commands to the LEDControl device using usbtool. From
+the file requests.h in custom-class/firmware, we know that the set-status
+request has numeric value 1 and the get-status request is 2. See this file
+for details of the protocol used. We can therefore query the status with
+
+    usbtool -w -P LEDControl control in vendor device 2 0 0
+
+This command prints 0x00 if the LED is off or 0x01 if it is on. To turn the
+LED on, use
+
+    usbtool -w -P LEDControl control out vendor device 1 1 0
+
+and to turn it off, use
+
+    usbtool -w -P LEDControl control out vendor device 1 0 0
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/usbtool/opendevice.c
===================================================================
--- vusb-20121206/examples/usbtool/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/usbtool/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/usbtool/opendevice.h
===================================================================
--- vusb-20121206/examples/usbtool/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/usbtool/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/usbtool/usbtool.c
===================================================================
--- vusb-20121206/examples/usbtool/usbtool.c	(nonexistent)
+++ vusb-20121206/examples/usbtool/usbtool.c	(working copy)
@@ -0,0 +1,355 @@
+/* Name: usbtool.c
+ * Project: V-USB examples, host side
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-06
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This command line tool can perform various USB requests at arbitrary
+USB devices. It is intended as universal host side tool for experimentation
+and debugging purposes. It must be linked with libusb, a library for accessing
+the USB bus from Linux, FreeBSD, Mac OS X and other Unix operating systems.
+Libusb can be obtained from http://libusb.sourceforge.net/.
+On Windows use libusb-win32 from http://libusb-win32.sourceforge.net/.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include <usb.h>        /* this is libusb, see http://libusb.sourceforge.net/ */
+#include "opendevice.h" /* common code moved to separate module */
+
+#define DEFAULT_USB_VID         0   /* any */
+#define DEFAULT_USB_PID         0   /* any */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage: %s [options] <command>\n", name);
+    fprintf(stderr,
+        "Options are:\n"
+        "  -h or -? (print this help and exit)\n"
+        "  -v <vendor-id> (defaults to 0x%x, can be '*' for any VID)\n"
+        "  -p <product-id> (defaults to 0x%x, can be '*' for any PID)\n"
+        "  -V <vendor-name-pattern> (shell style matching, defaults to '*')\n"
+        "  -P <product-name-pattern> (shell style matching, defaults to '*')\n"
+        "  -S <serial-pattern> (shell style matching, defaults to '*')\n"
+        "  -d <databytes> (data byte for request, comma separated list)\n"
+        "  -D <file> (binary data for request taken from file)\n"
+        "  -O <file> (write received data bytes to file)\n"
+        "  -b (binary output format, default is hex)\n"
+        "  -n <count> (maximum number of bytes to receive)\n"
+        "  -e <endpoint> (specify endpoint for some commands)\n"
+        "  -t <timeout> (specify USB timeout in milliseconds)\n"
+        "  -c <configuration> (device configuration to choose)\n"
+        "  -i <interface> (configuration interface to claim)\n"
+        "  -w (suppress USB warnings, default is verbose)\n"
+        "\n"
+        "Commands are:\n"
+        "  list (list all matching devices by name)\n"
+        "  control in|out <type> <recipient> <request> <value> <index> (send control request)\n"
+        "  interrupt in|out (send or receive interrupt data)\n"
+        "  bulk in|out (send or receive bulk data)\n"
+        "For valid enum values for <type> and <recipient> pass \"x\" for the value.\n"
+        "Objective Development's free VID/PID pairs are:\n"
+        "  5824/1500 for vendor class devices\n"
+        "  5824/1503 for HID class devices excluding mice and keyboards\n"
+        "  5824/1505 for CDC-ACM class devices\n"
+        "  5824/1508 for MIDI class devices\n"
+        , DEFAULT_USB_VID, DEFAULT_USB_PID
+    );
+
+
+}
+
+static int  vendorID = DEFAULT_USB_VID;
+static int  productID = DEFAULT_USB_PID;
+static char *vendorNamePattern = "*";
+static char *productNamePattern = "*";
+static char *serialPattern = "*";
+static char *sendBytes = NULL;
+static int  sendByteCount;
+static char *outputFile = NULL;
+static int  endpoint = 0;
+static int  outputFormatIsBinary = 0;
+static int  showWarnings = 1;
+static int  usbTimeout = 5000;
+static int  usbCount = 128;
+static int  usbConfiguration = 1;
+static int  usbInterface = 0;
+
+static int  usbDirection, usbType, usbRecipient, usbRequest, usbValue, usbIndex; /* arguments of control transfer */
+
+/* ------------------------------------------------------------------------- */
+
+/* ASCII to integer (number parsing) which allows hex (0x prefix),
+ * octal (0 prefix) and decimal (1-9 prefix) input.
+ */
+static int  myAtoi(char *text)
+{
+long    l;
+char    *endPtr;
+
+    if(strcmp(text, "*") == 0)
+        return 0;
+    l = strtol(text, &endPtr, 0);
+    if(endPtr == text){
+        fprintf(stderr, "warning: can't parse numeric parameter ->%s<-, defaults to 0.\n", text);
+        l = 0;
+    }else if(*endPtr != 0){
+        fprintf(stderr, "warning: numeric parameter ->%s<- only partially parsed.\n", text);
+    }
+    return l;
+}
+
+static int  parseEnum(char *text, ...)
+{
+va_list vlist;
+char    *entries[64];
+int     i, numEntries;
+
+    va_start(vlist, text);
+    for(i = 0; i < 64; i++){
+        entries[i] = va_arg(vlist, char *);
+        if(entries[i] == NULL)
+            break;
+    }
+    numEntries = i;
+    va_end(vlist);
+    for(i = 0; i < numEntries; i++){
+        if(strcasecmp(text, entries[i]) == 0)
+            return i;
+    }
+    if(isdigit(*text)){
+        return myAtoi(text);
+    }
+    fprintf(stderr, "Enum value \"%s\" not allowed. Allowed values are:\n", text);
+    for(i = 0; i < numEntries; i++){
+        fprintf(stderr, "  %s\n", entries[i]);
+    }
+    exit(1);
+}
+
+/* ------------------------------------------------------------------------- */
+
+#define ACTION_LIST         0
+#define ACTION_CONTROL      1
+#define ACTION_INTERRUPT    2
+#define ACTION_BULK         3
+
+int main(int argc, char **argv)
+{
+usb_dev_handle  *handle = NULL;
+int             opt, len, action, argcnt;
+char            *myName = argv[0], *s, *rxBuffer = NULL;
+FILE            *fp;
+
+    while((opt = getopt(argc, argv, "?hv:p:V:P:S:d:D:O:e:n:tbw")) != -1){
+        switch(opt){
+        case 'h':
+        case '?':   /* -h or -? (print this help and exit) */
+            usage(myName);
+            exit(1);
+        case 'v':   /* -v <vendor-id> (defaults to 0x%x, can be '*' for any VID) */
+            vendorID = myAtoi(optarg);
+            break;
+        case 'p':   /* -p <product-id> (defaults to 0x%x, can be '*' for any PID) */
+            productID = myAtoi(optarg);
+            break;
+        case 'V':   /* -V <vendor-name-pattern> (shell style matching, defaults to '*') */
+            vendorNamePattern = optarg;
+            break;
+        case 'P':   /* -P <product-name-pattern> (shell style matching, defaults to '*') */
+            productNamePattern = optarg;
+            break;
+        case 'S':   /* -S <serial-pattern> (shell style matching, defaults to '*') */
+            serialPattern = optarg;
+            break;
+        case 'd':   /* -d <databytes> (data bytes for requests given on command line) */
+            while((s = strtok(optarg, ", ")) != NULL){
+                optarg = NULL;
+                if(sendBytes != NULL){
+                    sendBytes = realloc(sendBytes, sendByteCount + 1);
+                }else{
+                    sendBytes = malloc(sendByteCount + 1);
+                }
+                sendBytes[sendByteCount++] = myAtoi(s);
+            }
+            break;
+        case 'D':   /* -D <file> (data bytes for request taken from file) */
+            if((fp = fopen(optarg, "rb")) == NULL){
+                fprintf(stderr, "error opening %s: %s\n", optarg, strerror(errno));
+                exit(1);
+            }
+            fseek(fp, 0, SEEK_END);
+            len = ftell(fp);
+            fseek(fp, 0, SEEK_SET);
+            if(sendBytes != NULL){
+                sendBytes = realloc(sendBytes, sendByteCount + len);
+            }else{
+                sendBytes = malloc(sendByteCount + len);
+            }
+            fread(sendBytes + sendByteCount, 1, len, fp);   /* would need error checking */
+            sendByteCount += len;
+            fclose(fp);
+            break;
+        case 'O':   /* -O <file> (write received data bytes to file) */
+            outputFile = optarg;
+            break;
+        case 'e':   /* -e <endpoint> (specify endpoint for some commands) */
+            endpoint = myAtoi(optarg);
+            break;
+        case 't':   /* -t <timeout> (specify USB timeout in milliseconds) */
+            usbTimeout = myAtoi(optarg);
+            break;
+        case 'b':   /* -b (binary output format, default is hex) */
+            outputFormatIsBinary = 1;
+            break;
+        case 'n':   /* -n <count> (maximum number of bytes to receive) */
+            usbCount = myAtoi(optarg);
+            break;
+        case 'c':   /* -c <configuration> (device configuration to choose) */
+            usbConfiguration = myAtoi(optarg);
+            break;
+        case 'i':   /* -i <interface> (configuration interface to claim) */
+            usbInterface = myAtoi(optarg);
+            break;
+        case 'w':   /* -w (suppress USB warnings, default is verbose) */
+            showWarnings = 0;
+            break;
+        default:
+            fprintf(stderr, "Option -%c unknown\n", opt);
+            exit(1);
+        }
+    }
+    argc -= optind;
+    argv += optind;
+    if(argc < 1){
+        usage(myName);
+        exit(1);
+    }
+    argcnt = 2;
+    if(strcasecmp(argv[0], "list") == 0){
+        action = ACTION_LIST;
+        argcnt = 1;
+    }else if(strcasecmp(argv[0], "control") == 0){
+        action = ACTION_CONTROL;
+        argcnt = 7;
+    }else if(strcasecmp(argv[0], "interrupt") == 0){
+        action = ACTION_INTERRUPT;
+    }else if(strcasecmp(argv[0], "bulk") == 0){
+        action = ACTION_BULK;
+    }else{
+        fprintf(stderr, "command %s not known\n", argv[0]);
+        usage(myName);
+        exit(1);
+    }
+    if(argc < argcnt){
+        fprintf(stderr, "Not enough arguments.\n");
+        usage(myName);
+        exit(1);
+    }
+    if(argc > argcnt){
+        fprintf(stderr, "Warning: only %d arguments expected, rest ignored.\n", argcnt);
+    }
+    usb_init();
+    if(usbOpenDevice(&handle, vendorID, vendorNamePattern, productID, productNamePattern, serialPattern, action == ACTION_LIST ? stdout : NULL, showWarnings ? stderr : NULL) != 0){
+        fprintf(stderr, "Could not find USB device with VID=0x%x PID=0x%x Vname=%s Pname=%s Serial=%s\n", vendorID, productID, vendorNamePattern, productNamePattern, serialPattern);
+        exit(1);
+    }
+    if(action == ACTION_LIST)
+        exit(0);                /* we've done what we were asked to do already */
+    usbDirection = parseEnum(argv[1], "out", "in", NULL);
+    if(usbDirection){   /* IN transfer */
+        rxBuffer = malloc(usbCount);
+    }
+    if(action == ACTION_CONTROL){
+        int requestType;
+        usbType = parseEnum(argv[2], "standard", "class", "vendor", "reserved", NULL);
+        usbRecipient = parseEnum(argv[3], "device", "interface", "endpoint", "other", NULL);
+        usbRequest = myAtoi(argv[4]);
+        usbValue = myAtoi(argv[5]);
+        usbIndex = myAtoi(argv[6]);
+        requestType = ((usbDirection & 1) << 7) | ((usbType & 3) << 5) | (usbRecipient & 0x1f);
+        if(usbDirection){   /* IN transfer */
+            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, rxBuffer, usbCount, usbTimeout);
+        }else{              /* OUT transfer */
+            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, sendBytes, sendByteCount, usbTimeout);
+        }
+    }else{  /* must be ACTION_INTERRUPT or ACTION_BULK */
+        int retries = 1;
+        if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+            fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+        }
+        /* now try to claim the interface and detach the kernel HID driver on
+         * linux and other operating systems which support the call.
+         */
+        while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+            if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+                fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+            }
+#endif
+        }
+        if(len != 0 && showWarnings)
+            fprintf(stderr, "Warning: could not claim interface: %s\n", usb_strerror());
+        if(action == ACTION_INTERRUPT){
+            if(usbDirection){   /* IN transfer */
+                len = usb_interrupt_read(handle, endpoint, rxBuffer, usbCount, usbTimeout);
+            }else{
+                len = usb_interrupt_write(handle, endpoint, sendBytes, sendByteCount, usbTimeout);
+            }
+        }else{
+            if(usbDirection){   /* IN transfer */
+                len = usb_bulk_read(handle, endpoint, rxBuffer, usbCount, usbTimeout);
+            }else{
+                len = usb_bulk_write(handle, endpoint, sendBytes, sendByteCount, usbTimeout);
+            }
+        }
+    }
+    if(len < 0){
+        fprintf(stderr, "USB error: %s\n", usb_strerror());
+        exit(1);
+    }
+    if(usbDirection == 0)   /* OUT */
+        printf("%d bytes sent.\n", len);
+    if(rxBuffer != NULL){
+        FILE *fp = stdout;
+        if(outputFile != NULL){
+            fp = fopen(outputFile, outputFormatIsBinary ? "wb" : "w");
+            if(fp == NULL){
+                fprintf(stderr, "Error writing \"%s\": %s\n", outputFile, strerror(errno));
+                exit(1);
+            }
+        }
+        if(outputFormatIsBinary){
+            fwrite(rxBuffer, 1, len, fp);
+        }else{
+            int i;
+            for(i = 0; i < len; i++){
+                if(i != 0){
+                    if(i % 16 == 0){
+                        fprintf(fp, "\n");
+                    }else{
+                        fprintf(fp, " ");
+                    }
+                }
+                fprintf(fp, "0x%02x", rxBuffer[i] & 0xff);
+            }
+            if(i != 0)
+                fprintf(fp, "\n");
+        }
+    }
+    usb_close(handle);
+    if(rxBuffer != NULL)
+        free(rxBuffer);
+    return 0;
+}
Index: vusb-20121206/examples/usbtool/Makefile
===================================================================
--- vusb-20121206/examples/usbtool/Makefile	(nonexistent)
+++ vusb-20121206/examples/usbtool/Makefile	(working copy)
@@ -0,0 +1,47 @@
+# Name: Makefile
+# Project: usbtool
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+
+# Concigure the following definitions according to your system.
+# This Makefile has been tested on Mac OS X, Linux and Windows.
+
+# Use the following 3 lines on Unix (uncomment the framework on Mac OS X):
+USBFLAGS = `libusb-config --cflags`
+USBLIBS = `libusb-config --libs`
+EXE_SUFFIX =
+
+# Use the following 3 lines on Windows and comment out the 3 above. You may
+# have to change the include paths to where you installed libusb-win32
+#USBFLAGS = -I/usr/local/include
+#USBLIBS = -L/usr/local/lib -lusb
+#EXE_SUFFIX = .exe
+
+NAME = usbtool
+
+OBJECTS = opendevice.o $(NAME).o
+
+CC		= gcc
+CFLAGS	= $(CPPFLAGS) $(USBFLAGS) -O -g -Wall
+LIBS	= $(USBLIBS)
+
+PROGRAM = $(NAME)$(EXE_SUFFIX)
+
+
+all: $(PROGRAM)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+$(PROGRAM): $(OBJECTS)
+	$(CC) -o $(PROGRAM) $(OBJECTS) $(LIBS)
+
+strip: $(PROGRAM)
+	strip $(PROGRAM)
+
+clean:
+	rm -f *.o $(PROGRAM)
Index: vusb-20121206/examples/usbtool/Makefile.windows
===================================================================
--- vusb-20121206/examples/usbtool/Makefile.windows	(nonexistent)
+++ vusb-20121206/examples/usbtool/Makefile.windows	(working copy)
@@ -0,0 +1,17 @@
+# Name: Makefile.windows
+# Project: usbtool
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-06
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# You may use this file with
+#   make -f Makefile.windows
+# on Windows with MinGW instead of editing the main Makefile.
+
+include Makefile
+
+USBFLAGS = -I/usr/local/mingw/include
+USBLIBS = -L/usr/local/mingw/lib -lusb
+EXE_SUFFIX = .exe
Index: vusb-20121206/examples/usbtool/opendevice.c
===================================================================
--- vusb-20121206/examples/usbtool/opendevice.c	(nonexistent)
+++ vusb-20121206/examples/usbtool/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/examples/usbtool/opendevice.h
===================================================================
--- vusb-20121206/examples/usbtool/opendevice.h	(nonexistent)
+++ vusb-20121206/examples/usbtool/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/examples/usbtool/Readme.txt
===================================================================
--- vusb-20121206/examples/usbtool/Readme.txt	(nonexistent)
+++ vusb-20121206/examples/usbtool/Readme.txt	(working copy)
@@ -0,0 +1,209 @@
+This is the Readme file for usbtool, a general purpose command line utility
+which can send USB requests to arbitrary devices. Usbtool is based on libusb.
+
+
+WHAT IS USBTOOL GOOD FOR?
+=========================
+When you implement a communication protocol like USB, you must usually write
+two programs: one on each end of the communication. For USB, this means that
+you must write a firmware for the device and driver software for the host.
+
+Usbtool can save you the work of writing the host software, at least during
+firmware development and testing. Usbtool can send control-in and -out
+requests to arbitrary devices and send and receive data on interrupt- and
+bulk-endpoints.
+
+Usbtool is not only a useful developer tool, it's also an example for using
+libusb for communication with the device.
+
+
+SYNOPSIS
+========
+  usbtool [options] <command>
+
+
+COMMANDS
+========
+  list
+    This command prints a list of devices found on all available USB busses.
+    Options -v, -V, -p and -P can be used to filter the list.
+
+  control in|out <type> <recipient> <request> <value> <index>
+    Sends a control-in or control-out request to the device. The request
+    parameters are:
+      type ........ Type of request, can be "standard", "class", "vendor" or
+                    "reserved". The type determines which software module in
+                    the device is responsible for answering the request:
+                    Standard requests are answered by the driver, class
+                    requests by the class implementation (e.g. HID, CDC) and
+                    vendor requests by custom code.
+      recipient ... Recipient of the request in the device. Can be "device",
+                    "interface", "endpoint" or "other". For standard and
+                    class requests, the specification defines a recipient for
+                    each request. For vendor requests, choose whatever your
+                    code expects.
+      request ..... 8 bit numeric value identifying the request.
+      value ....... 16 bit numeric value passed to the device.
+      index ....... another 16 bit numeric value passed to the device.
+    Use options -v, -V, -p and -P to single out a particular device. Use
+    options -d or -D to to send data in an OUT request. Use options -n, -O
+    and -b to determine what to do with data received in an IN request.
+
+  interrupt in|out
+    Sends or receives data on an interrupt-out resp. -in endpoint.
+    Use options -v, -V, -p and -P to single out a particular device. Use
+    options -d or -D to to send data to an OUT endpoint. Use options -n, -O
+    and -b to determine what to do with data received from an IN endpoint.
+    Use option -e to set the endpoint number, -c to choose a configuration
+    -i to claim a particular interface.
+
+  bulk in|out
+    Same as "interrupt in" and "interrupt out", but for bulk endpoints.
+
+
+OPTIONS
+=======
+Most options have already been mentioned at the commands which use them.
+here is a complete list:
+
+  -h or -?
+    Prints a short help.
+
+  -v <vendor-id>
+    Numeric vendor ID, can be "*" to allow any VID. Take only devices with
+    matching vendor ID into account.
+
+  -p <product-id>
+    Numeric product ID, can be "*" to allow any PID. Take only devices with
+    matching product ID into account.
+
+  -V <vendor-name-pattern>
+    Shell style matching pattern for vendor name. Take only devices into
+    account which have a vendor name that matches this pattern.
+
+  -P <product-name-pattern>
+    Shell style matching pattern for product name. Take only devices into
+    account which have a product name that matches this pattern.
+
+  -S <serial-pattern>
+    Shell style matching pattern for serial number. Take only devices into
+    account which have a serial number that matches this pattern.
+
+  -d <databytes>
+    Data bytes to send to the device, comma separated list of numeric values.
+    E.g.: "1,2,3,4,5".
+
+  -D <file>
+    Binary data sent to the device should be taken from this file.
+
+  -O <file>
+    Write received data bytes to the given file. Format is either hex or
+    binary, depending on the -b flag. By default, received data is printed
+    to standard output.
+
+  -b
+    Request binary output format for files and standard output. Default is
+    a hexadecimal listing.
+
+  -n <count>
+    Numeric value: Maximum number of bytes to receive. This value is passed
+    directly to the libusb API functions.
+
+  -e <endpoint>
+    Numeric value: Endpoint number for interrupt and bulk commands.
+
+  -t <timeout>
+    Numeric value: Timeout in milliseconds for the request. This value is
+    passed directly to the libusb API functions.
+
+  -c <configuration>
+    Numeric value: Interrupt and bulk endpoints can usually only be used if
+    a configuration and an interface has been chosen. Use -c and -i to
+    specify configuration and interface values.
+
+  -i <interface>
+    Numeric value: Interrupt and bulk endpoints can usually only be used if
+    a configuration and an interface has been chosen. Use -c and -i to
+    specify configuration and interface values.
+
+  -w
+    Usbtool may be too verbose with warnings for some applications. Use this
+    option to suppress USB warnings.
+
+
+NUMERIC VALUES
+==============
+All numeric values can be given in hexadecimal, decimal or octal. Hex values
+are identified by their 0x or 0X prefix, octal values by a leading "0" (the
+digit zero) and decimal values because they start with a non-zero digit. An
+optional sign character is allowed. The special value "*" is translated to
+zero and stands for "any value" in some contexts.
+
+
+SHELL STYLE MATCHING PATTERNS
+=============================
+Some options take shell style matching patterns as an argument. This refers
+to Unix shells and their file wildcard operations:
+  + "*" (asterisk character) matches any number (0 to infinite) of any
+    characters.
+  + "?" matches exactly one arbitrary character.
+  + A list of characters in square brackets (e.g. "[abc]") matches any of the
+    characters in the list. If a dash ("-") is in the list, it must be the
+    first or the last character. If a caret ("^") is in the list, it must
+    not be the first character. A closing square bracket ("]") must be the
+    first character in the list. A range of characters can be specified in
+    the way "[a-z]". This matches all characters with numeric representation
+    (usually ASCII) starting with "a" and ending with "z". The entire
+    construct matches only one character.
+  + A list of characters in square brackets starting with a caret ("^"), e.g.
+    ("[^abc]") matches any character NOT in the list. The other rules are as
+    above.
+  + "\" (backslash) followed by any character matches that following
+    character. This can be used to escape "*", "?", "[" and "\".
+
+
+BUILDING USBTOOL
+================
+Usbtool uses libusb on Unix and libusb-win32 on Windows. These libraries can
+be obtained from http://libusb.sourceforge.net/ and
+http://libusb-win32.sourceforge.net/ respectively. On Unix, a simple "make"
+should compile the sources (although you may have to edit Makefile to
+include or remove additional libraries). On Windows, we recommend that you
+use MinGW and MSYS. See the top level Readme file for details. Edit
+Makefile.windows according to your library installation paths and build with
+"make -f Makefile.windows".
+
+
+EXAMPLES
+========
+To list all devices connected to your computer, do
+
+    usbtool -w list
+
+To check whether our selection options single out the desired device, use eg.
+
+    usbtool -w -P LEDControl list
+
+This command shows all LEDControl devices connected or prints nothing if
+none is found. LEDControl is the device from the "custom-class" example.
+
+You can also send commands to the LEDControl device using usbtool. From
+the file requests.h in custom-class/firmware, we know that the set-status
+request has numeric value 1 and the get-status request is 2. See this file
+for details of the protocol used. We can therefore query the status with
+
+    usbtool -w -P LEDControl control in vendor device 2 0 0
+
+This command prints 0x00 if the LED is off or 0x01 if it is on. To turn the
+LED on, use
+
+    usbtool -w -P LEDControl control out vendor device 1 1 0
+
+and to turn it off, use
+
+    usbtool -w -P LEDControl control out vendor device 1 0 0
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/examples/usbtool/usbtool.c
===================================================================
--- vusb-20121206/examples/usbtool/usbtool.c	(nonexistent)
+++ vusb-20121206/examples/usbtool/usbtool.c	(working copy)
@@ -0,0 +1,355 @@
+/* Name: usbtool.c
+ * Project: V-USB examples, host side
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-06
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This command line tool can perform various USB requests at arbitrary
+USB devices. It is intended as universal host side tool for experimentation
+and debugging purposes. It must be linked with libusb, a library for accessing
+the USB bus from Linux, FreeBSD, Mac OS X and other Unix operating systems.
+Libusb can be obtained from http://libusb.sourceforge.net/.
+On Windows use libusb-win32 from http://libusb-win32.sourceforge.net/.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include <usb.h>        /* this is libusb, see http://libusb.sourceforge.net/ */
+#include "opendevice.h" /* common code moved to separate module */
+
+#define DEFAULT_USB_VID         0   /* any */
+#define DEFAULT_USB_PID         0   /* any */
+
+static void usage(char *name)
+{
+    fprintf(stderr, "usage: %s [options] <command>\n", name);
+    fprintf(stderr,
+        "Options are:\n"
+        "  -h or -? (print this help and exit)\n"
+        "  -v <vendor-id> (defaults to 0x%x, can be '*' for any VID)\n"
+        "  -p <product-id> (defaults to 0x%x, can be '*' for any PID)\n"
+        "  -V <vendor-name-pattern> (shell style matching, defaults to '*')\n"
+        "  -P <product-name-pattern> (shell style matching, defaults to '*')\n"
+        "  -S <serial-pattern> (shell style matching, defaults to '*')\n"
+        "  -d <databytes> (data byte for request, comma separated list)\n"
+        "  -D <file> (binary data for request taken from file)\n"
+        "  -O <file> (write received data bytes to file)\n"
+        "  -b (binary output format, default is hex)\n"
+        "  -n <count> (maximum number of bytes to receive)\n"
+        "  -e <endpoint> (specify endpoint for some commands)\n"
+        "  -t <timeout> (specify USB timeout in milliseconds)\n"
+        "  -c <configuration> (device configuration to choose)\n"
+        "  -i <interface> (configuration interface to claim)\n"
+        "  -w (suppress USB warnings, default is verbose)\n"
+        "\n"
+        "Commands are:\n"
+        "  list (list all matching devices by name)\n"
+        "  control in|out <type> <recipient> <request> <value> <index> (send control request)\n"
+        "  interrupt in|out (send or receive interrupt data)\n"
+        "  bulk in|out (send or receive bulk data)\n"
+        "For valid enum values for <type> and <recipient> pass \"x\" for the value.\n"
+        "Objective Development's free VID/PID pairs are:\n"
+        "  5824/1500 for vendor class devices\n"
+        "  5824/1503 for HID class devices excluding mice and keyboards\n"
+        "  5824/1505 for CDC-ACM class devices\n"
+        "  5824/1508 for MIDI class devices\n"
+        , DEFAULT_USB_VID, DEFAULT_USB_PID
+    );
+
+
+}
+
+static int  vendorID = DEFAULT_USB_VID;
+static int  productID = DEFAULT_USB_PID;
+static char *vendorNamePattern = "*";
+static char *productNamePattern = "*";
+static char *serialPattern = "*";
+static char *sendBytes = NULL;
+static int  sendByteCount;
+static char *outputFile = NULL;
+static int  endpoint = 0;
+static int  outputFormatIsBinary = 0;
+static int  showWarnings = 1;
+static int  usbTimeout = 5000;
+static int  usbCount = 128;
+static int  usbConfiguration = 1;
+static int  usbInterface = 0;
+
+static int  usbDirection, usbType, usbRecipient, usbRequest, usbValue, usbIndex; /* arguments of control transfer */
+
+/* ------------------------------------------------------------------------- */
+
+/* ASCII to integer (number parsing) which allows hex (0x prefix),
+ * octal (0 prefix) and decimal (1-9 prefix) input.
+ */
+static int  myAtoi(char *text)
+{
+long    l;
+char    *endPtr;
+
+    if(strcmp(text, "*") == 0)
+        return 0;
+    l = strtol(text, &endPtr, 0);
+    if(endPtr == text){
+        fprintf(stderr, "warning: can't parse numeric parameter ->%s<-, defaults to 0.\n", text);
+        l = 0;
+    }else if(*endPtr != 0){
+        fprintf(stderr, "warning: numeric parameter ->%s<- only partially parsed.\n", text);
+    }
+    return l;
+}
+
+static int  parseEnum(char *text, ...)
+{
+va_list vlist;
+char    *entries[64];
+int     i, numEntries;
+
+    va_start(vlist, text);
+    for(i = 0; i < 64; i++){
+        entries[i] = va_arg(vlist, char *);
+        if(entries[i] == NULL)
+            break;
+    }
+    numEntries = i;
+    va_end(vlist);
+    for(i = 0; i < numEntries; i++){
+        if(strcasecmp(text, entries[i]) == 0)
+            return i;
+    }
+    if(isdigit(*text)){
+        return myAtoi(text);
+    }
+    fprintf(stderr, "Enum value \"%s\" not allowed. Allowed values are:\n", text);
+    for(i = 0; i < numEntries; i++){
+        fprintf(stderr, "  %s\n", entries[i]);
+    }
+    exit(1);
+}
+
+/* ------------------------------------------------------------------------- */
+
+#define ACTION_LIST         0
+#define ACTION_CONTROL      1
+#define ACTION_INTERRUPT    2
+#define ACTION_BULK         3
+
+int main(int argc, char **argv)
+{
+usb_dev_handle  *handle = NULL;
+int             opt, len, action, argcnt;
+char            *myName = argv[0], *s, *rxBuffer = NULL;
+FILE            *fp;
+
+    while((opt = getopt(argc, argv, "?hv:p:V:P:S:d:D:O:e:n:tbw")) != -1){
+        switch(opt){
+        case 'h':
+        case '?':   /* -h or -? (print this help and exit) */
+            usage(myName);
+            exit(1);
+        case 'v':   /* -v <vendor-id> (defaults to 0x%x, can be '*' for any VID) */
+            vendorID = myAtoi(optarg);
+            break;
+        case 'p':   /* -p <product-id> (defaults to 0x%x, can be '*' for any PID) */
+            productID = myAtoi(optarg);
+            break;
+        case 'V':   /* -V <vendor-name-pattern> (shell style matching, defaults to '*') */
+            vendorNamePattern = optarg;
+            break;
+        case 'P':   /* -P <product-name-pattern> (shell style matching, defaults to '*') */
+            productNamePattern = optarg;
+            break;
+        case 'S':   /* -S <serial-pattern> (shell style matching, defaults to '*') */
+            serialPattern = optarg;
+            break;
+        case 'd':   /* -d <databytes> (data bytes for requests given on command line) */
+            while((s = strtok(optarg, ", ")) != NULL){
+                optarg = NULL;
+                if(sendBytes != NULL){
+                    sendBytes = realloc(sendBytes, sendByteCount + 1);
+                }else{
+                    sendBytes = malloc(sendByteCount + 1);
+                }
+                sendBytes[sendByteCount++] = myAtoi(s);
+            }
+            break;
+        case 'D':   /* -D <file> (data bytes for request taken from file) */
+            if((fp = fopen(optarg, "rb")) == NULL){
+                fprintf(stderr, "error opening %s: %s\n", optarg, strerror(errno));
+                exit(1);
+            }
+            fseek(fp, 0, SEEK_END);
+            len = ftell(fp);
+            fseek(fp, 0, SEEK_SET);
+            if(sendBytes != NULL){
+                sendBytes = realloc(sendBytes, sendByteCount + len);
+            }else{
+                sendBytes = malloc(sendByteCount + len);
+            }
+            fread(sendBytes + sendByteCount, 1, len, fp);   /* would need error checking */
+            sendByteCount += len;
+            fclose(fp);
+            break;
+        case 'O':   /* -O <file> (write received data bytes to file) */
+            outputFile = optarg;
+            break;
+        case 'e':   /* -e <endpoint> (specify endpoint for some commands) */
+            endpoint = myAtoi(optarg);
+            break;
+        case 't':   /* -t <timeout> (specify USB timeout in milliseconds) */
+            usbTimeout = myAtoi(optarg);
+            break;
+        case 'b':   /* -b (binary output format, default is hex) */
+            outputFormatIsBinary = 1;
+            break;
+        case 'n':   /* -n <count> (maximum number of bytes to receive) */
+            usbCount = myAtoi(optarg);
+            break;
+        case 'c':   /* -c <configuration> (device configuration to choose) */
+            usbConfiguration = myAtoi(optarg);
+            break;
+        case 'i':   /* -i <interface> (configuration interface to claim) */
+            usbInterface = myAtoi(optarg);
+            break;
+        case 'w':   /* -w (suppress USB warnings, default is verbose) */
+            showWarnings = 0;
+            break;
+        default:
+            fprintf(stderr, "Option -%c unknown\n", opt);
+            exit(1);
+        }
+    }
+    argc -= optind;
+    argv += optind;
+    if(argc < 1){
+        usage(myName);
+        exit(1);
+    }
+    argcnt = 2;
+    if(strcasecmp(argv[0], "list") == 0){
+        action = ACTION_LIST;
+        argcnt = 1;
+    }else if(strcasecmp(argv[0], "control") == 0){
+        action = ACTION_CONTROL;
+        argcnt = 7;
+    }else if(strcasecmp(argv[0], "interrupt") == 0){
+        action = ACTION_INTERRUPT;
+    }else if(strcasecmp(argv[0], "bulk") == 0){
+        action = ACTION_BULK;
+    }else{
+        fprintf(stderr, "command %s not known\n", argv[0]);
+        usage(myName);
+        exit(1);
+    }
+    if(argc < argcnt){
+        fprintf(stderr, "Not enough arguments.\n");
+        usage(myName);
+        exit(1);
+    }
+    if(argc > argcnt){
+        fprintf(stderr, "Warning: only %d arguments expected, rest ignored.\n", argcnt);
+    }
+    usb_init();
+    if(usbOpenDevice(&handle, vendorID, vendorNamePattern, productID, productNamePattern, serialPattern, action == ACTION_LIST ? stdout : NULL, showWarnings ? stderr : NULL) != 0){
+        fprintf(stderr, "Could not find USB device with VID=0x%x PID=0x%x Vname=%s Pname=%s Serial=%s\n", vendorID, productID, vendorNamePattern, productNamePattern, serialPattern);
+        exit(1);
+    }
+    if(action == ACTION_LIST)
+        exit(0);                /* we've done what we were asked to do already */
+    usbDirection = parseEnum(argv[1], "out", "in", NULL);
+    if(usbDirection){   /* IN transfer */
+        rxBuffer = malloc(usbCount);
+    }
+    if(action == ACTION_CONTROL){
+        int requestType;
+        usbType = parseEnum(argv[2], "standard", "class", "vendor", "reserved", NULL);
+        usbRecipient = parseEnum(argv[3], "device", "interface", "endpoint", "other", NULL);
+        usbRequest = myAtoi(argv[4]);
+        usbValue = myAtoi(argv[5]);
+        usbIndex = myAtoi(argv[6]);
+        requestType = ((usbDirection & 1) << 7) | ((usbType & 3) << 5) | (usbRecipient & 0x1f);
+        if(usbDirection){   /* IN transfer */
+            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, rxBuffer, usbCount, usbTimeout);
+        }else{              /* OUT transfer */
+            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, sendBytes, sendByteCount, usbTimeout);
+        }
+    }else{  /* must be ACTION_INTERRUPT or ACTION_BULK */
+        int retries = 1;
+        if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
+            fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
+        }
+        /* now try to claim the interface and detach the kernel HID driver on
+         * linux and other operating systems which support the call.
+         */
+        while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
+#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
+            if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
+                fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
+            }
+#endif
+        }
+        if(len != 0 && showWarnings)
+            fprintf(stderr, "Warning: could not claim interface: %s\n", usb_strerror());
+        if(action == ACTION_INTERRUPT){
+            if(usbDirection){   /* IN transfer */
+                len = usb_interrupt_read(handle, endpoint, rxBuffer, usbCount, usbTimeout);
+            }else{
+                len = usb_interrupt_write(handle, endpoint, sendBytes, sendByteCount, usbTimeout);
+            }
+        }else{
+            if(usbDirection){   /* IN transfer */
+                len = usb_bulk_read(handle, endpoint, rxBuffer, usbCount, usbTimeout);
+            }else{
+                len = usb_bulk_write(handle, endpoint, sendBytes, sendByteCount, usbTimeout);
+            }
+        }
+    }
+    if(len < 0){
+        fprintf(stderr, "USB error: %s\n", usb_strerror());
+        exit(1);
+    }
+    if(usbDirection == 0)   /* OUT */
+        printf("%d bytes sent.\n", len);
+    if(rxBuffer != NULL){
+        FILE *fp = stdout;
+        if(outputFile != NULL){
+            fp = fopen(outputFile, outputFormatIsBinary ? "wb" : "w");
+            if(fp == NULL){
+                fprintf(stderr, "Error writing \"%s\": %s\n", outputFile, strerror(errno));
+                exit(1);
+            }
+        }
+        if(outputFormatIsBinary){
+            fwrite(rxBuffer, 1, len, fp);
+        }else{
+            int i;
+            for(i = 0; i < len; i++){
+                if(i != 0){
+                    if(i % 16 == 0){
+                        fprintf(fp, "\n");
+                    }else{
+                        fprintf(fp, " ");
+                    }
+                }
+                fprintf(fp, "0x%02x", rxBuffer[i] & 0xff);
+            }
+            if(i != 0)
+                fprintf(fp, "\n");
+        }
+    }
+    usb_close(handle);
+    if(rxBuffer != NULL)
+        free(rxBuffer);
+    return 0;
+}
Index: vusb-20121206/libs-device/Readme.txt
===================================================================
--- vusb-20121206/libs-device/Readme.txt	(nonexistent)
+++ vusb-20121206/libs-device/Readme.txt	(working copy)
@@ -0,0 +1,22 @@
+This is the Readme file for the libs-device directory. This directory contains
+code snippets which may be useful for USB device firmware.
+
+
+WHAT IS INCLUDED IN THIS DIRECTORY?
+===================================
+
+osccal.c and osccal.h
+  This module contains a function which calibrates the AVR's built-in RC
+  oscillator based on the USB frame clock. See osccal.h for a documentation
+  of the API.
+
+osctune.h
+  This header file contains a code snippet for usbconfig.h. With this code,
+  you can keep the AVR's internal RC oscillator in sync with the USB frame
+  clock. This is a continuous synchronization, not a single calibration at
+  USB reset as with osccal.c above. Please note that this code works only
+  if D- is wired to the interrupt, not D+.
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/libs-device/osccal.c
===================================================================
--- vusb-20121206/libs-device/osccal.c	(nonexistent)
+++ vusb-20121206/libs-device/osccal.c	(working copy)
@@ -0,0 +1,62 @@
+/* Name: osccal.c
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <avr/io.h>
+
+#ifndef uchar
+#define uchar   unsigned char
+#endif
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------ Oscillator Calibration ------------------------- */
+/* ------------------------------------------------------------------------- */
+
+/* Calibrate the RC oscillator. Our timing reference is the Start Of Frame
+ * signal (a single SE0 bit) repeating every millisecond immediately after
+ * a USB RESET. We first do a binary search for the OSCCAL value and then
+ * optimize this value with a neighboorhod search.
+ */
+void    calibrateOscillator(void)
+{
+uchar       step = 128;
+uchar       trialValue = 0, optimumValue;
+int         x, optimumDev, targetValue = (unsigned)(1499 * (double)F_CPU / 10.5e6 + 0.5);
+
+    /* do a binary search: */
+    do{
+        OSCCAL = trialValue + step;
+        x = usbMeasureFrameLength();    /* proportional to current real frequency */
+        if(x < targetValue)             /* frequency still too low */
+            trialValue += step;
+        step >>= 1;
+    }while(step > 0);
+    /* We have a precision of +/- 1 for optimum OSCCAL here */
+    /* now do a neighborhood search for optimum value */
+    optimumValue = trialValue;
+    optimumDev = x; /* this is certainly far away from optimum */
+    for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){
+        x = usbMeasureFrameLength() - targetValue;
+        if(x < 0)
+            x = -x;
+        if(x < optimumDev){
+            optimumDev = x;
+            optimumValue = OSCCAL;
+        }
+    }
+    OSCCAL = optimumValue;
+}
+/*
+Note: This calibration algorithm may try OSCCAL values of up to 192 even if
+the optimum value is far below 192. It may therefore exceed the allowed clock
+frequency of the CPU in low voltage designs!
+You may replace this search algorithm with any other algorithm you like if
+you have additional constraints such as a maximum CPU clock.
+For version 5.x RC oscillators (those with a split range of 2x128 steps, e.g.
+ATTiny25, ATTiny45, ATTiny85), it may be useful to search for the optimum in
+both regions.
+*/
Index: vusb-20121206/libs-device/osccal.h
===================================================================
--- vusb-20121206/libs-device/osccal.h	(nonexistent)
+++ vusb-20121206/libs-device/osccal.h	(working copy)
@@ -0,0 +1,62 @@
+/* Name: osccal.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module contains a function which calibrates the AVR's internal RC
+oscillator so that the CPU runs at F_CPU (F_CPU is a macro which must be
+defined when the module is compiled, best passed in the compiler command
+line). The time reference is the USB frame clock of 1 kHz available
+immediately after a USB RESET condition. Timing is done by counting CPU
+cycles, so all interrupts must be disabled while the calibration runs. For
+low level timing measurements, usbMeasureFrameLength() is called. This
+function must be enabled in usbconfig.h by defining
+USB_CFG_HAVE_MEASURE_FRAME_LENGTH to 1. It is recommended to call
+calibrateOscillator() from the reset hook in usbconfig.h:
+
+#ifndef __ASSEMBLER__
+#include <avr/interrupt.h>  // for sei()
+extern void calibrateOscillator(void);
+#endif
+#define USB_RESET_HOOK(resetStarts)  if(!resetStarts){cli(); calibrateOscillator(); sei();}
+
+This routine is an alternative to the continuous synchronization described
+in osctune.h.
+
+Algorithm used:
+calibrateOscillator() first does a binary search in the OSCCAL register for
+the best matching oscillator frequency. Then it does a next neighbor search
+to find the value with the lowest clock rate deviation. It is guaranteed to
+find the best match among neighboring values, but for version 5 oscillators
+(which have a discontinuous relationship between OSCCAL and frequency) a
+better match might be available in another OSCCAL region.
+
+Limitations:
+This calibration algorithm may try OSCCAL values of up to 192 even if the
+optimum value is far below 192. It may therefore exceed the allowed clock
+frequency of the CPU in low voltage designs!
+Precision depends on the OSCCAL vs. frequency dependency of the oscillator.
+Typical precision for an ATMega168 (derived from the OSCCAL vs. F_RC diagram
+in the data sheet) should be in the range of 0.4%. Only the 12.8 MHz and
+16.5 MHz versions of V-USB (with built-in receiver PLL) can tolerate this
+deviation! All other frequency modules require at least 0.2% precision.
+*/
+
+#ifndef __OSCCAL_H_INCLUDED__
+#define __OSCCAL_H_INCLUDED__
+
+void    calibrateOscillator(void);
+/* This function calibrates the RC oscillator so that the CPU runs at F_CPU.
+ * It MUST be called immediately after the end of a USB RESET condition!
+ * Disable all interrupts during the call!
+ * It is recommended that you store the resulting value in EEPROM so that a
+ * good guess value is available after the next reset.
+ */
+
+
+#endif /* __OSCCAL_H_INCLUDED__ */
Index: vusb-20121206/libs-device/osctune.h
===================================================================
--- vusb-20121206/libs-device/osctune.h	(nonexistent)
+++ vusb-20121206/libs-device/osctune.h	(working copy)
@@ -0,0 +1,87 @@
+/* Name: osctune.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-10-18
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This file is declared as C-header file although it is mostly documentation
+how the RC oscillator can be kept in sync to the USB frame rate. The code
+shown here must be added to usbconfig.h or this header file is included from
+there. This code works only if D- is wired to the interrupt, not D+!!!
+
+This is an alternative to the osccal routine in osccal.c. It has the advantage
+that the synchronization is done continuously and that it has more compact
+code size. The disadvantages are slow synchronization (it may take a while
+until the driver works), that messages immediately after the SOF pulse may be
+lost (and need to be retried by the host) and that the interrupt is on D-
+contrary to most examples.
+
+You may want to store a good calibration value in EEPROM for the next startup.
+You know that the calibration value is good when the first USB message is
+received. Do not store the value on every received message because the EEPROM
+has a limited endurance.
+
+Notes:
+(*) You must declare the global character variable "lastTimer0Value" in your
+main code.
+
+(*) Timer 0 must be free running (not written by your code) and the prescaling
+must be consistent with the TIMER0_PRESCALING define.
+
+(*) Good values for Timer 0 prescaling depend on how precise the clock must
+be tuned and how far away from the default clock rate the target clock is.
+For precise tuning, choose a low prescaler factor, for a broad range of tuning
+choose a high one. A prescaler factor of 64 is good for the entire OSCCAL
+range and allows a precision of better than +/-1%. A prescaler factor of 8
+allows tuning to slightly more than +/-6% of the default frequency and is
+more precise than one step of OSCCAL. It is therefore not suitable to tune an
+8 MHz oscillator to 12.5 MHz.
+
+Thanks to Henrik Haftmann for the idea to this routine!
+*/
+
+#define TIMER0_PRESCALING           64 /* must match the configuration for TIMER0 in main */
+#define TOLERATED_DEVIATION_PPT     5  /* max clock deviation before we tune in 1/10 % */
+/* derived constants: */
+#define EXPECTED_TIMER0_INCREMENT   ((F_CPU / (1000 * TIMER0_PRESCALING)) & 0xff)
+#define TOLERATED_DEVIATION         (TOLERATED_DEVIATION_PPT * F_CPU / (1000000 * TIMER0_PRESCALING))
+
+#ifdef __ASSEMBLER__
+macro tuneOsccal
+    push    YH                              ;[0]
+    in      YL, TCNT0                       ;[2]
+    lds     YH, lastTimer0Value             ;[3]
+    sts     lastTimer0Value, YL             ;[5]
+    sub     YL, YH                          ;[7] time passed since last frame
+    subi    YL, EXPECTED_TIMER0_INCREMENT   ;[8]
+#if OSCCAL > 0x3f   /* outside I/O addressable range */
+    lds     YH, OSCCAL                      ;[6]
+#else
+    in      YH, OSCCAL                      ;[6] assembler modle uses __SFR_OFFSET == 0
+#endif
+    cpi     YL, TOLERATED_DEVIATION + 1     ;[10]
+    brmi    notTooHigh                      ;[11]
+    subi    YH, 1                           ;[12] clock rate was too high
+;   brcs    tuningOverflow                  ; optionally check for overflow
+    rjmp    osctuneDone                     ;[13]
+notTooHigh:
+    cpi     YL, -TOLERATED_DEVIATION        ;[13]
+    brpl    osctuneDone                     ;[14] not too low
+    inc     YH                              ;[15] clock rate was too low
+;   breq    tuningOverflow                  ; optionally check for overflow
+osctuneDone:
+#if OSCCAL > 0x3f   /* outside I/O addressable range */
+    sts     OSCCAL, YH                      ;[12-13] store tuned value
+#else
+    out     OSCCAL, YH                      ;[12-13] store tuned value
+#endif
+tuningOverflow:
+    pop     YH                              ;[17]
+    endm                                    ;[19] max number of cycles
+#endif
+
+#define USB_SOF_HOOK        tuneOsccal
Index: vusb-20121206/libs-device/osccal.c
===================================================================
--- vusb-20121206/libs-device/osccal.c	(nonexistent)
+++ vusb-20121206/libs-device/osccal.c	(working copy)
@@ -0,0 +1,62 @@
+/* Name: osccal.c
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <avr/io.h>
+
+#ifndef uchar
+#define uchar   unsigned char
+#endif
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------ Oscillator Calibration ------------------------- */
+/* ------------------------------------------------------------------------- */
+
+/* Calibrate the RC oscillator. Our timing reference is the Start Of Frame
+ * signal (a single SE0 bit) repeating every millisecond immediately after
+ * a USB RESET. We first do a binary search for the OSCCAL value and then
+ * optimize this value with a neighboorhod search.
+ */
+void    calibrateOscillator(void)
+{
+uchar       step = 128;
+uchar       trialValue = 0, optimumValue;
+int         x, optimumDev, targetValue = (unsigned)(1499 * (double)F_CPU / 10.5e6 + 0.5);
+
+    /* do a binary search: */
+    do{
+        OSCCAL = trialValue + step;
+        x = usbMeasureFrameLength();    /* proportional to current real frequency */
+        if(x < targetValue)             /* frequency still too low */
+            trialValue += step;
+        step >>= 1;
+    }while(step > 0);
+    /* We have a precision of +/- 1 for optimum OSCCAL here */
+    /* now do a neighborhood search for optimum value */
+    optimumValue = trialValue;
+    optimumDev = x; /* this is certainly far away from optimum */
+    for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){
+        x = usbMeasureFrameLength() - targetValue;
+        if(x < 0)
+            x = -x;
+        if(x < optimumDev){
+            optimumDev = x;
+            optimumValue = OSCCAL;
+        }
+    }
+    OSCCAL = optimumValue;
+}
+/*
+Note: This calibration algorithm may try OSCCAL values of up to 192 even if
+the optimum value is far below 192. It may therefore exceed the allowed clock
+frequency of the CPU in low voltage designs!
+You may replace this search algorithm with any other algorithm you like if
+you have additional constraints such as a maximum CPU clock.
+For version 5.x RC oscillators (those with a split range of 2x128 steps, e.g.
+ATTiny25, ATTiny45, ATTiny85), it may be useful to search for the optimum in
+both regions.
+*/
Index: vusb-20121206/libs-device/osccal.h
===================================================================
--- vusb-20121206/libs-device/osccal.h	(nonexistent)
+++ vusb-20121206/libs-device/osccal.h	(working copy)
@@ -0,0 +1,62 @@
+/* Name: osccal.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module contains a function which calibrates the AVR's internal RC
+oscillator so that the CPU runs at F_CPU (F_CPU is a macro which must be
+defined when the module is compiled, best passed in the compiler command
+line). The time reference is the USB frame clock of 1 kHz available
+immediately after a USB RESET condition. Timing is done by counting CPU
+cycles, so all interrupts must be disabled while the calibration runs. For
+low level timing measurements, usbMeasureFrameLength() is called. This
+function must be enabled in usbconfig.h by defining
+USB_CFG_HAVE_MEASURE_FRAME_LENGTH to 1. It is recommended to call
+calibrateOscillator() from the reset hook in usbconfig.h:
+
+#ifndef __ASSEMBLER__
+#include <avr/interrupt.h>  // for sei()
+extern void calibrateOscillator(void);
+#endif
+#define USB_RESET_HOOK(resetStarts)  if(!resetStarts){cli(); calibrateOscillator(); sei();}
+
+This routine is an alternative to the continuous synchronization described
+in osctune.h.
+
+Algorithm used:
+calibrateOscillator() first does a binary search in the OSCCAL register for
+the best matching oscillator frequency. Then it does a next neighbor search
+to find the value with the lowest clock rate deviation. It is guaranteed to
+find the best match among neighboring values, but for version 5 oscillators
+(which have a discontinuous relationship between OSCCAL and frequency) a
+better match might be available in another OSCCAL region.
+
+Limitations:
+This calibration algorithm may try OSCCAL values of up to 192 even if the
+optimum value is far below 192. It may therefore exceed the allowed clock
+frequency of the CPU in low voltage designs!
+Precision depends on the OSCCAL vs. frequency dependency of the oscillator.
+Typical precision for an ATMega168 (derived from the OSCCAL vs. F_RC diagram
+in the data sheet) should be in the range of 0.4%. Only the 12.8 MHz and
+16.5 MHz versions of V-USB (with built-in receiver PLL) can tolerate this
+deviation! All other frequency modules require at least 0.2% precision.
+*/
+
+#ifndef __OSCCAL_H_INCLUDED__
+#define __OSCCAL_H_INCLUDED__
+
+void    calibrateOscillator(void);
+/* This function calibrates the RC oscillator so that the CPU runs at F_CPU.
+ * It MUST be called immediately after the end of a USB RESET condition!
+ * Disable all interrupts during the call!
+ * It is recommended that you store the resulting value in EEPROM so that a
+ * good guess value is available after the next reset.
+ */
+
+
+#endif /* __OSCCAL_H_INCLUDED__ */
Index: vusb-20121206/libs-device/osctune.h
===================================================================
--- vusb-20121206/libs-device/osctune.h	(nonexistent)
+++ vusb-20121206/libs-device/osctune.h	(working copy)
@@ -0,0 +1,87 @@
+/* Name: osctune.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-10-18
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This file is declared as C-header file although it is mostly documentation
+how the RC oscillator can be kept in sync to the USB frame rate. The code
+shown here must be added to usbconfig.h or this header file is included from
+there. This code works only if D- is wired to the interrupt, not D+!!!
+
+This is an alternative to the osccal routine in osccal.c. It has the advantage
+that the synchronization is done continuously and that it has more compact
+code size. The disadvantages are slow synchronization (it may take a while
+until the driver works), that messages immediately after the SOF pulse may be
+lost (and need to be retried by the host) and that the interrupt is on D-
+contrary to most examples.
+
+You may want to store a good calibration value in EEPROM for the next startup.
+You know that the calibration value is good when the first USB message is
+received. Do not store the value on every received message because the EEPROM
+has a limited endurance.
+
+Notes:
+(*) You must declare the global character variable "lastTimer0Value" in your
+main code.
+
+(*) Timer 0 must be free running (not written by your code) and the prescaling
+must be consistent with the TIMER0_PRESCALING define.
+
+(*) Good values for Timer 0 prescaling depend on how precise the clock must
+be tuned and how far away from the default clock rate the target clock is.
+For precise tuning, choose a low prescaler factor, for a broad range of tuning
+choose a high one. A prescaler factor of 64 is good for the entire OSCCAL
+range and allows a precision of better than +/-1%. A prescaler factor of 8
+allows tuning to slightly more than +/-6% of the default frequency and is
+more precise than one step of OSCCAL. It is therefore not suitable to tune an
+8 MHz oscillator to 12.5 MHz.
+
+Thanks to Henrik Haftmann for the idea to this routine!
+*/
+
+#define TIMER0_PRESCALING           64 /* must match the configuration for TIMER0 in main */
+#define TOLERATED_DEVIATION_PPT     5  /* max clock deviation before we tune in 1/10 % */
+/* derived constants: */
+#define EXPECTED_TIMER0_INCREMENT   ((F_CPU / (1000 * TIMER0_PRESCALING)) & 0xff)
+#define TOLERATED_DEVIATION         (TOLERATED_DEVIATION_PPT * F_CPU / (1000000 * TIMER0_PRESCALING))
+
+#ifdef __ASSEMBLER__
+macro tuneOsccal
+    push    YH                              ;[0]
+    in      YL, TCNT0                       ;[2]
+    lds     YH, lastTimer0Value             ;[3]
+    sts     lastTimer0Value, YL             ;[5]
+    sub     YL, YH                          ;[7] time passed since last frame
+    subi    YL, EXPECTED_TIMER0_INCREMENT   ;[8]
+#if OSCCAL > 0x3f   /* outside I/O addressable range */
+    lds     YH, OSCCAL                      ;[6]
+#else
+    in      YH, OSCCAL                      ;[6] assembler modle uses __SFR_OFFSET == 0
+#endif
+    cpi     YL, TOLERATED_DEVIATION + 1     ;[10]
+    brmi    notTooHigh                      ;[11]
+    subi    YH, 1                           ;[12] clock rate was too high
+;   brcs    tuningOverflow                  ; optionally check for overflow
+    rjmp    osctuneDone                     ;[13]
+notTooHigh:
+    cpi     YL, -TOLERATED_DEVIATION        ;[13]
+    brpl    osctuneDone                     ;[14] not too low
+    inc     YH                              ;[15] clock rate was too low
+;   breq    tuningOverflow                  ; optionally check for overflow
+osctuneDone:
+#if OSCCAL > 0x3f   /* outside I/O addressable range */
+    sts     OSCCAL, YH                      ;[12-13] store tuned value
+#else
+    out     OSCCAL, YH                      ;[12-13] store tuned value
+#endif
+tuningOverflow:
+    pop     YH                              ;[17]
+    endm                                    ;[19] max number of cycles
+#endif
+
+#define USB_SOF_HOOK        tuneOsccal
Index: vusb-20121206/libs-device/Readme.txt
===================================================================
--- vusb-20121206/libs-device/Readme.txt	(nonexistent)
+++ vusb-20121206/libs-device/Readme.txt	(working copy)
@@ -0,0 +1,22 @@
+This is the Readme file for the libs-device directory. This directory contains
+code snippets which may be useful for USB device firmware.
+
+
+WHAT IS INCLUDED IN THIS DIRECTORY?
+===================================
+
+osccal.c and osccal.h
+  This module contains a function which calibrates the AVR's built-in RC
+  oscillator based on the USB frame clock. See osccal.h for a documentation
+  of the API.
+
+osctune.h
+  This header file contains a code snippet for usbconfig.h. With this code,
+  you can keep the AVR's internal RC oscillator in sync with the USB frame
+  clock. This is a continuous synchronization, not a single calibration at
+  USB reset as with osccal.c above. Please note that this code works only
+  if D- is wired to the interrupt, not D+.
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/libs-host/Readme.txt
===================================================================
--- vusb-20121206/libs-host/Readme.txt	(nonexistent)
+++ vusb-20121206/libs-host/Readme.txt	(working copy)
@@ -0,0 +1,26 @@
+This is the Readme file for the libs-host directory. This directory contains
+code snippets which may be useful for host side USB software.
+
+
+WHAT IS INCLUDED IN THIS DIRECTORY?
+===================================
+
+opendevice.c and opendevice.h
+  This module contains a function to find and open a device given its
+  numeric IDs (VID, PID), names (vendor name and product name) and serial
+  number. It is based on libusb/libusb-win32 and returns a libusb device
+  handle. See opendevice.h for an API documentation.
+
+hiddata.c and hiddata.h
+  This module contains functions for data transfer over HID feature reports.
+  It is based on libusb on Unix and native Windows functions on Windows. No
+  driver DLL is needed on Windows. See hiddata.h for an API documentation.
+
+hidsdi.h
+  This DDK header file is missing in the free MinGW version of the Windows
+  DDK. Use this version if you get an "include file not found" error.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/libs-host/hiddata.c
===================================================================
--- vusb-20121206/libs-host/hiddata.c	(nonexistent)
+++ vusb-20121206/libs-host/hiddata.c	(working copy)
@@ -0,0 +1,323 @@
+/* Name: hiddata.c
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include "hiddata.h"
+
+/* ######################################################################## */
+#if defined(WIN32) /* ##################################################### */
+/* ######################################################################## */
+
+#include <windows.h>
+#include <setupapi.h>
+#include "hidsdi.h"
+#include <ddk/hidpi.h>
+
+#ifdef DEBUG
+#define DEBUG_PRINT(arg)    printf arg
+#else
+#define DEBUG_PRINT(arg)
+#endif
+
+/* ------------------------------------------------------------------------ */
+
+static void convertUniToAscii(char *buffer)
+{
+unsigned short  *uni = (void *)buffer;
+char            *ascii = buffer;
+
+    while(*uni != 0){
+        if(*uni >= 256){
+            *ascii++ = '?';
+        }else{
+            *ascii++ = *uni++;
+        }
+    }
+    *ascii++ = 0;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int usesReportIDs)
+{
+GUID                                hidGuid;        /* GUID for HID driver */
+HDEVINFO                            deviceInfoList;
+SP_DEVICE_INTERFACE_DATA            deviceInfo;
+SP_DEVICE_INTERFACE_DETAIL_DATA     *deviceDetails = NULL;
+DWORD                               size;
+int                                 i, openFlag = 0;  /* may be FILE_FLAG_OVERLAPPED */
+int                                 errorCode = USBOPEN_ERR_NOTFOUND;
+HANDLE                              handle = INVALID_HANDLE_VALUE;
+HIDD_ATTRIBUTES                     deviceAttributes;
+				
+    HidD_GetHidGuid(&hidGuid);
+    deviceInfoList = SetupDiGetClassDevs(&hidGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
+    deviceInfo.cbSize = sizeof(deviceInfo);
+    for(i=0;;i++){
+        if(handle != INVALID_HANDLE_VALUE){
+            CloseHandle(handle);
+            handle = INVALID_HANDLE_VALUE;
+        }
+        if(!SetupDiEnumDeviceInterfaces(deviceInfoList, 0, &hidGuid, i, &deviceInfo))
+            break;  /* no more entries */
+        /* first do a dummy call just to determine the actual size required */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, NULL, 0, &size, NULL);
+        if(deviceDetails != NULL)
+            free(deviceDetails);
+        deviceDetails = malloc(size);
+        deviceDetails->cbSize = sizeof(*deviceDetails);
+        /* this call is for real: */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, deviceDetails, size, &size, NULL);
+        DEBUG_PRINT(("checking HID path \"%s\"\n", deviceDetails->DevicePath));
+#if 0
+        /* If we want to access a mouse our keyboard, we can only use feature
+         * requests as the device is locked by Windows. It must be opened
+         * with ACCESS_TYPE_NONE.
+         */
+        handle = CreateFile(deviceDetails->DevicePath, ACCESS_TYPE_NONE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+#endif
+        /* attempt opening for R/W -- we don't care about devices which can't be accessed */
+        handle = CreateFile(deviceDetails->DevicePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+        if(handle == INVALID_HANDLE_VALUE){
+            DEBUG_PRINT(("opening failed: %d\n", (int)GetLastError()));
+            /* errorCode = USBOPEN_ERR_ACCESS; opening will always fail for mouse -- ignore */
+            continue;
+        }
+        deviceAttributes.Size = sizeof(deviceAttributes);
+        HidD_GetAttributes(handle, &deviceAttributes);
+        DEBUG_PRINT(("device attributes: vid=%d pid=%d\n", deviceAttributes.VendorID, deviceAttributes.ProductID));
+        if(deviceAttributes.VendorID != vendor || deviceAttributes.ProductID != product)
+            continue;   /* ignore this device */
+        errorCode = USBOPEN_ERR_NOTFOUND;
+        if(vendorName != NULL && productName != NULL){
+            char    buffer[512];
+            if(!HidD_GetManufacturerString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining vendor name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("vendorName = \"%s\"\n", buffer));
+            if(strcmp(vendorName, buffer) != 0)
+                continue;
+            if(!HidD_GetProductString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining product name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("productName = \"%s\"\n", buffer));
+            if(strcmp(productName, buffer) != 0)
+                continue;
+        }
+        break;  /* we have found the device we are looking for! */
+    }
+    SetupDiDestroyDeviceInfoList(deviceInfoList);
+    if(deviceDetails != NULL)
+        free(deviceDetails);
+    if(handle != INVALID_HANDLE_VALUE){
+        *device = (usbDevice_t *)handle;
+        errorCode = 0;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------ */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    CloseHandle((HANDLE)device);
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+BOOLEAN rval;
+
+    rval = HidD_SetFeature((HANDLE)device, buffer, len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+BOOLEAN rval = 0;
+
+    buffer[0] = reportNumber;
+    rval = HidD_GetFeature((HANDLE)device, buffer, *len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+/* ######################################################################## */
+#else /* defined WIN32 #################################################### */
+/* ######################################################################## */
+
+#include <string.h>
+#include <usb.h>
+
+#define usbDevice   usb_dev_handle  /* use libusb's device structure */
+
+/* ------------------------------------------------------------------------- */
+
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_SET_REPORT    0x09
+
+#define USB_HID_REPORT_TYPE_FEATURE 3
+
+
+static int  usesReportIDs;
+
+/* ------------------------------------------------------------------------- */
+
+static int usbhidGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int _usesReportIDs)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+static int          didUsbInit = 0;
+
+    if(!didUsbInit){
+        usb_init();
+        didUsbInit = 1;
+    }
+    usb_find_busses();
+    usb_find_devices();
+    for(bus=usb_get_busses(); bus; bus=bus->next){
+        for(dev=bus->devices; dev; dev=dev->next){
+            if(dev->descriptor.idVendor == vendor && dev->descriptor.idProduct == product){
+                char    string[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    fprintf(stderr, "Warning: cannot open USB device: %s\n", usb_strerror());
+                    continue;
+                }
+                if(vendorName == NULL && productName == NULL){  /* name does not matter */
+                    break;
+                }
+                /* now check whether the names match: */
+                len = usbhidGetStringAscii(handle, dev->descriptor.iManufacturer, string, sizeof(string));
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_IO;
+                    fprintf(stderr, "Warning: cannot query manufacturer for device: %s\n", usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* fprintf(stderr, "seen device from vendor ->%s<-\n", string); */
+                    if(strcmp(string, vendorName) == 0){
+                        len = usbhidGetStringAscii(handle, dev->descriptor.iProduct, string, sizeof(string));
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_IO;
+                            fprintf(stderr, "Warning: cannot query product for device: %s\n", usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* fprintf(stderr, "seen product ->%s<-\n", string); */
+                            if(strcmp(string, productName) == 0)
+                                break;
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = (void *)handle;
+        usesReportIDs = _usesReportIDs;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    if(device != NULL)
+        usb_close((void *)device);
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+int bytesSent, reportId = buffer[0];
+
+    if(!usesReportIDs){
+        buffer++;   /* skip dummy report ID */
+        len--;
+    }
+    bytesSent = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, USBRQ_HID_SET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | (reportId & 0xff), 0, buffer, len, 5000);
+    if(bytesSent != len){
+        if(bytesSent < 0)
+            fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+int bytesReceived, maxLen = *len;
+
+    if(!usesReportIDs){
+        buffer++;   /* make room for dummy report ID */
+        maxLen--;
+    }
+    bytesReceived = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_IN, USBRQ_HID_GET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | reportNumber, 0, buffer, maxLen, 5000);
+    if(bytesReceived < 0){
+        fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    *len = bytesReceived;
+    if(!usesReportIDs){
+        buffer[-1] = reportNumber;  /* add dummy report ID */
+        (*len)++;
+    }
+    return 0;
+}
+
+/* ######################################################################## */
+#endif /* defined WIN32 ################################################### */
+/* ######################################################################## */
Index: vusb-20121206/libs-host/hiddata.h
===================================================================
--- vusb-20121206/libs-host/hiddata.h	(nonexistent)
+++ vusb-20121206/libs-host/hiddata.h	(working copy)
@@ -0,0 +1,70 @@
+/* Name: hiddata.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __HIDDATA_H_INCLUDED__
+#define __HIDDATA_H_INCLUDED__
+
+/*
+General Description:
+This module implements an abstraction layer for data transfer over HID feature
+requests. The implementation uses native Windows functions on Windows so that
+no driver installation is required and libusb on Unix. You must link the
+appropriate libraries in either case: "-lhid -lusb -lsetupapi" on Windows and
+`libusb-config --libs` on Unix.
+*/
+
+/* ------------------------------------------------------------------------ */
+
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+/* ------------------------------------------------------------------------ */
+
+typedef struct usbDevice    usbDevice_t;
+/* Opaque data type representing the USB device. This can be a Windows handle
+ * or a libusb handle, depending on the backend implementation.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidOpenDevice(usbDevice_t **device, int vendorID, char *vendorName, int productID, char *productName, int usesReportIDs);
+/* This function opens a USB device. 'vendorID' and 'productID' are the numeric
+ * Vendor-ID and Product-ID of the device we want to open. If 'vendorName' and
+ * 'productName' are both not NULL, only devices with matching manufacturer-
+ * and product name strings are accepted. If the device uses report IDs,
+ * 'usesReportIDs' must be set to a non-zero value.
+ * Returns: If a matching device has been found, USBOPEN_SUCCESS is returned
+ * and '*device' is set to an opaque pointer representing the device. The
+ * device must be closed with usbhidCloseDevice(). If the device has not been
+ * found or opening failed, an error code is returned.
+ */
+void    usbhidCloseDevice(usbDevice_t *device);
+/* Every device opened with usbhidOpenDevice() must be closed with this function.
+ */
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len);
+/* This function sends a feature report to the device. The report ID must be
+ * in the first byte of buffer and the length 'len' of the report is specified
+ * including this report ID. If no report IDs are used, buffer[0] must be set
+ * to 0 (dummy report ID).
+ * Returns: 0 on success, an error code otherwise.
+ */
+int usbhidGetReport(usbDevice_t *device, int reportID, char *buffer, int *len);
+/* This function obtains a feature report from the device. The requested
+ * report-ID is passed in 'reportID'. The caller must pass a buffer of the size
+ * of the expected report in 'buffer' and initialize the variable pointed to by
+ * 'len' to the total size of this buffer. Upon successful return, the report
+ * (prefixed with the report-ID) is in 'buffer' and the actual length of the
+ * report is returned in '*len'.
+ * Returns: 0 on success, an error code otherwise.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+#endif /* __HIDDATA_H_INCLUDED__ */
Index: vusb-20121206/libs-host/hidsdi.h
===================================================================
--- vusb-20121206/libs-host/hidsdi.h	(nonexistent)
+++ vusb-20121206/libs-host/hidsdi.h	(working copy)
@@ -0,0 +1,48 @@
+/* Name: hidsdi.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-02-02
+ * Tabsize: 4
+ * Copyright: (c) 2006-2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description
+This file is a replacement for hidsdi.h from the Windows DDK. It defines some
+of the types and function prototypes of this header for our project. If you
+have the Windows DDK version of this file or a version shipped with MinGW, use
+that instead.
+*/
+
+#ifndef _HIDSDI_H
+#define _HIDSDI_H
+
+#include <pshpack4.h>
+
+#include <ddk/hidusage.h>
+#include <ddk/hidpi.h>
+
+typedef struct{
+    ULONG   Size;
+    USHORT  VendorID;
+    USHORT  ProductID;
+    USHORT  VersionNumber;
+}HIDD_ATTRIBUTES;
+
+void __stdcall      HidD_GetHidGuid(OUT LPGUID hidGuid);
+
+BOOLEAN __stdcall   HidD_GetAttributes(IN HANDLE device, OUT HIDD_ATTRIBUTES *attributes);
+
+BOOLEAN __stdcall   HidD_GetManufacturerString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetProductString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetSerialNumberString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetFeature(IN HANDLE device, OUT void *reportBuffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_SetFeature(IN HANDLE device, IN void *reportBuffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetNumInputBuffers(IN HANDLE device, OUT ULONG *numBuffers);
+BOOLEAN __stdcall   HidD_SetNumInputBuffers(IN HANDLE device, OUT ULONG numBuffers);
+
+#include <poppack.h>
+
+#endif
Index: vusb-20121206/libs-host/opendevice.c
===================================================================
--- vusb-20121206/libs-host/opendevice.c	(nonexistent)
+++ vusb-20121206/libs-host/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/libs-host/opendevice.h
===================================================================
--- vusb-20121206/libs-host/opendevice.h	(nonexistent)
+++ vusb-20121206/libs-host/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/libs-host/hiddata.c
===================================================================
--- vusb-20121206/libs-host/hiddata.c	(nonexistent)
+++ vusb-20121206/libs-host/hiddata.c	(working copy)
@@ -0,0 +1,323 @@
+/* Name: hiddata.c
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include <stdio.h>
+#include "hiddata.h"
+
+/* ######################################################################## */
+#if defined(WIN32) /* ##################################################### */
+/* ######################################################################## */
+
+#include <windows.h>
+#include <setupapi.h>
+#include "hidsdi.h"
+#include <ddk/hidpi.h>
+
+#ifdef DEBUG
+#define DEBUG_PRINT(arg)    printf arg
+#else
+#define DEBUG_PRINT(arg)
+#endif
+
+/* ------------------------------------------------------------------------ */
+
+static void convertUniToAscii(char *buffer)
+{
+unsigned short  *uni = (void *)buffer;
+char            *ascii = buffer;
+
+    while(*uni != 0){
+        if(*uni >= 256){
+            *ascii++ = '?';
+        }else{
+            *ascii++ = *uni++;
+        }
+    }
+    *ascii++ = 0;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int usesReportIDs)
+{
+GUID                                hidGuid;        /* GUID for HID driver */
+HDEVINFO                            deviceInfoList;
+SP_DEVICE_INTERFACE_DATA            deviceInfo;
+SP_DEVICE_INTERFACE_DETAIL_DATA     *deviceDetails = NULL;
+DWORD                               size;
+int                                 i, openFlag = 0;  /* may be FILE_FLAG_OVERLAPPED */
+int                                 errorCode = USBOPEN_ERR_NOTFOUND;
+HANDLE                              handle = INVALID_HANDLE_VALUE;
+HIDD_ATTRIBUTES                     deviceAttributes;
+				
+    HidD_GetHidGuid(&hidGuid);
+    deviceInfoList = SetupDiGetClassDevs(&hidGuid, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
+    deviceInfo.cbSize = sizeof(deviceInfo);
+    for(i=0;;i++){
+        if(handle != INVALID_HANDLE_VALUE){
+            CloseHandle(handle);
+            handle = INVALID_HANDLE_VALUE;
+        }
+        if(!SetupDiEnumDeviceInterfaces(deviceInfoList, 0, &hidGuid, i, &deviceInfo))
+            break;  /* no more entries */
+        /* first do a dummy call just to determine the actual size required */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, NULL, 0, &size, NULL);
+        if(deviceDetails != NULL)
+            free(deviceDetails);
+        deviceDetails = malloc(size);
+        deviceDetails->cbSize = sizeof(*deviceDetails);
+        /* this call is for real: */
+        SetupDiGetDeviceInterfaceDetail(deviceInfoList, &deviceInfo, deviceDetails, size, &size, NULL);
+        DEBUG_PRINT(("checking HID path \"%s\"\n", deviceDetails->DevicePath));
+#if 0
+        /* If we want to access a mouse our keyboard, we can only use feature
+         * requests as the device is locked by Windows. It must be opened
+         * with ACCESS_TYPE_NONE.
+         */
+        handle = CreateFile(deviceDetails->DevicePath, ACCESS_TYPE_NONE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+#endif
+        /* attempt opening for R/W -- we don't care about devices which can't be accessed */
+        handle = CreateFile(deviceDetails->DevicePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, openFlag, NULL);
+        if(handle == INVALID_HANDLE_VALUE){
+            DEBUG_PRINT(("opening failed: %d\n", (int)GetLastError()));
+            /* errorCode = USBOPEN_ERR_ACCESS; opening will always fail for mouse -- ignore */
+            continue;
+        }
+        deviceAttributes.Size = sizeof(deviceAttributes);
+        HidD_GetAttributes(handle, &deviceAttributes);
+        DEBUG_PRINT(("device attributes: vid=%d pid=%d\n", deviceAttributes.VendorID, deviceAttributes.ProductID));
+        if(deviceAttributes.VendorID != vendor || deviceAttributes.ProductID != product)
+            continue;   /* ignore this device */
+        errorCode = USBOPEN_ERR_NOTFOUND;
+        if(vendorName != NULL && productName != NULL){
+            char    buffer[512];
+            if(!HidD_GetManufacturerString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining vendor name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("vendorName = \"%s\"\n", buffer));
+            if(strcmp(vendorName, buffer) != 0)
+                continue;
+            if(!HidD_GetProductString(handle, buffer, sizeof(buffer))){
+                DEBUG_PRINT(("error obtaining product name\n"));
+                errorCode = USBOPEN_ERR_IO;
+                continue;
+            }
+            convertUniToAscii(buffer);
+            DEBUG_PRINT(("productName = \"%s\"\n", buffer));
+            if(strcmp(productName, buffer) != 0)
+                continue;
+        }
+        break;  /* we have found the device we are looking for! */
+    }
+    SetupDiDestroyDeviceInfoList(deviceInfoList);
+    if(deviceDetails != NULL)
+        free(deviceDetails);
+    if(handle != INVALID_HANDLE_VALUE){
+        *device = (usbDevice_t *)handle;
+        errorCode = 0;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------ */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    CloseHandle((HANDLE)device);
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+BOOLEAN rval;
+
+    rval = HidD_SetFeature((HANDLE)device, buffer, len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+BOOLEAN rval = 0;
+
+    buffer[0] = reportNumber;
+    rval = HidD_GetFeature((HANDLE)device, buffer, *len);
+    return rval == 0 ? USBOPEN_ERR_IO : 0;
+}
+
+/* ------------------------------------------------------------------------ */
+
+/* ######################################################################## */
+#else /* defined WIN32 #################################################### */
+/* ######################################################################## */
+
+#include <string.h>
+#include <usb.h>
+
+#define usbDevice   usb_dev_handle  /* use libusb's device structure */
+
+/* ------------------------------------------------------------------------- */
+
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_SET_REPORT    0x09
+
+#define USB_HID_REPORT_TYPE_FEATURE 3
+
+
+static int  usesReportIDs;
+
+/* ------------------------------------------------------------------------- */
+
+static int usbhidGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+int usbhidOpenDevice(usbDevice_t **device, int vendor, char *vendorName, int product, char *productName, int _usesReportIDs)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+static int          didUsbInit = 0;
+
+    if(!didUsbInit){
+        usb_init();
+        didUsbInit = 1;
+    }
+    usb_find_busses();
+    usb_find_devices();
+    for(bus=usb_get_busses(); bus; bus=bus->next){
+        for(dev=bus->devices; dev; dev=dev->next){
+            if(dev->descriptor.idVendor == vendor && dev->descriptor.idProduct == product){
+                char    string[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    fprintf(stderr, "Warning: cannot open USB device: %s\n", usb_strerror());
+                    continue;
+                }
+                if(vendorName == NULL && productName == NULL){  /* name does not matter */
+                    break;
+                }
+                /* now check whether the names match: */
+                len = usbhidGetStringAscii(handle, dev->descriptor.iManufacturer, string, sizeof(string));
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_IO;
+                    fprintf(stderr, "Warning: cannot query manufacturer for device: %s\n", usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* fprintf(stderr, "seen device from vendor ->%s<-\n", string); */
+                    if(strcmp(string, vendorName) == 0){
+                        len = usbhidGetStringAscii(handle, dev->descriptor.iProduct, string, sizeof(string));
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_IO;
+                            fprintf(stderr, "Warning: cannot query product for device: %s\n", usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* fprintf(stderr, "seen product ->%s<-\n", string); */
+                            if(strcmp(string, productName) == 0)
+                                break;
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = (void *)handle;
+        usesReportIDs = _usesReportIDs;
+    }
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
+
+void    usbhidCloseDevice(usbDevice_t *device)
+{
+    if(device != NULL)
+        usb_close((void *)device);
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len)
+{
+int bytesSent, reportId = buffer[0];
+
+    if(!usesReportIDs){
+        buffer++;   /* skip dummy report ID */
+        len--;
+    }
+    bytesSent = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_OUT, USBRQ_HID_SET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | (reportId & 0xff), 0, buffer, len, 5000);
+    if(bytesSent != len){
+        if(bytesSent < 0)
+            fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbhidGetReport(usbDevice_t *device, int reportNumber, char *buffer, int *len)
+{
+int bytesReceived, maxLen = *len;
+
+    if(!usesReportIDs){
+        buffer++;   /* make room for dummy report ID */
+        maxLen--;
+    }
+    bytesReceived = usb_control_msg((void *)device, USB_TYPE_CLASS | USB_RECIP_DEVICE | USB_ENDPOINT_IN, USBRQ_HID_GET_REPORT, USB_HID_REPORT_TYPE_FEATURE << 8 | reportNumber, 0, buffer, maxLen, 5000);
+    if(bytesReceived < 0){
+        fprintf(stderr, "Error sending message: %s\n", usb_strerror());
+        return USBOPEN_ERR_IO;
+    }
+    *len = bytesReceived;
+    if(!usesReportIDs){
+        buffer[-1] = reportNumber;  /* add dummy report ID */
+        (*len)++;
+    }
+    return 0;
+}
+
+/* ######################################################################## */
+#endif /* defined WIN32 ################################################### */
+/* ######################################################################## */
Index: vusb-20121206/libs-host/hiddata.h
===================================================================
--- vusb-20121206/libs-host/hiddata.h	(nonexistent)
+++ vusb-20121206/libs-host/hiddata.h	(working copy)
@@ -0,0 +1,70 @@
+/* Name: hiddata.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __HIDDATA_H_INCLUDED__
+#define __HIDDATA_H_INCLUDED__
+
+/*
+General Description:
+This module implements an abstraction layer for data transfer over HID feature
+requests. The implementation uses native Windows functions on Windows so that
+no driver installation is required and libusb on Unix. You must link the
+appropriate libraries in either case: "-lhid -lusb -lsetupapi" on Windows and
+`libusb-config --libs` on Unix.
+*/
+
+/* ------------------------------------------------------------------------ */
+
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+/* ------------------------------------------------------------------------ */
+
+typedef struct usbDevice    usbDevice_t;
+/* Opaque data type representing the USB device. This can be a Windows handle
+ * or a libusb handle, depending on the backend implementation.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+int usbhidOpenDevice(usbDevice_t **device, int vendorID, char *vendorName, int productID, char *productName, int usesReportIDs);
+/* This function opens a USB device. 'vendorID' and 'productID' are the numeric
+ * Vendor-ID and Product-ID of the device we want to open. If 'vendorName' and
+ * 'productName' are both not NULL, only devices with matching manufacturer-
+ * and product name strings are accepted. If the device uses report IDs,
+ * 'usesReportIDs' must be set to a non-zero value.
+ * Returns: If a matching device has been found, USBOPEN_SUCCESS is returned
+ * and '*device' is set to an opaque pointer representing the device. The
+ * device must be closed with usbhidCloseDevice(). If the device has not been
+ * found or opening failed, an error code is returned.
+ */
+void    usbhidCloseDevice(usbDevice_t *device);
+/* Every device opened with usbhidOpenDevice() must be closed with this function.
+ */
+int usbhidSetReport(usbDevice_t *device, char *buffer, int len);
+/* This function sends a feature report to the device. The report ID must be
+ * in the first byte of buffer and the length 'len' of the report is specified
+ * including this report ID. If no report IDs are used, buffer[0] must be set
+ * to 0 (dummy report ID).
+ * Returns: 0 on success, an error code otherwise.
+ */
+int usbhidGetReport(usbDevice_t *device, int reportID, char *buffer, int *len);
+/* This function obtains a feature report from the device. The requested
+ * report-ID is passed in 'reportID'. The caller must pass a buffer of the size
+ * of the expected report in 'buffer' and initialize the variable pointed to by
+ * 'len' to the total size of this buffer. Upon successful return, the report
+ * (prefixed with the report-ID) is in 'buffer' and the actual length of the
+ * report is returned in '*len'.
+ * Returns: 0 on success, an error code otherwise.
+ */
+
+/* ------------------------------------------------------------------------ */
+
+#endif /* __HIDDATA_H_INCLUDED__ */
Index: vusb-20121206/libs-host/hidsdi.h
===================================================================
--- vusb-20121206/libs-host/hidsdi.h	(nonexistent)
+++ vusb-20121206/libs-host/hidsdi.h	(working copy)
@@ -0,0 +1,48 @@
+/* Name: hidsdi.h
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-02-02
+ * Tabsize: 4
+ * Copyright: (c) 2006-2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description
+This file is a replacement for hidsdi.h from the Windows DDK. It defines some
+of the types and function prototypes of this header for our project. If you
+have the Windows DDK version of this file or a version shipped with MinGW, use
+that instead.
+*/
+
+#ifndef _HIDSDI_H
+#define _HIDSDI_H
+
+#include <pshpack4.h>
+
+#include <ddk/hidusage.h>
+#include <ddk/hidpi.h>
+
+typedef struct{
+    ULONG   Size;
+    USHORT  VendorID;
+    USHORT  ProductID;
+    USHORT  VersionNumber;
+}HIDD_ATTRIBUTES;
+
+void __stdcall      HidD_GetHidGuid(OUT LPGUID hidGuid);
+
+BOOLEAN __stdcall   HidD_GetAttributes(IN HANDLE device, OUT HIDD_ATTRIBUTES *attributes);
+
+BOOLEAN __stdcall   HidD_GetManufacturerString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetProductString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_GetSerialNumberString(IN HANDLE device, OUT void *buffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetFeature(IN HANDLE device, OUT void *reportBuffer, IN ULONG bufferLen);
+BOOLEAN __stdcall   HidD_SetFeature(IN HANDLE device, IN void *reportBuffer, IN ULONG bufferLen);
+
+BOOLEAN __stdcall   HidD_GetNumInputBuffers(IN HANDLE device, OUT ULONG *numBuffers);
+BOOLEAN __stdcall   HidD_SetNumInputBuffers(IN HANDLE device, OUT ULONG numBuffers);
+
+#include <poppack.h>
+
+#endif
Index: vusb-20121206/libs-host/opendevice.c
===================================================================
--- vusb-20121206/libs-host/opendevice.c	(nonexistent)
+++ vusb-20121206/libs-host/opendevice.c	(working copy)
@@ -0,0 +1,202 @@
+/* Name: opendevice.c
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The functions in this module can be used to find and open a device based on
+libusb or libusb-win32.
+*/
+
+#include <stdio.h>
+#include "opendevice.h"
+
+/* ------------------------------------------------------------------------- */
+
+#define MATCH_SUCCESS			1
+#define MATCH_FAILED			0
+#define MATCH_ABORT				-1
+
+/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
+static int  _shellStyleMatch(char *text, char *p)
+{
+int last, matched, reverse;
+
+    for(; *p; text++, p++){
+        if(*text == 0 && *p != '*')
+            return MATCH_ABORT;
+        switch(*p){
+        case '\\':
+            /* Literal match with following character. */
+            p++;
+            /* FALLTHROUGH */
+        default:
+            if(*text != *p)
+                return MATCH_FAILED;
+            continue;
+        case '?':
+            /* Match anything. */
+            continue;
+        case '*':
+            while(*++p == '*')
+                /* Consecutive stars act just like one. */
+                continue;
+            if(*p == 0)
+                /* Trailing star matches everything. */
+                return MATCH_SUCCESS;
+            while(*text)
+                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
+                    return matched;
+            return MATCH_ABORT;
+        case '[':
+            reverse = p[1] == '^';
+            if(reverse) /* Inverted character class. */
+                p++;
+            matched = MATCH_FAILED;
+            if(p[1] == ']' || p[1] == '-')
+                if(*++p == *text)
+                    matched = MATCH_SUCCESS;
+            for(last = *p; *++p && *p != ']'; last = *p)
+                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
+                    matched = MATCH_SUCCESS;
+            if(matched == reverse)
+                return MATCH_FAILED;
+            continue;
+        }
+    }
+    return *text == 0;
+}
+
+/* public interface for shell style matching: returns 0 if fails, 1 if matches */
+static int shellStyleMatch(char *text, char *pattern)
+{
+    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
+        return 1;
+    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
+{
+char    buffer[256];
+int     rval, i;
+
+    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
+        return rval;
+    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
+        return rval;
+    if(buffer[1] != USB_DT_STRING){
+        *buf = 0;
+        return 0;
+    }
+    if((unsigned char)buffer[0] < rval)
+        rval = (unsigned char)buffer[0];
+    rval /= 2;
+    /* lossy conversion to ISO Latin1: */
+    for(i=1;i<rval;i++){
+        if(i > buflen)              /* destination buffer overflow */
+            break;
+        buf[i-1] = buffer[2 * i];
+        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
+            buf[i-1] = '?';
+    }
+    buf[i-1] = 0;
+    return i-1;
+}
+
+/* ------------------------------------------------------------------------- */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
+{
+struct usb_bus      *bus;
+struct usb_device   *dev;
+usb_dev_handle      *handle = NULL;
+int                 errorCode = USBOPEN_ERR_NOTFOUND;
+
+    usb_find_busses();
+    usb_find_devices();
+    for(bus = usb_get_busses(); bus; bus = bus->next){
+        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
+            if((vendorID == 0 || dev->descriptor.idVendor == vendorID)
+                        && (productID == 0 || dev->descriptor.idProduct == productID)){
+                char    vendor[256], product[256], serial[256];
+                int     len;
+                handle = usb_open(dev); /* we need to open the device in order to query strings */
+                if(!handle){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                    continue;
+                }
+                /* now check whether the names match: */
+                len = vendor[0] = 0;
+                if(dev->descriptor.iManufacturer > 0){
+                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
+                }
+                if(len < 0){
+                    errorCode = USBOPEN_ERR_ACCESS;
+                    if(warningsFp != NULL)
+                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                }else{
+                    errorCode = USBOPEN_ERR_NOTFOUND;
+                    /* printf("seen device from vendor ->%s<-\n", vendor); */
+                    if(shellStyleMatch(vendor, vendorNamePattern)){
+                        len = product[0] = 0;
+                        if(dev->descriptor.iProduct > 0){
+                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
+                        }
+                        if(len < 0){
+                            errorCode = USBOPEN_ERR_ACCESS;
+                            if(warningsFp != NULL)
+                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                        }else{
+                            errorCode = USBOPEN_ERR_NOTFOUND;
+                            /* printf("seen product ->%s<-\n", product); */
+                            if(shellStyleMatch(product, productNamePattern)){
+                                len = serial[0] = 0;
+                                if(dev->descriptor.iSerialNumber > 0){
+                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
+                                }
+                                if(len < 0){
+                                    errorCode = USBOPEN_ERR_ACCESS;
+                                    if(warningsFp != NULL)
+                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
+                                }
+                                if(shellStyleMatch(serial, serialNamePattern)){
+                                    if(printMatchingDevicesFp != NULL){
+                                        if(serial[0] == 0){
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
+                                        }else{
+                                            fprintf(printMatchingDevicesFp, "VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
+                                        }
+                                    }else{
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                usb_close(handle);
+                handle = NULL;
+            }
+        }
+        if(handle)  /* we have found a deice */
+            break;
+    }
+    if(handle != NULL){
+        errorCode = 0;
+        *device = handle;
+    }
+    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
+        errorCode = 0;
+    return errorCode;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/libs-host/opendevice.h
===================================================================
--- vusb-20121206/libs-host/opendevice.h	(nonexistent)
+++ vusb-20121206/libs-host/opendevice.h	(working copy)
@@ -0,0 +1,76 @@
+/* Name: opendevice.h
+ * Project: V-USB host-side library
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-10
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module offers additional functionality for host side drivers based on
+libusb or libusb-win32. It includes a function to find and open a device
+based on numeric IDs and textual description. It also includes a function to
+obtain textual descriptions from a device.
+
+To use this functionality, simply copy opendevice.c and opendevice.h into your
+project and add them to your Makefile. You may modify and redistribute these
+files according to the GNU General Public License (GPL) version 2 or 3.
+*/
+
+#ifndef __OPENDEVICE_H_INCLUDED__
+#define __OPENDEVICE_H_INCLUDED__
+
+#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
+#include <stdio.h>
+
+int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
+/* This function gets a string descriptor from the device. 'index' is the
+ * string descriptor index. The string is returned in ISO Latin 1 encoding in
+ * 'buf' and it is terminated with a 0-character. The buffer size must be
+ * passed in 'buflen' to prevent buffer overflows. A libusb device handle
+ * must be given in 'dev'.
+ * Returns: The length of the string (excluding the terminating 0) or
+ * a negative number in case of an error. If there was an error, use
+ * usb_strerror() to obtain the error message.
+ */
+
+int usbOpenDevice(usb_dev_handle **device, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
+/* This function iterates over all devices on all USB busses and searches for
+ * a device. Matching is done first by means of Vendor- and Product-ID (passed
+ * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
+ * When a device matches by its IDs, matching by names is performed. Name
+ * matching can be done on textual vendor name ('vendorNamePattern'), product
+ * name ('productNamePattern') and serial number ('serialNamePattern'). A
+ * device matches only if all non-null pattern match. If you don't care about
+ * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
+ * '*' stands for 0 or more characters, '?' for one single character, a list
+ * of characters in square brackets for a single character from the list
+ * (dashes are allowed to specify a range) and if the lis of characters begins
+ * with a caret ('^'), it matches one character which is NOT in the list.
+ * Other parameters to the function: If 'warningsFp' is not NULL, warning
+ * messages are printed to this file descriptor with fprintf(). If
+ * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
+ * devices are printed to the given file descriptor with fprintf().
+ * If a device is opened, the resulting USB handle is stored in '*device'. A
+ * pointer to a "usb_dev_handle *" type variable must be passed here.
+ * Returns: 0 on success, an error code (see defines below) on failure.
+ */
+
+/* usbOpenDevice() error codes: */
+#define USBOPEN_SUCCESS         0   /* no error */
+#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
+#define USBOPEN_ERR_IO          2   /* I/O error */
+#define USBOPEN_ERR_NOTFOUND    3   /* device not found */
+
+
+/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */
+
+#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
+#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
+#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
+#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
+#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */
+
+#endif /* __OPENDEVICE_H_INCLUDED__ */
Index: vusb-20121206/libs-host/Readme.txt
===================================================================
--- vusb-20121206/libs-host/Readme.txt	(nonexistent)
+++ vusb-20121206/libs-host/Readme.txt	(working copy)
@@ -0,0 +1,26 @@
+This is the Readme file for the libs-host directory. This directory contains
+code snippets which may be useful for host side USB software.
+
+
+WHAT IS INCLUDED IN THIS DIRECTORY?
+===================================
+
+opendevice.c and opendevice.h
+  This module contains a function to find and open a device given its
+  numeric IDs (VID, PID), names (vendor name and product name) and serial
+  number. It is based on libusb/libusb-win32 and returns a libusb device
+  handle. See opendevice.h for an API documentation.
+
+hiddata.c and hiddata.h
+  This module contains functions for data transfer over HID feature reports.
+  It is based on libusb on Unix and native Windows functions on Windows. No
+  driver DLL is needed on Windows. See hiddata.h for an API documentation.
+
+hidsdi.h
+  This DDK header file is missing in the free MinGW version of the Windows
+  DDK. Use this version if you get an "include file not found" error.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/License.txt
===================================================================
--- vusb-20121206/License.txt	(nonexistent)
+++ vusb-20121206/License.txt	(working copy)
@@ -0,0 +1,361 @@
+OBJECTIVE DEVELOPMENT GmbH's V-USB driver software is distributed under the
+terms and conditions of the GNU GPL version 2 or the GNU GPL version 3. It is
+your choice whether you apply the terms of version 2 or version 3. The full
+text of GPLv2 is included below. In addition to the requirements in the GPL,
+we STRONGLY ENCOURAGE you to do the following:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: vusb-20121206/Makefile
===================================================================
--- vusb-20121206/Makefile	(nonexistent)
+++ vusb-20121206/Makefile	(working copy)
@@ -0,0 +1,60 @@
+# Name: Makefile
+# Project: v-usb
+# Author: Christian Starkjohann
+# Creation Date: 2012-12-05
+# Tabsize: 4
+# Copyright: (c) 2012 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+# This is the main Makefile. The two primary targets are "all", to build
+# everything which can be built (except tests), and "clean" to remove all
+# dependent files. In a repository clone, derived source files are generated
+# and deleted as well.
+#
+# We distinguish between repository clones and source packages by the existence
+# of make-files.sh scripts in various subdirectories.
+
+
+all:
+	if [ ! -f examples/hid-mouse/firmware/Makefile ]; then \
+		$(MAKE) files; \
+	fi
+	if [ -n "$(uname -s | grep -i mingw)" ]; then \
+		$(MAKE) windows; \
+	else \
+		$(MAKE) unix; \
+	fi
+
+clean:
+	$(MAKE) unixclean
+	if cross-make.sh --help >/dev/null 2>&1; then \
+		$(MAKE) windowsclean; \
+	fi
+	$(MAKE) filesremove
+
+
+unix unixclean:
+	target=$$(echo $@ | sed -e 's/unix//g'); \
+	find . -mindepth 3 -name Makefile -print | while read i; do \
+		dir=$$(dirname $$i); \
+		dirname=$$(basename $$dir); \
+		pushd $$dir >/dev/null; \
+		if [ "$$dirname" = firmware -a -z "$$target" ]; then \
+			if ! $(MAKE) hex; then break; fi; \
+		else \
+			if ! $(MAKE) $$target; then break; fi;\
+		fi; \
+		popd >/dev/null; \
+	done
+
+
+windows windowsclean:
+	target=$$(echo $@ | sed -e 's/windows//g'); \
+	find . -mindepth 3 -name Makefile.windows -execdir cross-make.sh $$target \; ; \
+	if [ -z "$$target" ]; then target=hex; fi; \
+	find . -mindepth 2 -name firmware -exec sh -c "cd '{}'; $(MAKE) $$target" \;
+
+files filesremove:
+	target=$$(echo $@ | sed -e 's/files//g'); \
+	find . -mindepth 2 -name make-files.sh -execdir ./make-files.sh $$target \;
+
Index: vusb-20121206/Readme.txt
===================================================================
--- vusb-20121206/Readme.txt	(nonexistent)
+++ vusb-20121206/Readme.txt	(working copy)
@@ -0,0 +1,83 @@
+This is the Readme file for V-USB and related code. V-USB is Objective
+Development's firmware-only USB driver for Atmel's(r) AVR(r) microcontrollers.
+For more information please visit http://www.obdev.at/vusb/.
+
+To avoid name confusion: This project was formerly known as AVR-USB. Due to
+a trademark issue, it was renamed to V-USB in April 2009.
+
+
+WHAT IS INCLUDED IN THIS PACKAGE?
+=================================
+This package consists of the device side USB driver firmware, library code
+for device and host and fully working examples for device and host:
+
+  Readme.txt .............. The file you are currently reading.
+  usbdrv .................. V-USB firmware, to be included in your project.
+  examples ................ Example code for device and host side.
+  libs-device ............. Useful code snippets for the device firmware.
+  libs-host ............... Useful code snippets for host-side drivers.
+  circuits ................ Example circuits using this driver.
+  Changelog.txt ........... Documentation of changes between versions.
+  License.txt ............. Free Open Source license for this package (GPL).
+  CommercialLicense.txt ... Alternative commercial license for this package.
+  USB-ID-FAQ.txt .......... General infos about USB Product- and Vendor-IDs.
+  USB-IDs-for-free.txt .... List and terms of use for free shared PIDs.
+
+Each subdirectory contains a separate Readme file which explains its
+contents. We recommend that you also read the Readme.txt file in the
+usbdrv subdirectory.
+
+
+PREREQUISITES
+=============
+The AVR code of V-USB is written in C and assembler. You need either
+avr-gcc or IAR CC to compile the project. We recommend avr-gcc because it
+is free and easily available. Gcc version 3 generates slightly more
+efficient code than version 4 for V-USB. Not every release is tested with
+the IAR compiler. Previous versions have been tested with IAR 4.10B/W32 and
+4.12A/W32 on an ATmega8 with the "small" and "tiny" memory model.
+
+Ready made avr-gcc tool chains are available for most operating systems:
+  * Windows: WinAVR http://winavr.sourceforge.net/
+  * Mac: CrossPack for AVR Development http://www.obdev.at/crosspack/
+  * Linux and other Unixes: Most free Unixes have optional packages for AVR
+    development. If not, follow the instructions at
+    http://www.nongnu.org/avr-libc/user-manual/install_tools.html
+
+Our host side examples are compiled with gcc on all platforms. Gcc is the
+default C compiler on Mac, Linux and many other Unixes. On windows, we
+recommend MinGW (http://www.mingw.org/). Use the automated MinGW installer
+for least troubles. You also need MSYS from the same site to work with
+standard Makefiles.
+
+Most examples also depend on libusb. Libusb is available from
+http://libusb.sourceforge.net/ for Unix and
+http://libusb-win32.sourceforge.net/ for Windows.
+
+
+TECHNICAL DOCUMENTATION
+=======================
+The API reference of the driver firmware can be found in usbdrv/usbdrv.h.
+Documentation for host and device library files are in the respective header
+files. For more information, see our documentation wiki at
+http://www.obdev.at/goto.php?t=vusb-wiki.
+
+See the file usbdrv/Readme.txt for more info about the driver itself.
+
+
+LICENSE
+=======
+V-USB and related code is distributed under the terms of the GNU General
+Public License (GPL) version 2 (see License.txt for details) and the GNU
+General Public License (GPL) version 3. It is your choice whether you apply
+the terms of version 2 or version 3. In addition to the terms of the GPL, we
+strongly encourage you to publish your entire project and mail OBJECTIVE
+DEVELOPMENT a link to your publication.
+
+Alternatively, we offer a commercial license without the restrictions of the
+GPL. See CommercialLicense.txt for details.
+
+
+----------------------------------------------------------------------------
+(c) 2010 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/tests/Makefile
===================================================================
--- vusb-20121206/tests/Makefile	(nonexistent)
+++ vusb-20121206/tests/Makefile	(working copy)
@@ -0,0 +1,126 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = attiny2313
+F_CPU   = 16000000	# in Hz
+DEFINES =
+
+CFLAGS  = $(DEFINES) -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+SIZES_TMP = /tmp/sizetmp.txt
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make clean ..... to delete objects and hex file"
+	@echo "make sizes ..... compute code and RAM sizes for various options"
+	@echo "make test ...... test with all features whether everything compiles"
+
+sizes sizes.txt:
+	rm -f $(SIZES_TMP) sizes.txt
+	$(MAKE) null.elf
+	avr-size null.elf | tail -1 | awk '{print "null", $$1+$$2, $$3+$$2}' >$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_16_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=12000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_12_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=12800000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_12_8_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=15000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_15_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=16500000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_16_5_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=18000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_18_MHz+CRC", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=20000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_20_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf DEFINES=-DUSB_CFG_IMPLEMENT_FN_WRITE=1
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionWrite", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf DEFINES=-DUSB_CFG_IMPLEMENT_FN_READ=1
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionRead", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_IMPLEMENT_FN_READ=1 -DUSB_CFG_IMPLEMENT_FN_WRITE=1"
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionRead_and_Write", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_IMPLEMENT_FN_WRITEOUT=1"
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionWriteOut", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_HAVE_INTRIN_ENDPOINT=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Interrupt_In_Endpoint_1", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_IMPLEMENT_HALT=1 -DUSB_CFG_HAVE_INTRIN_ENDPOINT=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Interrupt_In_Endpoint_1_and_Halt", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_HAVE_INTRIN_ENDPOINT3=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Interrupt_In_Endpoint_1_and_3", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSE_DYNAMIC_DESCRIPTOR=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Dynamic_Descriptor", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_LONG_TRANSFERS=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Long_Transfers", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	cat $(SIZES_TMP) | awk 'BEGIN{printf("%39s %5s %5s %5s %5s\n"), "Variation", "Flash", "RAM", "+F", "+RAM"}\
+		/^null/{nullRom=$$2; nullRam=$$3; next} \
+		{rom=$$2-nullRom; ram=$$3-nullRam; if(!refRom){refRom=rom; refRam=ram} \
+		printf("%39s %5d %5d %+5d %+5d\n", $$1, rom, ram, rom-refRom, ram-refRam)}' | tee sizes.txt
+	rm $(SIZES_TMP)
+
+test:
+	for freq in 12000000 12800000 15000000 16000000 16500000 18000000 20000000; do \
+		for opt in USB_COUNT_SOF USB_CFG_HAVE_INTRIN_ENDPOINT USB_CFG_HAVE_INTRIN_ENDPOINT3 USB_CFG_HAVE_MEASURE_FRAME_LENGTH USB_CFG_LONG_TRANSFERS; do \
+			$(MAKE) clean; $(MAKE) main.elf F_CPU=$$freq "DEFINES=-D$$opt=1" || exit 1; \
+			$(MAKE) clean; $(MAKE) main.elf F_CPU=$$freq "DEFINES=-D$$opt=1 -DDUSB_CFG_IMPLEMENT_FN_WRITEOUT=1" || exit 1; \
+		done \
+	done
+
+# The following rule is used to check the compiler
+devices: #exclude devices without RAM for stack and atmega603 for gcc 3
+	excludes="at90s1200 attiny11 attiny12 attiny15 attiny28"; \
+	for gccVersion in 3 4; do \
+		avr-gcc-select $$gccVersion; \
+		for device in `echo | avr-gcc -xc -mmcu=x - 2>&1 | egrep '^ *at[a-zA-Z0-9_-]+$$'`; do \
+			if echo "$$excludes" | grep "$$device" >/dev/null; then continue; fi; \
+			if [ "$$gccVersion" = 3 -a "$$device" = atmega603 ]; then continue; fi; \
+			$(MAKE) clean; $(MAKE) null.elf DEVICE=$$device || exit 1; \
+		done \
+	done
+	$(MAKE) clean
+	avr-gcc-select 3
+	@echo "+++ Device test succeeded!"
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f *.hex *.lst *.map  *.elf *.o
+	rm -rf usbdrv
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main_i.elf: usbdrv main.o usbdrv/usbdrvasm.o	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main_i.elf main.o usbdrv/usbdrvasm.o
+
+null.elf: null.o
+	$(COMPILE) -o null.elf null.o
Index: vusb-20121206/tests/Readme.txt
===================================================================
--- vusb-20121206/tests/Readme.txt	(nonexistent)
+++ vusb-20121206/tests/Readme.txt	(working copy)
@@ -0,0 +1,13 @@
+This is the Readme file for the directory "tests" of V-USB, a firmware-only
+USB driver for AVR microcontrollers.
+
+WHAT IS IN THIS DIRECTORY?
+==========================
+This directory is for driver development only. It contains tests to check
+whether all branches of #ifdef code compile as they should and whether the
+code size of the driver increased.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/tests/compare-sizes.awk
===================================================================
--- vusb-20121206/tests/compare-sizes.awk	(nonexistent)
+++ vusb-20121206/tests/compare-sizes.awk	(working copy)
@@ -0,0 +1,44 @@
+#!/usr/bin/awk -f
+# Name: compare-sizes.awk
+# Project: v-usb
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-29
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+BEGIN{
+	opt = 0;
+	if(ARGC != 3){
+		printf("usage: compare-sizes.awk file1 file2\n");
+		printf("  computes size differences between two size lists\n");
+		exit 1;
+	}
+	file1 = ARGV[1];
+	file2 = ARGV[2];
+}
+
+{
+	if(($2 + 0) != 0){
+		if(!hadOption[$1]){
+			hadOption[$1] = 1;
+			options[opt++] = $1;
+		}
+		flash[FILENAME, $1] = $2;
+		ram[FILENAME, $1] = $3;
+	}
+}
+
+END{
+	if(opt > 0){
+		printf ("%39s %6s %5s\n", "Variation", "+Flash", "+RAM");
+	}
+	for(i = 0; i < opt; i++){
+		option = options[i];
+        if(!flash[file2, option] || !flash[file1, option]){
+            printf("%39s %6s %5s\n", option, "n/a", "n/a");
+        }else{
+            printf("%39s %+6d %+5d\n", option, flash[file2, option] - flash[file1, option], ram[file2, option] - ram[file1, option]);
+        }
+	}
+}
Index: vusb-20121206/tests/main.c
===================================================================
--- vusb-20121206/tests/main.c	(nonexistent)
+++ vusb-20121206/tests/main.c	(working copy)
@@ -0,0 +1,158 @@
+/* Name: main.c
+ * Project: Testing driver features
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-29
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This module is a do-nothing test code linking against (or including) the USB
+driver. It is used to determine the code size for various options and to
+check whether the code compiles with all options.
+*/
+#include <avr/io.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include <util/delay.h>     /* for _delay_ms() */
+#include "usbdrv.h"
+#if USE_INCLUDE
+#include "usbdrv.c"
+#endif
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#if USB_CFG_IMPLEMENT_FN_WRITE
+uchar usbFunctionWrite(uchar *data, uchar len)
+{
+    return 1;
+}
+#endif
+
+#if USB_CFG_IMPLEMENT_FN_READ
+uchar usbFunctionRead(uchar *data, uchar len)
+{
+    return len;
+}
+#endif
+
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+void usbFunctionWriteOut(uchar *data, uchar len)
+{
+}
+#endif
+
+#if USE_DYNAMIC_DESCRIPTOR
+
+static PROGMEM const char myDescriptorDevice[] = {    /* USB device descriptor */
+    18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
+    USBDESCR_DEVICE,        /* descriptor type */
+    0x10, 0x01,             /* USB version supported */
+    USB_CFG_DEVICE_CLASS,
+    USB_CFG_DEVICE_SUBCLASS,
+    0,                      /* protocol */
+    8,                      /* max packet size */
+    /* the following two casts affect the first byte of the constant only, but
+     * that's sufficient to avoid a warning with the default values.
+     */
+    (char)USB_CFG_VENDOR_ID,/* 2 bytes */
+    (char)USB_CFG_DEVICE_ID,/* 2 bytes */
+    USB_CFG_DEVICE_VERSION, /* 2 bytes */
+    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
+    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
+    1,          /* number of configurations */
+};
+
+static PROGMEM const char myDescriptorConfiguration[] = { /* USB configuration descriptor */
+    9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
+    USBDESCR_CONFIG,    /* descriptor type */
+    18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
+                /* total length of data returned (including inlined descriptors) */
+    1,          /* number of interfaces in this configuration */
+    1,          /* index of this configuration */
+    0,          /* configuration name string index */
+#if USB_CFG_IS_SELF_POWERED
+    USBATTR_SELFPOWER,      /* attributes */
+#else
+    0,                      /* attributes */
+#endif
+    USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
+/* interface descriptor follows inline: */
+    9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
+    USBDESCR_INTERFACE, /* descriptor type */
+    0,          /* index of this interface */
+    0,          /* alternate setting for this interface */
+    USB_CFG_HAVE_INTRIN_ENDPOINT,   /* endpoints excl 0: number of endpoint descriptors to follow */
+    USB_CFG_INTERFACE_CLASS,
+    USB_CFG_INTERFACE_SUBCLASS,
+    USB_CFG_INTERFACE_PROTOCOL,
+    0,          /* string index for interface */
+#if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
+    9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
+    USBDESCR_HID,   /* descriptor type: HID */
+    0x01, 0x01, /* BCD representation of HID version */
+    0x00,       /* target country code */
+    0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
+    0x22,       /* descriptor type: report */
+    USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)0x81, /* IN endpoint number 1 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+};
+
+USB_PUBLIC usbMsgLen_t usbFunctionDescriptor(usbRequest_t *rq)
+{
+uchar *p = 0, len = 0;
+
+    if(rq->wValue.bytes[1] == USBDESCR_DEVICE){
+        p = (uchar *)myDescriptorDevice;
+        len = sizeof(myDescriptorDevice);
+    }else{  /* must be configuration descriptor */
+        p = (uchar *)(myDescriptorConfiguration);
+        len = sizeof(myDescriptorConfiguration);
+    }
+    usbMsgPtr = (usbMsgPtr_t)p;
+    return len;
+}
+#endif
+
+USB_PUBLIC usbMsgLen_t  usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if(rq->bRequest == 0)   /* request using usbFunctionRead()/usbFunctionWrite() */
+        return 0xff;
+	return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int	main(void)
+{
+uchar   i;
+
+	usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+	sei();
+	for(;;){                /* main event loop */
+		usbPoll();
+	}
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/tests/null.c
===================================================================
--- vusb-20121206/tests/null.c	(nonexistent)
+++ vusb-20121206/tests/null.c	(working copy)
@@ -0,0 +1,25 @@
+/* Name: null.c
+ * Project: Testing driver features
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-29
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This is a NULL main() function to find out the code size required by libusb's
+startup code, interrupt vectors etc.
+*/
+#include <avr/io.h>
+
+
+/* ------------------------------------------------------------------------- */
+
+int	main(void)
+{
+    for(;;);
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,13 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1154    45    +0    +0
+                    Minimum_with_12_MHz  1274    45  +120    +0
+                    Minimum_with_15_MHz  1260    45  +106    +0
+                  Minimum_with_16_5_MHz  1276    45  +122    +0
+                  With_usbFunctionWrite  1214    45   +60    +0
+                   With_usbFunctionRead  1200    45   +46    +0
+         With_usbFunctionRead_and_Write  1246    45   +92    +0
+               With_usbFunctionWriteOut  1178    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1284    58  +130   +13
+  With_Interrupt_In_Endpoint_1_and_Halt  1372    58  +218   +13
+     With_Interrupt_In_Endpoint_1_and_3  1386    69  +232   +24
+                With_Dynamic_Descriptor  1186    45   +32    +0
Index: vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt	(working copy)
@@ -0,0 +1,13 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1208    45    +0    +0
+                    Minimum_with_12_MHz  1328    45  +120    +0
+                    Minimum_with_15_MHz  1314    45  +106    +0
+                  Minimum_with_16_5_MHz  1330    45  +122    +0
+                  With_usbFunctionWrite  1268    45   +60    +0
+                   With_usbFunctionRead  1264    45   +56    +0
+         With_usbFunctionRead_and_Write  1314    45  +106    +0
+               With_usbFunctionWriteOut  1218    45   +10    +0
+           With_Interrupt_In_Endpoint_1  1340    58  +132   +13
+  With_Interrupt_In_Endpoint_1_and_Halt  1414    58  +206   +13
+     With_Interrupt_In_Endpoint_1_and_3  1426    69  +218   +24
+                With_Dynamic_Descriptor  1238    45   +30    +0
Index: vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,15 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1154    45    +0    +0
+                    Minimum_with_12_MHz  1274    45  +120    +0
+                    Minimum_with_15_MHz  1260    45  +106    +0
+                  Minimum_with_16_5_MHz  1276    45  +122    +0
+                    Minimum_with_20_MHz  1136    45   -18    +0
+                  With_usbFunctionWrite  1214    45   +60    +0
+                   With_usbFunctionRead  1192    45   +38    +0
+         With_usbFunctionRead_and_Write  1234    45   +80    +0
+               With_usbFunctionWriteOut  1178    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1280    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1370    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1346    69  +192   +24
+                With_Dynamic_Descriptor  1182    45   +28    +0
+                    With_Long_Transfers  1200    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,15 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1192    45    +0    +0
+                    Minimum_with_12_MHz  1312    45  +120    +0
+                    Minimum_with_15_MHz  1298    45  +106    +0
+                  Minimum_with_16_5_MHz  1314    45  +122    +0
+                    Minimum_with_20_MHz  1174    45   -18    +0
+                  With_usbFunctionWrite  1246    45   +54    +0
+                   With_usbFunctionRead  1242    45   +50    +0
+         With_usbFunctionRead_and_Write  1280    45   +88    +0
+               With_usbFunctionWriteOut  1208    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1320    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1410    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1428    69  +236   +24
+                With_Dynamic_Descriptor  1212    45   +20    +0
+                    With_Long_Transfers  1270    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1194    45    +0    +0
+                    Minimum_with_12_MHz  1244    45   +50    +0
+                  Minimum_with_12_8_MHz  1564    45  +370    +0
+                    Minimum_with_15_MHz  1300    45  +106    +0
+                  Minimum_with_16_5_MHz  1316    45  +122    +0
+                    Minimum_with_20_MHz  1176    45   -18    +0
+                  With_usbFunctionWrite  1248    45   +54    +0
+                   With_usbFunctionRead  1244    45   +50    +0
+         With_usbFunctionRead_and_Write  1282    45   +88    +0
+               With_usbFunctionWriteOut  1210    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1322    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1412    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1430    69  +236   +24
+                With_Dynamic_Descriptor  1214    45   +20    +0
+                    With_Long_Transfers  1272    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1194    45    +0    +0
+                    Minimum_with_12_MHz  1244    45   +50    +0
+                  Minimum_with_12_8_MHz  1564    45  +370    +0
+                    Minimum_with_15_MHz  1300    45  +106    +0
+                  Minimum_with_16_5_MHz  1316    45  +122    +0
+                    Minimum_with_20_MHz  1176    45   -18    +0
+                  With_usbFunctionWrite  1248    45   +54    +0
+                   With_usbFunctionRead  1244    45   +50    +0
+         With_usbFunctionRead_and_Write  1282    45   +88    +0
+               With_usbFunctionWriteOut  1210    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1322    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1412    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1430    69  +236   +24
+                With_Dynamic_Descriptor  1214    45   +20    +0
+                    With_Long_Transfers  1272    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1224    45    +0    +0
+                    Minimum_with_12_MHz  1274    45   +50    +0
+                  Minimum_with_12_8_MHz  1594    45  +370    +0
+                    Minimum_with_15_MHz  1330    45  +106    +0
+                  Minimum_with_16_5_MHz  1346    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1074    +0
+                    Minimum_with_20_MHz  1206    45   -18    +0
+                  With_usbFunctionWrite  1284    45   +60    +0
+                   With_usbFunctionRead  1280    45   +56    +0
+         With_usbFunctionRead_and_Write  1318    45   +94    +0
+               With_usbFunctionWriteOut  1246    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1358    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1448    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1466    69  +242   +24
+                With_Dynamic_Descriptor  1250    45   +26    +0
+                    With_Long_Transfers  1302    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1224    45    +0    +0
+                    Minimum_with_12_MHz  1274    45   +50    +0
+                  Minimum_with_12_8_MHz  1594    45  +370    +0
+                    Minimum_with_15_MHz  1330    45  +106    +0
+                  Minimum_with_16_5_MHz  1346    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1074    +0
+                    Minimum_with_20_MHz  1206    45   -18    +0
+                  With_usbFunctionWrite  1284    45   +60    +0
+                   With_usbFunctionRead  1280    45   +56    +0
+         With_usbFunctionRead_and_Write  1318    45   +94    +0
+               With_usbFunctionWriteOut  1246    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1358    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1448    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1466    69  +242   +24
+                With_Dynamic_Descriptor  1250    45   +26    +0
+                    With_Long_Transfers  1302    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1518    45  +366    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1226    45    +0    +0
+                    Minimum_with_12_MHz  1276    45   +50    +0
+                  Minimum_with_12_8_MHz  1592    45  +366    +0
+                    Minimum_with_15_MHz  1332    45  +106    +0
+                  Minimum_with_16_5_MHz  1348    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1072    +0
+                    Minimum_with_20_MHz  1208    45   -18    +0
+                  With_usbFunctionWrite  1286    45   +60    +0
+                   With_usbFunctionRead  1282    45   +56    +0
+         With_usbFunctionRead_and_Write  1320    45   +94    +0
+               With_usbFunctionWriteOut  1248    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1360    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1450    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1418    69  +192   +24
+                With_Dynamic_Descriptor  1252    45   +26    +0
+                    With_Long_Transfers  1304    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1518    45  +366    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1206    47   +54    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1226    45    +0    +0
+                    Minimum_with_12_MHz  1276    45   +50    +0
+                  Minimum_with_12_8_MHz  1592    45  +366    +0
+                    Minimum_with_15_MHz  1332    45  +106    +0
+                  Minimum_with_16_5_MHz  1348    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1072    +0
+                    Minimum_with_20_MHz  1208    45   -18    +0
+                  With_usbFunctionWrite  1286    45   +60    +0
+                   With_usbFunctionRead  1282    45   +56    +0
+         With_usbFunctionRead_and_Write  1320    45   +94    +0
+               With_usbFunctionWriteOut  1248    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1360    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1450    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1418    69  +192   +24
+                With_Dynamic_Descriptor  1252    45   +26    +0
+                    With_Long_Transfers  1300    47   +74    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1192    45    +0    +0
+                    Minimum_with_12_MHz  1242    45   +50    +0
+                  Minimum_with_12_8_MHz  1558    45  +366    +0
+                    Minimum_with_15_MHz  1298    45  +106    +0
+                  Minimum_with_16_5_MHz  1314    45  +122    +0
+                Minimum_with_18_MHz+CRC  2262    45 +1070    +0
+                    Minimum_with_20_MHz  1174    45   -18    +0
+                  With_usbFunctionWrite  1252    45   +60    +0
+                   With_usbFunctionRead  1248    45   +56    +0
+         With_usbFunctionRead_and_Write  1286    45   +94    +0
+               With_usbFunctionWriteOut  1214    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1328    57  +136   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1420    57  +228   +12
+     With_Interrupt_In_Endpoint_1_and_3  1386    69  +194   +24
+                With_Dynamic_Descriptor  1198    45    +6    +0
+                    With_Long_Transfers  1236    47   +44    +2
Index: vusb-20121206/tests/usbconfig.h
===================================================================
--- vusb-20121206/tests/usbconfig.h	(nonexistent)
+++ vusb-20121206/tests/usbconfig.h	(working copy)
@@ -0,0 +1,295 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This is the config file for tests. It is not updated to the latest set of
+features. Don't use it as a prototype, use usbconfig-prototype.h instead!
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+#define USB_CFG_DMINUS_BIT      4
+#define USB_CFG_DPLUS_BIT       2
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+#define USB_CFG_CHECK_CRC       (USB_CFG_CLOCK_KHZ == 18000)
+
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#ifndef USB_CFG_HAVE_INTRIN_ENDPOINT3
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+#endif
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#ifndef USB_CFG_HAVE_INTRIN_ENDPOINT
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    USB_CFG_HAVE_INTRIN_ENDPOINT3
+#endif
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+//#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+//#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+//#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+//#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+//#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+//#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+//#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you use one of obdev's free shared
+ * VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ */
+#define  USB_CFG_DEVICE_ID       0x08, 0x3e /* 1000 dec, "free for lab use" */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you use obdev's free shared VID/PID pair. Be sure to read the rules in
+ * USB-IDs-for-free.txt!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'T', 'e', 's', 't'
+#define USB_CFG_DEVICE_NAME_LEN 4
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor().
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ */
+
+#if USE_DYNAMIC_DESCRIPTOR
+#define USB_CFG_DESCR_PROPS_DEVICE                  USB_PROP_IS_DYNAMIC
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           USB_PROP_IS_DYNAMIC
+#else
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#endif
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/tests/compare-sizes.awk
===================================================================
--- vusb-20121206/tests/compare-sizes.awk	(nonexistent)
+++ vusb-20121206/tests/compare-sizes.awk	(working copy)
@@ -0,0 +1,44 @@
+#!/usr/bin/awk -f
+# Name: compare-sizes.awk
+# Project: v-usb
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-29
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+BEGIN{
+	opt = 0;
+	if(ARGC != 3){
+		printf("usage: compare-sizes.awk file1 file2\n");
+		printf("  computes size differences between two size lists\n");
+		exit 1;
+	}
+	file1 = ARGV[1];
+	file2 = ARGV[2];
+}
+
+{
+	if(($2 + 0) != 0){
+		if(!hadOption[$1]){
+			hadOption[$1] = 1;
+			options[opt++] = $1;
+		}
+		flash[FILENAME, $1] = $2;
+		ram[FILENAME, $1] = $3;
+	}
+}
+
+END{
+	if(opt > 0){
+		printf ("%39s %6s %5s\n", "Variation", "+Flash", "+RAM");
+	}
+	for(i = 0; i < opt; i++){
+		option = options[i];
+        if(!flash[file2, option] || !flash[file1, option]){
+            printf("%39s %6s %5s\n", option, "n/a", "n/a");
+        }else{
+            printf("%39s %+6d %+5d\n", option, flash[file2, option] - flash[file1, option], ram[file2, option] - ram[file1, option]);
+        }
+	}
+}
Index: vusb-20121206/tests/main.c
===================================================================
--- vusb-20121206/tests/main.c	(nonexistent)
+++ vusb-20121206/tests/main.c	(working copy)
@@ -0,0 +1,158 @@
+/* Name: main.c
+ * Project: Testing driver features
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-29
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This module is a do-nothing test code linking against (or including) the USB
+driver. It is used to determine the code size for various options and to
+check whether the code compiles with all options.
+*/
+#include <avr/io.h>
+#include <avr/interrupt.h>  /* for sei() */
+#include <avr/pgmspace.h>   /* required by usbdrv.h */
+#include <util/delay.h>     /* for _delay_ms() */
+#include "usbdrv.h"
+#if USE_INCLUDE
+#include "usbdrv.c"
+#endif
+
+/* ------------------------------------------------------------------------- */
+/* ----------------------------- USB interface ----------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#if USB_CFG_IMPLEMENT_FN_WRITE
+uchar usbFunctionWrite(uchar *data, uchar len)
+{
+    return 1;
+}
+#endif
+
+#if USB_CFG_IMPLEMENT_FN_READ
+uchar usbFunctionRead(uchar *data, uchar len)
+{
+    return len;
+}
+#endif
+
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+void usbFunctionWriteOut(uchar *data, uchar len)
+{
+}
+#endif
+
+#if USE_DYNAMIC_DESCRIPTOR
+
+static PROGMEM const char myDescriptorDevice[] = {    /* USB device descriptor */
+    18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
+    USBDESCR_DEVICE,        /* descriptor type */
+    0x10, 0x01,             /* USB version supported */
+    USB_CFG_DEVICE_CLASS,
+    USB_CFG_DEVICE_SUBCLASS,
+    0,                      /* protocol */
+    8,                      /* max packet size */
+    /* the following two casts affect the first byte of the constant only, but
+     * that's sufficient to avoid a warning with the default values.
+     */
+    (char)USB_CFG_VENDOR_ID,/* 2 bytes */
+    (char)USB_CFG_DEVICE_ID,/* 2 bytes */
+    USB_CFG_DEVICE_VERSION, /* 2 bytes */
+    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
+    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
+    1,          /* number of configurations */
+};
+
+static PROGMEM const char myDescriptorConfiguration[] = { /* USB configuration descriptor */
+    9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
+    USBDESCR_CONFIG,    /* descriptor type */
+    18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
+                /* total length of data returned (including inlined descriptors) */
+    1,          /* number of interfaces in this configuration */
+    1,          /* index of this configuration */
+    0,          /* configuration name string index */
+#if USB_CFG_IS_SELF_POWERED
+    USBATTR_SELFPOWER,      /* attributes */
+#else
+    0,                      /* attributes */
+#endif
+    USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
+/* interface descriptor follows inline: */
+    9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
+    USBDESCR_INTERFACE, /* descriptor type */
+    0,          /* index of this interface */
+    0,          /* alternate setting for this interface */
+    USB_CFG_HAVE_INTRIN_ENDPOINT,   /* endpoints excl 0: number of endpoint descriptors to follow */
+    USB_CFG_INTERFACE_CLASS,
+    USB_CFG_INTERFACE_SUBCLASS,
+    USB_CFG_INTERFACE_PROTOCOL,
+    0,          /* string index for interface */
+#if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
+    9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
+    USBDESCR_HID,   /* descriptor type: HID */
+    0x01, 0x01, /* BCD representation of HID version */
+    0x00,       /* target country code */
+    0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
+    0x22,       /* descriptor type: report */
+    USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)0x81, /* IN endpoint number 1 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+};
+
+USB_PUBLIC usbMsgLen_t usbFunctionDescriptor(usbRequest_t *rq)
+{
+uchar *p = 0, len = 0;
+
+    if(rq->wValue.bytes[1] == USBDESCR_DEVICE){
+        p = (uchar *)myDescriptorDevice;
+        len = sizeof(myDescriptorDevice);
+    }else{  /* must be configuration descriptor */
+        p = (uchar *)(myDescriptorConfiguration);
+        len = sizeof(myDescriptorConfiguration);
+    }
+    usbMsgPtr = (usbMsgPtr_t)p;
+    return len;
+}
+#endif
+
+USB_PUBLIC usbMsgLen_t  usbFunctionSetup(uchar data[8])
+{
+usbRequest_t    *rq = (void *)data;
+
+    if(rq->bRequest == 0)   /* request using usbFunctionRead()/usbFunctionWrite() */
+        return 0xff;
+	return 0;   /* default for not implemented requests: return no data back to host */
+}
+
+/* ------------------------------------------------------------------------- */
+
+int	main(void)
+{
+uchar   i;
+
+	usbInit();
+    usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
+    i = 0;
+    while(--i){             /* fake USB disconnect for > 250 ms */
+        _delay_ms(1);
+    }
+    usbDeviceConnect();
+	sei();
+	for(;;){                /* main event loop */
+		usbPoll();
+	}
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/tests/Makefile
===================================================================
--- vusb-20121206/tests/Makefile	(nonexistent)
+++ vusb-20121206/tests/Makefile	(working copy)
@@ -0,0 +1,126 @@
+# Name: Makefile
+# Project: custom-class example
+# Author: Christian Starkjohann
+# Creation Date: 2008-04-07
+# Tabsize: 4
+# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+
+DEVICE  = attiny2313
+F_CPU   = 16000000	# in Hz
+DEFINES =
+
+CFLAGS  = $(DEFINES) -Iusbdrv -I. -DDEBUG_LEVEL=0
+OBJECTS = usbdrv/usbdrv.o usbdrv/usbdrvasm.o usbdrv/oddebug.o main.o
+
+COMPILE = avr-gcc -Wall -Os -DF_CPU=$(F_CPU) $(CFLAGS) -mmcu=$(DEVICE)
+
+SIZES_TMP = /tmp/sizetmp.txt
+
+# symbolic targets:
+help:
+	@echo "This Makefile has no default rule. Use one of the following:"
+	@echo "make clean ..... to delete objects and hex file"
+	@echo "make sizes ..... compute code and RAM sizes for various options"
+	@echo "make test ...... test with all features whether everything compiles"
+
+sizes sizes.txt:
+	rm -f $(SIZES_TMP) sizes.txt
+	$(MAKE) null.elf
+	avr-size null.elf | tail -1 | awk '{print "null", $$1+$$2, $$3+$$2}' >$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_16_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=12000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_12_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=12800000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_12_8_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=15000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_15_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=16500000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_16_5_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=18000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_18_MHz+CRC", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf F_CPU=20000000
+	avr-size main.elf | tail -1 | awk '{print "Minimum_with_20_MHz", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf DEFINES=-DUSB_CFG_IMPLEMENT_FN_WRITE=1
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionWrite", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf DEFINES=-DUSB_CFG_IMPLEMENT_FN_READ=1
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionRead", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_IMPLEMENT_FN_READ=1 -DUSB_CFG_IMPLEMENT_FN_WRITE=1"
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionRead_and_Write", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_IMPLEMENT_FN_WRITEOUT=1"
+	avr-size main.elf | tail -1 | awk '{print "With_usbFunctionWriteOut", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_HAVE_INTRIN_ENDPOINT=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Interrupt_In_Endpoint_1", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_IMPLEMENT_HALT=1 -DUSB_CFG_HAVE_INTRIN_ENDPOINT=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Interrupt_In_Endpoint_1_and_Halt", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_HAVE_INTRIN_ENDPOINT3=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Interrupt_In_Endpoint_1_and_3", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSE_DYNAMIC_DESCRIPTOR=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Dynamic_Descriptor", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	$(MAKE) clean; $(MAKE) main.elf "DEFINES=-DUSB_CFG_LONG_TRANSFERS=1"
+	avr-size main.elf | tail -1 | awk '{print "With_Long_Transfers", $$1+$$2, $$3+$$2}' >>$(SIZES_TMP)
+	cat $(SIZES_TMP) | awk 'BEGIN{printf("%39s %5s %5s %5s %5s\n"), "Variation", "Flash", "RAM", "+F", "+RAM"}\
+		/^null/{nullRom=$$2; nullRam=$$3; next} \
+		{rom=$$2-nullRom; ram=$$3-nullRam; if(!refRom){refRom=rom; refRam=ram} \
+		printf("%39s %5d %5d %+5d %+5d\n", $$1, rom, ram, rom-refRom, ram-refRam)}' | tee sizes.txt
+	rm $(SIZES_TMP)
+
+test:
+	for freq in 12000000 12800000 15000000 16000000 16500000 18000000 20000000; do \
+		for opt in USB_COUNT_SOF USB_CFG_HAVE_INTRIN_ENDPOINT USB_CFG_HAVE_INTRIN_ENDPOINT3 USB_CFG_HAVE_MEASURE_FRAME_LENGTH USB_CFG_LONG_TRANSFERS; do \
+			$(MAKE) clean; $(MAKE) main.elf F_CPU=$$freq "DEFINES=-D$$opt=1" || exit 1; \
+			$(MAKE) clean; $(MAKE) main.elf F_CPU=$$freq "DEFINES=-D$$opt=1 -DDUSB_CFG_IMPLEMENT_FN_WRITEOUT=1" || exit 1; \
+		done \
+	done
+
+# The following rule is used to check the compiler
+devices: #exclude devices without RAM for stack and atmega603 for gcc 3
+	excludes="at90s1200 attiny11 attiny12 attiny15 attiny28"; \
+	for gccVersion in 3 4; do \
+		avr-gcc-select $$gccVersion; \
+		for device in `echo | avr-gcc -xc -mmcu=x - 2>&1 | egrep '^ *at[a-zA-Z0-9_-]+$$'`; do \
+			if echo "$$excludes" | grep "$$device" >/dev/null; then continue; fi; \
+			if [ "$$gccVersion" = 3 -a "$$device" = atmega603 ]; then continue; fi; \
+			$(MAKE) clean; $(MAKE) null.elf DEVICE=$$device || exit 1; \
+		done \
+	done
+	$(MAKE) clean
+	avr-gcc-select 3
+	@echo "+++ Device test succeeded!"
+
+# rule for deleting dependent files (those which can be built by Make):
+clean:
+	rm -f *.hex *.lst *.map  *.elf *.o
+	rm -rf usbdrv
+
+# Generic rule for compiling C files:
+.c.o:
+	$(COMPILE) -c $< -o $@
+
+# Generic rule for assembling Assembler source files:
+.S.o:
+	$(COMPILE) -x assembler-with-cpp -c $< -o $@
+# "-x assembler-with-cpp" should not be necessary since this is the default
+# file type for the .S (with capital S) extension. However, upper case
+# characters are not always preserved on Windows. To ensure WinAVR
+# compatibility define the file type manually.
+
+# Generic rule for compiling C to assembler, used for debugging only.
+.c.s:
+	$(COMPILE) -S $< -o $@
+
+# file targets:
+
+# Since we don't want to ship the driver multipe times, we copy it into this project:
+usbdrv:
+	cp -r ../usbdrv .
+
+main.elf: usbdrv $(OBJECTS)	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main.elf $(OBJECTS)
+
+main_i.elf: usbdrv main.o usbdrv/usbdrvasm.o	# usbdrv dependency only needed because we copy it
+	$(COMPILE) -o main_i.elf main.o usbdrv/usbdrvasm.o
+
+null.elf: null.o
+	$(COMPILE) -o null.elf null.o
Index: vusb-20121206/tests/null.c
===================================================================
--- vusb-20121206/tests/null.c	(nonexistent)
+++ vusb-20121206/tests/null.c	(working copy)
@@ -0,0 +1,25 @@
+/* Name: null.c
+ * Project: Testing driver features
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-04-29
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+This is a NULL main() function to find out the code size required by libusb's
+startup code, interrupt vectors etc.
+*/
+#include <avr/io.h>
+
+
+/* ------------------------------------------------------------------------- */
+
+int	main(void)
+{
+    for(;;);
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/tests/Readme.txt
===================================================================
--- vusb-20121206/tests/Readme.txt	(nonexistent)
+++ vusb-20121206/tests/Readme.txt	(working copy)
@@ -0,0 +1,13 @@
+This is the Readme file for the directory "tests" of V-USB, a firmware-only
+USB driver for AVR microcontrollers.
+
+WHAT IS IN THIS DIRECTORY?
+==========================
+This directory is for driver development only. It contains tests to check
+whether all branches of #ifdef code compile as they should and whether the
+code size of the driver increased.
+
+
+----------------------------------------------------------------------------
+(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
+http://www.obdev.at/
Index: vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,13 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1154    45    +0    +0
+                    Minimum_with_12_MHz  1274    45  +120    +0
+                    Minimum_with_15_MHz  1260    45  +106    +0
+                  Minimum_with_16_5_MHz  1276    45  +122    +0
+                  With_usbFunctionWrite  1214    45   +60    +0
+                   With_usbFunctionRead  1200    45   +46    +0
+         With_usbFunctionRead_and_Write  1246    45   +92    +0
+               With_usbFunctionWriteOut  1178    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1284    58  +130   +13
+  With_Interrupt_In_Endpoint_1_and_Halt  1372    58  +218   +13
+     With_Interrupt_In_Endpoint_1_and_3  1386    69  +232   +24
+                With_Dynamic_Descriptor  1186    45   +32    +0
Index: vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt	(working copy)
@@ -0,0 +1,13 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1208    45    +0    +0
+                    Minimum_with_12_MHz  1328    45  +120    +0
+                    Minimum_with_15_MHz  1314    45  +106    +0
+                  Minimum_with_16_5_MHz  1330    45  +122    +0
+                  With_usbFunctionWrite  1268    45   +60    +0
+                   With_usbFunctionRead  1264    45   +56    +0
+         With_usbFunctionRead_and_Write  1314    45  +106    +0
+               With_usbFunctionWriteOut  1218    45   +10    +0
+           With_Interrupt_In_Endpoint_1  1340    58  +132   +13
+  With_Interrupt_In_Endpoint_1_and_Halt  1414    58  +206   +13
+     With_Interrupt_In_Endpoint_1_and_3  1426    69  +218   +24
+                With_Dynamic_Descriptor  1238    45   +30    +0
Index: vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,15 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1154    45    +0    +0
+                    Minimum_with_12_MHz  1274    45  +120    +0
+                    Minimum_with_15_MHz  1260    45  +106    +0
+                  Minimum_with_16_5_MHz  1276    45  +122    +0
+                    Minimum_with_20_MHz  1136    45   -18    +0
+                  With_usbFunctionWrite  1214    45   +60    +0
+                   With_usbFunctionRead  1192    45   +38    +0
+         With_usbFunctionRead_and_Write  1234    45   +80    +0
+               With_usbFunctionWriteOut  1178    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1280    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1370    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1346    69  +192   +24
+                With_Dynamic_Descriptor  1182    45   +28    +0
+                    With_Long_Transfers  1200    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,15 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1192    45    +0    +0
+                    Minimum_with_12_MHz  1312    45  +120    +0
+                    Minimum_with_15_MHz  1298    45  +106    +0
+                  Minimum_with_16_5_MHz  1314    45  +122    +0
+                    Minimum_with_20_MHz  1174    45   -18    +0
+                  With_usbFunctionWrite  1246    45   +54    +0
+                   With_usbFunctionRead  1242    45   +50    +0
+         With_usbFunctionRead_and_Write  1280    45   +88    +0
+               With_usbFunctionWriteOut  1208    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1320    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1410    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1428    69  +236   +24
+                With_Dynamic_Descriptor  1212    45   +20    +0
+                    With_Long_Transfers  1270    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1194    45    +0    +0
+                    Minimum_with_12_MHz  1244    45   +50    +0
+                  Minimum_with_12_8_MHz  1564    45  +370    +0
+                    Minimum_with_15_MHz  1300    45  +106    +0
+                  Minimum_with_16_5_MHz  1316    45  +122    +0
+                    Minimum_with_20_MHz  1176    45   -18    +0
+                  With_usbFunctionWrite  1248    45   +54    +0
+                   With_usbFunctionRead  1244    45   +50    +0
+         With_usbFunctionRead_and_Write  1282    45   +88    +0
+               With_usbFunctionWriteOut  1210    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1322    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1412    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1430    69  +236   +24
+                With_Dynamic_Descriptor  1214    45   +20    +0
+                    With_Long_Transfers  1272    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1194    45    +0    +0
+                    Minimum_with_12_MHz  1244    45   +50    +0
+                  Minimum_with_12_8_MHz  1564    45  +370    +0
+                    Minimum_with_15_MHz  1300    45  +106    +0
+                  Minimum_with_16_5_MHz  1316    45  +122    +0
+                    Minimum_with_20_MHz  1176    45   -18    +0
+                  With_usbFunctionWrite  1248    45   +54    +0
+                   With_usbFunctionRead  1244    45   +50    +0
+         With_usbFunctionRead_and_Write  1282    45   +88    +0
+               With_usbFunctionWriteOut  1210    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1322    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1412    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1430    69  +236   +24
+                With_Dynamic_Descriptor  1214    45   +20    +0
+                    With_Long_Transfers  1272    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1224    45    +0    +0
+                    Minimum_with_12_MHz  1274    45   +50    +0
+                  Minimum_with_12_8_MHz  1594    45  +370    +0
+                    Minimum_with_15_MHz  1330    45  +106    +0
+                  Minimum_with_16_5_MHz  1346    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1074    +0
+                    Minimum_with_20_MHz  1206    45   -18    +0
+                  With_usbFunctionWrite  1284    45   +60    +0
+                   With_usbFunctionRead  1280    45   +56    +0
+         With_usbFunctionRead_and_Write  1318    45   +94    +0
+               With_usbFunctionWriteOut  1246    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1358    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1448    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1466    69  +242   +24
+                With_Dynamic_Descriptor  1250    45   +26    +0
+                    With_Long_Transfers  1302    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1224    45    +0    +0
+                    Minimum_with_12_MHz  1274    45   +50    +0
+                  Minimum_with_12_8_MHz  1594    45  +370    +0
+                    Minimum_with_15_MHz  1330    45  +106    +0
+                  Minimum_with_16_5_MHz  1346    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1074    +0
+                    Minimum_with_20_MHz  1206    45   -18    +0
+                  With_usbFunctionWrite  1284    45   +60    +0
+                   With_usbFunctionRead  1280    45   +56    +0
+         With_usbFunctionRead_and_Write  1318    45   +94    +0
+               With_usbFunctionWriteOut  1246    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1358    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1448    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1466    69  +242   +24
+                With_Dynamic_Descriptor  1250    45   +26    +0
+                    With_Long_Transfers  1302    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1518    45  +366    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1226    45    +0    +0
+                    Minimum_with_12_MHz  1276    45   +50    +0
+                  Minimum_with_12_8_MHz  1592    45  +366    +0
+                    Minimum_with_15_MHz  1332    45  +106    +0
+                  Minimum_with_16_5_MHz  1348    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1072    +0
+                    Minimum_with_20_MHz  1208    45   -18    +0
+                  With_usbFunctionWrite  1286    45   +60    +0
+                   With_usbFunctionRead  1282    45   +56    +0
+         With_usbFunctionRead_and_Write  1320    45   +94    +0
+               With_usbFunctionWriteOut  1248    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1360    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1450    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1418    69  +192   +24
+                With_Dynamic_Descriptor  1252    45   +26    +0
+                    With_Long_Transfers  1304    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1518    45  +366    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1206    47   +54    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1226    45    +0    +0
+                    Minimum_with_12_MHz  1276    45   +50    +0
+                  Minimum_with_12_8_MHz  1592    45  +366    +0
+                    Minimum_with_15_MHz  1332    45  +106    +0
+                  Minimum_with_16_5_MHz  1348    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1072    +0
+                    Minimum_with_20_MHz  1208    45   -18    +0
+                  With_usbFunctionWrite  1286    45   +60    +0
+                   With_usbFunctionRead  1282    45   +56    +0
+         With_usbFunctionRead_and_Write  1320    45   +94    +0
+               With_usbFunctionWriteOut  1248    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1360    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1450    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1418    69  +192   +24
+                With_Dynamic_Descriptor  1252    45   +26    +0
+                    With_Long_Transfers  1300    47   +74    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1192    45    +0    +0
+                    Minimum_with_12_MHz  1242    45   +50    +0
+                  Minimum_with_12_8_MHz  1558    45  +366    +0
+                    Minimum_with_15_MHz  1298    45  +106    +0
+                  Minimum_with_16_5_MHz  1314    45  +122    +0
+                Minimum_with_18_MHz+CRC  2262    45 +1070    +0
+                    Minimum_with_20_MHz  1174    45   -18    +0
+                  With_usbFunctionWrite  1252    45   +60    +0
+                   With_usbFunctionRead  1248    45   +56    +0
+         With_usbFunctionRead_and_Write  1286    45   +94    +0
+               With_usbFunctionWriteOut  1214    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1328    57  +136   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1420    57  +228   +12
+     With_Interrupt_In_Endpoint_1_and_3  1386    69  +194   +24
+                With_Dynamic_Descriptor  1198    45    +6    +0
+                    With_Long_Transfers  1236    47   +44    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080418-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,13 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1154    45    +0    +0
+                    Minimum_with_12_MHz  1274    45  +120    +0
+                    Minimum_with_15_MHz  1260    45  +106    +0
+                  Minimum_with_16_5_MHz  1276    45  +122    +0
+                  With_usbFunctionWrite  1214    45   +60    +0
+                   With_usbFunctionRead  1200    45   +46    +0
+         With_usbFunctionRead_and_Write  1246    45   +92    +0
+               With_usbFunctionWriteOut  1178    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1284    58  +130   +13
+  With_Interrupt_In_Endpoint_1_and_Halt  1372    58  +218   +13
+     With_Interrupt_In_Endpoint_1_and_3  1386    69  +232   +24
+                With_Dynamic_Descriptor  1186    45   +32    +0
Index: vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080418-gcc4.2.2.txt	(working copy)
@@ -0,0 +1,13 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1208    45    +0    +0
+                    Minimum_with_12_MHz  1328    45  +120    +0
+                    Minimum_with_15_MHz  1314    45  +106    +0
+                  Minimum_with_16_5_MHz  1330    45  +122    +0
+                  With_usbFunctionWrite  1268    45   +60    +0
+                   With_usbFunctionRead  1264    45   +56    +0
+         With_usbFunctionRead_and_Write  1314    45  +106    +0
+               With_usbFunctionWriteOut  1218    45   +10    +0
+           With_Interrupt_In_Endpoint_1  1340    58  +132   +13
+  With_Interrupt_In_Endpoint_1_and_Halt  1414    58  +206   +13
+     With_Interrupt_In_Endpoint_1_and_3  1426    69  +218   +24
+                With_Dynamic_Descriptor  1238    45   +30    +0
Index: vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080513-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,15 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1154    45    +0    +0
+                    Minimum_with_12_MHz  1274    45  +120    +0
+                    Minimum_with_15_MHz  1260    45  +106    +0
+                  Minimum_with_16_5_MHz  1276    45  +122    +0
+                    Minimum_with_20_MHz  1136    45   -18    +0
+                  With_usbFunctionWrite  1214    45   +60    +0
+                   With_usbFunctionRead  1192    45   +38    +0
+         With_usbFunctionRead_and_Write  1234    45   +80    +0
+               With_usbFunctionWriteOut  1178    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1280    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1370    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1346    69  +192   +24
+                With_Dynamic_Descriptor  1182    45   +28    +0
+                    With_Long_Transfers  1200    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20080513-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,15 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1192    45    +0    +0
+                    Minimum_with_12_MHz  1312    45  +120    +0
+                    Minimum_with_15_MHz  1298    45  +106    +0
+                  Minimum_with_16_5_MHz  1314    45  +122    +0
+                    Minimum_with_20_MHz  1174    45   -18    +0
+                  With_usbFunctionWrite  1246    45   +54    +0
+                   With_usbFunctionRead  1242    45   +50    +0
+         With_usbFunctionRead_and_Write  1280    45   +88    +0
+               With_usbFunctionWriteOut  1208    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1320    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1410    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1428    69  +236   +24
+                With_Dynamic_Descriptor  1212    45   +20    +0
+                    With_Long_Transfers  1270    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081022-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081022-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1194    45    +0    +0
+                    Minimum_with_12_MHz  1244    45   +50    +0
+                  Minimum_with_12_8_MHz  1564    45  +370    +0
+                    Minimum_with_15_MHz  1300    45  +106    +0
+                  Minimum_with_16_5_MHz  1316    45  +122    +0
+                    Minimum_with_20_MHz  1176    45   -18    +0
+                  With_usbFunctionWrite  1248    45   +54    +0
+                   With_usbFunctionRead  1244    45   +50    +0
+         With_usbFunctionRead_and_Write  1282    45   +88    +0
+               With_usbFunctionWriteOut  1210    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1322    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1412    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1430    69  +236   +24
+                With_Dynamic_Descriptor  1214    45   +20    +0
+                    With_Long_Transfers  1272    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081126-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20081126-gcc4.3.0.txt	(working copy)
@@ -0,0 +1,16 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1194    45    +0    +0
+                    Minimum_with_12_MHz  1244    45   +50    +0
+                  Minimum_with_12_8_MHz  1564    45  +370    +0
+                    Minimum_with_15_MHz  1300    45  +106    +0
+                  Minimum_with_16_5_MHz  1316    45  +122    +0
+                    Minimum_with_20_MHz  1176    45   -18    +0
+                  With_usbFunctionWrite  1248    45   +54    +0
+                   With_usbFunctionRead  1244    45   +50    +0
+         With_usbFunctionRead_and_Write  1282    45   +88    +0
+               With_usbFunctionWriteOut  1210    45   +16    +0
+           With_Interrupt_In_Endpoint_1  1322    57  +128   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1412    57  +218   +12
+     With_Interrupt_In_Endpoint_1_and_3  1430    69  +236   +24
+                With_Dynamic_Descriptor  1214    45   +20    +0
+                    With_Long_Transfers  1272    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090323-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090323-gcc4.3.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1224    45    +0    +0
+                    Minimum_with_12_MHz  1274    45   +50    +0
+                  Minimum_with_12_8_MHz  1594    45  +370    +0
+                    Minimum_with_15_MHz  1330    45  +106    +0
+                  Minimum_with_16_5_MHz  1346    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1074    +0
+                    Minimum_with_20_MHz  1206    45   -18    +0
+                  With_usbFunctionWrite  1284    45   +60    +0
+                   With_usbFunctionRead  1280    45   +56    +0
+         With_usbFunctionRead_and_Write  1318    45   +94    +0
+               With_usbFunctionWriteOut  1246    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1358    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1448    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1466    69  +242   +24
+                With_Dynamic_Descriptor  1250    45   +26    +0
+                    With_Long_Transfers  1302    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090415-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1522    45  +370    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20090415-gcc4.3.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1224    45    +0    +0
+                    Minimum_with_12_MHz  1274    45   +50    +0
+                  Minimum_with_12_8_MHz  1594    45  +370    +0
+                    Minimum_with_15_MHz  1330    45  +106    +0
+                  Minimum_with_16_5_MHz  1346    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1074    +0
+                    Minimum_with_20_MHz  1206    45   -18    +0
+                  With_usbFunctionWrite  1284    45   +60    +0
+                   With_usbFunctionRead  1280    45   +56    +0
+         With_usbFunctionRead_and_Write  1318    45   +94    +0
+               With_usbFunctionWriteOut  1246    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1358    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1448    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1466    69  +242   +24
+                With_Dynamic_Descriptor  1250    45   +26    +0
+                    With_Long_Transfers  1302    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20100715-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1518    45  +366    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1198    47   +46    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20100715-gcc4.3.3.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1226    45    +0    +0
+                    Minimum_with_12_MHz  1276    45   +50    +0
+                  Minimum_with_12_8_MHz  1592    45  +366    +0
+                    Minimum_with_15_MHz  1332    45  +106    +0
+                  Minimum_with_16_5_MHz  1348    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1072    +0
+                    Minimum_with_20_MHz  1208    45   -18    +0
+                  With_usbFunctionWrite  1286    45   +60    +0
+                   With_usbFunctionRead  1282    45   +56    +0
+         With_usbFunctionRead_and_Write  1320    45   +94    +0
+               With_usbFunctionWriteOut  1248    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1360    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1450    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1418    69  +192   +24
+                With_Dynamic_Descriptor  1252    45   +26    +0
+                    With_Long_Transfers  1304    47   +78    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20120109-gcc3.4.6.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1152    45    +0    +0
+                    Minimum_with_12_MHz  1202    45   +50    +0
+                  Minimum_with_12_8_MHz  1518    45  +366    +0
+                    Minimum_with_15_MHz  1258    45  +106    +0
+                  Minimum_with_16_5_MHz  1274    45  +122    +0
+                Minimum_with_18_MHz+CRC  2268    45 +1116    +0
+                    Minimum_with_20_MHz  1134    45   -18    +0
+                  With_usbFunctionWrite  1212    45   +60    +0
+                   With_usbFunctionRead  1190    45   +38    +0
+         With_usbFunctionRead_and_Write  1232    45   +80    +0
+               With_usbFunctionWriteOut  1176    45   +24    +0
+           With_Interrupt_In_Endpoint_1  1278    57  +126   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1368    57  +216   +12
+     With_Interrupt_In_Endpoint_1_and_3  1344    69  +192   +24
+                With_Dynamic_Descriptor  1180    45   +28    +0
+                    With_Long_Transfers  1206    47   +54    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20120109-gcc4.3.3.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1226    45    +0    +0
+                    Minimum_with_12_MHz  1276    45   +50    +0
+                  Minimum_with_12_8_MHz  1592    45  +366    +0
+                    Minimum_with_15_MHz  1332    45  +106    +0
+                  Minimum_with_16_5_MHz  1348    45  +122    +0
+                Minimum_with_18_MHz+CRC  2298    45 +1072    +0
+                    Minimum_with_20_MHz  1208    45   -18    +0
+                  With_usbFunctionWrite  1286    45   +60    +0
+                   With_usbFunctionRead  1282    45   +56    +0
+         With_usbFunctionRead_and_Write  1320    45   +94    +0
+               With_usbFunctionWriteOut  1248    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1360    57  +134   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1450    57  +224   +12
+     With_Interrupt_In_Endpoint_1_and_3  1418    69  +192   +24
+                With_Dynamic_Descriptor  1252    45   +26    +0
+                    With_Long_Transfers  1300    47   +74    +2
Index: vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt
===================================================================
--- vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt	(nonexistent)
+++ vusb-20121206/tests/sizes-reference/sizes-20121206-gcc4.6.2.txt	(working copy)
@@ -0,0 +1,17 @@
+                              Variation Flash   RAM    +F  +RAM
+                    Minimum_with_16_MHz  1192    45    +0    +0
+                    Minimum_with_12_MHz  1242    45   +50    +0
+                  Minimum_with_12_8_MHz  1558    45  +366    +0
+                    Minimum_with_15_MHz  1298    45  +106    +0
+                  Minimum_with_16_5_MHz  1314    45  +122    +0
+                Minimum_with_18_MHz+CRC  2262    45 +1070    +0
+                    Minimum_with_20_MHz  1174    45   -18    +0
+                  With_usbFunctionWrite  1252    45   +60    +0
+                   With_usbFunctionRead  1248    45   +56    +0
+         With_usbFunctionRead_and_Write  1286    45   +94    +0
+               With_usbFunctionWriteOut  1214    45   +22    +0
+           With_Interrupt_In_Endpoint_1  1328    57  +136   +12
+  With_Interrupt_In_Endpoint_1_and_Halt  1420    57  +228   +12
+     With_Interrupt_In_Endpoint_1_and_3  1386    69  +194   +24
+                With_Dynamic_Descriptor  1198    45    +6    +0
+                    With_Long_Transfers  1236    47   +44    +2
Index: vusb-20121206/tests/usbconfig.h
===================================================================
--- vusb-20121206/tests/usbconfig.h	(nonexistent)
+++ vusb-20121206/tests/usbconfig.h	(working copy)
@@ -0,0 +1,295 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This is the config file for tests. It is not updated to the latest set of
+features. Don't use it as a prototype, use usbconfig-prototype.h instead!
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+#define USB_CFG_DMINUS_BIT      4
+#define USB_CFG_DPLUS_BIT       2
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+#define USB_CFG_CHECK_CRC       (USB_CFG_CLOCK_KHZ == 18000)
+
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#ifndef USB_CFG_HAVE_INTRIN_ENDPOINT3
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+#endif
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#ifndef USB_CFG_HAVE_INTRIN_ENDPOINT
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    USB_CFG_HAVE_INTRIN_ENDPOINT3
+#endif
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+//#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           40
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+//#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+//#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+//#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+//#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+//#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+//#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you use one of obdev's free shared
+ * VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ */
+#define  USB_CFG_DEVICE_ID       0x08, 0x3e /* 1000 dec, "free for lab use" */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you use obdev's free shared VID/PID pair. Be sure to read the rules in
+ * USB-IDs-for-free.txt!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'T', 'e', 's', 't'
+#define USB_CFG_DEVICE_NAME_LEN 4
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor().
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ */
+
+#if USE_DYNAMIC_DESCRIPTOR
+#define USB_CFG_DESCR_PROPS_DEVICE                  USB_PROP_IS_DYNAMIC
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           USB_PROP_IS_DYNAMIC
+#else
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#endif
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/USB-ID-FAQ.txt
===================================================================
--- vusb-20121206/USB-ID-FAQ.txt	(nonexistent)
+++ vusb-20121206/USB-ID-FAQ.txt	(working copy)
@@ -0,0 +1,149 @@
+Version 2012-07-09
+
+==========================
+WHY DO WE NEED THESE IDs?
+==========================
+
+USB is more than a low level protocol for data transport. It also defines a
+common set of requests which must be understood by all devices. And as part
+of these common requests, the specification defines data structures, the
+USB Descriptors, which are used to describe the properties of the device.
+
+From the perspective of an operating system, it is therefore possible to find
+out basic properties of a device (such as e.g. the manufacturer and the name
+of the device) without a device-specific driver. This is essential because
+the operating system can choose a driver to load based on this information
+(Plug-And-Play).
+
+Among the most important properties in the Device Descriptor are the USB
+Vendor- and Product-ID. Both are 16 bit integers. The most simple form of
+driver matching is based on these IDs. The driver announces the Vendor- and
+Product-IDs of the devices it can handle and the operating system loads the
+appropriate driver when the device is connected.
+
+It is obvious that this technique only works if the pair Vendor- plus
+Product-ID is unique: Only devices which require the same driver can have the
+same pair of IDs.
+
+
+=====================================================
+HOW DOES THE USB STANDARD ENSURE THAT IDs ARE UNIQUE?
+=====================================================
+
+Since it is so important that USB IDs are unique, the USB Implementers Forum,
+Inc. (usb.org) needs a way to enforce this legally. It is not forbidden by
+law to build a device and assign it any random numbers as IDs. Usb.org
+therefore needs an agreement to regulate the use of USB IDs. The agreement
+binds only parties who agreed to it, of course. Everybody else is free to use
+any numbers for their IDs.
+
+So how can usb.org ensure that every manufacturer of USB devices enters into
+an agreement with them? They do it via trademark licensing. Usb.org has
+registered the trademark "USB", all associated logos and related terms. If
+you want to put an USB logo on your product or claim that it is USB
+compliant, you must license these trademarks from usb.org. And this is where
+you enter into an agreement. See the "USB-IF Trademark License Agreement and
+Usage Guidelines for the USB-IF Logo" at
+http://www.usb.org/developers/logo_license/.
+
+Licensing the USB trademarks requires that you buy a USB Vendor-ID from
+usb.org (one-time fee of ca. 2,000 USD), that you become a member of usb.org
+(yearly fee of ca. 4,000 USD) and that you meet all the technical
+specifications from the USB spec.
+
+This means that most hobbyists and small companies will never be able to
+become USB compliant, just because membership is so expensive. And you can't
+be compliant with a driver based on V-USB anyway, because the AVR's port pins
+don't meet the electrical specifications for USB. So, in principle, all
+hobbyists and small companies are free to choose any random numbers for their
+IDs. They have nothing to lose...
+
+There is one exception worth noting, though: If you use a sub-component which
+implements USB, the vendor of the sub-components may guarantee USB
+compliance. This might apply to some or all of FTDI's solutions.
+
+
+=======================================================================
+WHY SHOULD YOU OBTAIN USB IDs EVEN IF YOU DON'T LICENSE USB TRADEMARKS?
+=======================================================================
+
+You have learned in the previous section that you are free to choose any
+numbers for your IDs anyway. So why not do exactly this? There is still the
+technical issue. If you choose IDs which are already in use by somebody else,
+operating systems will load the wrong drivers and your device won't work.
+Even if you choose IDs which are not currently in use, they may be in use in
+the next version of the operating system or even after an automatic update.
+
+So what you need is a pair of Vendor- and Product-IDs for which you have the
+guarantee that no USB compliant product uses them. This implies that no
+operating system will ever ship with drivers responsible for these IDs.
+
+
+==============================================
+HOW DOES OBJECTIVE DEVELOPMENT HANDLE USB IDs?
+==============================================
+
+Objective Development gives away pairs of USB-IDs with their V-USB licenses.
+In order to ensure that these IDs are unique, Objective Development has an
+agreement with the company/person who has bought the USB Vendor-ID from
+usb.org. This agreement ensures that a range of USB Product-IDs is reserved
+for assignment by Objective Development and that the owner of the Vendor-ID
+won't give it to anybody else.
+
+This means that you have to trust three parties to ensure uniqueness of
+your IDs:
+
+  - Objective Development, that they don't give the same PID to more than
+    one person.
+  - The owner of the Vendor-ID that they don't assign PIDs from the range
+    assigned to Objective Development to anybody else.
+  - Usb.org that they don't assign the same Vendor-ID a second time.
+
+
+==================================
+WHO IS THE OWNER OF THE VENDOR-ID?
+==================================
+
+Objective Development has obtained ranges of USB Product-IDs under two
+Vendor-IDs: Under Vendor-ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under Vendor-ID 8352 from Jason
+Kotzin (now flirc.tv, Inc.). Both VID owners have received their Vendor-ID
+directly from usb.org.
+
+
+=========================================================================
+CAN I USE USB-IDs FROM OBJECTIVE DEVELOPMENT WITH OTHER DRIVERS/HARDWARE?
+=========================================================================
+
+The short answer is: Yes. All you get is a guarantee that the IDs are never
+assigned to anybody else. What more do you need?
+
+
+============================
+WHAT ABOUT SHARED ID PAIRS?
+============================
+
+Objective Development has reserved some PID/VID pairs for shared use. You
+have no guarantee of uniqueness for them, except that no USB compliant device
+uses them. In order to avoid technical problems, we must ensure that all
+devices with the same pair of IDs use the same driver on kernel level. For
+details, see the file USB-IDs-for-free.txt.
+
+
+======================================================
+I HAVE HEARD THAT SUB-LICENSING OF USB-IDs IS ILLEGAL?
+======================================================
+
+A 16 bit integer number cannot be protected by copyright laws. It is not
+sufficiently complex. And since none of the parties involved entered into the
+USB-IF Trademark License Agreement, we are not bound by this agreement. So
+there is no reason why it should be illegal to sub-license USB-IDs.
+
+
+=============================================
+WHO IS LIABLE IF THERE ARE INCOMPATIBILITIES?
+=============================================
+
+Objective Development disclaims all liabilities which might arise from the
+assignment of IDs. If you guarantee product features to your customers
+without proper disclaimer, YOU are liable for that.
Index: vusb-20121206/USB-IDs-for-free.txt
===================================================================
--- vusb-20121206/USB-IDs-for-free.txt	(nonexistent)
+++ vusb-20121206/USB-IDs-for-free.txt	(working copy)
@@ -0,0 +1,154 @@
+Version 2009-08-22
+
+===========================
+FREE USB-IDs FOR SHARED USE
+===========================
+
+Objective Development has reserved a set of USB Product-IDs for use according
+to the guidelines outlined below. For more information about the concept of
+USB IDs please see the file USB-ID-FAQ.txt. Objective Development guarantees
+that the IDs listed below are not used by any USB compliant devices.
+
+
+====================
+MECHANISM OF SHARING
+====================
+
+From a technical point of view, two different devices can share the same USB
+Vendor- and Product-ID if they require the same driver on operating system
+level. We make use of this fact by assigning separate IDs for various device
+classes. On application layer, devices must be distinguished by their textual
+name or serial number. We offer separate sets of IDs for discrimination by
+textual name and for serial number.
+
+Examples for shared use of USB IDs are included with V-USB in the "examples"
+subdirectory.
+
+
+======================================
+IDs FOR DISCRIMINATION BY TEXTUAL NAME
+======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the manufacturer
+and product identification. The manufacturer identification MUST be available
+at least in USB language 0x0409 (English/US).
+
+(2) The textual manufacturer identification MUST contain either an Internet
+domain name (e.g. "mycompany.com") registered and owned by you, or an e-mail
+address under your control (e.g. "myname@gmx.net"). You can embed the domain
+name or e-mail address in any string you like, e.g.  "Objective Development
+http://www.obdev.at/vusb/".
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(4) You may choose any string for the textual product identification, as long
+as this string is unique within the scope of your textual manufacturer
+identification.
+
+(5) Application side device look-up MUST be based on the textual manufacturer
+and product identification in addition to VID/PID matching. The driver
+matching MUST be a comparison of the entire strings, NOT a sub-string match.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+Table if IDs for discrimination by textual name:
+
+PID dec (hex) | VID dec (hex) | Description of use
+==============+===============+============================================
+1500 (0x05dc) | 5824 (0x16c0) | For Vendor Class devices with libusb
+--------------+---------------+--------------------------------------------
+1503 (0x05df) | 5824 (0x16c0) | For generic HID class devices (which are
+              |               | NOT mice, keyboards or joysticks)
+--------------+---------------+--------------------------------------------
+1505 (0x05e1) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+--------------+---------------+--------------------------------------------
+1508 (0x05e4) | 5824 (0x16c0) | For MIDI class devices
+--------------+---------------+--------------------------------------------
+
+Note that Windows caches the textual product- and vendor-description for
+mice, keyboards and joysticks. Name-bsed discrimination is therefore not
+recommended for these device classes.
+
+
+=======================================
+IDs FOR DISCRIMINATION BY SERIAL NUMBER
+=======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the serial
+number, unless ONLY the operating system's default class driver is used.
+The serial number string MUST be available at least in USB language 0x0409
+(English/US).
+
+(2) The serial number MUST start with either an Internet domain name (e.g.
+"mycompany.com") registered and owned by you, or an e-mail address under your
+control (e.g. "myname@gmx.net"), both terminated with a colon (":") character.
+You MAY append any string you like for further discrimination of your devices.
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(5) Application side device look-up MUST be based on the serial number string
+in addition to VID/PID matching. The matching must start at the first
+character of the serial number string and include the colon character
+terminating your domain or e-mail address. It MAY stop anywhere after that.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+(7) If ONLY the operating system's default class driver is used, e.g. for
+mice, keyboards, joysticks, CDC or MIDI devices and no discrimination by an
+application is needed, the serial number may be omitted.
+
+
+Table if IDs for discrimination by serial number string:
+
+PID dec (hex)  | VID dec (hex) | Description of use
+===============+===============+===========================================
+10200 (0x27d8) | 5824 (0x16c0) | For Vendor Class devices with libusb
+---------------+---------------+-------------------------------------------
+10201 (0x27d9) | 5824 (0x16c0) | For generic HID class devices (which are
+               |               | NOT mice, keyboards or joysticks)
+---------------+---------------+-------------------------------------------
+10202 (0x27da) | 5824 (0x16c0) | For USB Mice
+---------------+---------------+-------------------------------------------
+10203 (0x27db) | 5824 (0x16c0) | For USB Keyboards
+---------------+---------------+-------------------------------------------
+10204 (0x27dc) | 5824 (0x16c0) | For USB Joysticks
+---------------+---------------+-------------------------------------------
+10205 (0x27dd) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+---------------+---------------+-------------------------------------------
+10206 (0x27de) | 5824 (0x16c0) | For MIDI class devices
+---------------+---------------+-------------------------------------------
+
+
+=================
+ORIGIN OF USB-IDs
+=================
+
+OBJECTIVE DEVELOPMENT Software GmbH has obtained all VID/PID pairs listed
+here from Wouter van Ooijen (see www.voti.nl) for exclusive disposition.
+Wouter van Ooijen has obtained the VID from the USB Implementers Forum, Inc.
+(see www.usb.org). The VID is registered for the company name "Van Ooijen
+Technische Informatica".
+
+
+==========
+DISCLAIMER
+==========
+
+OBJECTIVE DEVELOPMENT Software GmbH disclaims all liability for any
+problems which are caused by the shared use of these VID/PID pairs.
Index: vusb-20121206/usbdrv/Changelog.txt
===================================================================
--- vusb-20121206/usbdrv/Changelog.txt	(nonexistent)
+++ vusb-20121206/usbdrv/Changelog.txt	(working copy)
@@ -0,0 +1,329 @@
+This file documents changes in the firmware-only USB driver for atmel's AVR
+microcontrollers. New entries are always appended to the end of the file.
+Scroll down to the bottom to see the most recent changes.
+
+2005-04-01:
+  - Implemented endpoint 1 as interrupt-in endpoint.
+  - Moved all configuration options to usbconfig.h which is not part of the
+    driver.
+  - Changed interface for usbVendorSetup().
+  - Fixed compatibility with ATMega8 device.
+  - Various minor optimizations.
+
+2005-04-11:
+  - Changed interface to application: Use usbFunctionSetup(), usbFunctionRead()
+    and usbFunctionWrite() now. Added configuration options to choose which
+    of these functions to compile in.
+  - Assembler module delivers receive data non-inverted now.
+  - Made register and bit names compatible with more AVR devices.
+
+2005-05-03:
+  - Allow address of usbRxBuf on any memory page as long as the buffer does
+    not cross 256 byte page boundaries.
+  - Better device compatibility: works with Mega88 now.
+  - Code optimization in debugging module.
+  - Documentation updates.
+
+2006-01-02:
+  - Added (free) default Vendor- and Product-IDs bought from voti.nl.
+  - Added USBID-License.txt file which defines the rules for using the free
+    shared VID/PID pair.
+  - Added Readme.txt to the usbdrv directory which clarifies administrative
+    issues.
+
+2006-01-25:
+  - Added "configured state" to become more standards compliant.
+  - Added "HALT" state for interrupt endpoint.
+  - Driver passes the "USB Command Verifier" test from usb.org now.
+  - Made "serial number" a configuration option.
+  - Minor optimizations, we now recommend compiler option "-Os" for best
+    results.
+  - Added a version number to usbdrv.h
+
+2006-02-03:
+  - New configuration variable USB_BUFFER_SECTION for the memory section where
+    the USB rx buffer will go. This defaults to ".bss" if not defined. Since
+    this buffer MUST NOT cross 256 byte pages (not even touch a page at the
+    end), the user may want to pass a linker option similar to
+    "-Wl,--section-start=.mybuffer=0x800060".
+  - Provide structure for usbRequest_t.
+  - New defines for USB constants.
+  - Prepared for HID implementations.
+  - Increased data size limit for interrupt transfers to 8 bytes.
+  - New macro usbInterruptIsReady() to query interrupt buffer state.
+
+2006-02-18:
+  - Ensure that the data token which is sent as an ack to an OUT transfer is
+    always zero sized. This fixes a bug where the host reports an error after
+    sending an out transfer to the device, although all data arrived at the
+    device.
+  - Updated docs in usbdrv.h to reflect changed API in usbFunctionWrite().
+
+* Release 2006-02-20
+
+  - Give a compiler warning when compiling with debugging turned on.
+  - Added Oleg Semyonov's changes for IAR-cc compatibility.
+  - Added new (optional) functions usbDeviceConnect() and usbDeviceDisconnect()
+    (also thanks to Oleg!).
+  - Rearranged tests in usbPoll() to save a couple of instructions in the most
+    likely case that no actions are pending.
+  - We need a delay between the SET ADDRESS request until the new address
+    becomes active. This delay was handled in usbPoll() until now. Since the
+    spec says that the delay must not exceed 2ms, previous versions required
+    aggressive polling during the enumeration phase. We have now moved the
+    handling of the delay into the interrupt routine.
+  - We must not reply with NAK to a SETUP transaction. We can only achieve this
+    by making sure that the rx buffer is empty when SETUP tokens are expected.
+    We therefore don't pass zero sized data packets from the status phase of
+    a transfer to usbPoll(). This change MAY cause troubles if you rely on
+    receiving a less than 8 bytes long packet in usbFunctionWrite() to
+    identify the end of a transfer. usbFunctionWrite() will NEVER be called
+    with a zero length.
+
+* Release 2006-03-14
+
+  - Improved IAR C support: tiny memory model, more devices
+  - Added template usbconfig.h file under the name usbconfig-prototype.h
+
+* Release 2006-03-26
+
+  - Added provision for one more interrupt-in endpoint (endpoint 3).
+  - Added provision for one interrupt-out endpoint (endpoint 1).
+  - Added flowcontrol macros for USB.
+  - Added provision for custom configuration descriptor.
+  - Allow ANY two port bits for D+ and D-.
+  - Merged (optional) receive endpoint number into global usbRxToken variable.
+  - Use USB_CFG_IOPORTNAME instead of USB_CFG_IOPORT. We now construct the
+    variable name from the single port letter instead of computing the address
+    of related ports from the output-port address.
+
+* Release 2006-06-26
+
+  - Updated documentation in usbdrv.h and usbconfig-prototype.h to reflect the
+    new features.
+  - Removed "#warning" directives because IAR does not understand them. Use
+    unused static variables instead to generate a warning.
+  - Do not include <avr/io.h> when compiling with IAR.
+  - Introduced USB_CFG_DESCR_PROPS_* in usbconfig.h to configure how each
+    USB descriptor should be handled. It is now possible to provide descriptor
+    data in Flash, RAM or dynamically at runtime.
+  - STALL is now a status in usbTxLen* instead of a message. We can now conform
+    to the spec and leave the stall status pending until it is cleared.
+  - Made usbTxPacketCnt1 and usbTxPacketCnt3 public. This allows the
+    application code to reset data toggling on interrupt pipes.
+
+* Release 2006-07-18
+
+  - Added an #if !defined __ASSEMBLER__ to the warning in usbdrv.h. This fixes
+    an assembler error.
+  - usbDeviceDisconnect() takes pull-up resistor to high impedance now.
+
+* Release 2007-02-01
+
+  - Merged in some code size improvements from usbtiny (thanks to Dick
+    Streefland for these optimizations!)
+  - Special alignment requirement for usbRxBuf not required any more. Thanks
+    again to Dick Streefland for this hint!
+  - Reverted to "#warning" instead of unused static variables -- new versions
+    of IAR CC should handle this directive.
+  - Changed Open Source license to GNU GPL v2 in order to make linking against
+    other free libraries easier. We no longer require publication of the
+    circuit diagrams, but we STRONGLY encourage it. If you improve the driver
+    itself, PLEASE grant us a royalty free license to your changes for our
+    commercial license.
+
+* Release 2007-03-29
+
+  - New configuration option "USB_PUBLIC" in usbconfig.h.
+  - Set USB version number to 1.10 instead of 1.01.
+  - Code used USB_CFG_DESCR_PROPS_STRING_DEVICE and
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT inconsistently. Changed all occurrences
+    to USB_CFG_DESCR_PROPS_STRING_PRODUCT.
+  - New assembler module for 16.5 MHz RC oscillator clock with PLL in receiver
+    code.
+  - New assembler module for 16 MHz crystal.
+  - usbdrvasm.S contains common code only, clock-specific parts have been moved
+    to usbdrvasm12.S, usbdrvasm16.S and usbdrvasm165.S respectively.
+
+* Release 2007-06-25
+
+  - 16 MHz module: Do SE0 check in stuffed bits as well.
+
+* Release 2007-07-07
+
+  - Define hi8(x) for IAR compiler to limit result to 8 bits. This is necessary
+    for negative values.
+  - Added 15 MHz module contributed by V. Bosch.
+  - Interrupt vector name can now be configured. This is useful if somebody
+    wants to use a different hardware interrupt than INT0.
+
+* Release 2007-08-07
+
+  - Moved handleIn3 routine in usbdrvasm16.S so that relative jump range is
+    not exceeded.
+  - More config options: USB_RX_USER_HOOK(), USB_INITIAL_DATATOKEN,
+    USB_COUNT_SOF
+  - USB_INTR_PENDING can now be a memory address, not just I/O
+
+* Release 2007-09-19
+
+  - Split out common parts of assembler modules into separate include file
+  - Made endpoint numbers configurable so that given interface definitions
+    can be matched. See USB_CFG_EP3_NUMBER in usbconfig-prototype.h.
+  - Store endpoint number for interrupt/bulk-out so that usbFunctionWriteOut()
+    can handle any number of endpoints.
+  - Define usbDeviceConnect() and usbDeviceDisconnect() even if no
+    USB_CFG_PULLUP_IOPORTNAME is defined. Directly set D+ and D- to 0 in this
+    case.
+
+* Release 2007-12-01
+
+  - Optimize usbDeviceConnect() and usbDeviceDisconnect() for less code size
+    when USB_CFG_PULLUP_IOPORTNAME is not defined.
+
+* Release 2007-12-13
+
+  - Renamed all include-only assembler modules from *.S to *.inc so that
+    people don't add them to their project sources.
+  - Distribute leap bits in tx loop more evenly for 16 MHz module.
+  - Use "macro" and "endm" instead of ".macro" and ".endm" for IAR
+  - Avoid compiler warnings for constant expr range by casting some values in
+    USB descriptors.
+
+* Release 2008-01-21
+
+  - Fixed bug in 15 and 16 MHz module where the new address set with
+    SET_ADDRESS was already accepted at the next NAK or ACK we send, not at
+    the next data packet we send. This caused problems when the host polled
+    too fast. Thanks to Alexander Neumann for his help and patience debugging
+    this issue!
+
+* Release 2008-02-05
+
+  - Fixed bug in 16.5 MHz module where a register was used in the interrupt
+    handler before it was pushed. This bug was introduced with version
+    2007-09-19 when common parts were moved to a separate file.
+  - Optimized CRC routine (thanks to Reimar Doeffinger).
+
+* Release 2008-02-16
+
+  - Removed outdated IAR compatibility stuff (code sections).
+  - Added hook macros for USB_RESET_HOOK() and USB_SET_ADDRESS_HOOK().
+  - Added optional routine usbMeasureFrameLength() for calibration of the
+    internal RC oscillator.
+
+* Release 2008-02-28
+
+  - USB_INITIAL_DATATOKEN defaults to USBPID_DATA1 now, which means that we
+    start with sending USBPID_DATA0.
+  - Changed defaults in usbconfig-prototype.h
+  - Added free USB VID/PID pair for MIDI class devices
+  - Restructured AVR-USB as separate package, not part of PowerSwitch any more.
+
+* Release 2008-04-18
+
+  - Restructured usbdrv.c so that it is easier to read and understand.
+  - Better code optimization with gcc 4.
+  - If a second interrupt in endpoint is enabled, also add it to config
+    descriptor.
+  - Added config option for long transfers (above 254 bytes), see
+    USB_CFG_LONG_TRANSFERS in usbconfig.h.
+  - Added 20 MHz module contributed by Jeroen Benschop.
+
+* Release 2008-05-13
+
+  - Fixed bug in libs-host/hiddata.c function usbhidGetReport(): length
+    was not incremented, pointer to length was incremented instead.
+  - Added code to command line tool(s) which claims an interface. This code
+    is disabled by default, but may be necessary on newer Linux kernels.
+  - Added usbconfig.h option "USB_CFG_CHECK_DATA_TOGGLING".
+  - New header "usbportability.h" prepares ports to other development
+    environments.
+  - Long transfers (above 254 bytes) did not work when usbFunctionRead() was
+    used to supply the data. Fixed this bug. [Thanks to Alexander Neumann!]
+  - In hiddata.c (example code for sending/receiving data over HID), use
+    USB_RECIP_DEVICE instead of USB_RECIP_INTERFACE for control transfers so
+    that we need not claim the interface.
+  - in usbPoll() loop 20 times polling for RESET state instead of 10 times.
+    This accounts for the higher clock rates we now support.
+  - Added a module for 12.8 MHz RC oscillator with PLL in receiver loop.
+  - Added hook to SOF code so that oscillator can be tuned to USB frame clock.
+  - Added timeout to waitForJ loop. Helps preventing unexpected hangs.
+  - Added example code for oscillator tuning to libs-device (thanks to
+    Henrik Haftmann for the idea to this routine).
+  - Implemented option USB_CFG_SUPPRESS_INTR_CODE.
+
+* Release 2008-10-22
+
+  - Fixed libs-device/osctune.h: OSCCAL is memory address on ATMega88 and
+    similar, not offset of 0x20 needs to be added.
+  - Allow distribution under GPLv3 for those who have to link against other
+    code distributed under GPLv3.
+
+* Release 2008-11-26
+
+  - Removed libusb-win32 dependency for hid-data example in Makefile.windows.
+    It was never required and confused many people.
+  - Added extern uchar usbRxToken to usbdrv.h.
+  - Integrated a module with CRC checks at 18 MHz by Lukas Schrittwieser.
+
+* Release 2009-03-23
+
+  - Hid-mouse example used settings from hid-data example, fixed that.
+  - Renamed project to V-USB due to a trademark issue with Atmel(r).
+  - Changed CommercialLicense.txt and USBID-License.txt to make the
+    background of USB ID registration clearer.
+
+* Release 2009-04-15
+
+  - Changed CommercialLicense.txt to reflect the new range of PIDs from
+    Jason Kotzin.
+  - Removed USBID-License.txt in favor of USB-IDs-for-free.txt and
+    USB-ID-FAQ.txt
+  - Fixed a bug in the 12.8 MHz module: End Of Packet decection was made in
+    the center between bit 0 and 1 of each byte. This is where the data lines
+    are expected to change and the sampled data may therefore be nonsense.
+    We therefore check EOP ONLY if bits 0 AND 1 have both been read as 0 on D-.
+  - Fixed a bitstuffing problem in the 16 MHz module: If bit 6 was stuffed,
+    the unstuffing code in the receiver routine was 1 cycle too long. If
+    multiple bytes had the unstuffing in bit 6, the error summed up until the
+    receiver was out of sync.
+  - Included option for faster CRC routine.
+    Thanks to Slawomir Fras (BoskiDialer) for this code!
+  - Updated bits in Configuration Descriptor's bmAttributes according to
+    USB 1.1 (in particular bit 7, it is a must-be-set bit now).
+
+* Release 2009-08-22
+
+  - Moved first DBG1() after odDebugInit() in all examples.
+  - Use vector INT0_vect instead of SIG_INTERRUPT0 if defined. This makes
+    V-USB compatible with the new "p" suffix devices (e.g. ATMega328p).
+  - USB_CFG_CLOCK_KHZ setting is now required in usbconfig.h (no default any
+    more).
+  - New option USB_CFG_DRIVER_FLASH_PAGE allows boot loaders on devices with
+    more than 64 kB flash.
+  - Built-in configuration descriptor allows custom definition for second
+    endpoint now.
+
+* Release 2010-07-15
+
+  - Fixed bug in usbDriverSetup() which prevented descriptor sizes above 255
+    bytes.
+  - Avoid a compiler warning for unused parameter in usbHandleResetHook() when
+    compiler option -Wextra is enabled.
+  - Fixed wrong hex value for some IDs in USB-IDs-for-free.txt.
+  - Keep a define for USBATTR_BUSPOWER, although the flag does not exist
+    in USB 1.1 any more. Set it to 0. This is for backward compatibility.
+
+* Release 2012-01-09
+
+  - Define a separate (defined) type for usbMsgPtr so that projects using a
+    tiny memory model can define it to an 8 bit type in usbconfig.h. This
+    change also saves a couple of bytes when using a scalar 16 bit type.
+  - Inserted "const" keyword for all PROGMEM declarations because new GCC
+    requires it.
+  - Fixed problem with dependence of usbportability.h on usbconfig.h. This
+    problem occurred with IAR CC only.
+  - Prepared repository for github.com.
+
+* Release 2012-12-06
\ No newline at end of file
Index: vusb-20121206/usbdrv/CommercialLicense.txt
===================================================================
--- vusb-20121206/usbdrv/CommercialLicense.txt	(nonexistent)
+++ vusb-20121206/usbdrv/CommercialLicense.txt	(working copy)
@@ -0,0 +1,166 @@
+V-USB Driver Software License Agreement
+Version 2012-07-09
+
+THIS LICENSE AGREEMENT GRANTS YOU CERTAIN RIGHTS IN A SOFTWARE. YOU CAN
+ENTER INTO THIS AGREEMENT AND ACQUIRE THE RIGHTS OUTLINED BELOW BY PAYING
+THE AMOUNT ACCORDING TO SECTION 4 ("PAYMENT") TO OBJECTIVE DEVELOPMENT.
+
+
+1 DEFINITIONS
+
+1.1 "OBJECTIVE DEVELOPMENT" shall mean OBJECTIVE DEVELOPMENT Software GmbH,
+Grosse Schiffgasse 1A/7, 1020 Wien, AUSTRIA.
+
+1.2 "You" shall mean the Licensee.
+
+1.3 "V-USB" shall mean all files included in the package distributed under
+the name "vusb" by OBJECTIVE DEVELOPMENT (http://www.obdev.at/vusb/)
+unless otherwise noted. This includes the firmware-only USB device
+implementation for Atmel AVR microcontrollers, some simple device examples
+and host side software examples and libraries.
+
+
+2 LICENSE GRANTS
+
+2.1 Source Code. OBJECTIVE DEVELOPMENT shall furnish you with the source
+code of V-USB.
+
+2.2 Distribution and Use. OBJECTIVE DEVELOPMENT grants you the
+non-exclusive right to use, copy and distribute V-USB with your hardware
+product(s), restricted by the limitations in section 3 below.
+
+2.3 Modifications. OBJECTIVE DEVELOPMENT grants you the right to modify
+the source code and your copy of V-USB according to your needs.
+
+2.4 USB IDs. OBJECTIVE DEVELOPMENT furnishes you with one or two USB
+Product ID(s), sent to you in e-mail. These Product IDs are reserved
+exclusively for you. OBJECTIVE DEVELOPMENT has obtained USB Product ID
+ranges under the Vendor ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under the Vendor ID 8352 from
+Jason Kotzin (now flirc.tv, Inc.). Both owners of the Vendor IDs have
+obtained these IDs from the USB Implementers Forum, Inc. (www.usb.org).
+OBJECTIVE DEVELOPMENT disclaims all liability which might arise from the
+assignment of USB IDs.
+
+2.5 USB Certification. Although not part of this agreement, we want to make
+it clear that you cannot become USB certified when you use V-USB or a USB
+Product ID assigned by OBJECTIVE DEVELOPMENT. AVR microcontrollers don't
+meet the electrical specifications required by the USB specification and
+the USB Implementers Forum certifies only members who bought a Vendor ID of
+their own.
+
+
+3 LICENSE RESTRICTIONS
+
+3.1 Number of Units. Only one of the following three definitions is
+applicable. Which one is determined by the amount you pay to OBJECTIVE
+DEVELOPMENT, see section 4 ("Payment") below.
+
+Hobby License: You may use V-USB according to section 2 above in no more
+than 5 hardware units. These units must not be sold for profit.
+
+Entry Level License: You may use V-USB according to section 2 above in no
+more than 150 hardware units.
+
+Professional License: You may use V-USB according to section 2 above in
+any number of hardware units, except for large scale production ("unlimited
+fair use"). Quantities below 10,000 units are not considered large scale
+production. If your reach quantities which are obviously large scale
+production, you must pay a license fee of 0.10 EUR per unit for all units
+above 10,000.
+
+3.2 Rental. You may not rent, lease, or lend V-USB or otherwise encumber
+any copy of V-USB, or any of the rights granted herein.
+
+3.3 Transfer. You may not transfer your rights under this Agreement to
+another party without OBJECTIVE DEVELOPMENT's prior written consent. If
+such consent is obtained, you may permanently transfer this License to
+another party. The recipient of such transfer must agree to all terms and
+conditions of this Agreement.
+
+3.4 Reservation of Rights. OBJECTIVE DEVELOPMENT retains all rights not
+expressly granted.
+
+3.5 Non-Exclusive Rights. Your license rights under this Agreement are
+non-exclusive.
+
+3.6 Third Party Rights. This Agreement cannot grant you rights controlled
+by third parties. In particular, you are not allowed to use the USB logo or
+other trademarks owned by the USB Implementers Forum, Inc. without their
+consent. Since such consent depends on USB certification, it should be
+noted that V-USB will not pass certification because it does not
+implement checksum verification and the microcontroller ports do not meet
+the electrical specifications.
+
+
+4 PAYMENT
+
+The payment amount depends on the variation of this agreement (according to
+section 3.1) into which you want to enter. Concrete prices are listed on
+OBJECTIVE DEVELOPMENT's web site, usually at
+http://www.obdev.at/vusb/license.html. You agree to pay the amount listed
+there to OBJECTIVE DEVELOPMENT or OBJECTIVE DEVELOPMENT's payment processor
+or reseller.
+
+
+5 COPYRIGHT AND OWNERSHIP
+
+V-USB is protected by copyright laws and international copyright
+treaties, as well as other intellectual property laws and treaties. V-USB
+is licensed, not sold.
+
+
+6 TERM AND TERMINATION
+
+6.1 Term. This Agreement shall continue indefinitely. However, OBJECTIVE
+DEVELOPMENT may terminate this Agreement and revoke the granted license and
+USB-IDs if you fail to comply with any of its terms and conditions.
+
+6.2 Survival of Terms. All provisions regarding secrecy, confidentiality
+and limitation of liability shall survive termination of this agreement.
+
+
+7 DISCLAIMER OF WARRANTY AND LIABILITY
+
+LIMITED WARRANTY. V-USB IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
+KIND. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, OBJECTIVE
+DEVELOPMENT AND ITS SUPPLIERS HEREBY DISCLAIM ALL WARRANTIES, EITHER
+EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND
+NON-INFRINGEMENT, WITH REGARD TO V-USB, AND THE PROVISION OF OR FAILURE
+TO PROVIDE SUPPORT SERVICES. THIS LIMITED WARRANTY GIVES YOU SPECIFIC LEGAL
+RIGHTS. YOU MAY HAVE OTHERS, WHICH VARY FROM STATE/JURISDICTION TO
+STATE/JURISDICTION.
+
+LIMITATION OF LIABILITY. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW,
+IN NO EVENT SHALL OBJECTIVE DEVELOPMENT OR ITS SUPPLIERS BE LIABLE FOR ANY
+SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER
+(INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
+BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY
+LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE V-USB OR THE
+PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES, EVEN IF OBJECTIVE
+DEVELOPMENT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY
+CASE, OBJECTIVE DEVELOPMENT'S ENTIRE LIABILITY UNDER ANY PROVISION OF THIS
+AGREEMENT SHALL BE LIMITED TO THE AMOUNT ACTUALLY PAID BY YOU FOR V-USB.
+
+
+8 MISCELLANEOUS TERMS
+
+8.1 Marketing. OBJECTIVE DEVELOPMENT has the right to mention for marketing
+purposes that you entered into this agreement.
+
+8.2 Entire Agreement. This document represents the entire agreement between
+OBJECTIVE DEVELOPMENT and you. It may only be modified in writing signed by
+an authorized representative of both, OBJECTIVE DEVELOPMENT and you.
+
+8.3 Severability. In case a provision of these terms and conditions should
+be or become partly or entirely invalid, ineffective, or not executable,
+the validity of all other provisions shall not be affected.
+
+8.4 Applicable Law. This agreement is governed by the laws of the Republic
+of Austria.
+
+8.5 Responsible Courts. The responsible courts in Vienna/Austria will have
+exclusive jurisdiction regarding all disputes in connection with this
+agreement.
+
Index: vusb-20121206/usbdrv/License.txt
===================================================================
--- vusb-20121206/usbdrv/License.txt	(nonexistent)
+++ vusb-20121206/usbdrv/License.txt	(working copy)
@@ -0,0 +1,361 @@
+OBJECTIVE DEVELOPMENT GmbH's V-USB driver software is distributed under the
+terms and conditions of the GNU GPL version 2 or the GNU GPL version 3. It is
+your choice whether you apply the terms of version 2 or version 3. The full
+text of GPLv2 is included below. In addition to the requirements in the GPL,
+we STRONGLY ENCOURAGE you to do the following:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: vusb-20121206/usbdrv/Readme.txt
===================================================================
--- vusb-20121206/usbdrv/Readme.txt	(nonexistent)
+++ vusb-20121206/usbdrv/Readme.txt	(working copy)
@@ -0,0 +1,172 @@
+This is the Readme file to Objective Development's firmware-only USB driver
+for Atmel AVR microcontrollers. For more information please visit
+http://www.obdev.at/vusb/
+
+This directory contains the USB firmware only. Copy it as-is to your own
+project and add all .c and .S files to your project (these files are marked
+with an asterisk in the list below). Then copy usbconfig-prototype.h as
+usbconfig.h to your project and edit it according to your configuration.
+
+
+TECHNICAL DOCUMENTATION
+=======================
+The technical documentation (API) for the firmware driver is contained in the
+file "usbdrv.h". Please read all of it carefully! Configuration options are
+documented in "usbconfig-prototype.h".
+
+The driver consists of the following files:
+  Readme.txt ............. The file you are currently reading.
+  Changelog.txt .......... Release notes for all versions of the driver.
+  usbdrv.h ............... Driver interface definitions and technical docs.
+* usbdrv.c ............... High level language part of the driver. Link this
+                           module to your code!
+* usbdrvasm.S ............ Assembler part of the driver. This module is mostly
+                           a stub and includes one of the usbdrvasm*.S files
+                           depending on processor clock. Link this module to
+                           your code!
+  usbdrvasm*.inc ......... Assembler routines for particular clock frequencies.
+                           Included by usbdrvasm.S, don't link it directly!
+  asmcommon.inc .......... Common assembler routines. Included by
+                           usbdrvasm*.inc, don't link it directly!
+  usbconfig-prototype.h .. Prototype for your own usbdrv.h file.
+* oddebug.c .............. Debug functions. Only used when DEBUG_LEVEL is
+                           defined to a value greater than 0. Link this module
+                           to your code!
+  oddebug.h .............. Interface definitions of the debug module.
+  usbportability.h ....... Header with compiler-dependent stuff.
+  usbdrvasm.asm .......... Compatibility stub for IAR-C-compiler. Use this
+                           module instead of usbdrvasm.S when you assembler
+                           with IAR's tools.
+  License.txt ............ Open Source license for this driver.
+  CommercialLicense.txt .. Optional commercial license for this driver.
+  USB-ID-FAQ.txt ......... General infos about USB Product- and Vendor-IDs.
+  USB-IDs-for-free.txt ... List and terms of use for free shared PIDs.
+
+(*) ... These files should be linked to your project.
+
+
+CPU CORE CLOCK FREQUENCY
+========================
+We supply assembler modules for clock frequencies of 12 MHz, 12.8 MHz, 15 MHz,
+16 MHz, 16.5 MHz 18 MHz and 20 MHz. Other clock rates are not supported. The
+actual clock rate must be configured in usbconfig.h.
+
+12 MHz Clock
+This is the traditional clock rate of V-USB because it's the lowest clock
+rate where the timing constraints of the USB spec can be met.
+
+15 MHz Clock
+Similar to 12 MHz, but some NOPs inserted. On the other hand, the higher clock
+rate allows for some loops which make the resulting code size somewhat smaller
+than the 12 MHz version.
+
+16 MHz Clock
+This clock rate has been added for users of the Arduino board and other
+ready-made boards which come with a fixed 16 MHz crystal. It's also an option
+if you need the slightly higher clock rate for performance reasons. Since
+16 MHz is not divisible by the USB low speed bit clock of 1.5 MHz, the code
+is somewhat tricky and has to insert a leap cycle every third byte.
+
+12.8 MHz and 16.5 MHz Clock
+The assembler modules for these clock rates differ from the other modules
+because they have been built for an RC oscillator with only 1% precision. The
+receiver code inserts leap cycles to compensate for clock deviations. 1% is
+also the precision which can be achieved by calibrating the internal RC
+oscillator of the AVR. Please note that only AVRs with internal 64 MHz PLL
+oscillator can reach 16.5 MHz with the RC oscillator. This includes the very
+popular ATTiny25, ATTiny45, ATTiny85 series as well as the ATTiny26. Almost
+all AVRs can reach 12.8 MHz, although this is outside the specified range.
+
+See the EasyLogger example at http://www.obdev.at/vusb/easylogger.html for
+code which calibrates the RC oscillator based on the USB frame clock.
+
+18 MHz Clock
+This module is closer to the USB specification because it performs an on the
+fly CRC check for incoming packets. Packets with invalid checksum are
+discarded as required by the spec. If you also implement checks for data
+PID toggling on application level (see option USB_CFG_CHECK_DATA_TOGGLING
+in usbconfig.h for more info), this ensures data integrity. Due to the CRC
+tables and alignment requirements, this code is bigger than modules for other
+clock rates. To activate this module, you must define USB_CFG_CHECK_CRC to 1
+and USB_CFG_CLOCK_KHZ to 18000 in usbconfig.h.
+
+20 MHz Clock
+This module is for people who won't do it with less than the maximum. Since
+20 MHz is not divisible by the USB low speed bit clock of 1.5 MHz, the code
+uses similar tricks as the 16 MHz module to insert leap cycles.
+
+
+USB IDENTIFIERS
+===============
+Every USB device needs a vendor- and a product-identifier (VID and PID). VIDs
+are obtained from usb.org for a price of 1,500 USD. Once you have a VID, you
+can assign PIDs at will.
+
+Since an entry level cost of 1,500 USD is too high for most small companies
+and hobbyists, we provide some VID/PID pairs for free. See the file
+USB-IDs-for-free.txt for details.
+
+Objective Development also has some license offerings which include product
+IDs. See http://www.obdev.at/vusb/ for details.
+
+
+DEVELOPMENT SYSTEM
+==================
+This driver has been developed and optimized for the GNU compiler version 3
+and 4. We recommend that you use the GNU compiler suite because it is freely
+available. V-USB has also been ported to the IAR compiler and assembler. It
+has been tested with IAR 4.10B/W32 and 4.12A/W32 on an ATmega8 with the
+"small" and "tiny" memory model. Not every release is tested with IAR CC and
+the driver may therefore fail to compile with IAR. Please note that gcc is
+more efficient for usbdrv.c because this module has been deliberately
+optimized for gcc.
+
+Gcc version 3 produces smaller code than version 4 due to new optimizing
+capabilities which don't always improve things on 8 bit CPUs. The code size
+generated by gcc 4 can be reduced with the compiler options
+-fno-move-loop-invariants, -fno-tree-scev-cprop and
+-fno-inline-small-functions in addition to -Os. On devices with more than
+8k of flash memory, we also recommend the linker option --relax (written as
+-Wl,--relax for gcc) to convert absolute calls into relative where possible.
+
+For more information about optimizing options see:
+
+    http://www.tty1.net/blog/2008-04-29-avr-gcc-optimisations_en.html
+
+These optimizations are good for gcc 4.x. Version 3.x of gcc does not support
+most of these options and produces good code anyway.
+
+
+USING V-USB FOR FREE
+====================
+The AVR firmware driver is published under the GNU General Public License
+Version 2 (GPL2) and the GNU General Public License Version 3 (GPL3). It is
+your choice whether you apply the terms of version 2 or version 3.
+
+If you decide for the free GPL2 or GPL3, we STRONGLY ENCOURAGE you to do the
+following things IN ADDITION to the obligations from the GPL:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+If you don't have a web site, you can publish the project in obdev's
+documentation wiki at
+http://www.obdev.at/goto.php?t=vusb-wiki&p=hosted-projects.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+COMMERCIAL LICENSES FOR V-USB
+=============================
+If you don't want to publish your source code under the terms of the GPL,
+you can simply pay money for V-USB. As an additional benefit you get
+USB PIDs for free, reserved exclusively to you. See the file
+"CommercialLicense.txt" for details.
+
Index: vusb-20121206/usbdrv/USB-ID-FAQ.txt
===================================================================
--- vusb-20121206/usbdrv/USB-ID-FAQ.txt	(nonexistent)
+++ vusb-20121206/usbdrv/USB-ID-FAQ.txt	(working copy)
@@ -0,0 +1,149 @@
+Version 2012-07-09
+
+==========================
+WHY DO WE NEED THESE IDs?
+==========================
+
+USB is more than a low level protocol for data transport. It also defines a
+common set of requests which must be understood by all devices. And as part
+of these common requests, the specification defines data structures, the
+USB Descriptors, which are used to describe the properties of the device.
+
+From the perspective of an operating system, it is therefore possible to find
+out basic properties of a device (such as e.g. the manufacturer and the name
+of the device) without a device-specific driver. This is essential because
+the operating system can choose a driver to load based on this information
+(Plug-And-Play).
+
+Among the most important properties in the Device Descriptor are the USB
+Vendor- and Product-ID. Both are 16 bit integers. The most simple form of
+driver matching is based on these IDs. The driver announces the Vendor- and
+Product-IDs of the devices it can handle and the operating system loads the
+appropriate driver when the device is connected.
+
+It is obvious that this technique only works if the pair Vendor- plus
+Product-ID is unique: Only devices which require the same driver can have the
+same pair of IDs.
+
+
+=====================================================
+HOW DOES THE USB STANDARD ENSURE THAT IDs ARE UNIQUE?
+=====================================================
+
+Since it is so important that USB IDs are unique, the USB Implementers Forum,
+Inc. (usb.org) needs a way to enforce this legally. It is not forbidden by
+law to build a device and assign it any random numbers as IDs. Usb.org
+therefore needs an agreement to regulate the use of USB IDs. The agreement
+binds only parties who agreed to it, of course. Everybody else is free to use
+any numbers for their IDs.
+
+So how can usb.org ensure that every manufacturer of USB devices enters into
+an agreement with them? They do it via trademark licensing. Usb.org has
+registered the trademark "USB", all associated logos and related terms. If
+you want to put an USB logo on your product or claim that it is USB
+compliant, you must license these trademarks from usb.org. And this is where
+you enter into an agreement. See the "USB-IF Trademark License Agreement and
+Usage Guidelines for the USB-IF Logo" at
+http://www.usb.org/developers/logo_license/.
+
+Licensing the USB trademarks requires that you buy a USB Vendor-ID from
+usb.org (one-time fee of ca. 2,000 USD), that you become a member of usb.org
+(yearly fee of ca. 4,000 USD) and that you meet all the technical
+specifications from the USB spec.
+
+This means that most hobbyists and small companies will never be able to
+become USB compliant, just because membership is so expensive. And you can't
+be compliant with a driver based on V-USB anyway, because the AVR's port pins
+don't meet the electrical specifications for USB. So, in principle, all
+hobbyists and small companies are free to choose any random numbers for their
+IDs. They have nothing to lose...
+
+There is one exception worth noting, though: If you use a sub-component which
+implements USB, the vendor of the sub-components may guarantee USB
+compliance. This might apply to some or all of FTDI's solutions.
+
+
+=======================================================================
+WHY SHOULD YOU OBTAIN USB IDs EVEN IF YOU DON'T LICENSE USB TRADEMARKS?
+=======================================================================
+
+You have learned in the previous section that you are free to choose any
+numbers for your IDs anyway. So why not do exactly this? There is still the
+technical issue. If you choose IDs which are already in use by somebody else,
+operating systems will load the wrong drivers and your device won't work.
+Even if you choose IDs which are not currently in use, they may be in use in
+the next version of the operating system or even after an automatic update.
+
+So what you need is a pair of Vendor- and Product-IDs for which you have the
+guarantee that no USB compliant product uses them. This implies that no
+operating system will ever ship with drivers responsible for these IDs.
+
+
+==============================================
+HOW DOES OBJECTIVE DEVELOPMENT HANDLE USB IDs?
+==============================================
+
+Objective Development gives away pairs of USB-IDs with their V-USB licenses.
+In order to ensure that these IDs are unique, Objective Development has an
+agreement with the company/person who has bought the USB Vendor-ID from
+usb.org. This agreement ensures that a range of USB Product-IDs is reserved
+for assignment by Objective Development and that the owner of the Vendor-ID
+won't give it to anybody else.
+
+This means that you have to trust three parties to ensure uniqueness of
+your IDs:
+
+  - Objective Development, that they don't give the same PID to more than
+    one person.
+  - The owner of the Vendor-ID that they don't assign PIDs from the range
+    assigned to Objective Development to anybody else.
+  - Usb.org that they don't assign the same Vendor-ID a second time.
+
+
+==================================
+WHO IS THE OWNER OF THE VENDOR-ID?
+==================================
+
+Objective Development has obtained ranges of USB Product-IDs under two
+Vendor-IDs: Under Vendor-ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under Vendor-ID 8352 from Jason
+Kotzin (now flirc.tv, Inc.). Both VID owners have received their Vendor-ID
+directly from usb.org.
+
+
+=========================================================================
+CAN I USE USB-IDs FROM OBJECTIVE DEVELOPMENT WITH OTHER DRIVERS/HARDWARE?
+=========================================================================
+
+The short answer is: Yes. All you get is a guarantee that the IDs are never
+assigned to anybody else. What more do you need?
+
+
+============================
+WHAT ABOUT SHARED ID PAIRS?
+============================
+
+Objective Development has reserved some PID/VID pairs for shared use. You
+have no guarantee of uniqueness for them, except that no USB compliant device
+uses them. In order to avoid technical problems, we must ensure that all
+devices with the same pair of IDs use the same driver on kernel level. For
+details, see the file USB-IDs-for-free.txt.
+
+
+======================================================
+I HAVE HEARD THAT SUB-LICENSING OF USB-IDs IS ILLEGAL?
+======================================================
+
+A 16 bit integer number cannot be protected by copyright laws. It is not
+sufficiently complex. And since none of the parties involved entered into the
+USB-IF Trademark License Agreement, we are not bound by this agreement. So
+there is no reason why it should be illegal to sub-license USB-IDs.
+
+
+=============================================
+WHO IS LIABLE IF THERE ARE INCOMPATIBILITIES?
+=============================================
+
+Objective Development disclaims all liabilities which might arise from the
+assignment of IDs. If you guarantee product features to your customers
+without proper disclaimer, YOU are liable for that.
Index: vusb-20121206/usbdrv/USB-IDs-for-free.txt
===================================================================
--- vusb-20121206/usbdrv/USB-IDs-for-free.txt	(nonexistent)
+++ vusb-20121206/usbdrv/USB-IDs-for-free.txt	(working copy)
@@ -0,0 +1,154 @@
+Version 2009-08-22
+
+===========================
+FREE USB-IDs FOR SHARED USE
+===========================
+
+Objective Development has reserved a set of USB Product-IDs for use according
+to the guidelines outlined below. For more information about the concept of
+USB IDs please see the file USB-ID-FAQ.txt. Objective Development guarantees
+that the IDs listed below are not used by any USB compliant devices.
+
+
+====================
+MECHANISM OF SHARING
+====================
+
+From a technical point of view, two different devices can share the same USB
+Vendor- and Product-ID if they require the same driver on operating system
+level. We make use of this fact by assigning separate IDs for various device
+classes. On application layer, devices must be distinguished by their textual
+name or serial number. We offer separate sets of IDs for discrimination by
+textual name and for serial number.
+
+Examples for shared use of USB IDs are included with V-USB in the "examples"
+subdirectory.
+
+
+======================================
+IDs FOR DISCRIMINATION BY TEXTUAL NAME
+======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the manufacturer
+and product identification. The manufacturer identification MUST be available
+at least in USB language 0x0409 (English/US).
+
+(2) The textual manufacturer identification MUST contain either an Internet
+domain name (e.g. "mycompany.com") registered and owned by you, or an e-mail
+address under your control (e.g. "myname@gmx.net"). You can embed the domain
+name or e-mail address in any string you like, e.g.  "Objective Development
+http://www.obdev.at/vusb/".
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(4) You may choose any string for the textual product identification, as long
+as this string is unique within the scope of your textual manufacturer
+identification.
+
+(5) Application side device look-up MUST be based on the textual manufacturer
+and product identification in addition to VID/PID matching. The driver
+matching MUST be a comparison of the entire strings, NOT a sub-string match.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+Table if IDs for discrimination by textual name:
+
+PID dec (hex) | VID dec (hex) | Description of use
+==============+===============+============================================
+1500 (0x05dc) | 5824 (0x16c0) | For Vendor Class devices with libusb
+--------------+---------------+--------------------------------------------
+1503 (0x05df) | 5824 (0x16c0) | For generic HID class devices (which are
+              |               | NOT mice, keyboards or joysticks)
+--------------+---------------+--------------------------------------------
+1505 (0x05e1) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+--------------+---------------+--------------------------------------------
+1508 (0x05e4) | 5824 (0x16c0) | For MIDI class devices
+--------------+---------------+--------------------------------------------
+
+Note that Windows caches the textual product- and vendor-description for
+mice, keyboards and joysticks. Name-bsed discrimination is therefore not
+recommended for these device classes.
+
+
+=======================================
+IDs FOR DISCRIMINATION BY SERIAL NUMBER
+=======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the serial
+number, unless ONLY the operating system's default class driver is used.
+The serial number string MUST be available at least in USB language 0x0409
+(English/US).
+
+(2) The serial number MUST start with either an Internet domain name (e.g.
+"mycompany.com") registered and owned by you, or an e-mail address under your
+control (e.g. "myname@gmx.net"), both terminated with a colon (":") character.
+You MAY append any string you like for further discrimination of your devices.
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(5) Application side device look-up MUST be based on the serial number string
+in addition to VID/PID matching. The matching must start at the first
+character of the serial number string and include the colon character
+terminating your domain or e-mail address. It MAY stop anywhere after that.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+(7) If ONLY the operating system's default class driver is used, e.g. for
+mice, keyboards, joysticks, CDC or MIDI devices and no discrimination by an
+application is needed, the serial number may be omitted.
+
+
+Table if IDs for discrimination by serial number string:
+
+PID dec (hex)  | VID dec (hex) | Description of use
+===============+===============+===========================================
+10200 (0x27d8) | 5824 (0x16c0) | For Vendor Class devices with libusb
+---------------+---------------+-------------------------------------------
+10201 (0x27d9) | 5824 (0x16c0) | For generic HID class devices (which are
+               |               | NOT mice, keyboards or joysticks)
+---------------+---------------+-------------------------------------------
+10202 (0x27da) | 5824 (0x16c0) | For USB Mice
+---------------+---------------+-------------------------------------------
+10203 (0x27db) | 5824 (0x16c0) | For USB Keyboards
+---------------+---------------+-------------------------------------------
+10204 (0x27dc) | 5824 (0x16c0) | For USB Joysticks
+---------------+---------------+-------------------------------------------
+10205 (0x27dd) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+---------------+---------------+-------------------------------------------
+10206 (0x27de) | 5824 (0x16c0) | For MIDI class devices
+---------------+---------------+-------------------------------------------
+
+
+=================
+ORIGIN OF USB-IDs
+=================
+
+OBJECTIVE DEVELOPMENT Software GmbH has obtained all VID/PID pairs listed
+here from Wouter van Ooijen (see www.voti.nl) for exclusive disposition.
+Wouter van Ooijen has obtained the VID from the USB Implementers Forum, Inc.
+(see www.usb.org). The VID is registered for the company name "Van Ooijen
+Technische Informatica".
+
+
+==========
+DISCLAIMER
+==========
+
+OBJECTIVE DEVELOPMENT Software GmbH disclaims all liability for any
+problems which are caused by the shared use of these VID/PID pairs.
Index: vusb-20121206/usbdrv/asmcommon.inc
===================================================================
--- vusb-20121206/usbdrv/asmcommon.inc	(nonexistent)
+++ vusb-20121206/usbdrv/asmcommon.inc	(working copy)
@@ -0,0 +1,187 @@
+/* Name: asmcommon.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-11-05
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file contains assembler code which is shared among the USB driver
+implementations for different CPU cocks. Since the code must be inserted
+in the middle of the module, it's split out into this file and #included.
+
+Jump destinations called from outside:
+    sofError: Called when no start sequence was found.
+    se0: Called when a package has been successfully received.
+    overflow: Called when receive buffer overflows.
+    doReturn: Called after sending data.
+
+Outside jump destinations used by this module:
+    waitForJ: Called to receive an already arriving packet.
+    sendAckAndReti:
+    sendNakAndReti:
+    sendCntAndReti:
+    usbSendAndReti:
+
+The following macros must be defined before this file is included:
+    .macro POP_STANDARD
+    .endm
+    .macro POP_RETI
+    .endm
+*/
+
+#define token   x1
+
+overflow:
+    ldi     x2, 1<<USB_INTR_PENDING_BIT
+    USB_STORE_PENDING(x2)       ; clear any pending interrupts
+ignorePacket:
+    clr     token
+    rjmp    storeTokenAndReturn
+
+;----------------------------------------------------------------------------
+; Processing of received packet (numbers in brackets are cycles after center of SE0)
+;----------------------------------------------------------------------------
+;This is the only non-error exit point for the software receiver loop
+;we don't check any CRCs here because there is no time left.
+se0:
+    subi    cnt, USB_BUFSIZE    ;[5]
+    neg     cnt                 ;[6]
+    sub     YL, cnt             ;[7]
+    sbci    YH, 0               ;[8]
+    ldi     x2, 1<<USB_INTR_PENDING_BIT ;[9]
+    USB_STORE_PENDING(x2)       ;[10] clear pending intr and check flag later. SE0 should be over.
+    ld      token, y            ;[11]
+    cpi     token, USBPID_DATA0 ;[13]
+    breq    handleData          ;[14]
+    cpi     token, USBPID_DATA1 ;[15]
+    breq    handleData          ;[16]
+    lds     shift, usbDeviceAddr;[17]
+    ldd     x2, y+1             ;[19] ADDR and 1 bit endpoint number
+    lsl     x2                  ;[21] shift out 1 bit endpoint number
+    cpse    x2, shift           ;[22]
+    rjmp    ignorePacket        ;[23]
+/* only compute endpoint number in x3 if required later */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT || USB_CFG_IMPLEMENT_FN_WRITEOUT
+    ldd     x3, y+2             ;[24] endpoint number + crc
+    rol     x3                  ;[26] shift in LSB of endpoint
+#endif
+    cpi     token, USBPID_IN    ;[27]
+    breq    handleIn            ;[28]
+    cpi     token, USBPID_SETUP ;[29]
+    breq    handleSetupOrOut    ;[30]
+    cpi     token, USBPID_OUT   ;[31]
+    brne    ignorePacket        ;[32] must be ack, nak or whatever
+;   rjmp    handleSetupOrOut    ; fallthrough
+
+;Setup and Out are followed by a data packet two bit times (16 cycles) after
+;the end of SE0. The sync code allows up to 40 cycles delay from the start of
+;the sync pattern until the first bit is sampled. That's a total of 56 cycles.
+handleSetupOrOut:               ;[32]
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT   /* if we have data for endpoint != 0, set usbCurrentTok to address */
+    andi    x3, 0xf             ;[32]
+    breq    storeTokenAndReturn ;[33]
+    mov     token, x3           ;[34] indicate that this is endpoint x OUT
+#endif
+storeTokenAndReturn:
+    sts     usbCurrentTok, token;[35]
+doReturn:
+    POP_STANDARD                ;[37] 12...16 cycles
+    USB_LOAD_PENDING(YL)        ;[49]
+    sbrc    YL, USB_INTR_PENDING_BIT;[50] check whether data is already arriving
+    rjmp    waitForJ            ;[51] save the pops and pushes -- a new interrupt is already pending
+sofError:
+    POP_RETI                    ;macro call
+    reti
+
+handleData:
+#if USB_CFG_CHECK_CRC
+    CRC_CLEANUP_AND_CHECK       ; jumps to ignorePacket if CRC error
+#endif
+    lds     shift, usbCurrentTok;[18]
+    tst     shift               ;[20]
+    breq    doReturn            ;[21]
+    lds     x2, usbRxLen        ;[22]
+    tst     x2                  ;[24]
+    brne    sendNakAndReti      ;[25]
+; 2006-03-11: The following two lines fix a problem where the device was not
+; recognized if usbPoll() was called less frequently than once every 4 ms.
+    cpi     cnt, 4              ;[26] zero sized data packets are status phase only -- ignore and ack
+    brmi    sendAckAndReti      ;[27] keep rx buffer clean -- we must not NAK next SETUP
+#if USB_CFG_CHECK_DATA_TOGGLING
+    sts     usbCurrentDataToken, token  ; store for checking by C code
+#endif
+    sts     usbRxLen, cnt       ;[28] store received data, swap buffers
+    sts     usbRxToken, shift   ;[30]
+    lds     x2, usbInputBufOffset;[32] swap buffers
+    ldi     cnt, USB_BUFSIZE    ;[34]
+    sub     cnt, x2             ;[35]
+    sts     usbInputBufOffset, cnt;[36] buffers now swapped
+    rjmp    sendAckAndReti      ;[38] 40 + 17 = 57 until SOP
+
+handleIn:
+;We don't send any data as long as the C code has not processed the current
+;input data and potentially updated the output data. That's more efficient
+;in terms of code size than clearing the tx buffers when a packet is received.
+    lds     x1, usbRxLen        ;[30]
+    cpi     x1, 1               ;[32] negative values are flow control, 0 means "buffer free"
+    brge    sendNakAndReti      ;[33] unprocessed input packet?
+    ldi     x1, USBPID_NAK      ;[34] prepare value for usbTxLen
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+    andi    x3, 0xf             ;[35] x3 contains endpoint
+#if USB_CFG_SUPPRESS_INTR_CODE
+    brne    sendNakAndReti      ;[36]
+#else
+    brne    handleIn1           ;[36]
+#endif
+#endif
+    lds     cnt, usbTxLen       ;[37]
+    sbrc    cnt, 4              ;[39] all handshake tokens have bit 4 set
+    rjmp    sendCntAndReti      ;[40] 42 + 16 = 58 until SOP
+    sts     usbTxLen, x1        ;[41] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf)   ;[43]
+    ldi     YH, hi8(usbTxBuf)   ;[44]
+    rjmp    usbSendAndReti      ;[45] 57 + 12 = 59 until SOP
+
+; Comment about when to set usbTxLen to USBPID_NAK:
+; We should set it back when we receive the ACK from the host. This would
+; be simple to implement: One static variable which stores whether the last
+; tx was for endpoint 0 or 1 and a compare in the receiver to distinguish the
+; ACK. However, we set it back immediately when we send the package,
+; assuming that no error occurs and the host sends an ACK. We save one byte
+; RAM this way and avoid potential problems with endless retries. The rest of
+; the driver assumes error-free transfers anyway.
+
+#if !USB_CFG_SUPPRESS_INTR_CODE && USB_CFG_HAVE_INTRIN_ENDPOINT /* placed here due to relative jump range */
+handleIn1:                      ;[38]
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+; 2006-06-10 as suggested by O.Tamura: support second INTR IN / BULK IN endpoint
+    cpi     x3, USB_CFG_EP3_NUMBER;[38]
+    breq    handleIn3           ;[39]
+#endif
+    lds     cnt, usbTxLen1      ;[40]
+    sbrc    cnt, 4              ;[42] all handshake tokens have bit 4 set
+    rjmp    sendCntAndReti      ;[43] 47 + 16 = 63 until SOP
+    sts     usbTxLen1, x1       ;[44] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf1)  ;[46]
+    ldi     YH, hi8(usbTxBuf1)  ;[47]
+    rjmp    usbSendAndReti      ;[48] 50 + 12 = 62 until SOP
+
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+handleIn3:
+    lds     cnt, usbTxLen3      ;[41]
+    sbrc    cnt, 4              ;[43]
+    rjmp    sendCntAndReti      ;[44] 49 + 16 = 65 until SOP
+    sts     usbTxLen3, x1       ;[45] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf3)  ;[47]
+    ldi     YH, hi8(usbTxBuf3)  ;[48]
+    rjmp    usbSendAndReti      ;[49] 51 + 12 = 63 until SOP
+#endif
+#endif
Index: vusb-20121206/usbdrv/oddebug.c
===================================================================
--- vusb-20121206/usbdrv/oddebug.c	(nonexistent)
+++ vusb-20121206/usbdrv/oddebug.c	(working copy)
@@ -0,0 +1,49 @@
+/* Name: oddebug.c
+ * Project: AVR library
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-01-16
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include "oddebug.h"
+
+#if DEBUG_LEVEL > 0
+
+#warning "Never compile production devices with debugging enabled"
+
+static void uartPutc(char c)
+{
+    while(!(ODDBG_USR & (1 << ODDBG_UDRE)));    /* wait for data register empty */
+    ODDBG_UDR = c;
+}
+
+static uchar    hexAscii(uchar h)
+{
+    h &= 0xf;
+    if(h >= 10)
+        h += 'a' - (uchar)10 - '0';
+    h += '0';
+    return h;
+}
+
+static void printHex(uchar c)
+{
+    uartPutc(hexAscii(c >> 4));
+    uartPutc(hexAscii(c));
+}
+
+void    odDebug(uchar prefix, uchar *data, uchar len)
+{
+    printHex(prefix);
+    uartPutc(':');
+    while(len--){
+        uartPutc(' ');
+        printHex(*data++);
+    }
+    uartPutc('\r');
+    uartPutc('\n');
+}
+
+#endif
Index: vusb-20121206/usbdrv/oddebug.h
===================================================================
--- vusb-20121206/usbdrv/oddebug.h	(nonexistent)
+++ vusb-20121206/usbdrv/oddebug.h	(working copy)
@@ -0,0 +1,122 @@
+/* Name: oddebug.h
+ * Project: AVR library
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-01-16
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __oddebug_h_included__
+#define __oddebug_h_included__
+
+/*
+General Description:
+This module implements a function for debug logs on the serial line of the
+AVR microcontroller. Debugging can be configured with the define
+'DEBUG_LEVEL'. If this macro is not defined or defined to 0, all debugging
+calls are no-ops. If it is 1, DBG1 logs will appear, but not DBG2. If it is
+2, DBG1 and DBG2 logs will be printed.
+
+A debug log consists of a label ('prefix') to indicate which debug log created
+the output and a memory block to dump in hex ('data' and 'len').
+*/
+
+
+#ifndef F_CPU
+#   define  F_CPU   12000000    /* 12 MHz */
+#endif
+
+/* make sure we have the UART defines: */
+#include "usbportability.h"
+
+#ifndef uchar
+#   define  uchar   unsigned char
+#endif
+
+#if DEBUG_LEVEL > 0 && !(defined TXEN || defined TXEN0) /* no UART in device */
+#   warning "Debugging disabled because device has no UART"
+#   undef   DEBUG_LEVEL
+#endif
+
+#ifndef DEBUG_LEVEL
+#   define  DEBUG_LEVEL 0
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#if DEBUG_LEVEL > 0
+#   define  DBG1(prefix, data, len) odDebug(prefix, data, len)
+#else
+#   define  DBG1(prefix, data, len)
+#endif
+
+#if DEBUG_LEVEL > 1
+#   define  DBG2(prefix, data, len) odDebug(prefix, data, len)
+#else
+#   define  DBG2(prefix, data, len)
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#if DEBUG_LEVEL > 0
+extern void odDebug(uchar prefix, uchar *data, uchar len);
+
+/* Try to find our control registers; ATMEL likes to rename these */
+
+#if defined UBRR
+#   define  ODDBG_UBRR  UBRR
+#elif defined UBRRL
+#   define  ODDBG_UBRR  UBRRL
+#elif defined UBRR0
+#   define  ODDBG_UBRR  UBRR0
+#elif defined UBRR0L
+#   define  ODDBG_UBRR  UBRR0L
+#endif
+
+#if defined UCR
+#   define  ODDBG_UCR   UCR
+#elif defined UCSRB
+#   define  ODDBG_UCR   UCSRB
+#elif defined UCSR0B
+#   define  ODDBG_UCR   UCSR0B
+#endif
+
+#if defined TXEN
+#   define  ODDBG_TXEN  TXEN
+#else
+#   define  ODDBG_TXEN  TXEN0
+#endif
+
+#if defined USR
+#   define  ODDBG_USR   USR
+#elif defined UCSRA
+#   define  ODDBG_USR   UCSRA
+#elif defined UCSR0A
+#   define  ODDBG_USR   UCSR0A
+#endif
+
+#if defined UDRE
+#   define  ODDBG_UDRE  UDRE
+#else
+#   define  ODDBG_UDRE  UDRE0
+#endif
+
+#if defined UDR
+#   define  ODDBG_UDR   UDR
+#elif defined UDR0
+#   define  ODDBG_UDR   UDR0
+#endif
+
+static inline void  odDebugInit(void)
+{
+    ODDBG_UCR |= (1<<ODDBG_TXEN);
+    ODDBG_UBRR = F_CPU / (19200 * 16L) - 1;
+}
+#else
+#   define odDebugInit()
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#endif /* __oddebug_h_included__ */
Index: vusb-20121206/usbdrv/usbconfig-prototype.h
===================================================================
--- vusb-20121206/usbdrv/usbconfig-prototype.h	(nonexistent)
+++ vusb-20121206/usbdrv/usbconfig-prototype.h	(working copy)
@@ -0,0 +1,384 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
++ To create your own usbconfig.h file, copy this file to your project's
++ firmware source directory) and rename it to "usbconfig.h".
++ Then edit it accordingly.
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    0
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           100
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdc, 0x05 /* = 0x05dc = 1500 */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'T', 'e', 'm', 'p', 'l', 'a', 't', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 8
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/usbdrv/usbdrv.c
===================================================================
--- vusb-20121206/usbdrv/usbdrv.c	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrv.c	(working copy)
@@ -0,0 +1,628 @@
+/* Name: usbdrv.c
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include "usbdrv.h"
+#include "oddebug.h"
+
+/*
+General Description:
+This module implements the C-part of the USB driver. See usbdrv.h for a
+documentation of the entire driver.
+*/
+
+/* ------------------------------------------------------------------------- */
+
+/* raw USB registers / interface to assembler code: */
+uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
+uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
+uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
+uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
+uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but not used */
+volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow control */
+uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 0 */
+uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
+volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handshake token */
+uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains handshake token */
+#if USB_COUNT_SOF
+volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+usbTxStatus_t  usbTxStatus1;
+#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
+usbTxStatus_t  usbTxStatus3;
+#   endif
+#endif
+#if USB_CFG_CHECK_DATA_TOGGLING
+uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
+#endif
+
+/* USB status registers / not shared with asm code */
+usbMsgPtr_t         usbMsgPtr;      /* data to transmit next -- ROM or RAM address */
+static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
+static uchar        usbMsgFlags;    /* flag values see below */
+
+#define USB_FLG_MSGPTR_IS_ROM   (1<<6)
+#define USB_FLG_USE_USER_RW     (1<<7)
+
+/*
+optimizing hints:
+- do not post/pre inc/dec integer values in operations
+- assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
+- use narrow scope for variables which should be in X/Y/Z register
+- assign char sized expressions to variables to force 8 bit arithmetics
+*/
+
+/* -------------------------- String Descriptors --------------------------- */
+
+#if USB_CFG_DESCR_PROPS_STRINGS == 0
+
+#if USB_CFG_DESCR_PROPS_STRING_0 == 0
+#undef USB_CFG_DESCR_PROPS_STRING_0
+#define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
+PROGMEM const char usbDescriptorString0[] = { /* language descriptor */
+    4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
+    3,          /* descriptor type */
+    0x09, 0x04, /* language index (0x0409 = US-English) */
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_VENDOR
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
+PROGMEM const int  usbDescriptorStringVendor[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
+    USB_CFG_VENDOR_NAME
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
+PROGMEM const int  usbDescriptorStringDevice[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
+    USB_CFG_DEVICE_NAME
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
+PROGMEM const int usbDescriptorStringSerialNumber[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
+    USB_CFG_SERIAL_NUMBER
+};
+#endif
+
+#endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
+
+/* --------------------------- Device Descriptor --------------------------- */
+
+#if USB_CFG_DESCR_PROPS_DEVICE == 0
+#undef USB_CFG_DESCR_PROPS_DEVICE
+#define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
+PROGMEM const char usbDescriptorDevice[] = {    /* USB device descriptor */
+    18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
+    USBDESCR_DEVICE,        /* descriptor type */
+    0x10, 0x01,             /* USB version supported */
+    USB_CFG_DEVICE_CLASS,
+    USB_CFG_DEVICE_SUBCLASS,
+    0,                      /* protocol */
+    8,                      /* max packet size */
+    /* the following two casts affect the first byte of the constant only, but
+     * that's sufficient to avoid a warning with the default values.
+     */
+    (char)USB_CFG_VENDOR_ID,/* 2 bytes */
+    (char)USB_CFG_DEVICE_ID,/* 2 bytes */
+    USB_CFG_DEVICE_VERSION, /* 2 bytes */
+    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
+    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
+    1,          /* number of configurations */
+};
+#endif
+
+/* ----------------------- Configuration Descriptor ------------------------ */
+
+#if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
+#undef USB_CFG_DESCR_PROPS_HID
+#define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
+#endif
+
+#if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
+#undef USB_CFG_DESCR_PROPS_CONFIGURATION
+#define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
+PROGMEM const char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
+    9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
+    USBDESCR_CONFIG,    /* descriptor type */
+    18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
+                (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
+                /* total length of data returned (including inlined descriptors) */
+    1,          /* number of interfaces in this configuration */
+    1,          /* index of this configuration */
+    0,          /* configuration name string index */
+#if USB_CFG_IS_SELF_POWERED
+    (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
+#else
+    (1 << 7),                           /* attributes */
+#endif
+    USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
+/* interface descriptor follows inline: */
+    9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
+    USBDESCR_INTERFACE, /* descriptor type */
+    0,          /* index of this interface */
+    0,          /* alternate setting for this interface */
+    USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of endpoint descriptors to follow */
+    USB_CFG_INTERFACE_CLASS,
+    USB_CFG_INTERFACE_SUBCLASS,
+    USB_CFG_INTERFACE_PROTOCOL,
+    0,          /* string index for interface */
+#if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
+    9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
+    USBDESCR_HID,   /* descriptor type: HID */
+    0x01, 0x01, /* BCD representation of HID version */
+    0x00,       /* target country code */
+    0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
+    0x22,       /* descriptor type: report */
+    USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)0x81, /* IN endpoint number 1 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+};
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+static inline void  usbResetDataToggling(void)
+{
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
+#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
+    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
+#   endif
+#endif
+}
+
+static inline void  usbResetStall(void)
+{
+#if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
+        usbTxLen1 = USBPID_NAK;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+        usbTxLen3 = USBPID_NAK;
+#endif
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+#if !USB_CFG_SUPPRESS_INTR_CODE
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
+{
+uchar   *p;
+char    i;
+
+#if USB_CFG_IMPLEMENT_HALT
+    if(usbTxLen1 == USBPID_STALL)
+        return;
+#endif
+    if(txStatus->len & 0x10){   /* packet buffer was empty */
+        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
+    }else{
+        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
+    }
+    p = txStatus->buffer + 1;
+    i = len;
+    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
+        *p++ = *data++;
+    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
+    usbCrc16Append(&txStatus->buffer[1], len);
+    txStatus->len = len + 4;    /* len must be given including sync byte */
+    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
+}
+
+USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
+{
+    usbGenericSetInterrupt(data, len, &usbTxStatus1);
+}
+#endif
+
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
+{
+    usbGenericSetInterrupt(data, len, &usbTxStatus3);
+}
+#endif
+#endif /* USB_CFG_SUPPRESS_INTR_CODE */
+
+/* ------------------ utilities for code following below ------------------- */
+
+/* Use defines for the switch statement so that we can choose between an
+ * if()else if() and a switch/case based implementation. switch() is more
+ * efficient for a LARGE set of sequential choices, if() is better in all other
+ * cases.
+ */
+#if USB_CFG_USE_SWITCH_STATEMENT
+#   define SWITCH_START(cmd)       switch(cmd){{
+#   define SWITCH_CASE(value)      }break; case (value):{
+#   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
+#   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
+#   define SWITCH_DEFAULT          }break; default:{
+#   define SWITCH_END              }}
+#else
+#   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
+#   define SWITCH_CASE(value)      }else if(_cmd == (value)){
+#   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
+#   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
+#   define SWITCH_DEFAULT          }else{
+#   define SWITCH_END              }}
+#endif
+
+#ifndef USB_RX_USER_HOOK
+#define USB_RX_USER_HOOK(data, len)
+#endif
+#ifndef USB_SET_ADDRESS_HOOK
+#define USB_SET_ADDRESS_HOOK()
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+/* We use if() instead of #if in the macro below because #if can't be used
+ * in macros and the compiler optimizes constant conditions anyway.
+ * This may cause problems with undefined symbols if compiled without
+ * optimizing!
+ */
+#define GET_DESCRIPTOR(cfgProp, staticName)         \
+    if(cfgProp){                                    \
+        if((cfgProp) & USB_PROP_IS_RAM)             \
+            flags = 0;                              \
+        if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
+            len = usbFunctionDescriptor(rq);        \
+        }else{                                      \
+            len = USB_PROP_LENGTH(cfgProp);         \
+            usbMsgPtr = (usbMsgPtr_t)(staticName);  \
+        }                                           \
+    }
+
+/* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
+ * internally for all types of descriptors.
+ */
+static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
+{
+usbMsgLen_t len = 0;
+uchar       flags = USB_FLG_MSGPTR_IS_ROM;
+
+    SWITCH_START(rq->wValue.bytes[1])
+    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
+    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
+    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
+#if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
+        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
+            flags = 0;
+        len = usbFunctionDescriptor(rq);
+#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
+        SWITCH_START(rq->wValue.bytes[0])
+        SWITCH_CASE(0)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
+        SWITCH_CASE(1)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
+        SWITCH_CASE(2)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
+        SWITCH_CASE(3)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumber)
+        SWITCH_DEFAULT
+            if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
+                len = usbFunctionDescriptor(rq);
+            }
+        SWITCH_END
+#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
+#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
+    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
+    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
+#endif
+    SWITCH_DEFAULT
+        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
+            len = usbFunctionDescriptor(rq);
+        }
+    SWITCH_END
+    usbMsgFlags = flags;
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
+ * standard requests instead of class and custom requests.
+ */
+static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
+{
+usbMsgLen_t len = 0;
+uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
+uchar   value = rq->wValue.bytes[0];
+#if USB_CFG_IMPLEMENT_HALT
+uchar   index = rq->wIndex.bytes[0];
+#endif
+
+    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
+    SWITCH_START(rq->bRequest)
+    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
+        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */
+        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
+            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
+#if USB_CFG_IMPLEMENT_HALT
+        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
+            dataPtr[0] = usbTxLen1 == USBPID_STALL;
+#endif
+        dataPtr[1] = 0;
+        len = 2;
+#if USB_CFG_IMPLEMENT_HALT
+    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
+        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
+            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
+            usbResetDataToggling();
+        }
+#endif
+    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
+        usbNewDeviceAddr = value;
+        USB_SET_ADDRESS_HOOK();
+    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
+        len = usbDriverDescriptor(rq);
+        goto skipMsgPtrAssignment;
+    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
+        dataPtr = &usbConfiguration;  /* send current configuration value */
+        len = 1;
+    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
+        usbConfiguration = value;
+        usbResetStall();
+    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
+        len = 1;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
+        usbResetDataToggling();
+        usbResetStall();
+#endif
+    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
+        /* Should we add an optional hook here? */
+    SWITCH_END
+    usbMsgPtr = (usbMsgPtr_t)dataPtr;
+skipMsgPtrAssignment:
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbProcessRx() is called for every message received by the interrupt
+ * routine. It distinguishes between SETUP and DATA packets and processes
+ * them accordingly.
+ */
+static inline void usbProcessRx(uchar *data, uchar len)
+{
+usbRequest_t    *rq = (void *)data;
+
+/* usbRxToken can be:
+ * 0x2d 00101101 (USBPID_SETUP for setup data)
+ * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
+ * 0...0x0f for OUT on endpoint X
+ */
+    DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
+    USB_RX_USER_HOOK(data, len)
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
+        usbFunctionWriteOut(data, len);
+        return;
+    }
+#endif
+    if(usbRxToken == (uchar)USBPID_SETUP){
+        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
+            return;
+        usbMsgLen_t replyLen;
+        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
+        usbTxLen = USBPID_NAK;              /* abort pending transmit */
+        usbMsgFlags = 0;
+        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
+        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
+            replyLen = usbFunctionSetup(data);
+        }else{
+            replyLen = usbDriverSetup(rq);
+        }
+#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
+        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
+            /* do some conditioning on replyLen, but on IN transfers only */
+            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
+                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
+                    replyLen = rq->wLength.bytes[0];
+                }else{
+                    replyLen = rq->wLength.word;
+                }
+            }
+            usbMsgFlags = USB_FLG_USE_USER_RW;
+        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
+#endif
+        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
+            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
+                replyLen = rq->wLength.bytes[0];
+        }else{
+            if(replyLen > rq->wLength.word)     /* limit length to max */
+                replyLen = rq->wLength.word;
+        }
+        usbMsgLen = replyLen;
+    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
+#if USB_CFG_IMPLEMENT_FN_WRITE
+        if(usbMsgFlags & USB_FLG_USE_USER_RW){
+            uchar rval = usbFunctionWrite(data, len);
+            if(rval == 0xff){   /* an error occurred */
+                usbTxLen = USBPID_STALL;
+            }else if(rval != 0){    /* This was the final package */
+                usbMsgLen = 0;  /* answer with a zero-sized data packet */
+            }
+        }
+#endif
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* This function is similar to usbFunctionRead(), but it's also called for
+ * data handled automatically by the driver (e.g. descriptor reads).
+ */
+static uchar usbDeviceRead(uchar *data, uchar len)
+{
+    if(len > 0){    /* don't bother app with 0 sized reads */
+#if USB_CFG_IMPLEMENT_FN_READ
+        if(usbMsgFlags & USB_FLG_USE_USER_RW){
+            len = usbFunctionRead(data, len);
+        }else
+#endif
+        {
+            uchar i = len;
+            usbMsgPtr_t r = usbMsgPtr;
+            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
+                do{
+                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
+                    *data++ = c;
+                    r++;
+                }while(--i);
+            }else{  /* RAM data */
+                do{
+                    *data++ = *((uchar *)r);
+                    r++;
+                }while(--i);
+            }
+            usbMsgPtr = r;
+        }
+    }
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbBuildTxBlock() is called when we have data to transmit and the
+ * interrupt routine's transmit buffer is empty.
+ */
+static inline void usbBuildTxBlock(void)
+{
+usbMsgLen_t wantLen;
+uchar       len;
+
+    wantLen = usbMsgLen;
+    if(wantLen > 8)
+        wantLen = 8;
+    usbMsgLen -= wantLen;
+    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
+    len = usbDeviceRead(usbTxBuf + 1, wantLen);
+    if(len <= 8){           /* valid data packet */
+        usbCrc16Append(&usbTxBuf[1], len);
+        len += 4;           /* length including sync byte */
+        if(len < 12)        /* a partial package identifies end of message */
+            usbMsgLen = USB_NO_MSG;
+    }else{
+        len = USBPID_STALL;   /* stall the endpoint */
+        usbMsgLen = USB_NO_MSG;
+    }
+    usbTxLen = len;
+    DBG2(0x20, usbTxBuf, len-1);
+}
+
+/* ------------------------------------------------------------------------- */
+
+static inline void usbHandleResetHook(uchar notResetState)
+{
+#ifdef USB_RESET_HOOK
+static uchar    wasReset;
+uchar           isReset = !notResetState;
+
+    if(wasReset != isReset){
+        USB_RESET_HOOK(isReset);
+        wasReset = isReset;
+    }
+#else
+    notResetState = notResetState;  // avoid compiler warning
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+USB_PUBLIC void usbPoll(void)
+{
+schar   len;
+uchar   i;
+
+    len = usbRxLen - 3;
+    if(len >= 0){
+/* We could check CRC16 here -- but ACK has already been sent anyway. If you
+ * need data integrity checks with this driver, check the CRC in your app
+ * code and report errors back to the host. Since the ACK was already sent,
+ * retries must be handled on application level.
+ * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
+ */
+        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
+#if USB_CFG_HAVE_FLOWCONTROL
+        if(usbRxLen > 0)    /* only mark as available if not inactivated */
+            usbRxLen = 0;
+#else
+        usbRxLen = 0;       /* mark rx buffer as available */
+#endif
+    }
+    if(usbTxLen & 0x10){    /* transmit system idle */
+        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
+            usbBuildTxBlock();
+        }
+    }
+    for(i = 20; i > 0; i--){
+        uchar usbLineStatus = USBIN & USBMASK;
+        if(usbLineStatus != 0)  /* SE0 has ended */
+            goto isNotReset;
+    }
+    /* RESET condition, called multiple times during reset */
+    usbNewDeviceAddr = 0;
+    usbDeviceAddr = 0;
+    usbResetStall();
+    DBG1(0xff, 0, 0);
+isNotReset:
+    usbHandleResetHook(i);
+}
+
+/* ------------------------------------------------------------------------- */
+
+USB_PUBLIC void usbInit(void)
+{
+#if USB_INTR_CFG_SET != 0
+    USB_INTR_CFG |= USB_INTR_CFG_SET;
+#endif
+#if USB_INTR_CFG_CLR != 0
+    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
+#endif
+    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
+    usbResetDataToggling();
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    usbTxLen1 = USBPID_NAK;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+    usbTxLen3 = USBPID_NAK;
+#endif
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/usbdrv/usbdrv.h
===================================================================
--- vusb-20121206/usbdrv/usbdrv.h	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrv.h	(working copy)
@@ -0,0 +1,746 @@
+/* Name: usbdrv.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbdrv_h_included__
+#define __usbdrv_h_included__
+#include "usbconfig.h"
+#include "usbportability.h"
+
+/*
+Hardware Prerequisites:
+=======================
+USB lines D+ and D- MUST be wired to the same I/O port. We recommend that D+
+triggers the interrupt (best achieved by using INT0 for D+), but it is also
+possible to trigger the interrupt from D-. If D- is used, interrupts are also
+triggered by SOF packets. D- requires a pull-up of 1.5k to +3.5V (and the
+device must be powered at 3.5V) to identify as low-speed USB device. A
+pull-down or pull-up of 1M SHOULD be connected from D+ to +3.5V to prevent
+interference when no USB master is connected. If you use Zener diodes to limit
+the voltage on D+ and D-, you MUST use a pull-down resistor, not a pull-up.
+We use D+ as interrupt source and not D- because it does not trigger on
+keep-alive and RESET states. If you want to count keep-alive events with
+USB_COUNT_SOF, you MUST use D- as an interrupt source.
+
+As a compile time option, the 1.5k pull-up resistor on D- can be made
+switchable to allow the device to disconnect at will. See the definition of
+usbDeviceConnect() and usbDeviceDisconnect() further down in this file.
+
+Please adapt the values in usbconfig.h according to your hardware!
+
+The device MUST be clocked at exactly 12 MHz, 15 MHz, 16 MHz or 20 MHz
+or at 12.8 MHz resp. 16.5 MHz +/- 1%. See usbconfig-prototype.h for details.
+
+
+Limitations:
+============
+Robustness with respect to communication errors:
+The driver assumes error-free communication. It DOES check for errors in
+the PID, but does NOT check bit stuffing errors, SE0 in middle of a byte,
+token CRC (5 bit) and data CRC (16 bit). CRC checks can not be performed due
+to timing constraints: We must start sending a reply within 7 bit times.
+Bit stuffing and misplaced SE0 would have to be checked in real-time, but CPU
+performance does not permit that. The driver does not check Data0/Data1
+toggling, but application software can implement the check.
+
+Input characteristics:
+Since no differential receiver circuit is used, electrical interference
+robustness may suffer. The driver samples only one of the data lines with
+an ordinary I/O pin's input characteristics. However, since this is only a
+low speed USB implementation and the specification allows for 8 times the
+bit rate over the same hardware, we should be on the safe side. Even the spec
+requires detection of asymmetric states at high bit rate for SE0 detection.
+
+Number of endpoints:
+The driver supports the following endpoints:
+
+- Endpoint 0, the default control endpoint.
+- Any number of interrupt- or bulk-out endpoints. The data is sent to
+  usbFunctionWriteOut() and USB_CFG_IMPLEMENT_FN_WRITEOUT must be defined
+  to 1 to activate this feature. The endpoint number can be found in the
+  global variable 'usbRxToken'.
+- One default interrupt- or bulk-in endpoint. This endpoint is used for
+  interrupt- or bulk-in transfers which are not handled by any other endpoint.
+  You must define USB_CFG_HAVE_INTRIN_ENDPOINT in order to activate this
+  feature and call usbSetInterrupt() to send interrupt/bulk data.
+- One additional interrupt- or bulk-in endpoint. This was endpoint 3 in
+  previous versions of this driver but can now be configured to any endpoint
+  number. You must define USB_CFG_HAVE_INTRIN_ENDPOINT3 in order to activate
+  this feature and call usbSetInterrupt3() to send interrupt/bulk data. The
+  endpoint number can be set with USB_CFG_EP3_NUMBER.
+
+Please note that the USB standard forbids bulk endpoints for low speed devices!
+Most operating systems allow them anyway, but the AVR will spend 90% of the CPU
+time in the USB interrupt polling for bulk data.
+
+Maximum data payload:
+Data payload of control in and out transfers may be up to 254 bytes. In order
+to accept payload data of out transfers, you need to implement
+'usbFunctionWrite()'.
+
+USB Suspend Mode supply current:
+The USB standard limits power consumption to 500uA when the bus is in suspend
+mode. This is not a problem for self-powered devices since they don't need
+bus power anyway. Bus-powered devices can achieve this only by putting the
+CPU in sleep mode. The driver does not implement suspend handling by itself.
+However, the application may implement activity monitoring and wakeup from
+sleep. The host sends regular SE0 states on the bus to keep it active. These
+SE0 states can be detected by using D- as the interrupt source. Define
+USB_COUNT_SOF to 1 and use the global variable usbSofCount to check for bus
+activity.
+
+Operation without an USB master:
+The driver behaves neutral without connection to an USB master if D- reads
+as 1. To avoid spurious interrupts, we recommend a high impedance (e.g. 1M)
+pull-down or pull-up resistor on D+ (interrupt). If Zener diodes are used,
+use a pull-down. If D- becomes statically 0, the driver may block in the
+interrupt routine.
+
+Interrupt latency:
+The application must ensure that the USB interrupt is not disabled for more
+than 25 cycles (this is for 12 MHz, faster clocks allow longer latency).
+This implies that all interrupt routines must either have the "ISR_NOBLOCK"
+attribute set (see "avr/interrupt.h") or be written in assembler with "sei"
+as the first instruction.
+
+Maximum interrupt duration / CPU cycle consumption:
+The driver handles all USB communication during the interrupt service
+routine. The routine will not return before an entire USB message is received
+and the reply is sent. This may be up to ca. 1200 cycles @ 12 MHz (= 100us) if
+the host conforms to the standard. The driver will consume CPU cycles for all
+USB messages, even if they address another (low-speed) device on the same bus.
+
+*/
+
+/* ------------------------------------------------------------------------- */
+/* --------------------------- Module Interface ---------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#define USBDRV_VERSION  20121206
+/* This define uniquely identifies a driver version. It is a decimal number
+ * constructed from the driver's release date in the form YYYYMMDD. If the
+ * driver's behavior or interface changes, you can use this constant to
+ * distinguish versions. If it is not defined, the driver's release date is
+ * older than 2006-01-25.
+ */
+
+
+#ifndef USB_PUBLIC
+#define USB_PUBLIC
+#endif
+/* USB_PUBLIC is used as declaration attribute for all functions exported by
+ * the USB driver. The default is no attribute (see above). You may define it
+ * to static either in usbconfig.h or from the command line if you include
+ * usbdrv.c instead of linking against it. Including the C module of the driver
+ * directly in your code saves a couple of bytes in flash memory.
+ */
+
+#ifndef __ASSEMBLER__
+#ifndef uchar
+#define uchar   unsigned char
+#endif
+#ifndef schar
+#define schar   signed char
+#endif
+/* shortcuts for well defined 8 bit integer types */
+
+#if USB_CFG_LONG_TRANSFERS  /* if more than 254 bytes transfer size required */
+#   define usbMsgLen_t unsigned
+#else
+#   define usbMsgLen_t uchar
+#endif
+/* usbMsgLen_t is the data type used for transfer lengths. By default, it is
+ * defined to uchar, allowing a maximum of 254 bytes (255 is reserved for
+ * USB_NO_MSG below). If the usbconfig.h defines USB_CFG_LONG_TRANSFERS to 1,
+ * a 16 bit data type is used, allowing up to 16384 bytes (the rest is used
+ * for flags in the descriptor configuration).
+ */
+#define USB_NO_MSG  ((usbMsgLen_t)-1)   /* constant meaning "no message" */
+
+#ifndef usbMsgPtr_t
+#define usbMsgPtr_t uchar *
+#endif
+/* Making usbMsgPtr_t a define allows the user of this library to define it to
+ * an 8 bit type on tiny devices. This reduces code size, especially if the
+ * compiler supports a tiny memory model.
+ * The type can be a pointer or scalar type, casts are made where necessary.
+ * Although it's paradoxical, Gcc 4 generates slightly better code for scalar
+ * types than for pointers.
+ */
+
+struct usbRequest;  /* forward declaration */
+
+USB_PUBLIC void usbInit(void);
+/* This function must be called before interrupts are enabled and the main
+ * loop is entered. We exepct that the PORT and DDR bits for D+ and D- have
+ * not been changed from their default status (which is 0). If you have changed
+ * them, set both back to 0 (configure them as input with no internal pull-up).
+ */
+USB_PUBLIC void usbPoll(void);
+/* This function must be called at regular intervals from the main loop.
+ * Maximum delay between calls is somewhat less than 50ms (USB timeout for
+ * accepting a Setup message). Otherwise the device will not be recognized.
+ * Please note that debug outputs through the UART take ~ 0.5ms per byte
+ * at 19200 bps.
+ */
+extern usbMsgPtr_t usbMsgPtr;
+/* This variable may be used to pass transmit data to the driver from the
+ * implementation of usbFunctionWrite(). It is also used internally by the
+ * driver for standard control requests.
+ */
+USB_PUBLIC usbMsgLen_t usbFunctionSetup(uchar data[8]);
+/* This function is called when the driver receives a SETUP transaction from
+ * the host which is not answered by the driver itself (in practice: class and
+ * vendor requests). All control transfers start with a SETUP transaction where
+ * the host communicates the parameters of the following (optional) data
+ * transfer. The SETUP data is available in the 'data' parameter which can
+ * (and should) be casted to 'usbRequest_t *' for a more user-friendly access
+ * to parameters.
+ *
+ * If the SETUP indicates a control-in transfer, you should provide the
+ * requested data to the driver. There are two ways to transfer this data:
+ * (1) Set the global pointer 'usbMsgPtr' to the base of the static RAM data
+ * block and return the length of the data in 'usbFunctionSetup()'. The driver
+ * will handle the rest. Or (2) return USB_NO_MSG in 'usbFunctionSetup()'. The
+ * driver will then call 'usbFunctionRead()' when data is needed. See the
+ * documentation for usbFunctionRead() for details.
+ *
+ * If the SETUP indicates a control-out transfer, the only way to receive the
+ * data from the host is through the 'usbFunctionWrite()' call. If you
+ * implement this function, you must return USB_NO_MSG in 'usbFunctionSetup()'
+ * to indicate that 'usbFunctionWrite()' should be used. See the documentation
+ * of this function for more information. If you just want to ignore the data
+ * sent by the host, return 0 in 'usbFunctionSetup()'.
+ *
+ * Note that calls to the functions usbFunctionRead() and usbFunctionWrite()
+ * are only done if enabled by the configuration in usbconfig.h.
+ */
+USB_PUBLIC usbMsgLen_t usbFunctionDescriptor(struct usbRequest *rq);
+/* You need to implement this function ONLY if you provide USB descriptors at
+ * runtime (which is an expert feature). It is very similar to
+ * usbFunctionSetup() above, but it is called only to request USB descriptor
+ * data. See the documentation of usbFunctionSetup() above for more info.
+ */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len);
+/* This function sets the message which will be sent during the next interrupt
+ * IN transfer. The message is copied to an internal buffer and must not exceed
+ * a length of 8 bytes. The message may be 0 bytes long just to indicate the
+ * interrupt status to the host.
+ * If you need to transfer more bytes, use a control read after the interrupt.
+ */
+#define usbInterruptIsReady()   (usbTxLen1 & 0x10)
+/* This macro indicates whether the last interrupt message has already been
+ * sent. If you set a new interrupt message before the old was sent, the
+ * message already buffered will be lost.
+ */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len);
+#define usbInterruptIsReady3()   (usbTxLen3 & 0x10)
+/* Same as above for endpoint 3 */
+#endif
+#endif /* USB_CFG_HAVE_INTRIN_ENDPOINT */
+#if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    /* simplified interface for backward compatibility */
+#define usbHidReportDescriptor  usbDescriptorHidReport
+/* should be declared as: PROGMEM char usbHidReportDescriptor[]; */
+/* If you implement an HID device, you need to provide a report descriptor.
+ * The HID report descriptor syntax is a bit complex. If you understand how
+ * report descriptors are constructed, we recommend that you use the HID
+ * Descriptor Tool from usb.org, see http://www.usb.org/developers/hidpage/.
+ * Otherwise you should probably start with a working example.
+ */
+#endif  /* USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH */
+#if USB_CFG_IMPLEMENT_FN_WRITE
+USB_PUBLIC uchar usbFunctionWrite(uchar *data, uchar len);
+/* This function is called by the driver to provide a control transfer's
+ * payload data (control-out). It is called in chunks of up to 8 bytes. The
+ * total count provided in the current control transfer can be obtained from
+ * the 'length' property in the setup data. If an error occurred during
+ * processing, return 0xff (== -1). The driver will answer the entire transfer
+ * with a STALL token in this case. If you have received the entire payload
+ * successfully, return 1. If you expect more data, return 0. If you don't
+ * know whether the host will send more data (you should know, the total is
+ * provided in the usbFunctionSetup() call!), return 1.
+ * NOTE: If you return 0xff for STALL, 'usbFunctionWrite()' may still be called
+ * for the remaining data. You must continue to return 0xff for STALL in these
+ * calls.
+ * In order to get usbFunctionWrite() called, define USB_CFG_IMPLEMENT_FN_WRITE
+ * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_WRITE */
+#if USB_CFG_IMPLEMENT_FN_READ
+USB_PUBLIC uchar usbFunctionRead(uchar *data, uchar len);
+/* This function is called by the driver to ask the application for a control
+ * transfer's payload data (control-in). It is called in chunks of up to 8
+ * bytes each. You should copy the data to the location given by 'data' and
+ * return the actual number of bytes copied. If you return less than requested,
+ * the control-in transfer is terminated. If you return 0xff, the driver aborts
+ * the transfer with a STALL token.
+ * In order to get usbFunctionRead() called, define USB_CFG_IMPLEMENT_FN_READ
+ * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_READ */
+
+extern uchar usbRxToken;    /* may be used in usbFunctionWriteOut() below */
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+USB_PUBLIC void usbFunctionWriteOut(uchar *data, uchar len);
+/* This function is called by the driver when data is received on an interrupt-
+ * or bulk-out endpoint. The endpoint number can be found in the global
+ * variable usbRxToken. You must define USB_CFG_IMPLEMENT_FN_WRITEOUT to 1 in
+ * usbconfig.h to get this function called.
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_WRITEOUT */
+#ifdef USB_CFG_PULLUP_IOPORTNAME
+#define usbDeviceConnect()      ((USB_PULLUP_DDR |= (1<<USB_CFG_PULLUP_BIT)), \
+                                  (USB_PULLUP_OUT |= (1<<USB_CFG_PULLUP_BIT)))
+#define usbDeviceDisconnect()   ((USB_PULLUP_DDR &= ~(1<<USB_CFG_PULLUP_BIT)), \
+                                  (USB_PULLUP_OUT &= ~(1<<USB_CFG_PULLUP_BIT)))
+#else /* USB_CFG_PULLUP_IOPORTNAME */
+#define usbDeviceConnect()      (USBDDR &= ~(1<<USBMINUS))
+#define usbDeviceDisconnect()   (USBDDR |= (1<<USBMINUS))
+#endif /* USB_CFG_PULLUP_IOPORTNAME */
+/* The macros usbDeviceConnect() and usbDeviceDisconnect() (intended to look
+ * like a function) connect resp. disconnect the device from the host's USB.
+ * If the constants USB_CFG_PULLUP_IOPORT and USB_CFG_PULLUP_BIT are defined
+ * in usbconfig.h, a disconnect consists of removing the pull-up resisitor
+ * from D-, otherwise the disconnect is done by brute-force pulling D- to GND.
+ * This does not conform to the spec, but it works.
+ * Please note that the USB interrupt must be disabled while the device is
+ * in disconnected state, or the interrupt handler will hang! You can either
+ * turn off the USB interrupt selectively with
+ *     USB_INTR_ENABLE &= ~(1 << USB_INTR_ENABLE_BIT)
+ * or use cli() to disable interrupts globally.
+ */
+extern unsigned usbCrc16(unsigned data, uchar len);
+#define usbCrc16(data, len) usbCrc16((unsigned)(data), len)
+/* This function calculates the binary complement of the data CRC used in
+ * USB data packets. The value is used to build raw transmit packets.
+ * You may want to use this function for data checksums or to verify received
+ * data. We enforce 16 bit calling conventions for compatibility with IAR's
+ * tiny memory model.
+ */
+extern unsigned usbCrc16Append(unsigned data, uchar len);
+#define usbCrc16Append(data, len)    usbCrc16Append((unsigned)(data), len)
+/* This function is equivalent to usbCrc16() above, except that it appends
+ * the 2 bytes CRC (lowbyte first) in the 'data' buffer after reading 'len'
+ * bytes.
+ */
+#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
+extern unsigned usbMeasureFrameLength(void);
+/* This function MUST be called IMMEDIATELY AFTER USB reset and measures 1/7 of
+ * the number of CPU cycles during one USB frame minus one low speed bit
+ * length. In other words: return value = 1499 * (F_CPU / 10.5 MHz)
+ * Since this is a busy wait, you MUST disable all interrupts with cli() before
+ * calling this function.
+ * This can be used to calibrate the AVR's RC oscillator.
+ */
+#endif
+extern uchar    usbConfiguration;
+/* This value contains the current configuration set by the host. The driver
+ * allows setting and querying of this variable with the USB SET_CONFIGURATION
+ * and GET_CONFIGURATION requests, but does not use it otherwise.
+ * You may want to reflect the "configured" status with a LED on the device or
+ * switch on high power parts of the circuit only if the device is configured.
+ */
+#if USB_COUNT_SOF
+extern volatile uchar   usbSofCount;
+/* This variable is incremented on every SOF packet. It is only available if
+ * the macro USB_COUNT_SOF is defined to a value != 0.
+ */
+#endif
+#if USB_CFG_CHECK_DATA_TOGGLING
+extern uchar    usbCurrentDataToken;
+/* This variable can be checked in usbFunctionWrite() and usbFunctionWriteOut()
+ * to ignore duplicate packets.
+ */
+#endif
+
+#define USB_STRING_DESCRIPTOR_HEADER(stringLength) ((2*(stringLength)+2) | (3<<8))
+/* This macro builds a descriptor header for a string descriptor given the
+ * string's length. See usbdrv.c for an example how to use it.
+ */
+#if USB_CFG_HAVE_FLOWCONTROL
+extern volatile schar   usbRxLen;
+#define usbDisableAllRequests()     usbRxLen = -1
+/* Must be called from usbFunctionWrite(). This macro disables all data input
+ * from the USB interface. Requests from the host are answered with a NAK
+ * while they are disabled.
+ */
+#define usbEnableAllRequests()      usbRxLen = 0
+/* May only be called if requests are disabled. This macro enables input from
+ * the USB interface after it has been disabled with usbDisableAllRequests().
+ */
+#define usbAllRequestsAreDisabled() (usbRxLen < 0)
+/* Use this macro to find out whether requests are disabled. It may be needed
+ * to ensure that usbEnableAllRequests() is never called when requests are
+ * enabled.
+ */
+#endif
+
+#define USB_SET_DATATOKEN1(token)   usbTxBuf1[0] = token
+#define USB_SET_DATATOKEN3(token)   usbTxBuf3[0] = token
+/* These two macros can be used by application software to reset data toggling
+ * for interrupt-in endpoints 1 and 3. Since the token is toggled BEFORE
+ * sending data, you must set the opposite value of the token which should come
+ * first.
+ */
+
+#endif  /* __ASSEMBLER__ */
+
+
+/* ------------------------------------------------------------------------- */
+/* ----------------- Definitions for Descriptor Properties ----------------- */
+/* ------------------------------------------------------------------------- */
+/* This is advanced stuff. See usbconfig-prototype.h for more information
+ * about the various methods to define USB descriptors. If you do nothing,
+ * the default descriptors will be used.
+ */
+#define USB_PROP_IS_DYNAMIC     (1u << 14)
+/* If this property is set for a descriptor, usbFunctionDescriptor() will be
+ * used to obtain the particular descriptor. Data directly returned via
+ * usbMsgPtr are FLASH data by default, combine (OR) with USB_PROP_IS_RAM to
+ * return RAM data.
+ */
+#define USB_PROP_IS_RAM         (1u << 15)
+/* If this property is set for a descriptor, the data is read from RAM
+ * memory instead of Flash. The property is used for all methods to provide
+ * external descriptors.
+ */
+#define USB_PROP_LENGTH(len)    ((len) & 0x3fff)
+/* If a static external descriptor is used, this is the total length of the
+ * descriptor in bytes.
+ */
+
+/* all descriptors which may have properties: */
+#ifndef USB_CFG_DESCR_PROPS_DEVICE
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_CONFIGURATION
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRINGS
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_VENDOR
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_PRODUCT
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_HID
+#define USB_CFG_DESCR_PROPS_HID                     0
+#endif
+#if !(USB_CFG_DESCR_PROPS_HID_REPORT)
+#   undef USB_CFG_DESCR_PROPS_HID_REPORT
+#   if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH /* do some backward compatibility tricks */
+#       define USB_CFG_DESCR_PROPS_HID_REPORT       USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH
+#   else
+#       define USB_CFG_DESCR_PROPS_HID_REPORT       0
+#   endif
+#endif
+#ifndef USB_CFG_DESCR_PROPS_UNKNOWN
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+#endif
+
+/* ------------------ forward declaration of descriptors ------------------- */
+/* If you use external static descriptors, they must be stored in global
+ * arrays as declared below:
+ */
+#ifndef __ASSEMBLER__
+extern
+#if !(USB_CFG_DESCR_PROPS_DEVICE & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorDevice[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_CONFIGURATION & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorConfiguration[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_HID_REPORT & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorHidReport[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_0 & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorString0[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_VENDOR & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+int usbDescriptorStringVendor[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_PRODUCT & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+int usbDescriptorStringDevice[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+int usbDescriptorStringSerialNumber[];
+
+#endif /* __ASSEMBLER__ */
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------ General Purpose Macros ------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#define USB_CONCAT(a, b)            a ## b
+#define USB_CONCAT_EXPANDED(a, b)   USB_CONCAT(a, b)
+
+#define USB_OUTPORT(name)           USB_CONCAT(PORT, name)
+#define USB_INPORT(name)            USB_CONCAT(PIN, name)
+#define USB_DDRPORT(name)           USB_CONCAT(DDR, name)
+/* The double-define trick above lets us concatenate strings which are
+ * defined by macros.
+ */
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------- Constant definitions -------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#if !defined __ASSEMBLER__ && (!defined USB_CFG_VENDOR_ID || !defined USB_CFG_DEVICE_ID)
+#warning "You should define USB_CFG_VENDOR_ID and USB_CFG_DEVICE_ID in usbconfig.h"
+/* If the user has not defined IDs, we default to obdev's free IDs.
+ * See USB-IDs-for-free.txt for details.
+ */
+#endif
+
+/* make sure we have a VID and PID defined, byte order is lowbyte, highbyte */
+#ifndef USB_CFG_VENDOR_ID
+#   define  USB_CFG_VENDOR_ID   0xc0, 0x16  /* = 0x16c0 = 5824 = voti.nl */
+#endif
+
+#ifndef USB_CFG_DEVICE_ID
+#   if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH
+#       define USB_CFG_DEVICE_ID    0xdf, 0x05  /* = 0x5df = 1503, shared PID for HIDs */
+#   elif USB_CFG_INTERFACE_CLASS == 2
+#       define USB_CFG_DEVICE_ID    0xe1, 0x05  /* = 0x5e1 = 1505, shared PID for CDC Modems */
+#   else
+#       define USB_CFG_DEVICE_ID    0xdc, 0x05  /* = 0x5dc = 1500, obdev's free PID */
+#   endif
+#endif
+
+/* Derive Output, Input and DataDirection ports from port names */
+#ifndef USB_CFG_IOPORTNAME
+#error "You must define USB_CFG_IOPORTNAME in usbconfig.h, see usbconfig-prototype.h"
+#endif
+
+#define USBOUT          USB_OUTPORT(USB_CFG_IOPORTNAME)
+#define USB_PULLUP_OUT  USB_OUTPORT(USB_CFG_PULLUP_IOPORTNAME)
+#define USBIN           USB_INPORT(USB_CFG_IOPORTNAME)
+#define USBDDR          USB_DDRPORT(USB_CFG_IOPORTNAME)
+#define USB_PULLUP_DDR  USB_DDRPORT(USB_CFG_PULLUP_IOPORTNAME)
+
+#define USBMINUS    USB_CFG_DMINUS_BIT
+#define USBPLUS     USB_CFG_DPLUS_BIT
+#define USBIDLE     (1<<USB_CFG_DMINUS_BIT) /* value representing J state */
+#define USBMASK     ((1<<USB_CFG_DPLUS_BIT) | (1<<USB_CFG_DMINUS_BIT))  /* mask for USB I/O bits */
+
+/* defines for backward compatibility with older driver versions: */
+#define USB_CFG_IOPORT          USB_OUTPORT(USB_CFG_IOPORTNAME)
+#ifdef USB_CFG_PULLUP_IOPORTNAME
+#define USB_CFG_PULLUP_IOPORT   USB_OUTPORT(USB_CFG_PULLUP_IOPORTNAME)
+#endif
+
+#ifndef USB_CFG_EP3_NUMBER  /* if not defined in usbconfig.h */
+#define USB_CFG_EP3_NUMBER  3
+#endif
+
+#ifndef USB_CFG_HAVE_INTRIN_ENDPOINT3
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+#endif
+
+#define USB_BUFSIZE     11  /* PID, 8 bytes data, 2 bytes CRC */
+
+/* ----- Try to find registers and bits responsible for ext interrupt 0 ----- */
+
+#ifndef USB_INTR_CFG    /* allow user to override our default */
+#   if defined  EICRA
+#       define USB_INTR_CFG EICRA
+#   else
+#       define USB_INTR_CFG MCUCR
+#   endif
+#endif
+#ifndef USB_INTR_CFG_SET    /* allow user to override our default */
+#   if defined(USB_COUNT_SOF) || defined(USB_SOF_HOOK)
+#       define USB_INTR_CFG_SET (1 << ISC01)                    /* cfg for falling edge */
+        /* If any SOF logic is used, the interrupt must be wired to D- where
+         * we better trigger on falling edge
+         */
+#   else
+#       define USB_INTR_CFG_SET ((1 << ISC00) | (1 << ISC01))   /* cfg for rising edge */
+#   endif
+#endif
+#ifndef USB_INTR_CFG_CLR    /* allow user to override our default */
+#   define USB_INTR_CFG_CLR 0    /* no bits to clear */
+#endif
+
+#ifndef USB_INTR_ENABLE     /* allow user to override our default */
+#   if defined GIMSK
+#       define USB_INTR_ENABLE  GIMSK
+#   elif defined EIMSK
+#       define USB_INTR_ENABLE  EIMSK
+#   else
+#       define USB_INTR_ENABLE  GICR
+#   endif
+#endif
+#ifndef USB_INTR_ENABLE_BIT /* allow user to override our default */
+#   define USB_INTR_ENABLE_BIT  INT0
+#endif
+
+#ifndef USB_INTR_PENDING    /* allow user to override our default */
+#   if defined  EIFR
+#       define USB_INTR_PENDING EIFR
+#   else
+#       define USB_INTR_PENDING GIFR
+#   endif
+#endif
+#ifndef USB_INTR_PENDING_BIT    /* allow user to override our default */
+#   define USB_INTR_PENDING_BIT INTF0
+#endif
+
+/*
+The defines above don't work for the following chips
+at90c8534: no ISC0?, no PORTB, can't find a data sheet
+at86rf401: no PORTB, no MCUCR etc, low clock rate
+atmega103: no ISC0? (maybe omission in header, can't find data sheet)
+atmega603: not defined in avr-libc
+at43usb320, at43usb355, at76c711: have USB anyway
+at94k: is different...
+
+at90s1200, attiny11, attiny12, attiny15, attiny28: these have no RAM
+*/
+
+/* ------------------------------------------------------------------------- */
+/* ----------------- USB Specification Constants and Types ----------------- */
+/* ------------------------------------------------------------------------- */
+
+/* USB Token values */
+#define USBPID_SETUP    0x2d
+#define USBPID_OUT      0xe1
+#define USBPID_IN       0x69
+#define USBPID_DATA0    0xc3
+#define USBPID_DATA1    0x4b
+
+#define USBPID_ACK      0xd2
+#define USBPID_NAK      0x5a
+#define USBPID_STALL    0x1e
+
+#ifndef USB_INITIAL_DATATOKEN
+#define USB_INITIAL_DATATOKEN   USBPID_DATA1
+#endif
+
+#ifndef __ASSEMBLER__
+
+typedef struct usbTxStatus{
+    volatile uchar   len;
+    uchar   buffer[USB_BUFSIZE];
+}usbTxStatus_t;
+
+extern usbTxStatus_t   usbTxStatus1, usbTxStatus3;
+#define usbTxLen1   usbTxStatus1.len
+#define usbTxBuf1   usbTxStatus1.buffer
+#define usbTxLen3   usbTxStatus3.len
+#define usbTxBuf3   usbTxStatus3.buffer
+
+
+typedef union usbWord{
+    unsigned    word;
+    uchar       bytes[2];
+}usbWord_t;
+
+typedef struct usbRequest{
+    uchar       bmRequestType;
+    uchar       bRequest;
+    usbWord_t   wValue;
+    usbWord_t   wIndex;
+    usbWord_t   wLength;
+}usbRequest_t;
+/* This structure matches the 8 byte setup request */
+#endif
+
+/* bmRequestType field in USB setup:
+ * d t t r r r r r, where
+ * d ..... direction: 0=host->device, 1=device->host
+ * t ..... type: 0=standard, 1=class, 2=vendor, 3=reserved
+ * r ..... recipient: 0=device, 1=interface, 2=endpoint, 3=other
+ */
+
+/* USB setup recipient values */
+#define USBRQ_RCPT_MASK         0x1f
+#define USBRQ_RCPT_DEVICE       0
+#define USBRQ_RCPT_INTERFACE    1
+#define USBRQ_RCPT_ENDPOINT     2
+
+/* USB request type values */
+#define USBRQ_TYPE_MASK         0x60
+#define USBRQ_TYPE_STANDARD     (0<<5)
+#define USBRQ_TYPE_CLASS        (1<<5)
+#define USBRQ_TYPE_VENDOR       (2<<5)
+
+/* USB direction values: */
+#define USBRQ_DIR_MASK              0x80
+#define USBRQ_DIR_HOST_TO_DEVICE    (0<<7)
+#define USBRQ_DIR_DEVICE_TO_HOST    (1<<7)
+
+/* USB Standard Requests */
+#define USBRQ_GET_STATUS        0
+#define USBRQ_CLEAR_FEATURE     1
+#define USBRQ_SET_FEATURE       3
+#define USBRQ_SET_ADDRESS       5
+#define USBRQ_GET_DESCRIPTOR    6
+#define USBRQ_SET_DESCRIPTOR    7
+#define USBRQ_GET_CONFIGURATION 8
+#define USBRQ_SET_CONFIGURATION 9
+#define USBRQ_GET_INTERFACE     10
+#define USBRQ_SET_INTERFACE     11
+#define USBRQ_SYNCH_FRAME       12
+
+/* USB descriptor constants */
+#define USBDESCR_DEVICE         1
+#define USBDESCR_CONFIG         2
+#define USBDESCR_STRING         3
+#define USBDESCR_INTERFACE      4
+#define USBDESCR_ENDPOINT       5
+#define USBDESCR_HID            0x21
+#define USBDESCR_HID_REPORT     0x22
+#define USBDESCR_HID_PHYS       0x23
+
+//#define USBATTR_BUSPOWER        0x80  // USB 1.1 does not define this value any more
+#define USBATTR_BUSPOWER        0
+#define USBATTR_SELFPOWER       0x40
+#define USBATTR_REMOTEWAKE      0x20
+
+/* USB HID Requests */
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_GET_IDLE      0x02
+#define USBRQ_HID_GET_PROTOCOL  0x03
+#define USBRQ_HID_SET_REPORT    0x09
+#define USBRQ_HID_SET_IDLE      0x0a
+#define USBRQ_HID_SET_PROTOCOL  0x0b
+
+/* ------------------------------------------------------------------------- */
+
+#endif /* __usbdrv_h_included__ */
Index: vusb-20121206/usbdrv/usbdrvasm.S
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm.S	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm.S	(working copy)
@@ -0,0 +1,392 @@
+/* Name: usbdrvasm.S
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-13
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module is the assembler part of the USB driver. This file contains
+general code (preprocessor acrobatics and CRC computation) and then includes
+the file appropriate for the given clock rate.
+*/
+
+#define __SFR_OFFSET 0      /* used by avr-libc's register definitions */
+#include "usbportability.h"
+#include "usbdrv.h"         /* for common defs */
+
+/* register names */
+#define x1      r16
+#define x2      r17
+#define shift   r18
+#define cnt     r19
+#define x3      r20
+#define x4      r21
+#define x5		r22
+#define bitcnt  x5
+#define phase   x4
+#define leap    x4
+
+/* Some assembler dependent definitions and declarations: */
+
+#ifdef __IAR_SYSTEMS_ASM__
+    extern  usbRxBuf, usbDeviceAddr, usbNewDeviceAddr, usbInputBufOffset
+    extern  usbCurrentTok, usbRxLen, usbRxToken, usbTxLen
+    extern  usbTxBuf, usbTxStatus1, usbTxStatus3
+#   if USB_COUNT_SOF
+        extern usbSofCount
+#   endif
+    public  usbCrc16
+    public  usbCrc16Append
+
+    COMMON  INTVEC
+#   ifndef USB_INTR_VECTOR
+        ORG     INT0_vect
+#   else /* USB_INTR_VECTOR */
+        ORG     USB_INTR_VECTOR
+#       undef   USB_INTR_VECTOR
+#   endif /* USB_INTR_VECTOR */
+#   define  USB_INTR_VECTOR usbInterruptHandler
+    rjmp    USB_INTR_VECTOR
+    RSEG    CODE
+
+#else /* __IAR_SYSTEMS_ASM__ */
+
+#   ifndef USB_INTR_VECTOR /* default to hardware interrupt INT0 */
+#       ifdef INT0_vect
+#           define USB_INTR_VECTOR  INT0_vect       // this is the "new" define for the vector
+#       else
+#           define USB_INTR_VECTOR  SIG_INTERRUPT0  // this is the "old" vector
+#       endif
+#   endif
+    .text
+    .global USB_INTR_VECTOR
+    .type   USB_INTR_VECTOR, @function
+    .global usbCrc16
+    .global usbCrc16Append
+#endif /* __IAR_SYSTEMS_ASM__ */
+
+
+#if USB_INTR_PENDING < 0x40 /* This is an I/O address, use in and out */
+#   define  USB_LOAD_PENDING(reg)   in reg, USB_INTR_PENDING
+#   define  USB_STORE_PENDING(reg)  out USB_INTR_PENDING, reg
+#else   /* It's a memory address, use lds and sts */
+#   define  USB_LOAD_PENDING(reg)   lds reg, USB_INTR_PENDING
+#   define  USB_STORE_PENDING(reg)  sts USB_INTR_PENDING, reg
+#endif
+
+#define usbTxLen1   usbTxStatus1
+#define usbTxBuf1   (usbTxStatus1 + 1)
+#define usbTxLen3   usbTxStatus3
+#define usbTxBuf3   (usbTxStatus3 + 1)
+
+
+;----------------------------------------------------------------------------
+; Utility functions
+;----------------------------------------------------------------------------
+
+#ifdef __IAR_SYSTEMS_ASM__
+/* Register assignments for usbCrc16 on IAR cc */
+/* Calling conventions on IAR:
+ * First parameter passed in r16/r17, second in r18/r19 and so on.
+ * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+ * Result is passed in r16/r17
+ * In case of the "tiny" memory model, pointers are only 8 bit with no
+ * padding. We therefore pass argument 1 as "16 bit unsigned".
+ */
+RTMODEL "__rt_version", "3"
+/* The line above will generate an error if cc calling conventions change.
+ * The value "3" above is valid for IAR 4.10B/W32
+ */
+#   define argLen   r18 /* argument 2 */
+#   define argPtrL  r16 /* argument 1 */
+#   define argPtrH  r17 /* argument 1 */
+
+#   define resCrcL  r16 /* result */
+#   define resCrcH  r17 /* result */
+
+#   define ptrL     ZL
+#   define ptrH     ZH
+#   define ptr      Z
+#   define byte     r22
+#   define bitCnt   r19
+#   define polyL    r20
+#   define polyH    r21
+#   define scratch  r23
+
+#else  /* __IAR_SYSTEMS_ASM__ */ 
+/* Register assignments for usbCrc16 on gcc */
+/* Calling conventions on gcc:
+ * First parameter passed in r24/r25, second in r22/23 and so on.
+ * Callee must preserve r1-r17, r28/r29
+ * Result is passed in r24/r25
+ */
+#   define argLen   r22 /* argument 2 */
+#   define argPtrL  r24 /* argument 1 */
+#   define argPtrH  r25 /* argument 1 */
+
+#   define resCrcL  r24 /* result */
+#   define resCrcH  r25 /* result */
+
+#   define ptrL     XL
+#   define ptrH     XH
+#   define ptr      x
+#   define byte     r18
+#   define bitCnt   r19
+#   define polyL    r20
+#   define polyH    r21
+#   define scratch  r23
+
+#endif
+
+#if USB_USE_FAST_CRC
+
+; This implementation is faster, but has bigger code size
+; Thanks to Slawomir Fras (BoskiDialer) for this code!
+; It implements the following C pseudo-code:
+; unsigned table(unsigned char x)
+; {
+; unsigned    value;
+; 
+;     value = (unsigned)x << 6;
+;     value ^= (unsigned)x << 7;
+;     if(parity(x))
+;         value ^= 0xc001;
+;     return value;
+; }
+; unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen)
+; {
+; unsigned crc = 0xffff;
+; 
+;     while(argLen--)
+;         crc = table(lo8(crc) ^ *argPtr++) ^ hi8(crc);
+;     return ~crc;
+; }
+
+; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+;   argPtr  r24+25 / r16+r17
+;   argLen  r22 / r18
+; temp variables:
+;   byte    r18 / r22
+;   scratch r23
+;   resCrc  r24+r25 / r16+r17
+;   ptr     X / Z
+usbCrc16:
+    mov     ptrL, argPtrL
+    mov     ptrH, argPtrH
+    ldi     resCrcL, 0xFF
+    ldi     resCrcH, 0xFF
+    rjmp    usbCrc16LoopTest
+usbCrc16ByteLoop:
+    ld      byte, ptr+
+    eor     resCrcL, byte   ; resCrcL is now 'x' in table()
+    mov     byte, resCrcL   ; compute parity of 'x'
+    swap    byte
+    eor     byte, resCrcL
+    mov     scratch, byte
+    lsr     byte
+    lsr     byte
+    eor     byte, scratch
+    inc     byte
+    lsr     byte
+    andi    byte, 1         ; byte is now parity(x)
+    mov     scratch, resCrcL
+    mov     resCrcL, resCrcH
+    eor     resCrcL, byte   ; low byte of if(parity(x)) value ^= 0xc001;
+    neg     byte
+    andi    byte, 0xc0
+    mov     resCrcH, byte   ; high byte of if(parity(x)) value ^= 0xc001;
+    clr     byte
+    lsr     scratch
+    ror     byte
+    eor     resCrcH, scratch
+    eor     resCrcL, byte
+    lsr     scratch
+    ror     byte
+    eor     resCrcH, scratch
+    eor     resCrcL, byte
+usbCrc16LoopTest:
+    subi    argLen, 1
+    brsh    usbCrc16ByteLoop
+    com     resCrcL
+    com     resCrcH
+    ret
+
+#else   /* USB_USE_FAST_CRC */
+
+; This implementation is slower, but has less code size
+;
+; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+;   argPtr  r24+25 / r16+r17
+;   argLen  r22 / r18
+; temp variables:
+;   byte    r18 / r22
+;   bitCnt  r19
+;   poly    r20+r21
+;   scratch r23
+;   resCrc  r24+r25 / r16+r17
+;   ptr     X / Z
+usbCrc16:
+    mov     ptrL, argPtrL
+    mov     ptrH, argPtrH
+    ldi     resCrcL, 0
+    ldi     resCrcH, 0
+    ldi     polyL, lo8(0xa001)
+    ldi     polyH, hi8(0xa001)
+    com     argLen      ; argLen = -argLen - 1: modified loop to ensure that carry is set
+    ldi     bitCnt, 0   ; loop counter with starnd condition = end condition
+    rjmp    usbCrcLoopEntry
+usbCrcByteLoop:
+    ld      byte, ptr+
+    eor     resCrcL, byte
+usbCrcBitLoop:
+    ror     resCrcH     ; carry is always set here (see brcs jumps to here)
+    ror     resCrcL
+    brcs    usbCrcNoXor
+    eor     resCrcL, polyL
+    eor     resCrcH, polyH
+usbCrcNoXor:
+    subi    bitCnt, 224 ; (8 * 224) % 256 = 0; this loop iterates 8 times
+    brcs    usbCrcBitLoop
+usbCrcLoopEntry:
+    subi    argLen, -1
+    brcs    usbCrcByteLoop
+usbCrcReady:
+    ret
+; Thanks to Reimar Doeffinger for optimizing this CRC routine!
+
+#endif /* USB_USE_FAST_CRC */
+
+; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
+usbCrc16Append:
+    rcall   usbCrc16
+    st      ptr+, resCrcL
+    st      ptr+, resCrcH
+    ret
+
+#undef argLen
+#undef argPtrL
+#undef argPtrH
+#undef resCrcL
+#undef resCrcH
+#undef ptrL
+#undef ptrH
+#undef ptr
+#undef byte
+#undef bitCnt
+#undef polyL
+#undef polyH
+#undef scratch
+
+
+#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
+#ifdef __IAR_SYSTEMS_ASM__
+/* Register assignments for usbMeasureFrameLength on IAR cc */
+/* Calling conventions on IAR:
+ * First parameter passed in r16/r17, second in r18/r19 and so on.
+ * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+ * Result is passed in r16/r17
+ * In case of the "tiny" memory model, pointers are only 8 bit with no
+ * padding. We therefore pass argument 1 as "16 bit unsigned".
+ */
+#   define resL     r16
+#   define resH     r17
+#   define cnt16L   r30
+#   define cnt16H   r31
+#   define cntH     r18
+
+#else  /* __IAR_SYSTEMS_ASM__ */ 
+/* Register assignments for usbMeasureFrameLength on gcc */
+/* Calling conventions on gcc:
+ * First parameter passed in r24/r25, second in r22/23 and so on.
+ * Callee must preserve r1-r17, r28/r29
+ * Result is passed in r24/r25
+ */
+#   define resL     r24
+#   define resH     r25
+#   define cnt16L   r24
+#   define cnt16H   r25
+#   define cntH     r26
+#endif
+#   define cnt16    cnt16L
+
+; extern unsigned usbMeasurePacketLength(void);
+; returns time between two idle strobes in multiples of 7 CPU clocks
+.global usbMeasureFrameLength
+usbMeasureFrameLength:
+    ldi     cntH, 6         ; wait ~ 10 ms for D- == 0
+    clr     cnt16L
+    clr     cnt16H
+usbMFTime16:
+    dec     cntH
+    breq    usbMFTimeout
+usbMFWaitStrobe:            ; first wait for D- == 0 (idle strobe)
+    sbiw    cnt16, 1        ;[0] [6]
+    breq    usbMFTime16     ;[2]
+    sbic    USBIN, USBMINUS ;[3]
+    rjmp    usbMFWaitStrobe ;[4]
+usbMFWaitIdle:              ; then wait until idle again
+    sbis    USBIN, USBMINUS ;1 wait for D- == 1
+    rjmp    usbMFWaitIdle   ;2
+    ldi     cnt16L, 1       ;1 represents cycles so far
+    clr     cnt16H          ;1
+usbMFWaitLoop:
+    in      cntH, USBIN     ;[0] [7]
+    adiw    cnt16, 1        ;[1]
+    breq    usbMFTimeout    ;[3]
+    andi    cntH, USBMASK   ;[4]
+    brne    usbMFWaitLoop   ;[5]
+usbMFTimeout:
+#if resL != cnt16L
+    mov     resL, cnt16L
+    mov     resH, cnt16H
+#endif
+    ret
+
+#undef resL
+#undef resH
+#undef cnt16
+#undef cnt16L
+#undef cnt16H
+#undef cntH
+
+#endif  /* USB_CFG_HAVE_MEASURE_FRAME_LENGTH */
+
+;----------------------------------------------------------------------------
+; Now include the clock rate specific code
+;----------------------------------------------------------------------------
+
+#ifndef USB_CFG_CLOCK_KHZ
+#   ifdef F_CPU
+#       define USB_CFG_CLOCK_KHZ (F_CPU/1000)
+#   else
+#       error "USB_CFG_CLOCK_KHZ not defined in usbconfig.h and no F_CPU set!"
+#   endif
+#endif
+
+#if USB_CFG_CHECK_CRC   /* separate dispatcher for CRC type modules */
+#   if USB_CFG_CLOCK_KHZ == 18000
+#       include "usbdrvasm18-crc.inc"
+#   else
+#       error "USB_CFG_CLOCK_KHZ is not one of the supported crc-rates!"
+#   endif
+#else   /* USB_CFG_CHECK_CRC */
+#   if USB_CFG_CLOCK_KHZ == 12000
+#       include "usbdrvasm12.inc"
+#   elif USB_CFG_CLOCK_KHZ == 12800
+#       include "usbdrvasm128.inc"
+#   elif USB_CFG_CLOCK_KHZ == 15000
+#       include "usbdrvasm15.inc"
+#   elif USB_CFG_CLOCK_KHZ == 16000
+#       include "usbdrvasm16.inc"
+#   elif USB_CFG_CLOCK_KHZ == 16500
+#       include "usbdrvasm165.inc"
+#   elif USB_CFG_CLOCK_KHZ == 20000
+#       include "usbdrvasm20.inc"
+#   else
+#       error "USB_CFG_CLOCK_KHZ is not one of the supported non-crc-rates!"
+#   endif
+#endif /* USB_CFG_CHECK_CRC */
Index: vusb-20121206/usbdrv/usbdrvasm.asm
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm.asm	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm.asm	(working copy)
@@ -0,0 +1,20 @@
+/* Name: usbdrvasm.asm
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-03-01
+ * Tabsize: 4
+ * Copyright: (c) 2006 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The IAR compiler/assembler system prefers assembler files with file extension
+".asm". We simply provide this file as an alias for usbdrvasm.S.
+
+Thanks to Oleg Semyonov for his help with the IAR tools port!
+*/
+
+#include "usbdrvasm.S"
+
+end
Index: vusb-20121206/usbdrv/usbdrvasm12.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm12.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm12.inc	(working copy)
@@ -0,0 +1,392 @@
+/* Name: usbdrvasm12.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 12 MHz version of the asssembler part of the USB driver. It
+requires a 12 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+
+
+Timing constraints according to spec (in bit times):
+timing subject                                      min max    CPUcycles
+---------------------------------------------------------------------------
+EOP of OUT/SETUP to sync pattern of DATA0 (both rx) 2   16     16-128
+EOP of IN to sync pattern of DATA0 (rx, then tx)    2   7.5    16-60
+DATAx (rx) to ACK/NAK/STALL (tx)                    2   7.5    16-60
+*/
+
+;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
+;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
+;max allowable interrupt latency: 34 cycles -> max 25 cycles interrupt disable
+;max stack usage: [ret(2), YL, SREG, YH, shift, x1, x2, x3, cnt, x4] = 11 bytes
+;Numbers in brackets are maximum cycles since SOF.
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt
+    push    YL              ;2 [35] push only what is necessary to sync with edge ASAP
+    in      YL, SREG        ;1 [37]
+    push    YL              ;2 [39]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    YH                  ;2 [2]
+    lds     YL, usbInputBufOffset;2 [4]
+    clr     YH                  ;1 [5]
+    subi    YL, lo8(-(usbRxBuf));1 [6]
+    sbci    YH, hi8(-(usbRxBuf));1 [7]
+
+    sbis    USBIN, USBMINUS ;1 [8] we want two bits K [sample 1 cycle too early]
+    rjmp    haveTwoBitsK    ;2 [10]
+    pop     YH              ;2 [11] undo the push from before
+    rjmp    waitForK        ;2 [13] this was not the end of sync, retry
+haveTwoBitsK:
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+    push    shift           ;2 [16]
+    push    x1              ;2 [12]
+    push    x2              ;2 [14]
+
+    in      x1, USBIN       ;1 [17] <-- sample bit 0
+    ldi     shift, 0xff     ;1 [18]
+    bst     x1, USBMINUS    ;1 [19]
+    bld     shift, 0        ;1 [20]
+    push    x3              ;2 [22]
+    push    cnt             ;2 [24]
+    
+    in      x2, USBIN       ;1 [25] <-- sample bit 1
+    ser     x3              ;1 [26] [inserted init instruction]
+    eor     x1, x2          ;1 [27]
+    bst     x1, USBMINUS    ;1 [28]
+    bld     shift, 1        ;1 [29]
+    ldi     cnt, USB_BUFSIZE;1 [30] [inserted init instruction]
+    rjmp    rxbit2          ;2 [32]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+
+unstuff0:               ;1 (branch taken)
+    andi    x3, ~0x01   ;1 [15]
+    mov     x1, x2      ;1 [16] x2 contains last sampled (stuffed) bit
+    in      x2, USBIN   ;1 [17] <-- sample bit 1 again
+    ori     shift, 0x01 ;1 [18]
+    rjmp    didUnstuff0 ;2 [20]
+
+unstuff1:               ;1 (branch taken)
+    mov     x2, x1      ;1 [21] x1 contains last sampled (stuffed) bit
+    andi    x3, ~0x02   ;1 [22]
+    ori     shift, 0x02 ;1 [23]
+    nop                 ;1 [24]
+    in      x1, USBIN   ;1 [25] <-- sample bit 2 again
+    rjmp    didUnstuff1 ;2 [27]
+
+unstuff2:               ;1 (branch taken)
+    andi    x3, ~0x04   ;1 [29]
+    ori     shift, 0x04 ;1 [30]
+    mov     x1, x2      ;1 [31] x2 contains last sampled (stuffed) bit
+    nop                 ;1 [32]
+    in      x2, USBIN   ;1 [33] <-- sample bit 3
+    rjmp    didUnstuff2 ;2 [35]
+
+unstuff3:               ;1 (branch taken)
+    in      x2, USBIN   ;1 [34] <-- sample stuffed bit 3 [one cycle too late]
+    andi    x3, ~0x08   ;1 [35]
+    ori     shift, 0x08 ;1 [36]
+    rjmp    didUnstuff3 ;2 [38]
+
+unstuff4:               ;1 (branch taken)
+    andi    x3, ~0x10   ;1 [40]
+    in      x1, USBIN   ;1 [41] <-- sample stuffed bit 4
+    ori     shift, 0x10 ;1 [42]
+    rjmp    didUnstuff4 ;2 [44]
+
+unstuff5:               ;1 (branch taken)
+    andi    x3, ~0x20   ;1 [48]
+    in      x2, USBIN   ;1 [49] <-- sample stuffed bit 5
+    ori     shift, 0x20 ;1 [50]
+    rjmp    didUnstuff5 ;2 [52]
+
+unstuff6:               ;1 (branch taken)
+    andi    x3, ~0x40   ;1 [56]
+    in      x1, USBIN   ;1 [57] <-- sample stuffed bit 6
+    ori     shift, 0x40 ;1 [58]
+    rjmp    didUnstuff6 ;2 [60]
+
+; extra jobs done during bit interval:
+; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs]
+; bit 1:    se0 check
+; bit 2:    overflow check
+; bit 3:    recovery from delay [bit 0 tasks took too long]
+; bit 4:    none
+; bit 5:    none
+; bit 6:    none
+; bit 7:    jump, eor
+rxLoop:
+    eor     x3, shift   ;1 [0] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    in      x1, USBIN   ;1 [1] <-- sample bit 0
+    st      y+, x3      ;2 [3] store data
+    ser     x3          ;1 [4]
+    nop                 ;1 [5]
+    eor     x2, x1      ;1 [6]
+    bst     x2, USBMINUS;1 [7]
+    bld     shift, 0    ;1 [8]
+    in      x2, USBIN   ;1 [9] <-- sample bit 1 (or possibly bit 0 stuffed)
+    andi    x2, USBMASK ;1 [10]
+    breq    se0         ;1 [11] SE0 check for bit 1
+    andi    shift, 0xf9 ;1 [12]
+didUnstuff0:
+    breq    unstuff0    ;1 [13]
+    eor     x1, x2      ;1 [14]
+    bst     x1, USBMINUS;1 [15]
+    bld     shift, 1    ;1 [16]
+rxbit2:
+    in      x1, USBIN   ;1 [17] <-- sample bit 2 (or possibly bit 1 stuffed)
+    andi    shift, 0xf3 ;1 [18]
+    breq    unstuff1    ;1 [19] do remaining work for bit 1
+didUnstuff1:
+    subi    cnt, 1      ;1 [20]
+    brcs    overflow    ;1 [21] loop control
+    eor     x2, x1      ;1 [22]
+    bst     x2, USBMINUS;1 [23]
+    bld     shift, 2    ;1 [24]
+    in      x2, USBIN   ;1 [25] <-- sample bit 3 (or possibly bit 2 stuffed)
+    andi    shift, 0xe7 ;1 [26]
+    breq    unstuff2    ;1 [27]
+didUnstuff2:
+    eor     x1, x2      ;1 [28]
+    bst     x1, USBMINUS;1 [29]
+    bld     shift, 3    ;1 [30]
+didUnstuff3:
+    andi    shift, 0xcf ;1 [31]
+    breq    unstuff3    ;1 [32]
+    in      x1, USBIN   ;1 [33] <-- sample bit 4
+    eor     x2, x1      ;1 [34]
+    bst     x2, USBMINUS;1 [35]
+    bld     shift, 4    ;1 [36]
+didUnstuff4:
+    andi    shift, 0x9f ;1 [37]
+    breq    unstuff4    ;1 [38]
+    nop2                ;2 [40]
+    in      x2, USBIN   ;1 [41] <-- sample bit 5
+    eor     x1, x2      ;1 [42]
+    bst     x1, USBMINUS;1 [43]
+    bld     shift, 5    ;1 [44]
+didUnstuff5:
+    andi    shift, 0x3f ;1 [45]
+    breq    unstuff5    ;1 [46]
+    nop2                ;2 [48]
+    in      x1, USBIN   ;1 [49] <-- sample bit 6
+    eor     x2, x1      ;1 [50]
+    bst     x2, USBMINUS;1 [51]
+    bld     shift, 6    ;1 [52]
+didUnstuff6:
+    cpi     shift, 0x02 ;1 [53]
+    brlo    unstuff6    ;1 [54]
+    nop2                ;2 [56]
+    in      x2, USBIN   ;1 [57] <-- sample bit 7
+    eor     x1, x2      ;1 [58]
+    bst     x1, USBMINUS;1 [59]
+    bld     shift, 7    ;1 [60]
+didUnstuff7:
+    cpi     shift, 0x04 ;1 [61]
+    brsh    rxLoop      ;2 [63] loop control
+unstuff7:
+    andi    x3, ~0x80   ;1 [63]
+    ori     shift, 0x80 ;1 [64]
+    in      x2, USBIN   ;1 [65] <-- sample stuffed bit 7
+    nop                 ;1 [66]
+    rjmp    didUnstuff7 ;2 [68]
+
+macro POP_STANDARD ; 12 cycles
+    pop     cnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;----------------------------------------------------------------------------
+; Transmitting data
+;----------------------------------------------------------------------------
+
+txByteLoop:
+txBitloop:
+stuffN1Delay:                   ;     [03]
+    ror     shift               ;[-5] [11] [59]
+    brcc    doExorN1            ;[-4]      [60]
+    subi    x4, 1               ;[-3]
+    brne    commonN1            ;[-2]
+    lsl     shift               ;[-1] compensate ror after rjmp stuffDelay
+    nop                         ;[00] stuffing consists of just waiting 8 cycles
+    rjmp    stuffN1Delay        ;[01] after ror, C bit is reliably clear
+
+sendNakAndReti:                 ;0 [-19] 19 cycles until SOP
+    ldi     x3, USBPID_NAK      ;1 [-18]
+    rjmp    usbSendX3           ;2 [-16]
+sendAckAndReti:                 ;0 [-19] 19 cycles until SOP
+    ldi     x3, USBPID_ACK      ;1 [-18]
+    rjmp    usbSendX3           ;2 [-16]
+sendCntAndReti:                 ;0 [-17] 17 cycles until SOP
+    mov     x3, cnt             ;1 [-16]
+usbSendX3:                      ;0 [-16]
+    ldi     YL, 20              ;1 [-15] 'x3' is R20
+    ldi     YH, 0               ;1 [-14]
+    ldi     cnt, 2              ;1 [-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
+; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
+; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte
+;uses: x1...x2, x4, shift, cnt, Y [x1 = mirror USBOUT, x2 = USBMASK, x4 = bitstuff cnt]
+;Numbers in brackets are time since first bit of sync pattern is sent (start of instruction)
+usbSendAndReti:
+    in      x2, USBDDR          ;[-12] 12 cycles until SOP
+    ori     x2, USBMASK         ;[-11]
+    sbi     USBOUT, USBMINUS    ;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    out     USBDDR, x2          ;[-8] <--- acquire bus
+    in      x1, USBOUT          ;[-7] port mirror for tx loop
+    ldi     shift, 0x40         ;[-6] sync byte is first byte sent (we enter loop after ror)
+    ldi     x2, USBMASK         ;[-5]
+    push    x4                  ;[-4]
+doExorN1:
+    eor     x1, x2              ;[-2] [06] [62]
+    ldi     x4, 6               ;[-1] [07] [63]
+commonN1:
+stuffN2Delay:
+    out     USBOUT, x1          ;[00] [08] [64] <--- set bit
+    ror     shift               ;[01]
+    brcc    doExorN2            ;[02]
+    subi    x4, 1               ;[03]
+    brne    commonN2            ;[04]
+    lsl     shift               ;[05] compensate ror after rjmp stuffDelay
+    rjmp    stuffN2Delay        ;[06] after ror, C bit is reliably clear
+doExorN2:
+    eor     x1, x2              ;[04] [12]
+    ldi     x4, 6               ;[05] [13]
+commonN2:
+    nop                         ;[06] [14]
+    subi    cnt, 171            ;[07] [15] trick: (3 * 171) & 0xff = 1
+    out     USBOUT, x1          ;[08] [16] <--- set bit
+    brcs    txBitloop           ;[09]      [25] [41]
+
+stuff6Delay:
+    ror     shift               ;[42] [50]
+    brcc    doExor6             ;[43]
+    subi    x4, 1               ;[44]
+    brne    common6             ;[45]
+    lsl     shift               ;[46] compensate ror after rjmp stuffDelay
+    nop                         ;[47] stuffing consists of just waiting 8 cycles
+    rjmp    stuff6Delay         ;[48] after ror, C bit is reliably clear
+doExor6:
+    eor     x1, x2              ;[45] [53]
+    ldi     x4, 6               ;[46]
+common6:
+stuff7Delay:
+    ror     shift               ;[47] [55]
+    out     USBOUT, x1          ;[48] <--- set bit
+    brcc    doExor7             ;[49]
+    subi    x4, 1               ;[50]
+    brne    common7             ;[51]
+    lsl     shift               ;[52] compensate ror after rjmp stuffDelay
+    rjmp    stuff7Delay         ;[53] after ror, C bit is reliably clear
+doExor7:
+    eor     x1, x2              ;[51] [59]
+    ldi     x4, 6               ;[52]
+common7:
+    ld      shift, y+           ;[53]
+    tst     cnt                 ;[55]
+    out     USBOUT, x1          ;[56] <--- set bit
+    brne    txByteLoop          ;[57]
+
+;make SE0:
+    cbr     x1, USBMASK         ;[58] prepare SE0 [spec says EOP may be 15 to 18 cycles]
+    lds     x2, usbNewDeviceAddr;[59]
+    lsl     x2                  ;[61] we compare with left shifted address
+    subi    YL, 2 + 20          ;[62] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0               ;[63]
+    out     USBOUT, x1          ;[00] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign      ;[01]
+    sts     usbDeviceAddr, x2   ; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[03] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)       ;[04]
+    ori     x1, USBIDLE         ;[05]
+    in      x2, USBDDR          ;[06]
+    cbr     x2, USBMASK         ;[07] set both pins to input
+    mov     x3, x1              ;[08]
+    cbr     x3, USBMASK         ;[09] configure no pullup on both pins
+    pop     x4                  ;[10]
+    nop2                        ;[12]
+    nop2                        ;[14]
+    out     USBOUT, x1          ;[16] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2          ;[17] <-- release bus now
+    out     USBOUT, x3          ;[18] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: vusb-20121206/usbdrv/usbdrvasm128.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm128.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm128.inc	(working copy)
@@ -0,0 +1,749 @@
+/* Name: usbdrvasm128.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-10-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 12.8 MHz version of the USB driver. It is intended for use
+with the internal RC oscillator. Although 12.8 MHz is outside the guaranteed
+calibration range of the oscillator, almost all AVRs can reach this frequency.
+This version contains a phase locked loop in the receiver routine to cope with
+slight clock rate deviations of up to +/- 1%.
+
+See usbdrv.h for a description of the entire driver.
+
+LIMITATIONS
+===========
+Although it may seem very handy to save the crystal and use the internal
+RC oscillator of the CPU, this method (and this module) has some serious
+limitations:
+(1) The guaranteed calibration range of the oscillator is only 8.1 MHz.
+They typical range is 14.5 MHz and most AVRs can actually reach this rate.
+(2) Writing EEPROM and Flash may be unreliable (short data lifetime) since
+the write procedure is timed from the RC oscillator.
+(3) End Of Packet detection (SE0) should be in bit 1, bit it is only checked
+if bits 0 and 1 both read as 0 on D- and D+ read as 0 in the middle. This may
+cause problems with old hubs which delay SE0 by up to one cycle.
+(4) Code size is much larger than that of the other modules.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+
+Implementation notes:
+======================
+min frequency: 67 cycles for 8 bit -> 12.5625 MHz
+max frequency: 69.286 cycles for 8 bit -> 12.99 MHz
+nominal frequency: 12.77 MHz ( = sqrt(min * max))
+
+sampling positions: (next even number in range [+/- 0.5])
+cycle index range: 0 ... 66
+bits:
+.5, 8.875, 17.25, 25.625, 34, 42.375, 50.75, 59.125
+[0/1], [9], [17], [25/+26], [34], [+42/43], [51], [59]
+
+bit number:     0   1   2   3   4   5   6   7
+spare cycles    1   2   1   2   1   1   1   0
+
+operations to perform:      duration cycle
+                            ----------------
+    eor     fix, shift          1 -> 00
+    andi    phase, USBMASK      1 -> 08
+    breq    se0                 1 -> 16 (moved to 11)
+    st      y+, data            2 -> 24, 25
+    mov     data, fix           1 -> 33
+    ser     data                1 -> 41
+    subi    cnt, 1              1 -> 49
+    brcs    overflow            1 -> 50
+
+layout of samples and operations:
+[##] = sample bit
+<##> = sample phase
+*##* = operation
+
+0:  *00* [01]  02   03   04  <05>  06   07
+1:  *08* [09]  10   11   12  <13>  14   15  *16*
+2:  [17]  18   19   20  <21>  22   23
+3:  *24* *25* [26]  27   28   29  <30>  31   32
+4:  *33* [34]  35   36   37  <38>  39   40
+5:  *41* [42]  43   44   45  <46>  47   48
+6:  *49* *50* [51]  52   53   54  <55>  56   57   58
+7:  [59]  60   61   62  <63>  64   65   66
+*****************************************************************************/
+
+/* we prefer positive expressions (do if condition) instead of negative
+ * (skip if condition), therefore use defines for skip instructions:
+ */
+#define ifioclr sbis
+#define ifioset sbic
+#define ifrclr  sbrs
+#define ifrset  sbrc
+
+/* The registers "fix" and "data" swap their meaning during the loop. Use
+ * defines to keep their name constant.
+ */
+#define fix     x2
+#define data    x1
+#undef phase        /* phase has a default definition to x4 */
+#define phase   x3
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt, r0
+    push    YL              ;2 push only what is necessary to sync with edge ASAP
+    in      YL, SREG        ;1
+    push    YL              ;2
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS ;[0]
+    rjmp    foundK          ;[1]
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+
+foundK:
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    YH                  ;[2]
+    lds     YL, usbInputBufOffset;[4]
+    clr     YH                  ;[6]
+    subi    YL, lo8(-(usbRxBuf));[7]
+    sbci    YH, hi8(-(usbRxBuf));[8]
+
+    sbis    USBIN, USBMINUS     ;[9] we want two bits K [we want to sample at 8 + 4 - 1.5 = 10.5]
+    rjmp    haveTwoBitsK        ;[10]
+    pop     YH                  ;[11] undo the push from before
+    rjmp    waitForK            ;[13] this was not the end of sync, retry
+haveTwoBitsK:
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+#define fix     x2
+#define data    x1
+
+    push    shift               ;[12]
+    push    x1                  ;[14]
+    push    x2                  ;[16]
+    ldi     shift, 0x80         ;[18] prevent bit-unstuffing but init low bits to 0
+    ifioset USBIN, USBMINUS     ;[19] [01] <--- bit 0 [10.5 + 8 = 18.5]
+    ori     shift, 1<<0         ;[02]
+    push    x3                  ;[03]
+    push    cnt                 ;[05]
+    push    r0                  ;[07]
+    ifioset USBIN, USBMINUS     ;[09] <--- bit 1
+    ori     shift, 1<<1         ;[10]
+    ser     fix                 ;[11]
+    ldi     cnt, USB_BUFSIZE    ;[12]
+    mov     data, shift         ;[13]
+    lsl     shift               ;[14]
+    nop2                        ;[15]
+    ifioset USBIN, USBMINUS     ;[17] <--- bit 2
+    ori     data, 3<<2          ;[18] store in bit 2 AND bit 3
+    eor     shift, data         ;[19] do nrzi decoding
+    andi    data, 1<<3          ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    brne    jumpToEntryAfterSet ;[22] if USBMINS at bit 3 was 1
+    nop                         ;[23]
+    rjmp    entryAfterClr       ;[24]
+jumpToEntryAfterSet:
+    rjmp    entryAfterSet       ;[24]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+#undef  fix
+#define  fix    x1
+#undef  data
+#define data    x2
+
+bit7IsSet:
+    ifrclr  phase, USBMINUS     ;[62] check phase only if D- changed
+    lpm                         ;[63]
+    in      phase, USBIN        ;[64] <- phase (one cycle too late)
+    ori     shift, 1 << 7       ;[65]
+    nop                         ;[66]
+;;;;rjmp    bit0AfterSet        ; -> [00] == [67] moved block up to save jump
+bit0AfterSet:
+    eor     fix, shift          ;[00]
+#undef  fix
+#define fix     x2
+#undef  data
+#define data    x1  /* we now have result in data, fix is reset to 0xff */
+    ifioclr USBIN, USBMINUS     ;[01] <--- sample 0
+    rjmp    bit0IsClr           ;[02]
+    andi    shift, ~(7 << 0)    ;[03]
+    breq    unstuff0s           ;[04]
+    in      phase, USBIN        ;[05] <- phase
+    rjmp    bit1AfterSet        ;[06]
+unstuff0s:
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    andi    fix, ~(1 << 0)      ;[07]
+    ifioclr USBIN, USBMINUS     ;[00]
+    ifioset USBIN, USBPLUS      ;[01]
+    rjmp    bit0IsClr           ;[02] executed if first expr false or second true
+se0AndStore:                    ; executed only if both bits 0
+    st      y+, x1              ;[15/17] cycles after start of byte
+    rjmp    se0                 ;[17/19]
+
+bit0IsClr:
+    ifrset  phase, USBMINUS     ;[04] check phase only if D- changed
+    lpm                         ;[05]
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    ori     shift, 1 << 0       ;[07]
+bit1AfterClr:
+    andi    phase, USBMASK      ;[08]
+    ifioset USBIN, USBMINUS     ;[09] <--- sample 1
+    rjmp    bit1IsSet           ;[10]
+    breq    se0AndStore         ;[11] if D- was 0 in bits 0 AND 1 and D+ was 0 in between, we have SE0
+    andi    shift, ~(7 << 1)    ;[12]
+    in      phase, USBIN        ;[13] <- phase
+    breq    unstuff1c           ;[14]
+    rjmp    bit2AfterClr        ;[15]
+unstuff1c:
+    andi    fix, ~(1 << 1)      ;[16]
+    nop2                        ;[08]
+    nop2                        ;[10]
+bit1IsSet:
+    ifrclr  phase, USBMINUS     ;[12] check phase only if D- changed
+    lpm                         ;[13]
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    ori     shift, 1 << 1       ;[15]
+    nop                         ;[16]
+bit2AfterSet:
+    ifioclr USBIN, USBMINUS     ;[17] <--- sample 2
+    rjmp    bit2IsClr           ;[18]
+    andi    shift, ~(7 << 2)    ;[19]
+    breq    unstuff2s           ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    rjmp    bit3AfterSet        ;[22]
+unstuff2s:
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    andi    fix, ~(1 << 2)      ;[23]
+    nop2                        ;[16]
+    nop2                        ;[18]
+bit2IsClr:
+    ifrset  phase, USBMINUS     ;[20] check phase only if D- changed
+    lpm                         ;[21]
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    ori     shift, 1 << 2       ;[23]
+bit3AfterClr:
+    st      y+, data            ;[24]
+entryAfterClr:
+    ifioset USBIN, USBMINUS     ;[26] <--- sample 3
+    rjmp    bit3IsSet           ;[27]
+    andi    shift, ~(7 << 3)    ;[28]
+    breq    unstuff3c           ;[29]
+    in      phase, USBIN        ;[30] <- phase
+    rjmp    bit4AfterClr        ;[31]
+unstuff3c:
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    andi    fix, ~(1 << 3)      ;[32]
+    nop2                        ;[25]
+    nop2                        ;[27]
+bit3IsSet:
+    ifrclr  phase, USBMINUS     ;[29] check phase only if D- changed
+    lpm                         ;[30]
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    ori     shift, 1 << 3       ;[32]
+bit4AfterSet:
+    mov     data, fix           ;[33] undo this move by swapping defines
+#undef  fix
+#define fix     x1
+#undef  data
+#define data    x2
+    ifioclr USBIN, USBMINUS     ;[34] <--- sample 4
+    rjmp    bit4IsClr           ;[35]
+    andi    shift, ~(7 << 4)    ;[36]
+    breq    unstuff4s           ;[37]
+    in      phase, USBIN        ;[38] <- phase
+    rjmp    bit5AfterSet        ;[39]
+unstuff4s:
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    andi    fix, ~(1 << 4)      ;[40]
+    nop2                        ;[33]
+    nop2                        ;[35]
+bit4IsClr:
+    ifrset  phase, USBMINUS     ;[37] check phase only if D- changed
+    lpm                         ;[38]
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    ori     shift, 1 << 4       ;[40]
+bit5AfterClr:
+    ser     data                ;[41]
+    ifioset USBIN, USBMINUS     ;[42] <--- sample 5
+    rjmp    bit5IsSet           ;[43]
+    andi    shift, ~(7 << 5)    ;[44]
+    breq    unstuff5c           ;[45]
+    in      phase, USBIN        ;[46] <- phase
+    rjmp    bit6AfterClr        ;[47]
+unstuff5c:
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    andi    fix, ~(1 << 5)      ;[48]
+    nop2                        ;[41]
+    nop2                        ;[43]
+bit5IsSet:
+    ifrclr  phase, USBMINUS     ;[45] check phase only if D- changed
+    lpm                         ;[46]
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    ori     shift, 1 << 5       ;[48]
+bit6AfterSet:
+    subi    cnt, 1              ;[49]
+    brcs    jumpToOverflow      ;[50]
+    ifioclr USBIN, USBMINUS     ;[51] <--- sample 6
+    rjmp    bit6IsClr           ;[52]
+    andi    shift, ~(3 << 6)    ;[53]
+    cpi     shift, 2            ;[54]
+    in      phase, USBIN        ;[55] <- phase
+    brlt    unstuff6s           ;[56]
+    rjmp    bit7AfterSet        ;[57]
+
+jumpToOverflow:
+    rjmp    overflow
+
+unstuff6s:
+    andi    fix, ~(1 << 6)      ;[50]
+    lpm                         ;[51]
+bit6IsClr:
+    ifrset  phase, USBMINUS     ;[54] check phase only if D- changed
+    lpm                         ;[55]
+    in      phase, USBIN        ;[56] <- phase (one cycle too late)
+    ori     shift, 1 << 6       ;[57]
+    nop                         ;[58]
+bit7AfterClr:
+    ifioset USBIN, USBMINUS     ;[59] <--- sample 7
+    rjmp    bit7IsSet           ;[60]
+    andi    shift, ~(1 << 7)    ;[61]
+    cpi     shift, 4            ;[62]
+    in      phase, USBIN        ;[63] <- phase
+    brlt    unstuff7c           ;[64]
+    rjmp    bit0AfterClr        ;[65] -> [00] == [67]
+unstuff7c:
+    andi    fix, ~(1 << 7)      ;[58]
+    nop                         ;[59]
+    rjmp    bit7IsSet           ;[60]
+
+bit7IsClr:
+    ifrset  phase, USBMINUS     ;[62] check phase only if D- changed
+    lpm                         ;[63]
+    in      phase, USBIN        ;[64] <- phase (one cycle too late)
+    ori     shift, 1 << 7       ;[65]
+    nop                         ;[66]
+;;;;rjmp    bit0AfterClr        ; -> [00] == [67] moved block up to save jump
+bit0AfterClr:
+    eor     fix, shift          ;[00]
+#undef  fix
+#define fix     x2
+#undef  data
+#define data    x1  /* we now have result in data, fix is reset to 0xff */
+    ifioset USBIN, USBMINUS     ;[01] <--- sample 0
+    rjmp    bit0IsSet           ;[02]
+    andi    shift, ~(7 << 0)    ;[03]
+    breq    unstuff0c           ;[04]
+    in      phase, USBIN        ;[05] <- phase
+    rjmp    bit1AfterClr        ;[06]
+unstuff0c:
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    andi    fix, ~(1 << 0)      ;[07]
+    ifioclr USBIN, USBMINUS     ;[00]
+    ifioset USBIN, USBPLUS      ;[01]
+    rjmp    bit0IsSet           ;[02] executed if first expr false or second true
+    rjmp    se0AndStore         ;[03] executed only if both bits 0
+bit0IsSet:
+    ifrclr  phase, USBMINUS     ;[04] check phase only if D- changed
+    lpm                         ;[05]
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    ori     shift, 1 << 0       ;[07]
+bit1AfterSet:
+    andi    shift, ~(7 << 1)    ;[08] compensated by "ori shift, 1<<1" if bit1IsClr
+    ifioclr USBIN, USBMINUS     ;[09] <--- sample 1
+    rjmp    bit1IsClr           ;[10]
+    breq    unstuff1s           ;[11]
+    nop2                        ;[12] do not check for SE0 if bit 0 was 1
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    rjmp    bit2AfterSet        ;[15]
+unstuff1s:
+    in      phase, USBIN        ;[13] <- phase
+    andi    fix, ~(1 << 1)      ;[14]
+    lpm                         ;[07]
+    nop2                        ;[10]
+bit1IsClr:
+    ifrset  phase, USBMINUS     ;[12] check phase only if D- changed
+    lpm                         ;[13]
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    ori     shift, 1 << 1       ;[15]
+    nop                         ;[16]
+bit2AfterClr:
+    ifioset USBIN, USBMINUS     ;[17] <--- sample 2
+    rjmp    bit2IsSet           ;[18]
+    andi    shift, ~(7 << 2)    ;[19]
+    breq    unstuff2c           ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    rjmp    bit3AfterClr        ;[22]
+unstuff2c:
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    andi    fix, ~(1 << 2)      ;[23]
+    nop2                        ;[16]
+    nop2                        ;[18]
+bit2IsSet:
+    ifrclr  phase, USBMINUS     ;[20] check phase only if D- changed
+    lpm                         ;[21]
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    ori     shift, 1 << 2       ;[23]
+bit3AfterSet:
+    st      y+, data            ;[24]
+entryAfterSet:
+    ifioclr USBIN, USBMINUS     ;[26] <--- sample 3
+    rjmp    bit3IsClr           ;[27]
+    andi    shift, ~(7 << 3)    ;[28]
+    breq    unstuff3s           ;[29]
+    in      phase, USBIN        ;[30] <- phase
+    rjmp    bit4AfterSet        ;[31]
+unstuff3s:
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    andi    fix, ~(1 << 3)      ;[32]
+    nop2                        ;[25]
+    nop2                        ;[27]
+bit3IsClr:
+    ifrset  phase, USBMINUS     ;[29] check phase only if D- changed
+    lpm                         ;[30]
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    ori     shift, 1 << 3       ;[32]
+bit4AfterClr:
+    mov     data, fix           ;[33] undo this move by swapping defines
+#undef  fix
+#define fix     x1
+#undef  data
+#define data    x2
+    ifioset USBIN, USBMINUS     ;[34] <--- sample 4
+    rjmp    bit4IsSet           ;[35]
+    andi    shift, ~(7 << 4)    ;[36]
+    breq    unstuff4c           ;[37]
+    in      phase, USBIN        ;[38] <- phase
+    rjmp    bit5AfterClr        ;[39]
+unstuff4c:
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    andi    fix, ~(1 << 4)      ;[40]
+    nop2                        ;[33]
+    nop2                        ;[35]
+bit4IsSet:
+    ifrclr  phase, USBMINUS     ;[37] check phase only if D- changed
+    lpm                         ;[38]
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    ori     shift, 1 << 4       ;[40]
+bit5AfterSet:
+    ser     data                ;[41]
+    ifioclr USBIN, USBMINUS     ;[42] <--- sample 5
+    rjmp    bit5IsClr           ;[43]
+    andi    shift, ~(7 << 5)    ;[44]
+    breq    unstuff5s           ;[45]
+    in      phase, USBIN        ;[46] <- phase
+    rjmp    bit6AfterSet        ;[47]
+unstuff5s:
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    andi    fix, ~(1 << 5)      ;[48]
+    nop2                        ;[41]
+    nop2                        ;[43]
+bit5IsClr:
+    ifrset  phase, USBMINUS     ;[45] check phase only if D- changed
+    lpm                         ;[46]
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    ori     shift, 1 << 5       ;[48]
+bit6AfterClr:
+    subi    cnt, 1              ;[49]
+    brcs    overflow            ;[50]
+    ifioset USBIN, USBMINUS     ;[51] <--- sample 6
+    rjmp    bit6IsSet           ;[52]
+    andi    shift, ~(3 << 6)    ;[53]
+    cpi     shift, 2            ;[54]
+    in      phase, USBIN        ;[55] <- phase
+    brlt    unstuff6c           ;[56]
+    rjmp    bit7AfterClr        ;[57]
+unstuff6c:
+    andi    fix, ~(1 << 6)      ;[50]
+    lpm                         ;[51]
+bit6IsSet:
+    ifrclr  phase, USBMINUS     ;[54] check phase only if D- changed
+    lpm                         ;[55]
+    in      phase, USBIN        ;[56] <- phase (one cycle too late)
+    ori     shift, 1 << 6       ;[57]
+bit7AfterSet:
+    ifioclr USBIN, USBMINUS     ;[59] <--- sample 7
+    rjmp    bit7IsClr           ;[60]
+    andi    shift, ~(1 << 7)    ;[61]
+    cpi     shift, 4            ;[62]
+    in      phase, USBIN        ;[63] <- phase
+    brlt    unstuff7s           ;[64]
+    rjmp    bit0AfterSet        ;[65] -> [00] == [67]
+unstuff7s:
+    andi    fix, ~(1 << 7)      ;[58]
+    nop                         ;[59]
+    rjmp    bit7IsClr           ;[60]
+
+macro POP_STANDARD ; 14 cycles
+    pop     r0
+    pop     cnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;----------------------------------------------------------------------------
+; Transmitting data
+;----------------------------------------------------------------------------
+
+txByteLoop:
+txBitloop:
+stuffN1Delay:                   ;     [03]
+    ror     shift               ;[-5] [11] [63]
+    brcc    doExorN1            ;[-4]      [64]
+    subi    x3, 1               ;[-3]
+    brne    commonN1            ;[-2]
+    lsl     shift               ;[-1] compensate ror after rjmp stuffDelay
+    nop                         ;[00] stuffing consists of just waiting 8 cycles
+    rjmp    stuffN1Delay        ;[01] after ror, C bit is reliably clear
+
+sendNakAndReti:
+    ldi     cnt, USBPID_NAK ;[-19]
+    rjmp    sendCntAndReti  ;[-18]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     r0, cnt         ;[-16]
+    ldi     YL, 0           ;[-15] R0 address is 0
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
+; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
+; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte
+;uses: x1...x3, shift, cnt, Y [x1 = mirror USBOUT, x2 = USBMASK, x3 = bitstuff cnt]
+;Numbers in brackets are time since first bit of sync pattern is sent (start of instruction)
+usbSendAndReti:
+    in      x2, USBDDR          ;[-10] 10 cycles until SOP
+    ori     x2, USBMASK         ;[-9]
+    sbi     USBOUT, USBMINUS    ;[-8] prepare idle state; D+ and D- must have been 0 (no pullups)
+    out     USBDDR, x2          ;[-6] <--- acquire bus
+    in      x1, USBOUT          ;[-5] port mirror for tx loop
+    ldi     shift, 0x40         ;[-4] sync byte is first byte sent (we enter loop after ror)
+    ldi     x2, USBMASK         ;[-3]
+doExorN1:
+    eor     x1, x2              ;[-2] [06] [62]
+    ldi     x3, 6               ;[-1] [07] [63]
+commonN1:
+stuffN2Delay:
+    out     USBOUT, x1          ;[00] [08] [64] <--- set bit
+    ror     shift               ;[01]
+    brcc    doExorN2            ;[02]
+    subi    x3, 1               ;[03]
+    brne    commonN2            ;[04]
+    lsl     shift               ;[05] compensate ror after rjmp stuffDelay
+    rjmp    stuffN2Delay        ;[06] after ror, C bit is reliably clear
+doExorN2:
+    eor     x1, x2              ;[04] [12]
+    ldi     x3, 6               ;[05] [13]
+commonN2:
+    nop2                        ;[06] [14]
+    subi    cnt, 171            ;[08] [16] trick: (3 * 171) & 0xff = 1
+    out     USBOUT, x1          ;[09] [17] <--- set bit
+    brcs    txBitloop           ;[10]      [27] [44]
+
+stuff6Delay:
+    ror     shift               ;[45] [53]
+    brcc    doExor6             ;[46]
+    subi    x3, 1               ;[47]
+    brne    common6             ;[48]
+    lsl     shift               ;[49] compensate ror after rjmp stuffDelay
+    nop                         ;[50] stuffing consists of just waiting 8 cycles
+    rjmp    stuff6Delay         ;[51] after ror, C bit is reliably clear
+doExor6:
+    eor     x1, x2              ;[48] [56]
+    ldi     x3, 6               ;[49]
+common6:
+stuff7Delay:
+    ror     shift               ;[50] [58]
+    out     USBOUT, x1          ;[51] <--- set bit
+    brcc    doExor7             ;[52]
+    subi    x3, 1               ;[53]
+    brne    common7             ;[54]
+    lsl     shift               ;[55] compensate ror after rjmp stuffDelay
+    rjmp    stuff7Delay         ;[56] after ror, C bit is reliably clear
+doExor7:
+    eor     x1, x2              ;[54] [62]
+    ldi     x3, 6               ;[55]
+common7:
+    ld      shift, y+           ;[56]
+    nop                         ;[58]
+    tst     cnt                 ;[59]
+    out     USBOUT, x1          ;[60] [00]<--- set bit
+    brne    txByteLoop          ;[61] [01]
+;make SE0:
+    cbr     x1, USBMASK         ;[02] prepare SE0 [spec says EOP may be 15 to 18 cycles]
+    lds     x2, usbNewDeviceAddr;[03]
+    lsl     x2                  ;[05] we compare with left shifted address
+    subi    YL, 2 + 0           ;[06] Only assign address on data packets, not ACK/NAK in r0
+    sbci    YH, 0               ;[07]
+    out     USBOUT, x1          ;[00] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign      ;[01]
+    sts     usbDeviceAddr, x2   ; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[03] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)       ;[04]
+    ori     x1, USBIDLE         ;[05]
+    in      x2, USBDDR          ;[06]
+    cbr     x2, USBMASK         ;[07] set both pins to input
+    mov     x3, x1              ;[08]
+    cbr     x3, USBMASK         ;[09] configure no pullup on both pins
+    lpm                         ;[10]
+    lpm                         ;[13]
+    out     USBOUT, x1          ;[16] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2          ;[17] <-- release bus now
+    out     USBOUT, x3          ;[18] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
+
+
+/*****************************************************************************
+The following PHP script generates a code skeleton for the receiver routine:
+
+<?php
+
+function printCmdBuffer($thisBit)
+{
+global $cycle;
+
+    $nextBit = ($thisBit + 1) % 8;
+    $s = ob_get_contents();
+    ob_end_clean();
+    $s = str_replace("#", $thisBit, $s);
+    $s = str_replace("@", $nextBit, $s);
+    $lines = explode("\n", $s);
+    for($i = 0; $i < count($lines); $i++){
+        $s = $lines[$i];
+        if(ereg("\\[([0-9-][0-9])\\]", $s, $regs)){
+            $c = $cycle + (int)$regs[1];
+            $s = ereg_replace("\\[[0-9-][0-9]\\]", sprintf("[%02d]", $c), $s);
+        }
+        if(strlen($s) > 0)
+            echo "$s\n";
+    }
+}
+
+function printBit($isAfterSet, $bitNum)
+{
+    ob_start();
+    if($isAfterSet){
+?>
+    ifioclr USBIN, USBMINUS     ;[00] <--- sample
+    rjmp    bit#IsClr           ;[01]
+    andi    shift, ~(7 << #)    ;[02]
+    breq    unstuff#s           ;[03]
+    in      phase, USBIN        ;[04] <- phase
+    rjmp    bit@AfterSet        ;[05]
+unstuff#s:
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    andi    fix, ~(1 << #)      ;[06]
+    nop2                        ;[-1]
+    nop2                        ;[01]
+bit#IsClr:
+    ifrset  phase, USBMINUS     ;[03] check phase only if D- changed
+    lpm                         ;[04]
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    ori     shift, 1 << #       ;[06]
+<?php
+    }else{
+?>
+    ifioset USBIN, USBMINUS     ;[00] <--- sample
+    rjmp    bit#IsSet           ;[01]
+    andi    shift, ~(7 << #)    ;[02]
+    breq    unstuff#c           ;[03]
+    in      phase, USBIN        ;[04] <- phase
+    rjmp    bit@AfterClr        ;[05]
+unstuff#c:
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    andi    fix, ~(1 << #)      ;[06]
+    nop2                        ;[-1]
+    nop2                        ;[01]
+bit#IsSet:
+    ifrclr  phase, USBMINUS     ;[03] check phase only if D- changed
+    lpm                         ;[04]
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    ori     shift, 1 << #       ;[06]
+<?php
+    }
+    printCmdBuffer($bitNum);
+}
+
+$bitStartCycles = array(1, 9, 17, 26, 34, 42, 51, 59);
+for($i = 0; $i < 16; $i++){
+    $bit = $i % 8;
+    $emitClrCode = ($i + (int)($i / 8)) % 2;
+    $cycle = $bitStartCycles[$bit];
+    if($emitClrCode){
+        printf("bit%dAfterClr:\n", $bit);
+    }else{
+        printf("bit%dAfterSet:\n", $bit);
+    }
+    ob_start();
+    echo "    *****                       ;[-1]\n";
+    printCmdBuffer($bit);
+    printBit(!$emitClrCode, $bit);
+    if($i == 7)
+        echo "\n";
+}
+
+?>
+*****************************************************************************/
Index: vusb-20121206/usbdrv/usbdrvasm15.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm15.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm15.inc	(working copy)
@@ -0,0 +1,422 @@
+/* Name: usbdrvasm15.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: contributed by V. Bosch
+ * Creation Date: 2007-08-06
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 15 MHz version of the asssembler part of the USB driver. It
+requires a 15 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 15 MHz -> 10.0 cycles per bit, 80.0 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+;----------------------------------------------------------------------------
+; order of registers pushed: 
+;	YL, SREG [sofError] YH, shift, x1, x2, x3, bitcnt, cnt, x4
+;----------------------------------------------------------------------------
+USB_INTR_VECTOR:              
+    push    YL                   ;2 	push only what is necessary to sync with edge ASAP
+    in      YL, SREG             ;1 
+    push    YL                   ;2 
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;
+;   sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;   sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+;-------------------------------------------------------------------------------
+; The following code results in a sampling window of < 1/4 bit 
+;	which meets the spec.
+;-------------------------------------------------------------------------------
+waitForK:			 ;- 
+    sbis    USBIN, USBMINUS      ;1 [00] <-- sample
+    rjmp    foundK               ;2 [01]
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+;------------------------------------------------------------------------------
+; {3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for 
+;	center sampling] 
+; 	we have 1 bit time for setup purposes, then sample again. 
+;	Numbers in brackets are cycles from center of first sync (double K) 
+;	bit after the instruction
+;------------------------------------------------------------------------------
+foundK:                          ;- [02]
+    lds     YL, usbInputBufOffset;2 [03+04]	tx loop
+    push    YH                   ;2 [05+06]
+    clr     YH                   ;1 [07]
+    subi    YL, lo8(-(usbRxBuf)) ;1 [08] 	[rx loop init]
+    sbci    YH, hi8(-(usbRxBuf)) ;1 [09] 	[rx loop init]
+    push    shift                ;2 [10+11]
+    ser	    shift		 ;1 [12]
+    sbis    USBIN, USBMINUS      ;1 [-1] [13] <--sample:we want two bits K (sample 1 cycle too early)
+    rjmp    haveTwoBitsK         ;2 [00] [14]
+    pop     shift                ;2 	 [15+16] undo the push from before
+    pop     YH 			 ;2 	 [17+18] undo the push from before
+    rjmp    waitForK             ;2 	 [19+20] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 20 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:			;- [01]
+    push    x1              	;2 [02+03]
+    push    x2              	;2 [04+05]
+    push    x3              	;2 [06+07]
+    push    bitcnt              ;2 [08+09]	
+    in      x1, USBIN       	;1 [00] [10] <-- sample bit 0
+    bst     x1, USBMINUS    	;1 [01]
+    bld     shift, 0        	;1 [02]
+    push    cnt             	;2 [03+04]
+    ldi     cnt, USB_BUFSIZE	;1 [05] 
+    push    x4              	;2 [06+07] tx loop
+    rjmp    rxLoop          	;2 [08]
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+unstuff0:               	;- [07] (branch taken)
+    andi    x3, ~0x01   	;1 [08]
+    mov     x1, x2      	;1 [09] x2 contains last sampled (stuffed) bit
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 1 again
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 1 
+    ori     shift, 0x01 	;1 [03] 0b00000001
+    nop				;1 [04]
+    rjmp    didUnstuff0 	;2 [05]
+;-----------------------------------------------------
+unstuff1:               	;- [05] (branch taken)
+    mov     x2, x1      	;1 [06] x1 contains last sampled (stuffed) bit
+    andi    x3, ~0x02   	;1 [07]
+    ori     shift, 0x02 	;1 [08] 0b00000010
+    nop                 	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 2 again
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 2 
+    rjmp    didUnstuff1 	;2 [03]
+;-----------------------------------------------------
+unstuff2:               	;- [05] (branch taken)
+    andi    x3, ~0x04   	;1 [06]
+    ori     shift, 0x04 	;1 [07] 0b00000100
+    mov     x1, x2      	;1 [08] x2 contains last sampled (stuffed) bit
+    nop                 	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 3
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 3 
+    rjmp    didUnstuff2 	;2 [03]
+;-----------------------------------------------------
+unstuff3:               	;- [00] [10]  (branch taken)
+    in      x2, USBIN   	;1 [01] [11] <-- sample stuffed bit 3 one cycle too late
+    andi    x2, USBMASK 	;1 [02]
+    breq    se0Hop         	;1 [03] SE0 check for stuffed bit 3 
+    andi    x3, ~0x08   	;1 [04]
+    ori     shift, 0x08 	;1 [05] 0b00001000
+    rjmp    didUnstuff3 	;2 [06]
+;----------------------------------------------------------------------------
+; extra jobs done during bit interval:
+;
+; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs], 
+; 		overflow check, jump to the head of rxLoop
+; bit 1:    SE0 check
+; bit 2:    SE0 check, recovery from delay [bit 0 tasks took too long]
+; bit 3:    SE0 check, recovery from delay [bit 0 tasks took too long]
+; bit 4:    SE0 check, none
+; bit 5:    SE0 check, none
+; bit 6:    SE0 check, none
+; bit 7:    SE0 check, reconstruct: x3 is 0 at bit locations we changed, 1 at others
+;----------------------------------------------------------------------------
+rxLoop:				;- [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 1 (or possibly bit 0 stuffed)
+    andi    x2, USBMASK 	;1 [01]
+    brne    SkipSe0Hop		;1 [02]
+se0Hop:				;- [02]
+    rjmp    se0         	;2 [03] SE0 check for bit 1 
+SkipSe0Hop:			;- [03]
+    ser     x3          	;1 [04]
+    andi    shift, 0xf9 	;1 [05] 0b11111001
+    breq    unstuff0    	;1 [06]
+didUnstuff0:			;- [06]
+    eor     x1, x2      	;1 [07]
+    bst     x1, USBMINUS	;1 [08]
+    bld     shift, 1    	;1 [09] 
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 2 (or possibly bit 1 stuffed)
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 2 
+    andi    shift, 0xf3 	;1 [03] 0b11110011
+    breq    unstuff1    	;1 [04] do remaining work for bit 1
+didUnstuff1:			;- [04]
+    eor     x2, x1      	;1 [05]
+    bst     x2, USBMINUS	;1 [06]
+    bld     shift, 2    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 3 (or possibly bit 2 stuffed)
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 3 
+    andi    shift, 0xe7 	;1 [03] 0b11100111
+    breq    unstuff2    	;1 [04]
+didUnstuff2:			;- [04]
+    eor     x1, x2      	;1 [05]
+    bst     x1, USBMINUS	;1 [06]
+    bld     shift, 3    	;1 [07]
+didUnstuff3:			;- [07]
+    andi    shift, 0xcf 	;1 [08] 0b11001111
+    breq    unstuff3    	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 4
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 4
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 4    	;1 [05]
+didUnstuff4:			;- [05]
+    andi    shift, 0x9f 	;1 [06] 0b10011111
+    breq    unstuff4    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 5
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 5
+    eor     x1, x2      	;1 [03]
+    bst     x1, USBMINUS	;1 [04]
+    bld     shift, 5    	;1 [05]
+didUnstuff5:			;- [05]
+    andi    shift, 0x3f 	;1 [06] 0b00111111
+    breq    unstuff5    	;1 [07]
+    nop2			;2 [08+09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 6
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 6
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 6   	 	;1 [05]
+didUnstuff6:			;- [05]
+    cpi     shift, 0x02 	;1 [06] 0b00000010
+    brlo    unstuff6    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 7
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 7
+    eor     x1, x2      	;1 [03]
+    bst     x1, USBMINUS	;1 [04]
+    bld     shift, 7    	;1 [05]
+didUnstuff7:			;- [05] 
+    cpi     shift, 0x04 	;1 [06] 0b00000100
+    brlo    unstuff7		;1 [07]
+    eor     x3, shift   	;1 [08] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    nop				;1 [09]
+    in      x1, USBIN   	;1 [00]	[10] <-- sample bit 0
+    st      y+, x3      	;2 [01+02] store data
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 0    	;1 [05]
+    subi    cnt, 1		;1 [06]
+    brcs    overflow	;1 [07]
+    rjmp    rxLoop		;2 [08]
+;-----------------------------------------------------
+unstuff4:               	;- [08] 
+    andi    x3, ~0x10   	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample stuffed bit 4
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 4
+    ori     shift, 0x10 	;1 [03]
+    rjmp    didUnstuff4 	;2 [04]
+;-----------------------------------------------------
+unstuff5:               	;- [08] 
+    ori     shift, 0x20 	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample stuffed bit 5
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 5
+    andi    x3, ~0x20   	;1 [03]
+    rjmp    didUnstuff5		;2 [04]
+;-----------------------------------------------------
+unstuff6:               	;- [08] 
+    andi    x3, ~0x40   	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample stuffed bit 6
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 6
+    ori     shift, 0x40 	;1 [03]
+    rjmp    didUnstuff6 	;2 [04]
+;-----------------------------------------------------
+unstuff7:			;- [08]
+    andi    x3, ~0x80   	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample stuffed bit 7
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 7
+    ori     shift, 0x80 	;1 [03]
+    rjmp    didUnstuff7 	;2 [04]
+    
+macro POP_STANDARD ; 16 cycles
+    pop     x4    
+    pop     cnt
+    pop     bitcnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;---------------------------------------------------------------------------
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+;---------------------------------------------------------------------------
+bitstuffN:		    	;- [04]
+    eor     x1, x4          	;1 [05]
+    clr	    x2			;1 [06]
+    nop				;1 [07]
+    rjmp    didStuffN       	;1 [08]
+;---------------------------------------------------------------------------    
+bitstuff6:		    	;- [04]
+    eor     x1, x4          	;1 [05]
+    clr	    x2			;1 [06]
+    rjmp    didStuff6       	;1 [07]
+;---------------------------------------------------------------------------
+bitstuff7:		    	;- [02]
+    eor     x1, x4          	;1 [03]
+    clr	    x2			;1 [06]
+    nop			    	;1 [05]
+    rjmp    didStuff7       	;1 [06]
+;---------------------------------------------------------------------------
+sendNakAndReti:			;- [-19]
+    ldi     x3, USBPID_NAK  	;1 [-18]
+    rjmp    sendX3AndReti   	;1 [-17]
+;---------------------------------------------------------------------------
+sendAckAndReti:			;- [-17]
+    ldi     cnt, USBPID_ACK 	;1 [-16]
+sendCntAndReti:			;- [-16]
+    mov     x3, cnt         	;1 [-15]
+sendX3AndReti:			;- [-15]
+    ldi     YL, 20          	;1 [-14] x3==r20 address is 20
+    ldi     YH, 0           	;1 [-13]
+    ldi     cnt, 2          	;1 [-12]
+;   rjmp    usbSendAndReti      fallthrough
+;---------------------------------------------------------------------------
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We need not to match the transfer rate exactly because the spec demands 
+;only 1.5% precision anyway.
+usbSendAndReti:             	;- [-13] 13 cycles until SOP
+    in      x2, USBDDR      	;1 [-12]
+    ori     x2, USBMASK     	;1 [-11]
+    sbi     USBOUT, USBMINUS	;2 [-09-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      	;1 [-08] port mirror for tx loop
+    out     USBDDR, x2      	;1 [-07] <- acquire bus
+	; need not init x2 (bitstuff history) because sync starts with 0 
+    ldi     x4, USBMASK     	;1 [-06] 	exor mask
+    ldi     shift, 0x80     	;1 [-05] 	sync byte is first byte sent
+    ldi     bitcnt, 6    	;1 [-04] 
+txBitLoop:		    	;- [-04] [06]
+    sbrs    shift, 0        	;1 [-03] [07]
+    eor     x1, x4          	;1 [-02] [08] 
+    ror     shift           	;1 [-01] [09]  
+didStuffN:		    	;-       [09]
+    out     USBOUT, x1      	;1 [00]  [10] <-- out N
+    ror     x2              	;1 [01]
+    cpi     x2, 0xfc        	;1 [02]
+    brcc    bitstuffN       	;1 [03]
+    dec     bitcnt          	;1 [04]
+    brne    txBitLoop       	;1 [05]
+    sbrs    shift, 0        	;1 [06]
+    eor     x1, x4          	;1 [07]
+    ror     shift           	;1 [08]
+didStuff6:			;- [08]
+    nop				;1 [09]
+    out     USBOUT, x1      	;1 [00] [10] <-- out 6
+    ror     x2              	;1 [01] 
+    cpi     x2, 0xfc        	;1 [02]
+    brcc    bitstuff6       	;1 [03]
+    sbrs    shift, 0        	;1 [04]
+    eor     x1, x4          	;1 [05]
+    ror     shift           	;1 [06]
+    ror     x2              	;1 [07]
+didStuff7:			;- [07]
+    ldi     bitcnt, 6    	;1 [08]
+    cpi     x2, 0xfc        	;1 [09]
+    out     USBOUT, x1      	;1 [00] [10] <-- out 7
+    brcc    bitstuff7       	;1 [01]
+    ld      shift, y+       	;2 [02+03]
+    dec     cnt             	;1 [04]
+    brne    txBitLoop      	;1 [05]
+makeSE0:
+    cbr     x1, USBMASK     	;1 [06] 	prepare SE0 [spec says EOP may be 19 to 23 cycles]
+    lds     x2, usbNewDeviceAddr;2 [07+08]
+    lsl     x2                  ;1 [09] we compare with left shifted address
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    out     USBOUT, x1      	;1 [00] [10] <-- out SE0-- from now 2 bits==20 cycl. until bus idle
+    subi    YL, 20 + 2          ;1 [01] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           	;1 [02]
+    breq    skipAddrAssign  	;1 [03]
+    sts     usbDeviceAddr, x2	;2 [04+05] if not skipped: SE0 is one cycle longer
+;----------------------------------------------------------------------------
+;end of usbDeviceAddress transfer
+skipAddrAssign:				;- [03/04]
+    ldi     x2, 1<<USB_INTR_PENDING_BIT	;1 [05] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)           ;1 [06]
+    ori     x1, USBIDLE     		;1 [07]
+    in      x2, USBDDR      		;1 [08]
+    cbr     x2, USBMASK     		;1 [09] set both pins to input
+    mov     x3, x1          		;1 [10]
+    cbr     x3, USBMASK     		;1 [11] configure no pullup on both pins
+    ldi     x4, 3           		;1 [12]
+se0Delay:				;- [12] [15] 
+    dec     x4              		;1 [13] [16] 
+    brne    se0Delay        		;1 [14] [17] 
+    nop2				;2      [18+19]
+    out     USBOUT, x1      		;1      [20] <--out J (idle) -- end of SE0 (EOP sig.)
+    out     USBDDR, x2      		;1      [21] <--release bus now
+    out     USBOUT, x3      		;1      [22] <--ensure no pull-up resistors are active
+    rjmp    doReturn			;1	[23]
+;---------------------------------------------------------------------------
Index: vusb-20121206/usbdrv/usbdrvasm16.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm16.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm16.inc	(working copy)
@@ -0,0 +1,345 @@
+/* Name: usbdrvasm16.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-15
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 16 MHz version of the asssembler part of the USB driver. It
+requires a 16 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 16 MHz -> 10.6666666 cycles per bit, 85.333333333 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-25] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-23]
+    push    YL                  ;[-22]
+    push    YH                  ;[-20]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-15]
+    rjmp    foundK              ;[-14]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-12]
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    bitcnt              ;[-12]
+;   [---]                       ;[-11]
+    lds     YL, usbInputBufOffset;[-10]
+;   [---]                       ;[-9]
+    clr     YH                  ;[-8]
+    subi    YL, lo8(-(usbRxBuf));[-7] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-6] [rx loop init]
+    push    shift               ;[-5]
+;   [---]                       ;[-4]
+    ldi     bitcnt, 0x55        ;[-3] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-2] we want two bits K (sample 2 cycles too early)
+    rjmp    haveTwoBitsK        ;[-1]
+    pop     shift               ;[0] undo the push from before
+    pop     bitcnt              ;[2] undo the push from before
+    rjmp    waitForK            ;[4] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 21 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1              ;[1]
+    push    x2              ;[3]
+    push    x3              ;[5]
+    ldi     shift, 0        ;[7]
+    ldi     x3, 1<<4        ;[8] [rx loop init] first sample is inverse bit, compensate that
+    push    x4              ;[9] == leap
+
+    in      x1, USBIN       ;[11] <-- sample bit 0
+    andi    x1, USBMASK     ;[12]
+    bst     x1, USBMINUS    ;[13]
+    bld     shift, 7        ;[14]
+    push    cnt             ;[15]
+    ldi     leap, 0         ;[17] [rx loop init]
+    ldi     cnt, USB_BUFSIZE;[18] [rx loop init]
+    rjmp    rxbit1          ;[19] arrives at [21]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+
+; duration of unstuffing code should be 10.66666667 cycles. We adjust "leap"
+; accordingly to approximate this value in the long run.
+
+unstuff6:
+    andi    x2, USBMASK ;[03]
+    ori     x3, 1<<6    ;[04] will not be shifted any more
+    andi    shift, ~0x80;[05]
+    mov     x1, x2      ;[06] sampled bit 7 is actually re-sampled bit 6
+    subi    leap, -1    ;[07] total duration = 11 bits -> subtract 1/3
+    rjmp    didUnstuff6 ;[08]
+
+unstuff7:
+    ori     x3, 1<<7    ;[09] will not be shifted any more
+    in      x2, USBIN   ;[00] [10]  re-sample bit 7
+    andi    x2, USBMASK ;[01]
+    andi    shift, ~0x80;[02]
+    subi    leap, 2     ;[03] total duration = 10 bits -> add 1/3
+    rjmp    didUnstuff7 ;[04]
+
+unstuffEven:
+    ori     x3, 1<<6    ;[09] will be shifted right 6 times for bit 0
+    in      x1, USBIN   ;[00] [10]
+    andi    shift, ~0x80;[01]
+    andi    x1, USBMASK ;[02]
+    breq    se0         ;[03]
+    subi    leap, -1    ;[04] total duration = 11 bits -> subtract 1/3
+    nop2                ;[05]
+    rjmp    didUnstuffE ;[06]
+
+unstuffOdd:
+    ori     x3, 1<<5    ;[09] will be shifted right 4 times for bit 1
+    in      x2, USBIN   ;[00] [10]
+    andi    shift, ~0x80;[01]
+    andi    x2, USBMASK ;[02]
+    breq    se0         ;[03]
+    subi    leap, -1    ;[04] total duration = 11 bits -> subtract 1/3
+    nop2                ;[05]
+    rjmp    didUnstuffO ;[06]
+
+rxByteLoop:
+    andi    x1, USBMASK ;[03]
+    eor     x2, x1      ;[04]
+    subi    leap, 1     ;[05]
+    brpl    skipLeap    ;[06]
+    subi    leap, -3    ;1 one leap cycle every 3rd byte -> 85 + 1/3 cycles per byte
+    nop                 ;1
+skipLeap:
+    subi    x2, 1       ;[08]
+    ror     shift       ;[09]
+didUnstuff6:
+    cpi     shift, 0xfc ;[10]
+    in      x2, USBIN   ;[00] [11] <-- sample bit 7
+    brcc    unstuff6    ;[01]
+    andi    x2, USBMASK ;[02]
+    eor     x1, x2      ;[03]
+    subi    x1, 1       ;[04]
+    ror     shift       ;[05]
+didUnstuff7:
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuff7    ;[07]
+    eor     x3, shift   ;[08] reconstruct: x3 is 1 at bit locations we changed, 0 at others
+    st      y+, x3      ;[09] store data
+rxBitLoop:
+    in      x1, USBIN   ;[00] [11] <-- sample bit 0/2/4
+    andi    x1, USBMASK ;[01]
+    eor     x2, x1      ;[02]
+    andi    x3, 0x3f    ;[03] topmost two bits reserved for 6 and 7
+    subi    x2, 1       ;[04]
+    ror     shift       ;[05]
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuffEven ;[07]
+didUnstuffE:
+    lsr     x3          ;[08]
+    lsr     x3          ;[09]
+rxbit1:
+    in      x2, USBIN   ;[00] [10] <-- sample bit 1/3/5
+    andi    x2, USBMASK ;[01]
+    breq    se0         ;[02]
+    eor     x1, x2      ;[03]
+    subi    x1, 1       ;[04]
+    ror     shift       ;[05]
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuffOdd  ;[07]
+didUnstuffO:
+    subi    bitcnt, 0xab;[08] == addi 0x55, 0x55 = 0x100/3
+    brcs    rxBitLoop   ;[09]
+
+    subi    cnt, 1      ;[10]
+    in      x1, USBIN   ;[00] [11] <-- sample bit 6
+    brcc    rxByteLoop  ;[01]
+    rjmp    overflow
+
+macro POP_STANDARD ; 14 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     bitcnt
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+
+bitstuffN:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6]
+    nop2                    ;[7]
+    nop                     ;[9]
+    out     USBOUT, x1      ;[10] <-- out
+    rjmp    didStuffN       ;[0]
+    
+bitstuff6:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6] Carry is zero due to brcc
+    rol     shift           ;[7] compensate for ror shift at branch destination
+    rjmp    didStuff6       ;[8]
+
+bitstuff7:
+    ldi     x2, 0           ;[2] Carry is zero due to brcc
+    rjmp    didStuff7       ;[3]
+
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We don't match the transfer rate exactly (don't insert leap cycles every third
+;byte) because the spec demands only 1.5% precision anyway.
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x35    ;[-4] [6] binary 0011 0101
+txBitLoop:
+    sbrs    shift, 0        ;[-3] [7]
+    eor     x1, x4          ;[-2] [8]
+    out     USBOUT, x1      ;[-1] [9] <-- out N
+    ror     shift           ;[0] [10]
+    ror     x2              ;[1]
+didStuffN:
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuffN       ;[3]
+    lsr     bitcnt          ;[4]
+    brcc    txBitLoop       ;[5]
+    brne    txBitLoop       ;[6]
+
+    sbrs    shift, 0        ;[7]
+    eor     x1, x4          ;[8]
+didStuff6:
+    out     USBOUT, x1      ;[-1] [9] <-- out 6
+    ror     shift           ;[0] [10]
+    ror     x2              ;[1]
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuff6       ;[3]
+    ror     shift           ;[4]
+didStuff7:
+    ror     x2              ;[5]
+    sbrs    x2, 7           ;[6]
+    eor     x1, x4          ;[7]
+    nop                     ;[8]
+    cpi     x2, 0xfc        ;[9]
+    out     USBOUT, x1      ;[-1][10] <-- out 7
+    brcc    bitstuff7       ;[0] [11]
+    ld      shift, y+       ;[1]
+    dec     cnt             ;[3]
+    brne    txByteLoop      ;[4]
+;make SE0:
+    cbr     x1, USBMASK     ;[5] prepare SE0 [spec says EOP may be 21 to 25 cycles]
+    lds     x2, usbNewDeviceAddr;[6]
+    lsl     x2              ;[8] we compare with left shifted address
+    subi    YL, 20 + 2      ;[9] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[10]
+    out     USBOUT, x1      ;[11] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[0]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[2] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[3]
+    ori     x1, USBIDLE     ;[4]
+    in      x2, USBDDR      ;[5]
+    cbr     x2, USBMASK     ;[6] set both pins to input
+    mov     x3, x1          ;[7]
+    cbr     x3, USBMASK     ;[8] configure no pullup on both pins
+    ldi     x4, 4           ;[9]
+se0Delay:
+    dec     x4              ;[10] [13] [16] [19]
+    brne    se0Delay        ;[11] [14] [17] [20]
+    out     USBOUT, x1      ;[21] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[22] <-- release bus now
+    out     USBOUT, x3      ;[23] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: vusb-20121206/usbdrv/usbdrvasm165.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm165.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm165.inc	(working copy)
@@ -0,0 +1,452 @@
+/* Name: usbdrvasm165.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-04-22
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 16.5 MHz version of the USB driver. It is intended for the
+ATTiny45 and similar controllers running on 16.5 MHz internal RC oscillator.
+This version contains a phase locked loop in the receiver routine to cope with
+slight clock rate deviations of up to +/- 1%.
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
+;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
+;max allowable interrupt latency: 59 cycles -> max 52 cycles interrupt disable
+;max stack usage: [ret(2), r0, SREG, YL, YH, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 16.5 MHz -> 11 cycles per bit
+; 16.3125 MHz < F_CPU < 16.6875 MHz (+/- 1.1%)
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], r0, YH, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-23] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-21]
+    push    YL                  ;[-20]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-15]
+    rjmp    foundK              ;[-14]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-12]
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    r0                  ;[-12]
+;   [---]                       ;[-11]
+    push    YH                  ;[-10]
+;   [---]                       ;[-9]
+    lds     YL, usbInputBufOffset;[-8]
+;   [---]                       ;[-7]
+    clr     YH                  ;[-6]
+    subi    YL, lo8(-(usbRxBuf));[-5] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-4] [rx loop init]
+    mov     r0, x2              ;[-3] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-2] we want two bits K (sample 2 cycles too early)
+    rjmp    haveTwoBitsK        ;[-1]
+    pop     YH                  ;[0] undo the pushes from before
+    pop     r0                  ;[2]
+    rjmp    waitForK            ;[4] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 22 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:               ;[1]
+    push    shift           ;[1]
+    push    x1              ;[3]
+    push    x2              ;[5]
+    push    x3              ;[7]
+    ldi     shift, 0xff     ;[9] [rx loop init]
+    ori     x3, 0xff        ;[10] [rx loop init] == ser x3, clear zero flag
+
+    in      x1, USBIN       ;[11] <-- sample bit 0
+    bst     x1, USBMINUS    ;[12]
+    bld     shift, 0        ;[13]
+    push    x4              ;[14] == phase
+;   [---]                   ;[15]
+    push    cnt             ;[16]
+;   [---]                   ;[17]
+    ldi     phase, 0        ;[18] [rx loop init]
+    ldi     cnt, USB_BUFSIZE;[19] [rx loop init]
+    rjmp    rxbit1          ;[20]
+;   [---]                   ;[21]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+/*
+byte oriented operations done during loop:
+bit 0: store data
+bit 1: SE0 check
+bit 2: overflow check
+bit 3: catch up
+bit 4: rjmp to achieve conditional jump range
+bit 5: PLL
+bit 6: catch up
+bit 7: jump, fixup bitstuff
+; 87 [+ 2] cycles
+------------------------------------------------------------------
+*/
+continueWithBit5:
+    in      x2, USBIN       ;[055] <-- bit 5
+    eor     r0, x2          ;[056]
+    or      phase, r0       ;[057]
+    sbrc    phase, USBMINUS ;[058]
+    lpm                     ;[059] optional nop3; modifies r0
+    in      phase, USBIN    ;[060] <-- phase
+    eor     x1, x2          ;[061]
+    bst     x1, USBMINUS    ;[062]
+    bld     shift, 5        ;[063]
+    andi    shift, 0x3f     ;[064]
+    in      x1, USBIN       ;[065] <-- bit 6
+    breq    unstuff5        ;[066] *** unstuff escape
+    eor     phase, x1       ;[067]
+    eor     x2, x1          ;[068]
+    bst     x2, USBMINUS    ;[069]
+    bld     shift, 6        ;[070]
+didUnstuff6:                ;[   ]
+    in      r0, USBIN       ;[071] <-- phase
+    cpi     shift, 0x02     ;[072]
+    brlo    unstuff6        ;[073] *** unstuff escape
+didUnstuff5:                ;[   ]
+    nop2                    ;[074]
+;   [---]                   ;[075]
+    in      x2, USBIN       ;[076] <-- bit 7
+    eor     x1, x2          ;[077]
+    bst     x1, USBMINUS    ;[078]
+    bld     shift, 7        ;[079]
+didUnstuff7:                ;[   ]
+    eor     r0, x2          ;[080]
+    or      phase, r0       ;[081]
+    in      r0, USBIN       ;[082] <-- phase
+    cpi     shift, 0x04     ;[083]
+    brsh    rxLoop          ;[084]
+;   [---]                   ;[085]
+unstuff7:                   ;[   ]
+    andi    x3, ~0x80       ;[085]
+    ori     shift, 0x80     ;[086]
+    in      x2, USBIN       ;[087] <-- sample stuffed bit 7
+    nop                     ;[088]
+    rjmp    didUnstuff7     ;[089]
+;   [---]                   ;[090]
+                            ;[080]
+
+unstuff5:                   ;[067]
+    eor     phase, x1       ;[068]
+    andi    x3, ~0x20       ;[069]
+    ori     shift, 0x20     ;[070]
+    in      r0, USBIN       ;[071] <-- phase
+    mov     x2, x1          ;[072]
+    nop                     ;[073]
+    nop2                    ;[074]
+;   [---]                   ;[075]
+    in      x1, USBIN       ;[076] <-- bit 6
+    eor     r0, x1          ;[077]
+    or      phase, r0       ;[078]
+    eor     x2, x1          ;[079]
+    bst     x2, USBMINUS    ;[080]
+    bld     shift, 6        ;[081] no need to check bitstuffing, we just had one
+    in      r0, USBIN       ;[082] <-- phase
+    rjmp    didUnstuff5     ;[083]
+;   [---]                   ;[084]
+                            ;[074]
+
+unstuff6:                   ;[074]
+    andi    x3, ~0x40       ;[075]
+    in      x1, USBIN       ;[076] <-- bit 6 again
+    ori     shift, 0x40     ;[077]
+    nop2                    ;[078]
+;   [---]                   ;[079]
+    rjmp    didUnstuff6     ;[080]
+;   [---]                   ;[081]
+                            ;[071]
+
+unstuff0:                   ;[013]
+    eor     r0, x2          ;[014]
+    or      phase, r0       ;[015]
+    andi    x2, USBMASK     ;[016] check for SE0
+    in      r0, USBIN       ;[017] <-- phase
+    breq    didUnstuff0     ;[018] direct jump to se0 would be too long
+    andi    x3, ~0x01       ;[019]
+    ori     shift, 0x01     ;[020]
+    mov     x1, x2          ;[021] mov existing sample
+    in      x2, USBIN       ;[022] <-- bit 1 again
+    rjmp    didUnstuff0     ;[023]
+;   [---]                   ;[024]
+                            ;[014]
+
+unstuff1:                   ;[024]
+    eor     r0, x1          ;[025]
+    or      phase, r0       ;[026]
+    andi    x3, ~0x02       ;[027]
+    in      r0, USBIN       ;[028] <-- phase
+    ori     shift, 0x02     ;[029]
+    mov     x2, x1          ;[030]
+    rjmp    didUnstuff1     ;[031]
+;   [---]                   ;[032]
+                            ;[022]
+
+unstuff2:                   ;[035]
+    eor     r0, x2          ;[036]
+    or      phase, r0       ;[037]
+    andi    x3, ~0x04       ;[038]
+    in      r0, USBIN       ;[039] <-- phase
+    ori     shift, 0x04     ;[040]
+    mov     x1, x2          ;[041]
+    rjmp    didUnstuff2     ;[042]
+;   [---]                   ;[043]
+                            ;[033]
+
+unstuff3:                   ;[043]
+    in      x2, USBIN       ;[044] <-- bit 3 again
+    eor     r0, x2          ;[045]
+    or      phase, r0       ;[046]
+    andi    x3, ~0x08       ;[047]
+    ori     shift, 0x08     ;[048]
+    nop                     ;[049]
+    in      r0, USBIN       ;[050] <-- phase
+    rjmp    didUnstuff3     ;[051]
+;   [---]                   ;[052]
+                            ;[042]
+
+unstuff4:                   ;[053]
+    andi    x3, ~0x10       ;[054]
+    in      x1, USBIN       ;[055] <-- bit 4 again
+    ori     shift, 0x10     ;[056]
+    rjmp    didUnstuff4     ;[057]
+;   [---]                   ;[058]
+                            ;[048]
+
+rxLoop:                     ;[085]
+    eor     x3, shift       ;[086] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    in      x1, USBIN       ;[000] <-- bit 0
+    st      y+, x3          ;[001]
+;   [---]                   ;[002]
+    eor     r0, x1          ;[003]
+    or      phase, r0       ;[004]
+    eor     x2, x1          ;[005]
+    in      r0, USBIN       ;[006] <-- phase
+    ser     x3              ;[007]
+    bst     x2, USBMINUS    ;[008]
+    bld     shift, 0        ;[009]
+    andi    shift, 0xf9     ;[010]
+rxbit1:                     ;[   ]
+    in      x2, USBIN       ;[011] <-- bit 1
+    breq    unstuff0        ;[012] *** unstuff escape
+    andi    x2, USBMASK     ;[013] SE0 check for bit 1
+didUnstuff0:                ;[   ] Z only set if we detected SE0 in bitstuff
+    breq    se0             ;[014]
+    eor     r0, x2          ;[015]
+    or      phase, r0       ;[016]
+    in      r0, USBIN       ;[017] <-- phase
+    eor     x1, x2          ;[018]
+    bst     x1, USBMINUS    ;[019]
+    bld     shift, 1        ;[020]
+    andi    shift, 0xf3     ;[021]
+didUnstuff1:                ;[   ]
+    in      x1, USBIN       ;[022] <-- bit 2
+    breq    unstuff1        ;[023] *** unstuff escape
+    eor     r0, x1          ;[024]
+    or      phase, r0       ;[025]
+    subi    cnt, 1          ;[026] overflow check
+    brcs    overflow        ;[027]
+    in      r0, USBIN       ;[028] <-- phase
+    eor     x2, x1          ;[029]
+    bst     x2, USBMINUS    ;[030]
+    bld     shift, 2        ;[031]
+    andi    shift, 0xe7     ;[032]
+didUnstuff2:                ;[   ]
+    in      x2, USBIN       ;[033] <-- bit 3
+    breq    unstuff2        ;[034] *** unstuff escape
+    eor     r0, x2          ;[035]
+    or      phase, r0       ;[036]
+    eor     x1, x2          ;[037]
+    bst     x1, USBMINUS    ;[038]
+    in      r0, USBIN       ;[039] <-- phase
+    bld     shift, 3        ;[040]
+    andi    shift, 0xcf     ;[041]
+didUnstuff3:                ;[   ]
+    breq    unstuff3        ;[042] *** unstuff escape
+    nop                     ;[043]
+    in      x1, USBIN       ;[044] <-- bit 4
+    eor     x2, x1          ;[045]
+    bst     x2, USBMINUS    ;[046]
+    bld     shift, 4        ;[047]
+didUnstuff4:                ;[   ]
+    eor     r0, x1          ;[048]
+    or      phase, r0       ;[049]
+    in      r0, USBIN       ;[050] <-- phase
+    andi    shift, 0x9f     ;[051]
+    breq    unstuff4        ;[052] *** unstuff escape
+    rjmp    continueWithBit5;[053]
+;   [---]                   ;[054]
+
+macro POP_STANDARD ; 16 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    pop     r0
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+
+bitstuff7:
+    eor     x1, x4          ;[4]
+    ldi     x2, 0           ;[5]
+    nop2                    ;[6] C is zero (brcc)
+    rjmp    didStuff7       ;[8]
+
+bitstuffN:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6]
+    lpm                     ;[7] 3 cycle NOP, modifies r0
+    out     USBOUT, x1      ;[10] <-- out
+    rjmp    didStuffN       ;[0]
+
+#define bitStatus   x3
+
+sendNakAndReti:
+    ldi     cnt, USBPID_NAK ;[-19]
+    rjmp    sendCntAndReti  ;[-18]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     r0, cnt         ;[-16]
+    ldi     YL, 0           ;[-15] R0 address is 0
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+    ldi     bitStatus, 0xff ;[-4] init bit loop counter, works for up to 12 bytes
+byteloop:
+bitloop:
+    sbrs    shift, 0        ;[8] [-3]
+    eor     x1, x4          ;[9] [-2]
+    out     USBOUT, x1      ;[10] [-1] <-- out
+    ror     shift           ;[0]
+    ror     x2              ;[1]
+didStuffN:
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuffN       ;[3]
+    nop                     ;[4]
+    subi    bitStatus, 37   ;[5] 256 / 7 ~=~ 37
+    brcc    bitloop         ;[6] when we leave the loop, bitStatus has almost the initial value
+    sbrs    shift, 0        ;[7]
+    eor     x1, x4          ;[8]
+    ror     shift           ;[9]
+didStuff7:
+    out     USBOUT, x1      ;[10] <-- out
+    ror     x2              ;[0]
+    cpi     x2, 0xfc        ;[1]
+    brcc    bitstuff7       ;[2]
+    ld      shift, y+       ;[3]
+    dec     cnt             ;[5]
+    brne    byteloop        ;[6]
+;make SE0:
+    cbr     x1, USBMASK     ;[7] prepare SE0 [spec says EOP may be 21 to 25 cycles]
+    lds     x2, usbNewDeviceAddr;[8]
+    lsl     x2              ;[10] we compare with left shifted address
+    out     USBOUT, x1      ;[11] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    subi    YL, 2           ;[0] Only assign address on data packets, not ACK/NAK in r0
+    sbci    YH, 0           ;[1]
+    breq    skipAddrAssign  ;[2]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[5]
+    ori     x1, USBIDLE     ;[6]
+    in      x2, USBDDR      ;[7]
+    cbr     x2, USBMASK     ;[8] set both pins to input
+    mov     x3, x1          ;[9]
+    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
+    ldi     x4, 4           ;[11]
+se0Delay:
+    dec     x4              ;[12] [15] [18] [21]
+    brne    se0Delay        ;[13] [16] [19] [22]
+    out     USBOUT, x1      ;[23] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[24] <-- release bus now
+    out     USBOUT, x3      ;[25] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
Index: vusb-20121206/usbdrv/usbdrvasm18-crc.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm18-crc.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm18-crc.inc	(working copy)
@@ -0,0 +1,706 @@
+/* Name: usbdrvasm18.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Lukas Schrittwieser (based on 20 MHz usbdrvasm20.inc by Jeroen Benschop)
+ * Creation Date: 2009-01-20
+ * Tabsize: 4
+ * Copyright: (c) 2008 by Lukas Schrittwieser and OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 18 MHz version of the asssembler part of the USB driver. It
+requires a 18 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+
+;max stack usage: [ret(2), YL, SREG, YH, [sofError], bitcnt(x5), shift, x1, x2, x3, x4, cnt, ZL, ZH] = 14 bytes
+;nominal frequency: 18 MHz -> 12 cycles per bit
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+;register use in receive loop to receive the data bytes:
+; shift assembles the byte currently being received
+; x1 holds the D+ and D- line state
+; x2 holds the previous line state
+; cnt holds the number of bytes left in the receive buffer
+; x3 holds the higher crc byte (see algorithm below)
+; x4 is used as temporary register for the crc algorithm
+; x5 is used for unstuffing: when unstuffing the last received bit is inverted in shift (to prevent further
+;    unstuffing calls. In the same time the corresponding bit in x5 is cleared to mark the bit as beening iverted
+; zl lower crc value and crc table index
+; zh used for crc table accesses
+
+;--------------------------------------------------------------------------------------------------------------
+; CRC mods:
+;  table driven crc checker, Z points to table in prog space
+;   ZL is the lower crc byte, x3 is the higher crc byte
+;	x4 is used as temp register to store different results
+;	the initialization of the crc register is not 0xFFFF but 0xFE54. This is because during the receipt of the
+;	first data byte an virtual zero data byte is added to the crc register, this results in the correct initial
+;	value of 0xFFFF at beginning of the second data byte before the first data byte is added to the crc.
+;	The magic number 0xFE54 results form the crc table: At tabH[0x54] = 0xFF = crcH (required) and
+;	tabL[0x54] = 0x01  ->  crcL = 0x01 xor 0xFE = 0xFF
+;  bitcnt is renamed to x5 and is used for unstuffing purposes, the unstuffing works like in the 12MHz version
+;--------------------------------------------------------------------------------------------------------------
+; CRC algorithm:
+;	The crc register is formed by x3 (higher byte) and ZL (lower byte). The algorithm uses a 'reversed' form
+;	i.e. that it takes the least significant bit first and shifts to the right. So in fact the highest order
+;	bit seen from the polynomial devision point of view is the lsb of ZL. (If this sounds strange to you i
+;	propose a research on CRC :-) )
+;	Each data byte received is xored to ZL, the lower crc byte. This byte now builds the crc
+;	table index. Next the new high byte is loaded from the table and stored in x4 until we have space in x3
+;	(its destination).
+;	Afterwards the lower table is loaded from the table and stored in ZL (the old index is overwritten as
+;	we don't need it anymore. In fact this is a right shift by 8 bits.) Now the old crc high value is xored
+;	to ZL, this is the second shift of the old crc value. Now x4 (the temp reg) is moved to x3 and the crc
+; 	calculation is done.
+;	Prior to the first byte the two CRC register have to be initialized to 0xFFFF (as defined in usb spec)
+;	however the crc engine also runs during the receipt of the first byte, therefore x3 and zl are initialized
+;	to a magic number which results in a crc value of 0xFFFF after the first complete byte.
+;
+;	This algorithm is split into the extra cycles of the different bits:
+;	bit7:	XOR the received byte to ZL
+;	bit5:	load the new high byte to x4
+;	bit6:	load the lower xor byte from the table, xor zl and x3, store result in zl (=the new crc low value)
+;			move x4 (the new high byte) to x3, the crc value is ready
+;
+
+
+macro POP_STANDARD ; 18 cycles
+    pop		ZH
+    pop		ZL
+	pop     cnt
+    pop     x5
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     x4
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+macro CRC_CLEANUP_AND_CHECK
+	; the last byte has already been xored with the lower crc byte, we have to do the table lookup and xor
+	; x3 is the higher crc byte, zl the lower one
+	ldi		ZH, hi8(usbCrcTableHigh);[+1] get the new high byte from the table
+	lpm		x2, Z				;[+2][+3][+4]
+	ldi		ZH, hi8(usbCrcTableLow);[+5] get the new low xor byte from the table
+	lpm		ZL, Z				;[+6][+7][+8]
+	eor		ZL, x3				;[+7] xor the old high byte with the value from the table, x2:ZL now holds the crc value
+	cpi		ZL, 0x01			;[+8] if the crc is ok we have a fixed remainder value of 0xb001 in x2:ZL (see usb spec)
+	brne	ignorePacket		;[+9] detected a crc fault -> paket is ignored and retransmitted by the host
+	cpi		x2, 0xb0			;[+10]
+	brne	ignorePacket		;[+11] detected a crc fault -> paket is ignored and retransmitted by the host
+    endm
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG, YH, [sofError], x4, shift, x1, x2, x3, x5, cnt, ZL, ZH
+    push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-26]
+    push    YL                  ;[-25]
+    push    YH                  ;[-23]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-17]
+    rjmp    foundK              ;[-16]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-15]
+;{3, 5} after falling D- edge, average delay: 4 cycles
+;bit0 should be at 30  (2.5 bits) for center sampling. Currently at 4 so 26 cylces till bit 0 sample
+;use 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    x4                  ;[-14]
+;   [---]                       ;[-13]
+    lds     YL, usbInputBufOffset;[-12] used to toggle the two usb receive buffers
+;   [---]                       ;[-11]
+    clr     YH                  ;[-10]
+    subi    YL, lo8(-(usbRxBuf));[-9] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-8] [rx loop init]
+    push    shift               ;[-7]
+;   [---]                       ;[-6]
+    ldi		shift, 0x80			;[-5] the last bit is the end of byte marker for the pid receiver loop
+    clc			      	      	;[-4] the carry has to be clear for receipt of pid bit 0
+    sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
+    rjmp    haveTwoBitsK        ;[-2]
+    pop     shift               ;[-1] undo the push from before
+    pop     x4                  ;[1]
+    rjmp    waitForK            ;[3] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 24 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1                  ;[0]
+    push    x2                  ;[2]
+    push    x3                  ;[4] crc high byte
+    ldi     x2, 1<<USBPLUS      ;[6] [rx loop init] current line state is K state. D+=="1", D-=="0"
+    push    x5                  ;[7]
+    push    cnt                 ;[9]
+    ldi     cnt, USB_BUFSIZE    ;[11]
+
+
+;--------------------------------------------------------------------------------------------------------------
+; receives the pid byte
+; there is no real unstuffing algorithm implemented here as a stuffing bit is impossible in the pid byte.
+; That's because the last four bits of the byte are the inverted of the first four bits. If we detect a
+; unstuffing condition something went wrong and abort
+; shift has to be initialized to 0x80
+;--------------------------------------------------------------------------------------------------------------
+
+; pid bit 0 - used for even more register saving (we need the z pointer)
+	in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    eor		x2, x1				;[2] generate inverted of actual bit
+	sbrc	x2, USBMINUS		;[3] if the bit is set we received a zero
+	sec							;[4]
+	ror		shift				;[5] we perform no unstuffing check here as this is the first bit
+	mov		x2, x1				;[6]
+	push	ZL					;[7]
+								;[8]
+	push	ZH					;[9]
+								;[10]
+	ldi		x3, 0xFE			;[11] x3 is the high order crc value
+
+
+bitloopPid:						
+	in      x1, USBIN           ;[0] sample line state
+   	andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    breq    nse0                ;[2] both lines are low so handle se0	
+	eor		x2, x1				;[3] generate inverted of actual bit
+	sbrc	x2, USBMINUS		;[4] set the carry if we received a zero
+	sec							;[5]
+	ror		shift				;[6]
+	ldi		ZL, 0x54			;[7] ZL is the low order crc value
+	ser		x4					;[8] the is no bit stuffing check here as the pid bit can't be stuffed. if so
+								; some error occured. In this case the paket is discarded later on anyway.
+	mov		x2, x1				;[9] prepare for the next cycle
+	brcc	bitloopPid			;[10] while 0s drop out of shift we get the next bit
+	eor		x4, shift			;[11] invert all bits in shift and store result in x4
+
+;--------------------------------------------------------------------------------------------------------------
+; receives data bytes and calculates the crc
+; the last USBIN state has to be in x2
+; this is only the first half, due to branch distanc limitations the second half of the loop is near the end
+; of this asm file
+;--------------------------------------------------------------------------------------------------------------
+
+rxDataStart:
+    in      x1, USBIN           ;[0] sample line state (note: a se0 check is not useful due to bit dribbling)
+    ser		x5					;[1] prepare the unstuff marker register
+    eor		x2, x1             	;[2] generates the inverted of the actual bit
+    bst		x2, USBMINUS       	;[3] copy the bit from x2
+    bld		shift, 0	        ;[4] and store it in shift
+    mov		x2, shift	     	;[5] make a copy of shift for unstuffing check
+    andi	x2, 0xF9	      	;[6] mask the last six bits, if we got six zeros (which are six ones in fact)
+    breq	unstuff0	      	;[7] then Z is set now and we branch to the unstuffing handler
+didunstuff0:
+	subi    cnt, 1         		;[8] cannot use dec because it doesn't affect the carry flag
+    brcs    nOverflow    		;[9] Too many bytes received. Ignore packet							
+    st		Y+, x4				;[10] store the last received byte
+								;[11] st needs two cycles
+
+; bit1							
+	in		x2, USBIN			;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0 during bit 0
+    breq	nse0				;[2]
+    andi	x2, USBMASK			;[3] check se0 during bit 1
+    breq	nse0				;[4]
+	eor		x1, x2				;[5]
+    bst		x1, USBMINUS		;[6]
+    bld 	shift, 1	 		;[7]
+    mov		x1, shift			;[8]
+    andi	x1, 0xF3			;[9]
+    breq	unstuff1			;[10]
+didunstuff1:
+	nop							;[11]	
+
+; bit2
+	in      x1, USBIN           ;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0 (as there is nothing else to do here
+	breq	nOverflow	 		;[2]
+    eor		x2, x1              ;[3] generates the inverted of the actual bit
+    bst		x2, USBMINUS		;[4]
+    bld		shift, 2			;[5] store the bit
+    mov		x2, shift			;[6]
+    andi	x2, 0xE7			;[7] if we have six zeros here (which means six 1 in the stream)
+    breq	unstuff2			;[8] the next bit is a stuffing bit
+didunstuff2:
+	nop2						;[9]
+								;[10]
+	nop							;[11]					
+					
+; bit3							
+	in		x2, USBIN			;[0] sample line state
+    andi	x2, USBMASK			;[1] check for se0
+    breq	nOverflow           ;[2]
+    eor		x1, x2				;[3]
+    bst		x1, USBMINUS		;[4]
+    bld 	shift, 3	 		;[5]
+    mov		x1, shift			;[6]
+    andi	x1, 0xCF			;[7]
+    breq	unstuff3			;[8]
+didunstuff3:
+	nop							;[9]
+	rjmp 	rxDataBit4			;[10]
+								;[11]				
+
+; the avr branch instructions allow an offset of +63 insturction only, so we need this
+; 'local copy' of se0
+nse0:		
+	rjmp	se0					;[4]
+								;[5]
+; the same same as for se0 is needed for overflow and StuffErr
+nOverflow:
+stuffErr:
+	rjmp	overflow
+
+
+unstuff0:						;[8] this is the branch delay of breq unstuffX
+	andi	x1, USBMASK			;[9] do an se0 check here (if the last crc byte ends with 5 one's we might end up here
+	breq	didunstuff0			;[10] event tough the message is complete -> jump back and store the byte
+	ori		shift, 0x01			;[11] invert the last received bit to prevent furhter unstuffing
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	andi	x5, 0xFE			;[1] mark this bit as inverted (will be corrected before storing shift)
+	eor		x1, x2				;[2] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[3] mask the interesting bits
+	breq	stuffErr			;[4] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[5] the next bit expects the last state to be in x1
+	rjmp 	didunstuff0			;[6]
+								;[7] jump delay of rjmp didunstuffX	
+
+unstuff1:						;[11] this is the jump delay of breq unstuffX
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	ori		shift, 0x02			;[1] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xFD			;[2] mark this bit as inverted (will be corrected before storing shift)
+	eor		x2, x1				;[3] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[4] mask the interesting bits
+	breq	stuffErr			;[5] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[6] the next bit expects the last state to be in x2
+	nop2						;[7]
+								;[8]
+	rjmp 	didunstuff1			;[9]
+								;[10] jump delay of rjmp didunstuffX		
+
+unstuff2:						;[9] this is the jump delay of breq unstuffX
+	ori		shift, 0x04			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xFB			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff2			;[7]
+								;[8] jump delay of rjmp didunstuffX	
+
+unstuff3:						;[9] this is the jump delay of breq unstuffX
+	ori		shift, 0x08			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xF7			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff3			;[7]
+								;[8] jump delay of rjmp didunstuffX			
+
+
+
+; the include has to be here due to branch distance restirctions
+#define __USE_CRC__
+#include "asmcommon.inc"
+
+	
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+; 7.5 bit times is 90 cycles. ...there is plenty of time
+
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-6] <- acquire bus
+	ldi		x2, 0			;[-6] init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-5] exor mask
+    ldi     shift, 0x80     ;[-4] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x40    ;[-3]=[9]     binary 01000000
+txBitLoop:					; the loop sends the first 7 bits of the byte
+    sbrs    shift, 0        ;[-2]=[10] if we have to send a 1 don't change the line state
+    eor     x1, x4          ;[-1]=[11]
+    out     USBOUT, x1      ;[0]
+    ror     shift           ;[1]
+    ror     x2              ;[2] transfers the last sent bit to the stuffing history
+didStuffN:
+    nop	                    ;[3]
+    nop                     ;[4]
+    cpi     x2, 0xfc        ;[5] if we sent six consecutive ones
+    brcc    bitstuffN       ;[6]
+    lsr     bitcnt          ;[7]
+    brne    txBitLoop       ;[8] restart the loop while the 1 is still in the bitcount
+
+; transmit bit 7
+    sbrs    shift, 0        ;[9]
+    eor     x1, x4          ;[10]
+didStuff7:
+    ror     shift           ;[11]
+	out     USBOUT, x1      ;[0] transfer bit 7 to the pins
+    ror     x2              ;[1] move the bit into the stuffing history	
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuff7       ;[3]
+    ld      shift, y+       ;[4] get next byte to transmit
+    dec     cnt             ;[5] decrement byte counter
+    brne    txByteLoop      ;[7] if we have more bytes start next one
+    						;[8] branch delay
+    						
+;make SE0:
+    cbr     x1, USBMASK     ;[8] 		prepare SE0 [spec says EOP may be 25 to 30 cycles]
+    lds     x2, usbNewDeviceAddr;[9]
+    lsl     x2              ;[11] 		we compare with left shifted address
+    out     USBOUT, x1      ;[0] 		<-- out SE0 -- from now 2 bits = 24 cycles until bus idle
+    subi    YL, 20 + 2      ;[1] 		Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[2]
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[3]
+    sts     usbDeviceAddr, x2		; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[5] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[6]
+    ori     x1, USBIDLE     ;[7]
+    in      x2, USBDDR      ;[8]
+    cbr     x2, USBMASK     ;[9] set both pins to input
+    mov     x3, x1          ;[10]
+    cbr     x3, USBMASK     ;[11] configure no pullup on both pins
+    ldi     x4, 4           ;[12]
+se0Delay:
+    dec     x4              ;[13] [16] [19] [22]
+    brne    se0Delay        ;[14] [17] [20] [23]
+    out     USBOUT, x1      ;[24] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[25] <-- release bus now
+    out     USBOUT, x3      ;[26] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
+bitstuffN:
+    eor     x1, x4          ;[8] generate a zero
+    ldi     x2, 0           ;[9] reset the bit stuffing history
+    nop2                    ;[10]
+    out     USBOUT, x1      ;[0] <-- send the stuffing bit
+    rjmp    didStuffN       ;[1]
+
+bitstuff7:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6] reset bit stuffing history
+    clc						;[7] fill a zero into the shift register
+    rol     shift           ;[8] compensate for ror shift at branch destination
+    rjmp    didStuff7       ;[9]
+    						;[10] jump delay
+
+;--------------------------------------------------------------------------------------------------------------
+; receives data bytes and calculates the crc
+; second half of the data byte receiver loop
+; most parts of the crc algorithm are here
+;--------------------------------------------------------------------------------------------------------------
+
+nOverflow2:
+	rjmp overflow
+
+rxDataBit4:
+	in      x1, USBIN           ;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0
+    breq	nOverflow2			;[2]
+    eor		x2, x1              ;[3]
+    bst		x2, USBMINUS		;[4]
+    bld		shift, 4			;[5]
+    mov		x2, shift			;[6]
+    andi	x2, 0x9F			;[7]
+    breq	unstuff4			;[8]
+didunstuff4:
+	nop2						;[9][10]
+	nop							;[11]
+
+; bit5							
+	in		x2, USBIN			;[0] sample line state
+    ldi		ZH, hi8(usbCrcTableHigh);[1] use the table for the higher byte
+    eor		x1, x2				;[2]
+    bst		x1, USBMINUS		;[3]
+    bld 	shift, 5	 		;[4]
+    mov		x1, shift			;[5]
+    andi	x1, 0x3F			;[6]
+    breq	unstuff5			;[7]
+didunstuff5:
+	lpm		x4, Z				;[8] load the higher crc xor-byte and store it for later use
+								;[9] lpm needs 3 cycles
+								;[10]			
+	ldi		ZH, hi8(usbCrcTableLow);[11] load the lower crc xor byte adress
+
+; bit6	    					
+	in      x1, USBIN           ;[0] sample line state
+    eor		x2, x1              ;[1]
+    bst		x2, USBMINUS		;[2]
+    bld		shift, 6			;[3]
+    mov		x2, shift			;[4]
+    andi	x2, 0x7E			;[5]
+    breq	unstuff6			;[6]
+didunstuff6:
+	lpm		ZL, Z				;[7] load the lower xor crc byte
+								;[8] lpm needs 3 cycles
+	    						;[9]
+	eor		ZL, x3				;[10] xor the old high crc byte with the low xor-byte
+	mov		x3, x4				;[11] move the new high order crc value from temp to its destination
+			
+; bit7							
+	in		x2, USBIN			;[0] sample line state
+    eor		x1, x2				;[1]
+    bst		x1, USBMINUS		;[2]
+    bld 	shift, 7	 		;[3] now shift holds the complete but inverted data byte
+    mov		x1, shift			;[4]
+    andi	x1, 0xFC			;[5]
+    breq	unstuff7			;[6]
+didunstuff7:
+	eor		x5, shift			;[7] x5 marks all bits which have not been inverted by the unstuffing subs
+	mov		x4, x5				;[8] keep a copy of the data byte it will be stored during next bit0
+	eor		ZL, x4				;[9] feed the actual byte into the crc algorithm
+	rjmp	rxDataStart			;[10] next byte
+								;[11] during the reception of the next byte this one will be fed int the crc algorithm
+
+unstuff4:						;[9] this is the jump delay of rjmp unstuffX
+	ori		shift, 0x10			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xEF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff4			;[7]
+								;[8] jump delay of rjmp didunstuffX	
+
+unstuff5:						;[8] this is the jump delay of rjmp unstuffX
+	nop							;[9]
+	ori		shift, 0x20			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xDF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	nop							;[5]
+	rjmp 	didunstuff5			;[6]
+								;[7] jump delay of rjmp didunstuffX													
+
+unstuff6:						;[7] this is the jump delay of rjmp unstuffX
+	nop2						;[8]
+								;[9]
+	ori		shift, 0x40			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xBF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	rjmp 	didunstuff6			;[5]
+								;[6] jump delay of rjmp didunstuffX	
+
+unstuff7:						;[7] this is the jump delay of rjmp unstuffX
+	nop							;[8]
+	nop							;[9]
+	ori		shift, 0x80			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0x7F			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	rjmp 	didunstuff7			;[5]
+								;[6] jump delay of rjmp didunstuff7
+
+; local copy of the stuffErr desitnation for the second half of the receiver loop
+stuffErr2:
+	rjmp	stuffErr
+
+;--------------------------------------------------------------------------------------------------------------
+; The crc table follows. It has to be aligned to enable a fast loading of the needed bytes.
+; There are two tables of 256 entries each, the low and the high byte table.
+; Table values were generated with the following C code:
+/*
+#include <stdio.h>
+int main (int argc, char **argv)
+{
+	int i, j;
+	for (i=0; i<512; i++){
+		unsigned short crc = i & 0xff;
+		for(j=0; j<8; j++) crc = (crc >> 1) ^ ((crc & 1) ? 0xa001 : 0);
+		if((i & 7) == 0) printf("\n.byte ");
+		printf("0x%02x, ", (i > 0xff ? (crc >> 8) : crc) & 0xff);
+		if(i == 255) printf("\n");
+	}
+	return 0;
+}
+
+// Use the following algorithm to compute CRC values:
+ushort computeCrc(uchar *msg, uchar msgLen)
+{
+    uchar i;
+	ushort crc = 0xffff;
+	for(i = 0; i < msgLen; i++)
+		crc = usbCrcTable16[lo8(crc) ^ msg[i]] ^ hi8(crc);
+    return crc;
+}
+*/
+
+.balign 256
+usbCrcTableLow:	
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+
+; .balign 256
+usbCrcTableHigh:
+.byte 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2
+.byte 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04
+.byte 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E
+.byte 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8
+.byte 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A
+.byte 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC
+.byte 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6
+.byte 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10
+.byte 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32
+.byte 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4
+.byte 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE
+.byte 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38
+.byte 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA
+.byte 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C
+.byte 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26
+.byte 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0
+.byte 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62
+.byte 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4
+.byte 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE
+.byte 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68
+.byte 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA
+.byte 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C
+.byte 0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76
+.byte 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0
+.byte 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92
+.byte 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54
+.byte 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E
+.byte 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98
+.byte 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A
+.byte 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C
+.byte 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86
+.byte 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40	
+
Index: vusb-20121206/usbdrv/usbdrvasm20.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm20.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm20.inc	(working copy)
@@ -0,0 +1,359 @@
+/* Name: usbdrvasm20.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Jeroen Benschop
+ * Based on usbdrvasm16.inc from Christian Starkjohann
+ * Creation Date: 2008-03-05
+ * Tabsize: 4
+ * Copyright: (c) 2008 by Jeroen Benschop and OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 20 MHz version of the asssembler part of the USB driver. It
+requires a 20 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+#define leap2   x3
+#ifdef __IAR_SYSTEMS_ASM__
+#define nextInst    $+2
+#else
+#define nextInst    .+0
+#endif
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 20 MHz -> 13.333333 cycles per bit, 106.666667 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+;register use in receive loop:
+; shift assembles the byte currently being received
+; x1 holds the D+ and D- line state
+; x2 holds the previous line state
+; x4 (leap)  is used to add a leap cycle once every three bytes received
+; X3 (leap2) is used to add a leap cycle once every three stuff bits received
+; bitcnt is used to determine when a stuff bit is due
+; cnt holds the number of bytes left in the receive buffer
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-26]
+    push    YL                  ;[-25]
+    push    YH                  ;[-23]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-19]
+    rjmp    foundK              ;[-18]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-16]
+;{3, 5} after falling D- edge, average delay: 4 cycles
+;bit0 should be at 34 for center sampling. Currently at 4 so 30 cylces till bit 0 sample
+;use 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    bitcnt              ;[-16]
+;   [---]                       ;[-15]
+    lds     YL, usbInputBufOffset;[-14]
+;   [---]                       ;[-13]
+    clr     YH                  ;[-12]
+    subi    YL, lo8(-(usbRxBuf));[-11] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-10] [rx loop init]
+    push    shift               ;[-9]
+;   [---]                       ;[-8]
+    ldi     shift,0x40          ;[-7] set msb to "1" so processing bit7 can be detected
+    nop2                        ;[-6]
+;   [---]                       ;[-5]
+    ldi     bitcnt, 5           ;[-4] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
+    rjmp    haveTwoBitsK        ;[-2]
+    pop     shift               ;[-1] undo the push from before
+    pop     bitcnt              ;[1] 
+    rjmp    waitForK            ;[3] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 27 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1                  ;[0]
+    push    x2                  ;[2]
+    push    x3                  ;[4] (leap2)
+    ldi     leap2, 0x55         ;[6] add leap cycle on 2nd,5th,8th,... stuff bit
+    push    x4                  ;[7] == leap
+    ldi     leap, 0x55          ;[9] skip leap cycle on 2nd,5th,8th,... byte received
+    push    cnt                 ;[10]
+    ldi     cnt, USB_BUFSIZE    ;[12] [rx loop init]
+    ldi     x2, 1<<USBPLUS      ;[13] current line state is K state. D+=="1", D-=="0"
+bit0:       
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    rjmp    handleBit           ;[2] make bit0 14 cycles long
+
+;----------------------------------------------------------------------------
+; Process bit7. However, bit 6 still may need unstuffing.
+;----------------------------------------------------------------------------
+
+b6checkUnstuff:
+    dec     bitcnt              ;[9]
+    breq    unstuff6            ;[10]
+bit7:
+    subi    cnt, 1              ;[11] cannot use dec becaus it does not affect the carry flag
+    brcs    overflow            ;[12] Too many bytes received. Ignore packet
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    cpse    x1, x2              ;[2] when previous line state equals current line state, handle "1"
+    rjmp    b7handle0           ;[3] when line state differs, handle "0"
+    sec                         ;[4]
+    ror     shift               ;[5] shift "1" into the data
+    st      y+, shift           ;[6] store the data into the buffer
+    ldi     shift, 0x40         ;[7] reset data for receiving the next byte
+    subi    leap, 0x55          ;[9] trick to introduce a leap cycle every 3 bytes
+    brcc    nextInst            ;[10 or 11] it will fail after 85 bytes. However low speed can only receive 11
+    dec     bitcnt              ;[11 or 12]
+    brne    bit0                ;[12 or 13]
+    ldi     x1, 1               ;[13 or 14] unstuffing bit 7
+    in      bitcnt, USBIN       ;[0] sample stuff bit
+    rjmp    unstuff             ;[1]
+
+b7handle0:
+    mov     x2,x1               ;[5] Set x2 to current line state
+    ldi     bitcnt, 6           ;[6]
+    lsr     shift               ;[7] shift "0" into the data
+    st      y+, shift           ;[8] store data into the buffer
+    ldi     shift, 0x40         ;[10] reset data for receiving the next byte
+    subi    leap, 0x55          ;[11] trick to introduce a leap cycle every 3 bytes
+    brcs    bit0                ;[12] it will fail after 85 bytes. However low speed can only receive 11
+    rjmp    bit0                ;[13]
+
+
+;----------------------------------------------------------------------------
+; Handle unstuff
+; x1==0xFF indicate unstuffing bit6
+;----------------------------------------------------------------------------
+
+unstuff6:
+    ldi     x1,0xFF             ;[12] indicate unstuffing bit 6
+    in      bitcnt, USBIN       ;[0]  sample stuff bit
+    nop                         ;[1]  fix timing
+unstuff:                        ;b0-5  b6   b7
+    mov     x2,bitcnt           ;[3]  [2]  [3]  Set x2 to match line state
+    subi    leap2, 0x55         ;[4]  [3]  [4]  delay loop
+    brcs    nextInst            ;[5]  [4]  [5]  add one cycle every three stuff bits
+    sbci    leap2,0             ;[6]  [5]  [6]
+    ldi     bitcnt,6            ;[7]  [6]  [7]  reset bit stuff counter
+    andi    x2, USBMASK         ;[8]  [7]  [8] only keep D+ and D-
+    cpi     x1,0                ;[9]  [8]  [9]
+    brmi    bit7                ;[10] [9]  [10] finished unstuffing bit6 When x1<0
+    breq    bitloop             ;[11] ---  [11] finished unstuffing bit0-5 when x1=0
+    nop                         ;---  ---  [12]
+    in      x1, USBIN           ;---  ---  [0] sample line state for bit0
+    andi    x1, USBMASK         ;---  ---  [1] filter only D+ and D- bits
+    rjmp    handleBit           ;---  ---  [2] make bit0 14 cycles long
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+bitloop:
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    breq    se0                 ;[2] both lines are low so handle se0
+handleBit:
+    cpse    x1, x2              ;[3] when previous line state equals current line state, handle "1"
+    rjmp    handle0             ;[4] when line state differs, handle "0"
+    sec                         ;[5]
+    ror     shift               ;[6] shift "1" into the data
+    brcs    b6checkUnstuff      ;[7] When after shift C is set, next bit is bit7
+    nop2                        ;[8]
+    dec     bitcnt              ;[10]
+    brne    bitloop             ;[11]
+    ldi     x1,0                ;[12] indicate unstuff for bit other than bit6 or bit7
+    in      bitcnt, USBIN       ;[0] sample stuff bit
+    rjmp    unstuff             ;[1]
+
+handle0:
+    mov     x2, x1              ;[6] Set x2 to current line state
+    ldi     bitcnt, 6           ;[7] reset unstuff counter. 
+    lsr     shift               ;[8] shift "0" into the data
+    brcs    bit7                ;[9] When after shift C is set, next bit is bit7
+    nop                         ;[10]
+    rjmp    bitloop             ;[11] 
+    
+;----------------------------------------------------------------------------
+; End of receive loop. Now start handling EOP
+;----------------------------------------------------------------------------
+
+macro POP_STANDARD ; 14 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     bitcnt
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+
+
+#include "asmcommon.inc"
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+; 7.5 bit times is 100 cycles. This implementation arrives a bit later at se0
+; then specified in the include file but there is plenty of time
+
+bitstuffN:
+    eor     x1, x4          ;[8]
+    ldi     x2, 0           ;[9]
+    nop2                    ;[10]
+    out     USBOUT, x1      ;[12] <-- out
+    rjmp    didStuffN       ;[0]
+    
+bitstuff7:
+    eor     x1, x4          ;[6]
+    ldi     x2, 0           ;[7] Carry is zero due to brcc
+    rol     shift           ;[8] compensate for ror shift at branch destination
+    nop2                    ;[9]
+    rjmp    didStuff7       ;[11]
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We don't match the transfer rate exactly (don't insert leap cycles every third
+;byte) because the spec demands only 1.5% precision anyway.
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x49    ;[-4]        [10] binary 01001001
+txBitLoop:
+    sbrs    shift, 0        ;[-3] [10]   [11]
+    eor     x1, x4          ;[-2] [11]   [12]
+    out     USBOUT, x1      ;[-1] [12]   [13]   <-- out N
+    ror     shift           ;[0]  [13]   [14]
+    ror     x2              ;[1]
+didStuffN:
+    nop2                    ;[2]
+    nop                     ;[4]
+    cpi     x2, 0xfc        ;[5]
+    brcc    bitstuffN       ;[6]
+    lsr     bitcnt          ;[7]
+    brcc    txBitLoop       ;[8]
+    brne    txBitLoop       ;[9]
+
+    sbrs    shift, 0        ;[10]
+    eor     x1, x4          ;[11]
+didStuff7:
+    out     USBOUT, x1      ;[-1] [13] <-- out 7
+    ror     shift           ;[0] [14]
+    ror     x2              ;[1]
+    nop                     ;[2]
+    cpi     x2, 0xfc        ;[3]
+    brcc    bitstuff7       ;[4]
+    ld      shift, y+       ;[5]
+    dec     cnt             ;[7]
+    brne    txByteLoop      ;[8]
+;make SE0:
+    cbr     x1, USBMASK     ;[9] prepare SE0 [spec says EOP may be 25 to 30 cycles]
+    lds     x2, usbNewDeviceAddr;[10]
+    lsl     x2              ;[12] we compare with left shifted address
+    out     USBOUT, x1      ;[13] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+    subi    YL, 20 + 2      ;[0] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[1]
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[2]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[5]
+    ori     x1, USBIDLE     ;[6]
+    in      x2, USBDDR      ;[7]
+    cbr     x2, USBMASK     ;[8] set both pins to input
+    mov     x3, x1          ;[9]
+    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
+    ldi     x4, 5           ;[11]
+se0Delay:
+    dec     x4              ;[12] [15] [18] [21] [24]
+    brne    se0Delay        ;[13] [16] [19] [22] [25]
+    out     USBOUT, x1      ;[26] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[27] <-- release bus now
+    out     USBOUT, x3      ;[28] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: vusb-20121206/usbdrv/usbportability.h
===================================================================
--- vusb-20121206/usbdrv/usbportability.h	(nonexistent)
+++ vusb-20121206/usbdrv/usbportability.h	(working copy)
@@ -0,0 +1,143 @@
+/* Name: usbportability.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-06-17
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This header is intended to contain all (or at least most of) the compiler
+and library dependent stuff. The C code is written for avr-gcc and avr-libc.
+The API of other development environments is converted to gcc's and avr-libc's
+API by means of defines.
+
+This header also contains all system includes since they depend on the
+development environment.
+
+Thanks to Oleg Semyonov for his help with the IAR tools port!
+*/
+
+#ifndef __usbportability_h_INCLUDED__
+#define __usbportability_h_INCLUDED__
+
+/* We check explicitly for IAR and CodeVision. Default is avr-gcc/avr-libc. */
+
+/* ------------------------------------------------------------------------- */
+#if defined __IAR_SYSTEMS_ICC__ || defined __IAR_SYSTEMS_ASM__  /* check for IAR */
+/* ------------------------------------------------------------------------- */
+
+#ifndef ENABLE_BIT_DEFINITIONS
+#   define ENABLE_BIT_DEFINITIONS	1   /* Enable bit definitions */
+#endif
+
+/* Include IAR headers */
+#include <ioavr.h>
+#ifndef __IAR_SYSTEMS_ASM__
+#   include <inavr.h>
+#endif
+
+#define __attribute__(arg)  /* not supported on IAR */
+
+#ifdef __IAR_SYSTEMS_ASM__
+#   define __ASSEMBLER__    /* IAR does not define standard macro for asm */
+#endif
+
+#ifdef __HAS_ELPM__
+#   define PROGMEM __farflash
+#else
+#   define PROGMEM __flash
+#endif
+
+#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+
+/* The following definitions are not needed by the driver, but may be of some
+ * help if you port a gcc based project to IAR.
+ */
+#define cli()       __disable_interrupt()
+#define sei()       __enable_interrupt()
+#define wdt_reset() __watchdog_reset()
+#define _BV(x)      (1 << (x))
+
+/* assembler compatibility macros */
+#define nop2    rjmp    $+2 /* jump to next instruction */
+#define XL      r26
+#define XH      r27
+#define YL      r28
+#define YH      r29
+#define ZL      r30
+#define ZH      r31
+#define lo8(x)  LOW(x)
+#define hi8(x)  (((x)>>8) & 0xff)   /* not HIGH to allow XLINK to make a proper range check */
+
+/* Depending on the device you use, you may get problems with the way usbdrv.h
+ * handles the differences between devices. Since IAR does not use #defines
+ * for MCU registers, we can't check for the existence of a particular
+ * register with an #ifdef. If the autodetection mechanism fails, include
+ * definitions for the required USB_INTR_* macros in your usbconfig.h. See
+ * usbconfig-prototype.h and usbdrv.h for details.
+ */
+
+/* ------------------------------------------------------------------------- */
+#elif __CODEVISIONAVR__ /* check for CodeVision AVR */
+/* ------------------------------------------------------------------------- */
+/* This port is not working (yet) */
+
+/* #define F_CPU   _MCU_CLOCK_FREQUENCY_    seems to be defined automatically */
+
+#include <io.h>
+#include <delay.h>
+
+#define __attribute__(arg)  /* not supported on IAR */
+
+#define PROGMEM                 __flash
+#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+
+#ifndef __ASSEMBLER__
+static inline void  cli(void)
+{
+    #asm("cli");
+}
+static inline void  sei(void)
+{
+    #asm("sei");
+}
+#endif
+#define _delay_ms(t)    delay_ms(t)
+#define _BV(x)          (1 << (x))
+#define USB_CFG_USE_SWITCH_STATEMENT 1  /* macro for if() cascase fails for unknown reason */
+
+#define macro   .macro
+#define endm    .endmacro
+#define nop2    rjmp    .+0 /* jump to next instruction */
+
+/* ------------------------------------------------------------------------- */
+#else   /* default development environment is avr-gcc/avr-libc */
+/* ------------------------------------------------------------------------- */
+
+#include <avr/io.h>
+#ifdef __ASSEMBLER__
+#   define _VECTOR(N)   __vector_ ## N   /* io.h does not define this for asm */
+#else
+#   include <avr/pgmspace.h>
+#endif
+
+#if USB_CFG_DRIVER_FLASH_PAGE
+#   define USB_READ_FLASH(addr)    pgm_read_byte_far(((long)USB_CFG_DRIVER_FLASH_PAGE << 16) | (long)(addr))
+#else
+#   define USB_READ_FLASH(addr)    pgm_read_byte(addr)
+#endif
+
+#define macro   .macro
+#define endm    .endm
+#define nop2    rjmp    .+0 /* jump to next instruction */
+
+#endif  /* development environment */
+
+/* for conveniecne, ensure that PRG_RDB exists */
+#ifndef PRG_RDB
+#   define PRG_RDB(addr)    USB_READ_FLASH(addr)
+#endif
+#endif  /* __usbportability_h_INCLUDED__ */
Index: vusb-20121206/usbdrv/asmcommon.inc
===================================================================
--- vusb-20121206/usbdrv/asmcommon.inc	(nonexistent)
+++ vusb-20121206/usbdrv/asmcommon.inc	(working copy)
@@ -0,0 +1,187 @@
+/* Name: asmcommon.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-11-05
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file contains assembler code which is shared among the USB driver
+implementations for different CPU cocks. Since the code must be inserted
+in the middle of the module, it's split out into this file and #included.
+
+Jump destinations called from outside:
+    sofError: Called when no start sequence was found.
+    se0: Called when a package has been successfully received.
+    overflow: Called when receive buffer overflows.
+    doReturn: Called after sending data.
+
+Outside jump destinations used by this module:
+    waitForJ: Called to receive an already arriving packet.
+    sendAckAndReti:
+    sendNakAndReti:
+    sendCntAndReti:
+    usbSendAndReti:
+
+The following macros must be defined before this file is included:
+    .macro POP_STANDARD
+    .endm
+    .macro POP_RETI
+    .endm
+*/
+
+#define token   x1
+
+overflow:
+    ldi     x2, 1<<USB_INTR_PENDING_BIT
+    USB_STORE_PENDING(x2)       ; clear any pending interrupts
+ignorePacket:
+    clr     token
+    rjmp    storeTokenAndReturn
+
+;----------------------------------------------------------------------------
+; Processing of received packet (numbers in brackets are cycles after center of SE0)
+;----------------------------------------------------------------------------
+;This is the only non-error exit point for the software receiver loop
+;we don't check any CRCs here because there is no time left.
+se0:
+    subi    cnt, USB_BUFSIZE    ;[5]
+    neg     cnt                 ;[6]
+    sub     YL, cnt             ;[7]
+    sbci    YH, 0               ;[8]
+    ldi     x2, 1<<USB_INTR_PENDING_BIT ;[9]
+    USB_STORE_PENDING(x2)       ;[10] clear pending intr and check flag later. SE0 should be over.
+    ld      token, y            ;[11]
+    cpi     token, USBPID_DATA0 ;[13]
+    breq    handleData          ;[14]
+    cpi     token, USBPID_DATA1 ;[15]
+    breq    handleData          ;[16]
+    lds     shift, usbDeviceAddr;[17]
+    ldd     x2, y+1             ;[19] ADDR and 1 bit endpoint number
+    lsl     x2                  ;[21] shift out 1 bit endpoint number
+    cpse    x2, shift           ;[22]
+    rjmp    ignorePacket        ;[23]
+/* only compute endpoint number in x3 if required later */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT || USB_CFG_IMPLEMENT_FN_WRITEOUT
+    ldd     x3, y+2             ;[24] endpoint number + crc
+    rol     x3                  ;[26] shift in LSB of endpoint
+#endif
+    cpi     token, USBPID_IN    ;[27]
+    breq    handleIn            ;[28]
+    cpi     token, USBPID_SETUP ;[29]
+    breq    handleSetupOrOut    ;[30]
+    cpi     token, USBPID_OUT   ;[31]
+    brne    ignorePacket        ;[32] must be ack, nak or whatever
+;   rjmp    handleSetupOrOut    ; fallthrough
+
+;Setup and Out are followed by a data packet two bit times (16 cycles) after
+;the end of SE0. The sync code allows up to 40 cycles delay from the start of
+;the sync pattern until the first bit is sampled. That's a total of 56 cycles.
+handleSetupOrOut:               ;[32]
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT   /* if we have data for endpoint != 0, set usbCurrentTok to address */
+    andi    x3, 0xf             ;[32]
+    breq    storeTokenAndReturn ;[33]
+    mov     token, x3           ;[34] indicate that this is endpoint x OUT
+#endif
+storeTokenAndReturn:
+    sts     usbCurrentTok, token;[35]
+doReturn:
+    POP_STANDARD                ;[37] 12...16 cycles
+    USB_LOAD_PENDING(YL)        ;[49]
+    sbrc    YL, USB_INTR_PENDING_BIT;[50] check whether data is already arriving
+    rjmp    waitForJ            ;[51] save the pops and pushes -- a new interrupt is already pending
+sofError:
+    POP_RETI                    ;macro call
+    reti
+
+handleData:
+#if USB_CFG_CHECK_CRC
+    CRC_CLEANUP_AND_CHECK       ; jumps to ignorePacket if CRC error
+#endif
+    lds     shift, usbCurrentTok;[18]
+    tst     shift               ;[20]
+    breq    doReturn            ;[21]
+    lds     x2, usbRxLen        ;[22]
+    tst     x2                  ;[24]
+    brne    sendNakAndReti      ;[25]
+; 2006-03-11: The following two lines fix a problem where the device was not
+; recognized if usbPoll() was called less frequently than once every 4 ms.
+    cpi     cnt, 4              ;[26] zero sized data packets are status phase only -- ignore and ack
+    brmi    sendAckAndReti      ;[27] keep rx buffer clean -- we must not NAK next SETUP
+#if USB_CFG_CHECK_DATA_TOGGLING
+    sts     usbCurrentDataToken, token  ; store for checking by C code
+#endif
+    sts     usbRxLen, cnt       ;[28] store received data, swap buffers
+    sts     usbRxToken, shift   ;[30]
+    lds     x2, usbInputBufOffset;[32] swap buffers
+    ldi     cnt, USB_BUFSIZE    ;[34]
+    sub     cnt, x2             ;[35]
+    sts     usbInputBufOffset, cnt;[36] buffers now swapped
+    rjmp    sendAckAndReti      ;[38] 40 + 17 = 57 until SOP
+
+handleIn:
+;We don't send any data as long as the C code has not processed the current
+;input data and potentially updated the output data. That's more efficient
+;in terms of code size than clearing the tx buffers when a packet is received.
+    lds     x1, usbRxLen        ;[30]
+    cpi     x1, 1               ;[32] negative values are flow control, 0 means "buffer free"
+    brge    sendNakAndReti      ;[33] unprocessed input packet?
+    ldi     x1, USBPID_NAK      ;[34] prepare value for usbTxLen
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+    andi    x3, 0xf             ;[35] x3 contains endpoint
+#if USB_CFG_SUPPRESS_INTR_CODE
+    brne    sendNakAndReti      ;[36]
+#else
+    brne    handleIn1           ;[36]
+#endif
+#endif
+    lds     cnt, usbTxLen       ;[37]
+    sbrc    cnt, 4              ;[39] all handshake tokens have bit 4 set
+    rjmp    sendCntAndReti      ;[40] 42 + 16 = 58 until SOP
+    sts     usbTxLen, x1        ;[41] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf)   ;[43]
+    ldi     YH, hi8(usbTxBuf)   ;[44]
+    rjmp    usbSendAndReti      ;[45] 57 + 12 = 59 until SOP
+
+; Comment about when to set usbTxLen to USBPID_NAK:
+; We should set it back when we receive the ACK from the host. This would
+; be simple to implement: One static variable which stores whether the last
+; tx was for endpoint 0 or 1 and a compare in the receiver to distinguish the
+; ACK. However, we set it back immediately when we send the package,
+; assuming that no error occurs and the host sends an ACK. We save one byte
+; RAM this way and avoid potential problems with endless retries. The rest of
+; the driver assumes error-free transfers anyway.
+
+#if !USB_CFG_SUPPRESS_INTR_CODE && USB_CFG_HAVE_INTRIN_ENDPOINT /* placed here due to relative jump range */
+handleIn1:                      ;[38]
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+; 2006-06-10 as suggested by O.Tamura: support second INTR IN / BULK IN endpoint
+    cpi     x3, USB_CFG_EP3_NUMBER;[38]
+    breq    handleIn3           ;[39]
+#endif
+    lds     cnt, usbTxLen1      ;[40]
+    sbrc    cnt, 4              ;[42] all handshake tokens have bit 4 set
+    rjmp    sendCntAndReti      ;[43] 47 + 16 = 63 until SOP
+    sts     usbTxLen1, x1       ;[44] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf1)  ;[46]
+    ldi     YH, hi8(usbTxBuf1)  ;[47]
+    rjmp    usbSendAndReti      ;[48] 50 + 12 = 62 until SOP
+
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+handleIn3:
+    lds     cnt, usbTxLen3      ;[41]
+    sbrc    cnt, 4              ;[43]
+    rjmp    sendCntAndReti      ;[44] 49 + 16 = 65 until SOP
+    sts     usbTxLen3, x1       ;[45] x1 == USBPID_NAK from above
+    ldi     YL, lo8(usbTxBuf3)  ;[47]
+    ldi     YH, hi8(usbTxBuf3)  ;[48]
+    rjmp    usbSendAndReti      ;[49] 51 + 12 = 63 until SOP
+#endif
+#endif
Index: vusb-20121206/usbdrv/Changelog.txt
===================================================================
--- vusb-20121206/usbdrv/Changelog.txt	(nonexistent)
+++ vusb-20121206/usbdrv/Changelog.txt	(working copy)
@@ -0,0 +1,329 @@
+This file documents changes in the firmware-only USB driver for atmel's AVR
+microcontrollers. New entries are always appended to the end of the file.
+Scroll down to the bottom to see the most recent changes.
+
+2005-04-01:
+  - Implemented endpoint 1 as interrupt-in endpoint.
+  - Moved all configuration options to usbconfig.h which is not part of the
+    driver.
+  - Changed interface for usbVendorSetup().
+  - Fixed compatibility with ATMega8 device.
+  - Various minor optimizations.
+
+2005-04-11:
+  - Changed interface to application: Use usbFunctionSetup(), usbFunctionRead()
+    and usbFunctionWrite() now. Added configuration options to choose which
+    of these functions to compile in.
+  - Assembler module delivers receive data non-inverted now.
+  - Made register and bit names compatible with more AVR devices.
+
+2005-05-03:
+  - Allow address of usbRxBuf on any memory page as long as the buffer does
+    not cross 256 byte page boundaries.
+  - Better device compatibility: works with Mega88 now.
+  - Code optimization in debugging module.
+  - Documentation updates.
+
+2006-01-02:
+  - Added (free) default Vendor- and Product-IDs bought from voti.nl.
+  - Added USBID-License.txt file which defines the rules for using the free
+    shared VID/PID pair.
+  - Added Readme.txt to the usbdrv directory which clarifies administrative
+    issues.
+
+2006-01-25:
+  - Added "configured state" to become more standards compliant.
+  - Added "HALT" state for interrupt endpoint.
+  - Driver passes the "USB Command Verifier" test from usb.org now.
+  - Made "serial number" a configuration option.
+  - Minor optimizations, we now recommend compiler option "-Os" for best
+    results.
+  - Added a version number to usbdrv.h
+
+2006-02-03:
+  - New configuration variable USB_BUFFER_SECTION for the memory section where
+    the USB rx buffer will go. This defaults to ".bss" if not defined. Since
+    this buffer MUST NOT cross 256 byte pages (not even touch a page at the
+    end), the user may want to pass a linker option similar to
+    "-Wl,--section-start=.mybuffer=0x800060".
+  - Provide structure for usbRequest_t.
+  - New defines for USB constants.
+  - Prepared for HID implementations.
+  - Increased data size limit for interrupt transfers to 8 bytes.
+  - New macro usbInterruptIsReady() to query interrupt buffer state.
+
+2006-02-18:
+  - Ensure that the data token which is sent as an ack to an OUT transfer is
+    always zero sized. This fixes a bug where the host reports an error after
+    sending an out transfer to the device, although all data arrived at the
+    device.
+  - Updated docs in usbdrv.h to reflect changed API in usbFunctionWrite().
+
+* Release 2006-02-20
+
+  - Give a compiler warning when compiling with debugging turned on.
+  - Added Oleg Semyonov's changes for IAR-cc compatibility.
+  - Added new (optional) functions usbDeviceConnect() and usbDeviceDisconnect()
+    (also thanks to Oleg!).
+  - Rearranged tests in usbPoll() to save a couple of instructions in the most
+    likely case that no actions are pending.
+  - We need a delay between the SET ADDRESS request until the new address
+    becomes active. This delay was handled in usbPoll() until now. Since the
+    spec says that the delay must not exceed 2ms, previous versions required
+    aggressive polling during the enumeration phase. We have now moved the
+    handling of the delay into the interrupt routine.
+  - We must not reply with NAK to a SETUP transaction. We can only achieve this
+    by making sure that the rx buffer is empty when SETUP tokens are expected.
+    We therefore don't pass zero sized data packets from the status phase of
+    a transfer to usbPoll(). This change MAY cause troubles if you rely on
+    receiving a less than 8 bytes long packet in usbFunctionWrite() to
+    identify the end of a transfer. usbFunctionWrite() will NEVER be called
+    with a zero length.
+
+* Release 2006-03-14
+
+  - Improved IAR C support: tiny memory model, more devices
+  - Added template usbconfig.h file under the name usbconfig-prototype.h
+
+* Release 2006-03-26
+
+  - Added provision for one more interrupt-in endpoint (endpoint 3).
+  - Added provision for one interrupt-out endpoint (endpoint 1).
+  - Added flowcontrol macros for USB.
+  - Added provision for custom configuration descriptor.
+  - Allow ANY two port bits for D+ and D-.
+  - Merged (optional) receive endpoint number into global usbRxToken variable.
+  - Use USB_CFG_IOPORTNAME instead of USB_CFG_IOPORT. We now construct the
+    variable name from the single port letter instead of computing the address
+    of related ports from the output-port address.
+
+* Release 2006-06-26
+
+  - Updated documentation in usbdrv.h and usbconfig-prototype.h to reflect the
+    new features.
+  - Removed "#warning" directives because IAR does not understand them. Use
+    unused static variables instead to generate a warning.
+  - Do not include <avr/io.h> when compiling with IAR.
+  - Introduced USB_CFG_DESCR_PROPS_* in usbconfig.h to configure how each
+    USB descriptor should be handled. It is now possible to provide descriptor
+    data in Flash, RAM or dynamically at runtime.
+  - STALL is now a status in usbTxLen* instead of a message. We can now conform
+    to the spec and leave the stall status pending until it is cleared.
+  - Made usbTxPacketCnt1 and usbTxPacketCnt3 public. This allows the
+    application code to reset data toggling on interrupt pipes.
+
+* Release 2006-07-18
+
+  - Added an #if !defined __ASSEMBLER__ to the warning in usbdrv.h. This fixes
+    an assembler error.
+  - usbDeviceDisconnect() takes pull-up resistor to high impedance now.
+
+* Release 2007-02-01
+
+  - Merged in some code size improvements from usbtiny (thanks to Dick
+    Streefland for these optimizations!)
+  - Special alignment requirement for usbRxBuf not required any more. Thanks
+    again to Dick Streefland for this hint!
+  - Reverted to "#warning" instead of unused static variables -- new versions
+    of IAR CC should handle this directive.
+  - Changed Open Source license to GNU GPL v2 in order to make linking against
+    other free libraries easier. We no longer require publication of the
+    circuit diagrams, but we STRONGLY encourage it. If you improve the driver
+    itself, PLEASE grant us a royalty free license to your changes for our
+    commercial license.
+
+* Release 2007-03-29
+
+  - New configuration option "USB_PUBLIC" in usbconfig.h.
+  - Set USB version number to 1.10 instead of 1.01.
+  - Code used USB_CFG_DESCR_PROPS_STRING_DEVICE and
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT inconsistently. Changed all occurrences
+    to USB_CFG_DESCR_PROPS_STRING_PRODUCT.
+  - New assembler module for 16.5 MHz RC oscillator clock with PLL in receiver
+    code.
+  - New assembler module for 16 MHz crystal.
+  - usbdrvasm.S contains common code only, clock-specific parts have been moved
+    to usbdrvasm12.S, usbdrvasm16.S and usbdrvasm165.S respectively.
+
+* Release 2007-06-25
+
+  - 16 MHz module: Do SE0 check in stuffed bits as well.
+
+* Release 2007-07-07
+
+  - Define hi8(x) for IAR compiler to limit result to 8 bits. This is necessary
+    for negative values.
+  - Added 15 MHz module contributed by V. Bosch.
+  - Interrupt vector name can now be configured. This is useful if somebody
+    wants to use a different hardware interrupt than INT0.
+
+* Release 2007-08-07
+
+  - Moved handleIn3 routine in usbdrvasm16.S so that relative jump range is
+    not exceeded.
+  - More config options: USB_RX_USER_HOOK(), USB_INITIAL_DATATOKEN,
+    USB_COUNT_SOF
+  - USB_INTR_PENDING can now be a memory address, not just I/O
+
+* Release 2007-09-19
+
+  - Split out common parts of assembler modules into separate include file
+  - Made endpoint numbers configurable so that given interface definitions
+    can be matched. See USB_CFG_EP3_NUMBER in usbconfig-prototype.h.
+  - Store endpoint number for interrupt/bulk-out so that usbFunctionWriteOut()
+    can handle any number of endpoints.
+  - Define usbDeviceConnect() and usbDeviceDisconnect() even if no
+    USB_CFG_PULLUP_IOPORTNAME is defined. Directly set D+ and D- to 0 in this
+    case.
+
+* Release 2007-12-01
+
+  - Optimize usbDeviceConnect() and usbDeviceDisconnect() for less code size
+    when USB_CFG_PULLUP_IOPORTNAME is not defined.
+
+* Release 2007-12-13
+
+  - Renamed all include-only assembler modules from *.S to *.inc so that
+    people don't add them to their project sources.
+  - Distribute leap bits in tx loop more evenly for 16 MHz module.
+  - Use "macro" and "endm" instead of ".macro" and ".endm" for IAR
+  - Avoid compiler warnings for constant expr range by casting some values in
+    USB descriptors.
+
+* Release 2008-01-21
+
+  - Fixed bug in 15 and 16 MHz module where the new address set with
+    SET_ADDRESS was already accepted at the next NAK or ACK we send, not at
+    the next data packet we send. This caused problems when the host polled
+    too fast. Thanks to Alexander Neumann for his help and patience debugging
+    this issue!
+
+* Release 2008-02-05
+
+  - Fixed bug in 16.5 MHz module where a register was used in the interrupt
+    handler before it was pushed. This bug was introduced with version
+    2007-09-19 when common parts were moved to a separate file.
+  - Optimized CRC routine (thanks to Reimar Doeffinger).
+
+* Release 2008-02-16
+
+  - Removed outdated IAR compatibility stuff (code sections).
+  - Added hook macros for USB_RESET_HOOK() and USB_SET_ADDRESS_HOOK().
+  - Added optional routine usbMeasureFrameLength() for calibration of the
+    internal RC oscillator.
+
+* Release 2008-02-28
+
+  - USB_INITIAL_DATATOKEN defaults to USBPID_DATA1 now, which means that we
+    start with sending USBPID_DATA0.
+  - Changed defaults in usbconfig-prototype.h
+  - Added free USB VID/PID pair for MIDI class devices
+  - Restructured AVR-USB as separate package, not part of PowerSwitch any more.
+
+* Release 2008-04-18
+
+  - Restructured usbdrv.c so that it is easier to read and understand.
+  - Better code optimization with gcc 4.
+  - If a second interrupt in endpoint is enabled, also add it to config
+    descriptor.
+  - Added config option for long transfers (above 254 bytes), see
+    USB_CFG_LONG_TRANSFERS in usbconfig.h.
+  - Added 20 MHz module contributed by Jeroen Benschop.
+
+* Release 2008-05-13
+
+  - Fixed bug in libs-host/hiddata.c function usbhidGetReport(): length
+    was not incremented, pointer to length was incremented instead.
+  - Added code to command line tool(s) which claims an interface. This code
+    is disabled by default, but may be necessary on newer Linux kernels.
+  - Added usbconfig.h option "USB_CFG_CHECK_DATA_TOGGLING".
+  - New header "usbportability.h" prepares ports to other development
+    environments.
+  - Long transfers (above 254 bytes) did not work when usbFunctionRead() was
+    used to supply the data. Fixed this bug. [Thanks to Alexander Neumann!]
+  - In hiddata.c (example code for sending/receiving data over HID), use
+    USB_RECIP_DEVICE instead of USB_RECIP_INTERFACE for control transfers so
+    that we need not claim the interface.
+  - in usbPoll() loop 20 times polling for RESET state instead of 10 times.
+    This accounts for the higher clock rates we now support.
+  - Added a module for 12.8 MHz RC oscillator with PLL in receiver loop.
+  - Added hook to SOF code so that oscillator can be tuned to USB frame clock.
+  - Added timeout to waitForJ loop. Helps preventing unexpected hangs.
+  - Added example code for oscillator tuning to libs-device (thanks to
+    Henrik Haftmann for the idea to this routine).
+  - Implemented option USB_CFG_SUPPRESS_INTR_CODE.
+
+* Release 2008-10-22
+
+  - Fixed libs-device/osctune.h: OSCCAL is memory address on ATMega88 and
+    similar, not offset of 0x20 needs to be added.
+  - Allow distribution under GPLv3 for those who have to link against other
+    code distributed under GPLv3.
+
+* Release 2008-11-26
+
+  - Removed libusb-win32 dependency for hid-data example in Makefile.windows.
+    It was never required and confused many people.
+  - Added extern uchar usbRxToken to usbdrv.h.
+  - Integrated a module with CRC checks at 18 MHz by Lukas Schrittwieser.
+
+* Release 2009-03-23
+
+  - Hid-mouse example used settings from hid-data example, fixed that.
+  - Renamed project to V-USB due to a trademark issue with Atmel(r).
+  - Changed CommercialLicense.txt and USBID-License.txt to make the
+    background of USB ID registration clearer.
+
+* Release 2009-04-15
+
+  - Changed CommercialLicense.txt to reflect the new range of PIDs from
+    Jason Kotzin.
+  - Removed USBID-License.txt in favor of USB-IDs-for-free.txt and
+    USB-ID-FAQ.txt
+  - Fixed a bug in the 12.8 MHz module: End Of Packet decection was made in
+    the center between bit 0 and 1 of each byte. This is where the data lines
+    are expected to change and the sampled data may therefore be nonsense.
+    We therefore check EOP ONLY if bits 0 AND 1 have both been read as 0 on D-.
+  - Fixed a bitstuffing problem in the 16 MHz module: If bit 6 was stuffed,
+    the unstuffing code in the receiver routine was 1 cycle too long. If
+    multiple bytes had the unstuffing in bit 6, the error summed up until the
+    receiver was out of sync.
+  - Included option for faster CRC routine.
+    Thanks to Slawomir Fras (BoskiDialer) for this code!
+  - Updated bits in Configuration Descriptor's bmAttributes according to
+    USB 1.1 (in particular bit 7, it is a must-be-set bit now).
+
+* Release 2009-08-22
+
+  - Moved first DBG1() after odDebugInit() in all examples.
+  - Use vector INT0_vect instead of SIG_INTERRUPT0 if defined. This makes
+    V-USB compatible with the new "p" suffix devices (e.g. ATMega328p).
+  - USB_CFG_CLOCK_KHZ setting is now required in usbconfig.h (no default any
+    more).
+  - New option USB_CFG_DRIVER_FLASH_PAGE allows boot loaders on devices with
+    more than 64 kB flash.
+  - Built-in configuration descriptor allows custom definition for second
+    endpoint now.
+
+* Release 2010-07-15
+
+  - Fixed bug in usbDriverSetup() which prevented descriptor sizes above 255
+    bytes.
+  - Avoid a compiler warning for unused parameter in usbHandleResetHook() when
+    compiler option -Wextra is enabled.
+  - Fixed wrong hex value for some IDs in USB-IDs-for-free.txt.
+  - Keep a define for USBATTR_BUSPOWER, although the flag does not exist
+    in USB 1.1 any more. Set it to 0. This is for backward compatibility.
+
+* Release 2012-01-09
+
+  - Define a separate (defined) type for usbMsgPtr so that projects using a
+    tiny memory model can define it to an 8 bit type in usbconfig.h. This
+    change also saves a couple of bytes when using a scalar 16 bit type.
+  - Inserted "const" keyword for all PROGMEM declarations because new GCC
+    requires it.
+  - Fixed problem with dependence of usbportability.h on usbconfig.h. This
+    problem occurred with IAR CC only.
+  - Prepared repository for github.com.
+
+* Release 2012-12-06
\ No newline at end of file
Index: vusb-20121206/usbdrv/CommercialLicense.txt
===================================================================
--- vusb-20121206/usbdrv/CommercialLicense.txt	(nonexistent)
+++ vusb-20121206/usbdrv/CommercialLicense.txt	(working copy)
@@ -0,0 +1,166 @@
+V-USB Driver Software License Agreement
+Version 2012-07-09
+
+THIS LICENSE AGREEMENT GRANTS YOU CERTAIN RIGHTS IN A SOFTWARE. YOU CAN
+ENTER INTO THIS AGREEMENT AND ACQUIRE THE RIGHTS OUTLINED BELOW BY PAYING
+THE AMOUNT ACCORDING TO SECTION 4 ("PAYMENT") TO OBJECTIVE DEVELOPMENT.
+
+
+1 DEFINITIONS
+
+1.1 "OBJECTIVE DEVELOPMENT" shall mean OBJECTIVE DEVELOPMENT Software GmbH,
+Grosse Schiffgasse 1A/7, 1020 Wien, AUSTRIA.
+
+1.2 "You" shall mean the Licensee.
+
+1.3 "V-USB" shall mean all files included in the package distributed under
+the name "vusb" by OBJECTIVE DEVELOPMENT (http://www.obdev.at/vusb/)
+unless otherwise noted. This includes the firmware-only USB device
+implementation for Atmel AVR microcontrollers, some simple device examples
+and host side software examples and libraries.
+
+
+2 LICENSE GRANTS
+
+2.1 Source Code. OBJECTIVE DEVELOPMENT shall furnish you with the source
+code of V-USB.
+
+2.2 Distribution and Use. OBJECTIVE DEVELOPMENT grants you the
+non-exclusive right to use, copy and distribute V-USB with your hardware
+product(s), restricted by the limitations in section 3 below.
+
+2.3 Modifications. OBJECTIVE DEVELOPMENT grants you the right to modify
+the source code and your copy of V-USB according to your needs.
+
+2.4 USB IDs. OBJECTIVE DEVELOPMENT furnishes you with one or two USB
+Product ID(s), sent to you in e-mail. These Product IDs are reserved
+exclusively for you. OBJECTIVE DEVELOPMENT has obtained USB Product ID
+ranges under the Vendor ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under the Vendor ID 8352 from
+Jason Kotzin (now flirc.tv, Inc.). Both owners of the Vendor IDs have
+obtained these IDs from the USB Implementers Forum, Inc. (www.usb.org).
+OBJECTIVE DEVELOPMENT disclaims all liability which might arise from the
+assignment of USB IDs.
+
+2.5 USB Certification. Although not part of this agreement, we want to make
+it clear that you cannot become USB certified when you use V-USB or a USB
+Product ID assigned by OBJECTIVE DEVELOPMENT. AVR microcontrollers don't
+meet the electrical specifications required by the USB specification and
+the USB Implementers Forum certifies only members who bought a Vendor ID of
+their own.
+
+
+3 LICENSE RESTRICTIONS
+
+3.1 Number of Units. Only one of the following three definitions is
+applicable. Which one is determined by the amount you pay to OBJECTIVE
+DEVELOPMENT, see section 4 ("Payment") below.
+
+Hobby License: You may use V-USB according to section 2 above in no more
+than 5 hardware units. These units must not be sold for profit.
+
+Entry Level License: You may use V-USB according to section 2 above in no
+more than 150 hardware units.
+
+Professional License: You may use V-USB according to section 2 above in
+any number of hardware units, except for large scale production ("unlimited
+fair use"). Quantities below 10,000 units are not considered large scale
+production. If your reach quantities which are obviously large scale
+production, you must pay a license fee of 0.10 EUR per unit for all units
+above 10,000.
+
+3.2 Rental. You may not rent, lease, or lend V-USB or otherwise encumber
+any copy of V-USB, or any of the rights granted herein.
+
+3.3 Transfer. You may not transfer your rights under this Agreement to
+another party without OBJECTIVE DEVELOPMENT's prior written consent. If
+such consent is obtained, you may permanently transfer this License to
+another party. The recipient of such transfer must agree to all terms and
+conditions of this Agreement.
+
+3.4 Reservation of Rights. OBJECTIVE DEVELOPMENT retains all rights not
+expressly granted.
+
+3.5 Non-Exclusive Rights. Your license rights under this Agreement are
+non-exclusive.
+
+3.6 Third Party Rights. This Agreement cannot grant you rights controlled
+by third parties. In particular, you are not allowed to use the USB logo or
+other trademarks owned by the USB Implementers Forum, Inc. without their
+consent. Since such consent depends on USB certification, it should be
+noted that V-USB will not pass certification because it does not
+implement checksum verification and the microcontroller ports do not meet
+the electrical specifications.
+
+
+4 PAYMENT
+
+The payment amount depends on the variation of this agreement (according to
+section 3.1) into which you want to enter. Concrete prices are listed on
+OBJECTIVE DEVELOPMENT's web site, usually at
+http://www.obdev.at/vusb/license.html. You agree to pay the amount listed
+there to OBJECTIVE DEVELOPMENT or OBJECTIVE DEVELOPMENT's payment processor
+or reseller.
+
+
+5 COPYRIGHT AND OWNERSHIP
+
+V-USB is protected by copyright laws and international copyright
+treaties, as well as other intellectual property laws and treaties. V-USB
+is licensed, not sold.
+
+
+6 TERM AND TERMINATION
+
+6.1 Term. This Agreement shall continue indefinitely. However, OBJECTIVE
+DEVELOPMENT may terminate this Agreement and revoke the granted license and
+USB-IDs if you fail to comply with any of its terms and conditions.
+
+6.2 Survival of Terms. All provisions regarding secrecy, confidentiality
+and limitation of liability shall survive termination of this agreement.
+
+
+7 DISCLAIMER OF WARRANTY AND LIABILITY
+
+LIMITED WARRANTY. V-USB IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
+KIND. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, OBJECTIVE
+DEVELOPMENT AND ITS SUPPLIERS HEREBY DISCLAIM ALL WARRANTIES, EITHER
+EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND
+NON-INFRINGEMENT, WITH REGARD TO V-USB, AND THE PROVISION OF OR FAILURE
+TO PROVIDE SUPPORT SERVICES. THIS LIMITED WARRANTY GIVES YOU SPECIFIC LEGAL
+RIGHTS. YOU MAY HAVE OTHERS, WHICH VARY FROM STATE/JURISDICTION TO
+STATE/JURISDICTION.
+
+LIMITATION OF LIABILITY. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW,
+IN NO EVENT SHALL OBJECTIVE DEVELOPMENT OR ITS SUPPLIERS BE LIABLE FOR ANY
+SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER
+(INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
+BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY
+LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE V-USB OR THE
+PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES, EVEN IF OBJECTIVE
+DEVELOPMENT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY
+CASE, OBJECTIVE DEVELOPMENT'S ENTIRE LIABILITY UNDER ANY PROVISION OF THIS
+AGREEMENT SHALL BE LIMITED TO THE AMOUNT ACTUALLY PAID BY YOU FOR V-USB.
+
+
+8 MISCELLANEOUS TERMS
+
+8.1 Marketing. OBJECTIVE DEVELOPMENT has the right to mention for marketing
+purposes that you entered into this agreement.
+
+8.2 Entire Agreement. This document represents the entire agreement between
+OBJECTIVE DEVELOPMENT and you. It may only be modified in writing signed by
+an authorized representative of both, OBJECTIVE DEVELOPMENT and you.
+
+8.3 Severability. In case a provision of these terms and conditions should
+be or become partly or entirely invalid, ineffective, or not executable,
+the validity of all other provisions shall not be affected.
+
+8.4 Applicable Law. This agreement is governed by the laws of the Republic
+of Austria.
+
+8.5 Responsible Courts. The responsible courts in Vienna/Austria will have
+exclusive jurisdiction regarding all disputes in connection with this
+agreement.
+
Index: vusb-20121206/usbdrv/License.txt
===================================================================
--- vusb-20121206/usbdrv/License.txt	(nonexistent)
+++ vusb-20121206/usbdrv/License.txt	(working copy)
@@ -0,0 +1,361 @@
+OBJECTIVE DEVELOPMENT GmbH's V-USB driver software is distributed under the
+terms and conditions of the GNU GPL version 2 or the GNU GPL version 3. It is
+your choice whether you apply the terms of version 2 or version 3. The full
+text of GPLv2 is included below. In addition to the requirements in the GPL,
+we STRONGLY ENCOURAGE you to do the following:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: vusb-20121206/usbdrv/oddebug.c
===================================================================
--- vusb-20121206/usbdrv/oddebug.c	(nonexistent)
+++ vusb-20121206/usbdrv/oddebug.c	(working copy)
@@ -0,0 +1,49 @@
+/* Name: oddebug.c
+ * Project: AVR library
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-01-16
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include "oddebug.h"
+
+#if DEBUG_LEVEL > 0
+
+#warning "Never compile production devices with debugging enabled"
+
+static void uartPutc(char c)
+{
+    while(!(ODDBG_USR & (1 << ODDBG_UDRE)));    /* wait for data register empty */
+    ODDBG_UDR = c;
+}
+
+static uchar    hexAscii(uchar h)
+{
+    h &= 0xf;
+    if(h >= 10)
+        h += 'a' - (uchar)10 - '0';
+    h += '0';
+    return h;
+}
+
+static void printHex(uchar c)
+{
+    uartPutc(hexAscii(c >> 4));
+    uartPutc(hexAscii(c));
+}
+
+void    odDebug(uchar prefix, uchar *data, uchar len)
+{
+    printHex(prefix);
+    uartPutc(':');
+    while(len--){
+        uartPutc(' ');
+        printHex(*data++);
+    }
+    uartPutc('\r');
+    uartPutc('\n');
+}
+
+#endif
Index: vusb-20121206/usbdrv/oddebug.h
===================================================================
--- vusb-20121206/usbdrv/oddebug.h	(nonexistent)
+++ vusb-20121206/usbdrv/oddebug.h	(working copy)
@@ -0,0 +1,122 @@
+/* Name: oddebug.h
+ * Project: AVR library
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-01-16
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __oddebug_h_included__
+#define __oddebug_h_included__
+
+/*
+General Description:
+This module implements a function for debug logs on the serial line of the
+AVR microcontroller. Debugging can be configured with the define
+'DEBUG_LEVEL'. If this macro is not defined or defined to 0, all debugging
+calls are no-ops. If it is 1, DBG1 logs will appear, but not DBG2. If it is
+2, DBG1 and DBG2 logs will be printed.
+
+A debug log consists of a label ('prefix') to indicate which debug log created
+the output and a memory block to dump in hex ('data' and 'len').
+*/
+
+
+#ifndef F_CPU
+#   define  F_CPU   12000000    /* 12 MHz */
+#endif
+
+/* make sure we have the UART defines: */
+#include "usbportability.h"
+
+#ifndef uchar
+#   define  uchar   unsigned char
+#endif
+
+#if DEBUG_LEVEL > 0 && !(defined TXEN || defined TXEN0) /* no UART in device */
+#   warning "Debugging disabled because device has no UART"
+#   undef   DEBUG_LEVEL
+#endif
+
+#ifndef DEBUG_LEVEL
+#   define  DEBUG_LEVEL 0
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#if DEBUG_LEVEL > 0
+#   define  DBG1(prefix, data, len) odDebug(prefix, data, len)
+#else
+#   define  DBG1(prefix, data, len)
+#endif
+
+#if DEBUG_LEVEL > 1
+#   define  DBG2(prefix, data, len) odDebug(prefix, data, len)
+#else
+#   define  DBG2(prefix, data, len)
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#if DEBUG_LEVEL > 0
+extern void odDebug(uchar prefix, uchar *data, uchar len);
+
+/* Try to find our control registers; ATMEL likes to rename these */
+
+#if defined UBRR
+#   define  ODDBG_UBRR  UBRR
+#elif defined UBRRL
+#   define  ODDBG_UBRR  UBRRL
+#elif defined UBRR0
+#   define  ODDBG_UBRR  UBRR0
+#elif defined UBRR0L
+#   define  ODDBG_UBRR  UBRR0L
+#endif
+
+#if defined UCR
+#   define  ODDBG_UCR   UCR
+#elif defined UCSRB
+#   define  ODDBG_UCR   UCSRB
+#elif defined UCSR0B
+#   define  ODDBG_UCR   UCSR0B
+#endif
+
+#if defined TXEN
+#   define  ODDBG_TXEN  TXEN
+#else
+#   define  ODDBG_TXEN  TXEN0
+#endif
+
+#if defined USR
+#   define  ODDBG_USR   USR
+#elif defined UCSRA
+#   define  ODDBG_USR   UCSRA
+#elif defined UCSR0A
+#   define  ODDBG_USR   UCSR0A
+#endif
+
+#if defined UDRE
+#   define  ODDBG_UDRE  UDRE
+#else
+#   define  ODDBG_UDRE  UDRE0
+#endif
+
+#if defined UDR
+#   define  ODDBG_UDR   UDR
+#elif defined UDR0
+#   define  ODDBG_UDR   UDR0
+#endif
+
+static inline void  odDebugInit(void)
+{
+    ODDBG_UCR |= (1<<ODDBG_TXEN);
+    ODDBG_UBRR = F_CPU / (19200 * 16L) - 1;
+}
+#else
+#   define odDebugInit()
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+#endif /* __oddebug_h_included__ */
Index: vusb-20121206/usbdrv/Readme.txt
===================================================================
--- vusb-20121206/usbdrv/Readme.txt	(nonexistent)
+++ vusb-20121206/usbdrv/Readme.txt	(working copy)
@@ -0,0 +1,172 @@
+This is the Readme file to Objective Development's firmware-only USB driver
+for Atmel AVR microcontrollers. For more information please visit
+http://www.obdev.at/vusb/
+
+This directory contains the USB firmware only. Copy it as-is to your own
+project and add all .c and .S files to your project (these files are marked
+with an asterisk in the list below). Then copy usbconfig-prototype.h as
+usbconfig.h to your project and edit it according to your configuration.
+
+
+TECHNICAL DOCUMENTATION
+=======================
+The technical documentation (API) for the firmware driver is contained in the
+file "usbdrv.h". Please read all of it carefully! Configuration options are
+documented in "usbconfig-prototype.h".
+
+The driver consists of the following files:
+  Readme.txt ............. The file you are currently reading.
+  Changelog.txt .......... Release notes for all versions of the driver.
+  usbdrv.h ............... Driver interface definitions and technical docs.
+* usbdrv.c ............... High level language part of the driver. Link this
+                           module to your code!
+* usbdrvasm.S ............ Assembler part of the driver. This module is mostly
+                           a stub and includes one of the usbdrvasm*.S files
+                           depending on processor clock. Link this module to
+                           your code!
+  usbdrvasm*.inc ......... Assembler routines for particular clock frequencies.
+                           Included by usbdrvasm.S, don't link it directly!
+  asmcommon.inc .......... Common assembler routines. Included by
+                           usbdrvasm*.inc, don't link it directly!
+  usbconfig-prototype.h .. Prototype for your own usbdrv.h file.
+* oddebug.c .............. Debug functions. Only used when DEBUG_LEVEL is
+                           defined to a value greater than 0. Link this module
+                           to your code!
+  oddebug.h .............. Interface definitions of the debug module.
+  usbportability.h ....... Header with compiler-dependent stuff.
+  usbdrvasm.asm .......... Compatibility stub for IAR-C-compiler. Use this
+                           module instead of usbdrvasm.S when you assembler
+                           with IAR's tools.
+  License.txt ............ Open Source license for this driver.
+  CommercialLicense.txt .. Optional commercial license for this driver.
+  USB-ID-FAQ.txt ......... General infos about USB Product- and Vendor-IDs.
+  USB-IDs-for-free.txt ... List and terms of use for free shared PIDs.
+
+(*) ... These files should be linked to your project.
+
+
+CPU CORE CLOCK FREQUENCY
+========================
+We supply assembler modules for clock frequencies of 12 MHz, 12.8 MHz, 15 MHz,
+16 MHz, 16.5 MHz 18 MHz and 20 MHz. Other clock rates are not supported. The
+actual clock rate must be configured in usbconfig.h.
+
+12 MHz Clock
+This is the traditional clock rate of V-USB because it's the lowest clock
+rate where the timing constraints of the USB spec can be met.
+
+15 MHz Clock
+Similar to 12 MHz, but some NOPs inserted. On the other hand, the higher clock
+rate allows for some loops which make the resulting code size somewhat smaller
+than the 12 MHz version.
+
+16 MHz Clock
+This clock rate has been added for users of the Arduino board and other
+ready-made boards which come with a fixed 16 MHz crystal. It's also an option
+if you need the slightly higher clock rate for performance reasons. Since
+16 MHz is not divisible by the USB low speed bit clock of 1.5 MHz, the code
+is somewhat tricky and has to insert a leap cycle every third byte.
+
+12.8 MHz and 16.5 MHz Clock
+The assembler modules for these clock rates differ from the other modules
+because they have been built for an RC oscillator with only 1% precision. The
+receiver code inserts leap cycles to compensate for clock deviations. 1% is
+also the precision which can be achieved by calibrating the internal RC
+oscillator of the AVR. Please note that only AVRs with internal 64 MHz PLL
+oscillator can reach 16.5 MHz with the RC oscillator. This includes the very
+popular ATTiny25, ATTiny45, ATTiny85 series as well as the ATTiny26. Almost
+all AVRs can reach 12.8 MHz, although this is outside the specified range.
+
+See the EasyLogger example at http://www.obdev.at/vusb/easylogger.html for
+code which calibrates the RC oscillator based on the USB frame clock.
+
+18 MHz Clock
+This module is closer to the USB specification because it performs an on the
+fly CRC check for incoming packets. Packets with invalid checksum are
+discarded as required by the spec. If you also implement checks for data
+PID toggling on application level (see option USB_CFG_CHECK_DATA_TOGGLING
+in usbconfig.h for more info), this ensures data integrity. Due to the CRC
+tables and alignment requirements, this code is bigger than modules for other
+clock rates. To activate this module, you must define USB_CFG_CHECK_CRC to 1
+and USB_CFG_CLOCK_KHZ to 18000 in usbconfig.h.
+
+20 MHz Clock
+This module is for people who won't do it with less than the maximum. Since
+20 MHz is not divisible by the USB low speed bit clock of 1.5 MHz, the code
+uses similar tricks as the 16 MHz module to insert leap cycles.
+
+
+USB IDENTIFIERS
+===============
+Every USB device needs a vendor- and a product-identifier (VID and PID). VIDs
+are obtained from usb.org for a price of 1,500 USD. Once you have a VID, you
+can assign PIDs at will.
+
+Since an entry level cost of 1,500 USD is too high for most small companies
+and hobbyists, we provide some VID/PID pairs for free. See the file
+USB-IDs-for-free.txt for details.
+
+Objective Development also has some license offerings which include product
+IDs. See http://www.obdev.at/vusb/ for details.
+
+
+DEVELOPMENT SYSTEM
+==================
+This driver has been developed and optimized for the GNU compiler version 3
+and 4. We recommend that you use the GNU compiler suite because it is freely
+available. V-USB has also been ported to the IAR compiler and assembler. It
+has been tested with IAR 4.10B/W32 and 4.12A/W32 on an ATmega8 with the
+"small" and "tiny" memory model. Not every release is tested with IAR CC and
+the driver may therefore fail to compile with IAR. Please note that gcc is
+more efficient for usbdrv.c because this module has been deliberately
+optimized for gcc.
+
+Gcc version 3 produces smaller code than version 4 due to new optimizing
+capabilities which don't always improve things on 8 bit CPUs. The code size
+generated by gcc 4 can be reduced with the compiler options
+-fno-move-loop-invariants, -fno-tree-scev-cprop and
+-fno-inline-small-functions in addition to -Os. On devices with more than
+8k of flash memory, we also recommend the linker option --relax (written as
+-Wl,--relax for gcc) to convert absolute calls into relative where possible.
+
+For more information about optimizing options see:
+
+    http://www.tty1.net/blog/2008-04-29-avr-gcc-optimisations_en.html
+
+These optimizations are good for gcc 4.x. Version 3.x of gcc does not support
+most of these options and produces good code anyway.
+
+
+USING V-USB FOR FREE
+====================
+The AVR firmware driver is published under the GNU General Public License
+Version 2 (GPL2) and the GNU General Public License Version 3 (GPL3). It is
+your choice whether you apply the terms of version 2 or version 3.
+
+If you decide for the free GPL2 or GPL3, we STRONGLY ENCOURAGE you to do the
+following things IN ADDITION to the obligations from the GPL:
+
+(1) Publish your entire project on a web site and drop us a note with the URL.
+Use the form at http://www.obdev.at/vusb/feedback.html for your submission.
+If you don't have a web site, you can publish the project in obdev's
+documentation wiki at
+http://www.obdev.at/goto.php?t=vusb-wiki&p=hosted-projects.
+
+(2) Adhere to minimum publication standards. Please include AT LEAST:
+    - a circuit diagram in PDF, PNG or GIF format
+    - full source code for the host software
+    - a Readme.txt file in ASCII format which describes the purpose of the
+      project and what can be found in which directories and which files
+    - a reference to http://www.obdev.at/vusb/
+
+(3) If you improve the driver firmware itself, please give us a free license
+to your modifications for our commercial license offerings.
+
+
+COMMERCIAL LICENSES FOR V-USB
+=============================
+If you don't want to publish your source code under the terms of the GPL,
+you can simply pay money for V-USB. As an additional benefit you get
+USB PIDs for free, reserved exclusively to you. See the file
+"CommercialLicense.txt" for details.
+
Index: vusb-20121206/usbdrv/USB-ID-FAQ.txt
===================================================================
--- vusb-20121206/usbdrv/USB-ID-FAQ.txt	(nonexistent)
+++ vusb-20121206/usbdrv/USB-ID-FAQ.txt	(working copy)
@@ -0,0 +1,149 @@
+Version 2012-07-09
+
+==========================
+WHY DO WE NEED THESE IDs?
+==========================
+
+USB is more than a low level protocol for data transport. It also defines a
+common set of requests which must be understood by all devices. And as part
+of these common requests, the specification defines data structures, the
+USB Descriptors, which are used to describe the properties of the device.
+
+From the perspective of an operating system, it is therefore possible to find
+out basic properties of a device (such as e.g. the manufacturer and the name
+of the device) without a device-specific driver. This is essential because
+the operating system can choose a driver to load based on this information
+(Plug-And-Play).
+
+Among the most important properties in the Device Descriptor are the USB
+Vendor- and Product-ID. Both are 16 bit integers. The most simple form of
+driver matching is based on these IDs. The driver announces the Vendor- and
+Product-IDs of the devices it can handle and the operating system loads the
+appropriate driver when the device is connected.
+
+It is obvious that this technique only works if the pair Vendor- plus
+Product-ID is unique: Only devices which require the same driver can have the
+same pair of IDs.
+
+
+=====================================================
+HOW DOES THE USB STANDARD ENSURE THAT IDs ARE UNIQUE?
+=====================================================
+
+Since it is so important that USB IDs are unique, the USB Implementers Forum,
+Inc. (usb.org) needs a way to enforce this legally. It is not forbidden by
+law to build a device and assign it any random numbers as IDs. Usb.org
+therefore needs an agreement to regulate the use of USB IDs. The agreement
+binds only parties who agreed to it, of course. Everybody else is free to use
+any numbers for their IDs.
+
+So how can usb.org ensure that every manufacturer of USB devices enters into
+an agreement with them? They do it via trademark licensing. Usb.org has
+registered the trademark "USB", all associated logos and related terms. If
+you want to put an USB logo on your product or claim that it is USB
+compliant, you must license these trademarks from usb.org. And this is where
+you enter into an agreement. See the "USB-IF Trademark License Agreement and
+Usage Guidelines for the USB-IF Logo" at
+http://www.usb.org/developers/logo_license/.
+
+Licensing the USB trademarks requires that you buy a USB Vendor-ID from
+usb.org (one-time fee of ca. 2,000 USD), that you become a member of usb.org
+(yearly fee of ca. 4,000 USD) and that you meet all the technical
+specifications from the USB spec.
+
+This means that most hobbyists and small companies will never be able to
+become USB compliant, just because membership is so expensive. And you can't
+be compliant with a driver based on V-USB anyway, because the AVR's port pins
+don't meet the electrical specifications for USB. So, in principle, all
+hobbyists and small companies are free to choose any random numbers for their
+IDs. They have nothing to lose...
+
+There is one exception worth noting, though: If you use a sub-component which
+implements USB, the vendor of the sub-components may guarantee USB
+compliance. This might apply to some or all of FTDI's solutions.
+
+
+=======================================================================
+WHY SHOULD YOU OBTAIN USB IDs EVEN IF YOU DON'T LICENSE USB TRADEMARKS?
+=======================================================================
+
+You have learned in the previous section that you are free to choose any
+numbers for your IDs anyway. So why not do exactly this? There is still the
+technical issue. If you choose IDs which are already in use by somebody else,
+operating systems will load the wrong drivers and your device won't work.
+Even if you choose IDs which are not currently in use, they may be in use in
+the next version of the operating system or even after an automatic update.
+
+So what you need is a pair of Vendor- and Product-IDs for which you have the
+guarantee that no USB compliant product uses them. This implies that no
+operating system will ever ship with drivers responsible for these IDs.
+
+
+==============================================
+HOW DOES OBJECTIVE DEVELOPMENT HANDLE USB IDs?
+==============================================
+
+Objective Development gives away pairs of USB-IDs with their V-USB licenses.
+In order to ensure that these IDs are unique, Objective Development has an
+agreement with the company/person who has bought the USB Vendor-ID from
+usb.org. This agreement ensures that a range of USB Product-IDs is reserved
+for assignment by Objective Development and that the owner of the Vendor-ID
+won't give it to anybody else.
+
+This means that you have to trust three parties to ensure uniqueness of
+your IDs:
+
+  - Objective Development, that they don't give the same PID to more than
+    one person.
+  - The owner of the Vendor-ID that they don't assign PIDs from the range
+    assigned to Objective Development to anybody else.
+  - Usb.org that they don't assign the same Vendor-ID a second time.
+
+
+==================================
+WHO IS THE OWNER OF THE VENDOR-ID?
+==================================
+
+Objective Development has obtained ranges of USB Product-IDs under two
+Vendor-IDs: Under Vendor-ID 5824 from Wouter van Ooijen (Van Ooijen
+Technische Informatica, www.voti.nl) and under Vendor-ID 8352 from Jason
+Kotzin (now flirc.tv, Inc.). Both VID owners have received their Vendor-ID
+directly from usb.org.
+
+
+=========================================================================
+CAN I USE USB-IDs FROM OBJECTIVE DEVELOPMENT WITH OTHER DRIVERS/HARDWARE?
+=========================================================================
+
+The short answer is: Yes. All you get is a guarantee that the IDs are never
+assigned to anybody else. What more do you need?
+
+
+============================
+WHAT ABOUT SHARED ID PAIRS?
+============================
+
+Objective Development has reserved some PID/VID pairs for shared use. You
+have no guarantee of uniqueness for them, except that no USB compliant device
+uses them. In order to avoid technical problems, we must ensure that all
+devices with the same pair of IDs use the same driver on kernel level. For
+details, see the file USB-IDs-for-free.txt.
+
+
+======================================================
+I HAVE HEARD THAT SUB-LICENSING OF USB-IDs IS ILLEGAL?
+======================================================
+
+A 16 bit integer number cannot be protected by copyright laws. It is not
+sufficiently complex. And since none of the parties involved entered into the
+USB-IF Trademark License Agreement, we are not bound by this agreement. So
+there is no reason why it should be illegal to sub-license USB-IDs.
+
+
+=============================================
+WHO IS LIABLE IF THERE ARE INCOMPATIBILITIES?
+=============================================
+
+Objective Development disclaims all liabilities which might arise from the
+assignment of IDs. If you guarantee product features to your customers
+without proper disclaimer, YOU are liable for that.
Index: vusb-20121206/usbdrv/USB-IDs-for-free.txt
===================================================================
--- vusb-20121206/usbdrv/USB-IDs-for-free.txt	(nonexistent)
+++ vusb-20121206/usbdrv/USB-IDs-for-free.txt	(working copy)
@@ -0,0 +1,154 @@
+Version 2009-08-22
+
+===========================
+FREE USB-IDs FOR SHARED USE
+===========================
+
+Objective Development has reserved a set of USB Product-IDs for use according
+to the guidelines outlined below. For more information about the concept of
+USB IDs please see the file USB-ID-FAQ.txt. Objective Development guarantees
+that the IDs listed below are not used by any USB compliant devices.
+
+
+====================
+MECHANISM OF SHARING
+====================
+
+From a technical point of view, two different devices can share the same USB
+Vendor- and Product-ID if they require the same driver on operating system
+level. We make use of this fact by assigning separate IDs for various device
+classes. On application layer, devices must be distinguished by their textual
+name or serial number. We offer separate sets of IDs for discrimination by
+textual name and for serial number.
+
+Examples for shared use of USB IDs are included with V-USB in the "examples"
+subdirectory.
+
+
+======================================
+IDs FOR DISCRIMINATION BY TEXTUAL NAME
+======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the manufacturer
+and product identification. The manufacturer identification MUST be available
+at least in USB language 0x0409 (English/US).
+
+(2) The textual manufacturer identification MUST contain either an Internet
+domain name (e.g. "mycompany.com") registered and owned by you, or an e-mail
+address under your control (e.g. "myname@gmx.net"). You can embed the domain
+name or e-mail address in any string you like, e.g.  "Objective Development
+http://www.obdev.at/vusb/".
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(4) You may choose any string for the textual product identification, as long
+as this string is unique within the scope of your textual manufacturer
+identification.
+
+(5) Application side device look-up MUST be based on the textual manufacturer
+and product identification in addition to VID/PID matching. The driver
+matching MUST be a comparison of the entire strings, NOT a sub-string match.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+Table if IDs for discrimination by textual name:
+
+PID dec (hex) | VID dec (hex) | Description of use
+==============+===============+============================================
+1500 (0x05dc) | 5824 (0x16c0) | For Vendor Class devices with libusb
+--------------+---------------+--------------------------------------------
+1503 (0x05df) | 5824 (0x16c0) | For generic HID class devices (which are
+              |               | NOT mice, keyboards or joysticks)
+--------------+---------------+--------------------------------------------
+1505 (0x05e1) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+--------------+---------------+--------------------------------------------
+1508 (0x05e4) | 5824 (0x16c0) | For MIDI class devices
+--------------+---------------+--------------------------------------------
+
+Note that Windows caches the textual product- and vendor-description for
+mice, keyboards and joysticks. Name-bsed discrimination is therefore not
+recommended for these device classes.
+
+
+=======================================
+IDs FOR DISCRIMINATION BY SERIAL NUMBER
+=======================================
+
+If you use one of the IDs listed below, your device and host-side software
+must conform to these rules:
+
+(1) The USB device MUST provide a textual representation of the serial
+number, unless ONLY the operating system's default class driver is used.
+The serial number string MUST be available at least in USB language 0x0409
+(English/US).
+
+(2) The serial number MUST start with either an Internet domain name (e.g.
+"mycompany.com") registered and owned by you, or an e-mail address under your
+control (e.g. "myname@gmx.net"), both terminated with a colon (":") character.
+You MAY append any string you like for further discrimination of your devices.
+
+(3) You are responsible for retaining ownership of the domain or e-mail
+address for as long as any of your products are in use.
+
+(5) Application side device look-up MUST be based on the serial number string
+in addition to VID/PID matching. The matching must start at the first
+character of the serial number string and include the colon character
+terminating your domain or e-mail address. It MAY stop anywhere after that.
+
+(6) For devices which implement a particular USB device class (e.g. HID), the
+operating system's default class driver MUST be used. If an operating system
+driver for Vendor Class devices is needed, this driver must be libusb or
+libusb-win32 (see http://libusb.org/ and
+http://libusb-win32.sourceforge.net/).
+
+(7) If ONLY the operating system's default class driver is used, e.g. for
+mice, keyboards, joysticks, CDC or MIDI devices and no discrimination by an
+application is needed, the serial number may be omitted.
+
+
+Table if IDs for discrimination by serial number string:
+
+PID dec (hex)  | VID dec (hex) | Description of use
+===============+===============+===========================================
+10200 (0x27d8) | 5824 (0x16c0) | For Vendor Class devices with libusb
+---------------+---------------+-------------------------------------------
+10201 (0x27d9) | 5824 (0x16c0) | For generic HID class devices (which are
+               |               | NOT mice, keyboards or joysticks)
+---------------+---------------+-------------------------------------------
+10202 (0x27da) | 5824 (0x16c0) | For USB Mice
+---------------+---------------+-------------------------------------------
+10203 (0x27db) | 5824 (0x16c0) | For USB Keyboards
+---------------+---------------+-------------------------------------------
+10204 (0x27dc) | 5824 (0x16c0) | For USB Joysticks
+---------------+---------------+-------------------------------------------
+10205 (0x27dd) | 5824 (0x16c0) | For CDC-ACM class devices (modems)
+---------------+---------------+-------------------------------------------
+10206 (0x27de) | 5824 (0x16c0) | For MIDI class devices
+---------------+---------------+-------------------------------------------
+
+
+=================
+ORIGIN OF USB-IDs
+=================
+
+OBJECTIVE DEVELOPMENT Software GmbH has obtained all VID/PID pairs listed
+here from Wouter van Ooijen (see www.voti.nl) for exclusive disposition.
+Wouter van Ooijen has obtained the VID from the USB Implementers Forum, Inc.
+(see www.usb.org). The VID is registered for the company name "Van Ooijen
+Technische Informatica".
+
+
+==========
+DISCLAIMER
+==========
+
+OBJECTIVE DEVELOPMENT Software GmbH disclaims all liability for any
+problems which are caused by the shared use of these VID/PID pairs.
Index: vusb-20121206/usbdrv/usbconfig-prototype.h
===================================================================
--- vusb-20121206/usbdrv/usbconfig-prototype.h	(nonexistent)
+++ vusb-20121206/usbdrv/usbconfig-prototype.h	(working copy)
@@ -0,0 +1,384 @@
+/* Name: usbconfig.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2005-04-01
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbconfig_h_included__
+#define __usbconfig_h_included__
+
+/*
+General Description:
+This file is an example configuration (with inline documentation) for the USB
+driver. It configures V-USB for USB D+ connected to Port D bit 2 (which is
+also hardware interrupt 0 on many devices) and USB D- to Port D bit 4. You may
+wire the lines to any other port, as long as D+ is also wired to INT0 (or any
+other hardware interrupt, as long as it is the highest level interrupt, see
+section at the end of this file).
++ To create your own usbconfig.h file, copy this file to your project's
++ firmware source directory) and rename it to "usbconfig.h".
++ Then edit it accordingly.
+*/
+
+/* ---------------------------- Hardware Config ---------------------------- */
+
+#define USB_CFG_IOPORTNAME      D
+/* This is the port where the USB bus is connected. When you configure it to
+ * "B", the registers PORTB, PINB and DDRB will be used.
+ */
+#define USB_CFG_DMINUS_BIT      4
+/* This is the bit number in USB_CFG_IOPORT where the USB D- line is connected.
+ * This may be any bit in the port.
+ */
+#define USB_CFG_DPLUS_BIT       2
+/* This is the bit number in USB_CFG_IOPORT where the USB D+ line is connected.
+ * This may be any bit in the port. Please note that D+ must also be connected
+ * to interrupt pin INT0! [You can also use other interrupts, see section
+ * "Optional MCU Description" below, or you can connect D- to the interrupt, as
+ * it is required if you use the USB_COUNT_SOF feature. If you use D- for the
+ * interrupt, the USB interrupt will also be triggered at Start-Of-Frame
+ * markers every millisecond.]
+ */
+#define USB_CFG_CLOCK_KHZ       (F_CPU/1000)
+/* Clock rate of the AVR in kHz. Legal values are 12000, 12800, 15000, 16000,
+ * 16500, 18000 and 20000. The 12.8 MHz and 16.5 MHz versions of the code
+ * require no crystal, they tolerate +/- 1% deviation from the nominal
+ * frequency. All other rates require a precision of 2000 ppm and thus a
+ * crystal!
+ * Since F_CPU should be defined to your actual clock rate anyway, you should
+ * not need to modify this setting.
+ */
+#define USB_CFG_CHECK_CRC       0
+/* Define this to 1 if you want that the driver checks integrity of incoming
+ * data packets (CRC checks). CRC checks cost quite a bit of code size and are
+ * currently only available for 18 MHz crystal clock. You must choose
+ * USB_CFG_CLOCK_KHZ = 18000 if you enable this option.
+ */
+
+/* ----------------------- Optional Hardware Config ------------------------ */
+
+/* #define USB_CFG_PULLUP_IOPORTNAME   D */
+/* If you connect the 1.5k pullup resistor from D- to a port pin instead of
+ * V+, you can connect and disconnect the device from firmware by calling
+ * the macros usbDeviceConnect() and usbDeviceDisconnect() (see usbdrv.h).
+ * This constant defines the port on which the pullup resistor is connected.
+ */
+/* #define USB_CFG_PULLUP_BIT          4 */
+/* This constant defines the bit number in USB_CFG_PULLUP_IOPORT (defined
+ * above) where the 1.5k pullup resistor is connected. See description
+ * above for details.
+ */
+
+/* --------------------------- Functional Range ---------------------------- */
+
+#define USB_CFG_HAVE_INTRIN_ENDPOINT    0
+/* Define this to 1 if you want to compile a version with two endpoints: The
+ * default control endpoint 0 and an interrupt-in endpoint (any other endpoint
+ * number).
+ */
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+/* Define this to 1 if you want to compile a version with three endpoints: The
+ * default control endpoint 0, an interrupt-in endpoint 3 (or the number
+ * configured below) and a catch-all default interrupt-in endpoint as above.
+ * You must also define USB_CFG_HAVE_INTRIN_ENDPOINT to 1 for this feature.
+ */
+#define USB_CFG_EP3_NUMBER              3
+/* If the so-called endpoint 3 is used, it can now be configured to any other
+ * endpoint number (except 0) with this macro. Default if undefined is 3.
+ */
+/* #define USB_INITIAL_DATATOKEN           USBPID_DATA1 */
+/* The above macro defines the startup condition for data toggling on the
+ * interrupt/bulk endpoints 1 and 3. Defaults to USBPID_DATA1.
+ * Since the token is toggled BEFORE sending any data, the first packet is
+ * sent with the oposite value of this configuration!
+ */
+#define USB_CFG_IMPLEMENT_HALT          0
+/* Define this to 1 if you also want to implement the ENDPOINT_HALT feature
+ * for endpoint 1 (interrupt endpoint). Although you may not need this feature,
+ * it is required by the standard. We have made it a config option because it
+ * bloats the code considerably.
+ */
+#define USB_CFG_SUPPRESS_INTR_CODE      0
+/* Define this to 1 if you want to declare interrupt-in endpoints, but don't
+ * want to send any data over them. If this macro is defined to 1, functions
+ * usbSetInterrupt() and usbSetInterrupt3() are omitted. This is useful if
+ * you need the interrupt-in endpoints in order to comply to an interface
+ * (e.g. HID), but never want to send any data. This option saves a couple
+ * of bytes in flash memory and the transmit buffers in RAM.
+ */
+#define USB_CFG_INTR_POLL_INTERVAL      10
+/* If you compile a version with endpoint 1 (interrupt-in), this is the poll
+ * interval. The value is in milliseconds and must not be less than 10 ms for
+ * low speed devices.
+ */
+#define USB_CFG_IS_SELF_POWERED         0
+/* Define this to 1 if the device has its own power supply. Set it to 0 if the
+ * device is powered from the USB bus.
+ */
+#define USB_CFG_MAX_BUS_POWER           100
+/* Set this variable to the maximum USB bus power consumption of your device.
+ * The value is in milliamperes. [It will be divided by two since USB
+ * communicates power requirements in units of 2 mA.]
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITE      0
+/* Set this to 1 if you want usbFunctionWrite() to be called for control-out
+ * transfers. Set it to 0 if you don't need it and want to save a couple of
+ * bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_READ       0
+/* Set this to 1 if you need to send control replies which are generated
+ * "on the fly" when usbFunctionRead() is called. If you only want to send
+ * data from a static buffer, set it to 0 and return the data from
+ * usbFunctionSetup(). This saves a couple of bytes.
+ */
+#define USB_CFG_IMPLEMENT_FN_WRITEOUT   0
+/* Define this to 1 if you want to use interrupt-out (or bulk out) endpoints.
+ * You must implement the function usbFunctionWriteOut() which receives all
+ * interrupt/bulk data sent to any endpoint other than 0. The endpoint number
+ * can be found in 'usbRxToken'.
+ */
+#define USB_CFG_HAVE_FLOWCONTROL        0
+/* Define this to 1 if you want flowcontrol over USB data. See the definition
+ * of the macros usbDisableAllRequests() and usbEnableAllRequests() in
+ * usbdrv.h.
+ */
+#define USB_CFG_DRIVER_FLASH_PAGE       0
+/* If the device has more than 64 kBytes of flash, define this to the 64 k page
+ * where the driver's constants (descriptors) are located. Or in other words:
+ * Define this to 1 for boot loaders on the ATMega128.
+ */
+#define USB_CFG_LONG_TRANSFERS          0
+/* Define this to 1 if you want to send/receive blocks of more than 254 bytes
+ * in a single control-in or control-out transfer. Note that the capability
+ * for long transfers increases the driver size.
+ */
+/* #define USB_RX_USER_HOOK(data, len)     if(usbRxToken == (uchar)USBPID_SETUP) blinkLED(); */
+/* This macro is a hook if you want to do unconventional things. If it is
+ * defined, it's inserted at the beginning of received message processing.
+ * If you eat the received message and don't want default processing to
+ * proceed, do a return after doing your things. One possible application
+ * (besides debugging) is to flash a status LED on each packet.
+ */
+/* #define USB_RESET_HOOK(resetStarts)     if(!resetStarts){hadUsbReset();} */
+/* This macro is a hook if you need to know when an USB RESET occurs. It has
+ * one parameter which distinguishes between the start of RESET state and its
+ * end.
+ */
+/* #define USB_SET_ADDRESS_HOOK()              hadAddressAssigned(); */
+/* This macro (if defined) is executed when a USB SET_ADDRESS request was
+ * received.
+ */
+#define USB_COUNT_SOF                   0
+/* define this macro to 1 if you need the global variable "usbSofCount" which
+ * counts SOF packets. This feature requires that the hardware interrupt is
+ * connected to D- instead of D+.
+ */
+/* #ifdef __ASSEMBLER__
+ * macro myAssemblerMacro
+ *     in      YL, TCNT0
+ *     sts     timer0Snapshot, YL
+ *     endm
+ * #endif
+ * #define USB_SOF_HOOK                    myAssemblerMacro
+ * This macro (if defined) is executed in the assembler module when a
+ * Start Of Frame condition is detected. It is recommended to define it to
+ * the name of an assembler macro which is defined here as well so that more
+ * than one assembler instruction can be used. The macro may use the register
+ * YL and modify SREG. If it lasts longer than a couple of cycles, USB messages
+ * immediately after an SOF pulse may be lost and must be retried by the host.
+ * What can you do with this hook? Since the SOF signal occurs exactly every
+ * 1 ms (unless the host is in sleep mode), you can use it to tune OSCCAL in
+ * designs running on the internal RC oscillator.
+ * Please note that Start Of Frame detection works only if D- is wired to the
+ * interrupt, not D+. THIS IS DIFFERENT THAN MOST EXAMPLES!
+ */
+#define USB_CFG_CHECK_DATA_TOGGLING     0
+/* define this macro to 1 if you want to filter out duplicate data packets
+ * sent by the host. Duplicates occur only as a consequence of communication
+ * errors, when the host does not receive an ACK. Please note that you need to
+ * implement the filtering yourself in usbFunctionWriteOut() and
+ * usbFunctionWrite(). Use the global usbCurrentDataToken and a static variable
+ * for each control- and out-endpoint to check for duplicate packets.
+ */
+#define USB_CFG_HAVE_MEASURE_FRAME_LENGTH   0
+/* define this macro to 1 if you want the function usbMeasureFrameLength()
+ * compiled in. This function can be used to calibrate the AVR's RC oscillator.
+ */
+#define USB_USE_FAST_CRC                0
+/* The assembler module has two implementations for the CRC algorithm. One is
+ * faster, the other is smaller. This CRC routine is only used for transmitted
+ * messages where timing is not critical. The faster routine needs 31 cycles
+ * per byte while the smaller one needs 61 to 69 cycles. The faster routine
+ * may be worth the 32 bytes bigger code size if you transmit lots of data and
+ * run the AVR close to its limit.
+ */
+
+/* -------------------------- Device Description --------------------------- */
+
+#define  USB_CFG_VENDOR_ID       0xc0, 0x16 /* = 0x16c0 = 5824 = voti.nl */
+/* USB vendor ID for the device, low byte first. If you have registered your
+ * own Vendor ID, define it here. Otherwise you may use one of obdev's free
+ * shared VID/PID pairs. Be sure to read USB-IDs-for-free.txt for rules!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define  USB_CFG_DEVICE_ID       0xdc, 0x05 /* = 0x05dc = 1500 */
+/* This is the ID of the product, low byte first. It is interpreted in the
+ * scope of the vendor ID. If you have registered your own VID with usb.org
+ * or if you have licensed a PID from somebody else, define it here. Otherwise
+ * you may use one of obdev's free shared VID/PID pairs. See the file
+ * USB-IDs-for-free.txt for details!
+ * *** IMPORTANT NOTE ***
+ * This template uses obdev's shared VID/PID pair for Vendor Class devices
+ * with libusb: 0x16c0/0x5dc.  Use this VID/PID pair ONLY if you understand
+ * the implications!
+ */
+#define USB_CFG_DEVICE_VERSION  0x00, 0x01
+/* Version number of the device: Minor number first, then major number.
+ */
+#define USB_CFG_VENDOR_NAME     'o', 'b', 'd', 'e', 'v', '.', 'a', 't'
+#define USB_CFG_VENDOR_NAME_LEN 8
+/* These two values define the vendor name returned by the USB device. The name
+ * must be given as a list of characters under single quotes. The characters
+ * are interpreted as Unicode (UTF-16) entities.
+ * If you don't want a vendor name string, undefine these macros.
+ * ALWAYS define a vendor name containing your Internet domain name if you use
+ * obdev's free shared VID/PID pair. See the file USB-IDs-for-free.txt for
+ * details.
+ */
+#define USB_CFG_DEVICE_NAME     'T', 'e', 'm', 'p', 'l', 'a', 't', 'e'
+#define USB_CFG_DEVICE_NAME_LEN 8
+/* Same as above for the device name. If you don't want a device name, undefine
+ * the macros. See the file USB-IDs-for-free.txt before you assign a name if
+ * you use a shared VID/PID.
+ */
+/*#define USB_CFG_SERIAL_NUMBER   'N', 'o', 'n', 'e' */
+/*#define USB_CFG_SERIAL_NUMBER_LEN   0 */
+/* Same as above for the serial number. If you don't want a serial number,
+ * undefine the macros.
+ * It may be useful to provide the serial number through other means than at
+ * compile time. See the section about descriptor properties below for how
+ * to fine tune control over USB descriptors such as the string descriptor
+ * for the serial number.
+ */
+#define USB_CFG_DEVICE_CLASS        0xff    /* set to 0 if deferred to interface */
+#define USB_CFG_DEVICE_SUBCLASS     0
+/* See USB specification if you want to conform to an existing device class.
+ * Class 0xff is "vendor specific".
+ */
+#define USB_CFG_INTERFACE_CLASS     0   /* define class here if not at device level */
+#define USB_CFG_INTERFACE_SUBCLASS  0
+#define USB_CFG_INTERFACE_PROTOCOL  0
+/* See USB specification if you want to conform to an existing device class or
+ * protocol. The following classes must be set at interface level:
+ * HID class is 3, no subclass and protocol required (but may be useful!)
+ * CDC class is 2, use subclass 2 and protocol 1 for ACM
+ */
+/* #define USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    42 */
+/* Define this to the length of the HID report descriptor, if you implement
+ * an HID device. Otherwise don't define it or define it to 0.
+ * If you use this define, you must add a PROGMEM character array named
+ * "usbHidReportDescriptor" to your code which contains the report descriptor.
+ * Don't forget to keep the array and this define in sync!
+ */
+
+/* #define USB_PUBLIC static */
+/* Use the define above if you #include usbdrv.c instead of linking against it.
+ * This technique saves a couple of bytes in flash memory.
+ */
+
+/* ------------------- Fine Control over USB Descriptors ------------------- */
+/* If you don't want to use the driver's default USB descriptors, you can
+ * provide our own. These can be provided as (1) fixed length static data in
+ * flash memory, (2) fixed length static data in RAM or (3) dynamically at
+ * runtime in the function usbFunctionDescriptor(). See usbdrv.h for more
+ * information about this function.
+ * Descriptor handling is configured through the descriptor's properties. If
+ * no properties are defined or if they are 0, the default descriptor is used.
+ * Possible properties are:
+ *   + USB_PROP_IS_DYNAMIC: The data for the descriptor should be fetched
+ *     at runtime via usbFunctionDescriptor(). If the usbMsgPtr mechanism is
+ *     used, the data is in FLASH by default. Add property USB_PROP_IS_RAM if
+ *     you want RAM pointers.
+ *   + USB_PROP_IS_RAM: The data returned by usbFunctionDescriptor() or found
+ *     in static memory is in RAM, not in flash memory.
+ *   + USB_PROP_LENGTH(len): If the data is in static memory (RAM or flash),
+ *     the driver must know the descriptor's length. The descriptor itself is
+ *     found at the address of a well known identifier (see below).
+ * List of static descriptor names (must be declared PROGMEM if in flash):
+ *   char usbDescriptorDevice[];
+ *   char usbDescriptorConfiguration[];
+ *   char usbDescriptorHidReport[];
+ *   char usbDescriptorString0[];
+ *   int usbDescriptorStringVendor[];
+ *   int usbDescriptorStringDevice[];
+ *   int usbDescriptorStringSerialNumber[];
+ * Other descriptors can't be provided statically, they must be provided
+ * dynamically at runtime.
+ *
+ * Descriptor properties are or-ed or added together, e.g.:
+ * #define USB_CFG_DESCR_PROPS_DEVICE   (USB_PROP_IS_RAM | USB_PROP_LENGTH(18))
+ *
+ * The following descriptors are defined:
+ *   USB_CFG_DESCR_PROPS_DEVICE
+ *   USB_CFG_DESCR_PROPS_CONFIGURATION
+ *   USB_CFG_DESCR_PROPS_STRINGS
+ *   USB_CFG_DESCR_PROPS_STRING_0
+ *   USB_CFG_DESCR_PROPS_STRING_VENDOR
+ *   USB_CFG_DESCR_PROPS_STRING_PRODUCT
+ *   USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+ *   USB_CFG_DESCR_PROPS_HID
+ *   USB_CFG_DESCR_PROPS_HID_REPORT
+ *   USB_CFG_DESCR_PROPS_UNKNOWN (for all descriptors not handled by the driver)
+ *
+ * Note about string descriptors: String descriptors are not just strings, they
+ * are Unicode strings prefixed with a 2 byte header. Example:
+ * int  serialNumberDescriptor[] = {
+ *     USB_STRING_DESCRIPTOR_HEADER(6),
+ *     'S', 'e', 'r', 'i', 'a', 'l'
+ * };
+ */
+
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#define USB_CFG_DESCR_PROPS_HID                     0
+#define USB_CFG_DESCR_PROPS_HID_REPORT              0
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+
+
+#define usbMsgPtr_t unsigned short
+/* If usbMsgPtr_t is not defined, it defaults to 'uchar *'. We define it to
+ * a scalar type here because gcc generates slightly shorter code for scalar
+ * arithmetics than for pointer arithmetics. Remove this define for backward
+ * type compatibility or define it to an 8 bit type if you use data in RAM only
+ * and all RAM is below 256 bytes (tiny memory model in IAR CC).
+ */
+
+/* ----------------------- Optional MCU Description ------------------------ */
+
+/* The following configurations have working defaults in usbdrv.h. You
+ * usually don't need to set them explicitly. Only if you want to run
+ * the driver on a device which is not yet supported or with a compiler
+ * which is not fully supported (such as IAR C) or if you use a differnt
+ * interrupt than INT0, you may have to define some of these.
+ */
+/* #define USB_INTR_CFG            MCUCR */
+/* #define USB_INTR_CFG_SET        ((1 << ISC00) | (1 << ISC01)) */
+/* #define USB_INTR_CFG_CLR        0 */
+/* #define USB_INTR_ENABLE         GIMSK */
+/* #define USB_INTR_ENABLE_BIT     INT0 */
+/* #define USB_INTR_PENDING        GIFR */
+/* #define USB_INTR_PENDING_BIT    INTF0 */
+/* #define USB_INTR_VECTOR         INT0_vect */
+
+#endif /* __usbconfig_h_included__ */
Index: vusb-20121206/usbdrv/usbdrv.c
===================================================================
--- vusb-20121206/usbdrv/usbdrv.c	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrv.c	(working copy)
@@ -0,0 +1,628 @@
+/* Name: usbdrv.c
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#include "usbdrv.h"
+#include "oddebug.h"
+
+/*
+General Description:
+This module implements the C-part of the USB driver. See usbdrv.h for a
+documentation of the entire driver.
+*/
+
+/* ------------------------------------------------------------------------- */
+
+/* raw USB registers / interface to assembler code: */
+uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
+uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
+uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
+uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
+uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but not used */
+volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow control */
+uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 0 */
+uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
+volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handshake token */
+uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains handshake token */
+#if USB_COUNT_SOF
+volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+usbTxStatus_t  usbTxStatus1;
+#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
+usbTxStatus_t  usbTxStatus3;
+#   endif
+#endif
+#if USB_CFG_CHECK_DATA_TOGGLING
+uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
+#endif
+
+/* USB status registers / not shared with asm code */
+usbMsgPtr_t         usbMsgPtr;      /* data to transmit next -- ROM or RAM address */
+static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
+static uchar        usbMsgFlags;    /* flag values see below */
+
+#define USB_FLG_MSGPTR_IS_ROM   (1<<6)
+#define USB_FLG_USE_USER_RW     (1<<7)
+
+/*
+optimizing hints:
+- do not post/pre inc/dec integer values in operations
+- assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
+- use narrow scope for variables which should be in X/Y/Z register
+- assign char sized expressions to variables to force 8 bit arithmetics
+*/
+
+/* -------------------------- String Descriptors --------------------------- */
+
+#if USB_CFG_DESCR_PROPS_STRINGS == 0
+
+#if USB_CFG_DESCR_PROPS_STRING_0 == 0
+#undef USB_CFG_DESCR_PROPS_STRING_0
+#define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
+PROGMEM const char usbDescriptorString0[] = { /* language descriptor */
+    4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
+    3,          /* descriptor type */
+    0x09, 0x04, /* language index (0x0409 = US-English) */
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_VENDOR
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
+PROGMEM const int  usbDescriptorStringVendor[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
+    USB_CFG_VENDOR_NAME
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
+PROGMEM const int  usbDescriptorStringDevice[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
+    USB_CFG_DEVICE_NAME
+};
+#endif
+
+#if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
+#undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
+PROGMEM const int usbDescriptorStringSerialNumber[] = {
+    USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
+    USB_CFG_SERIAL_NUMBER
+};
+#endif
+
+#endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
+
+/* --------------------------- Device Descriptor --------------------------- */
+
+#if USB_CFG_DESCR_PROPS_DEVICE == 0
+#undef USB_CFG_DESCR_PROPS_DEVICE
+#define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
+PROGMEM const char usbDescriptorDevice[] = {    /* USB device descriptor */
+    18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
+    USBDESCR_DEVICE,        /* descriptor type */
+    0x10, 0x01,             /* USB version supported */
+    USB_CFG_DEVICE_CLASS,
+    USB_CFG_DEVICE_SUBCLASS,
+    0,                      /* protocol */
+    8,                      /* max packet size */
+    /* the following two casts affect the first byte of the constant only, but
+     * that's sufficient to avoid a warning with the default values.
+     */
+    (char)USB_CFG_VENDOR_ID,/* 2 bytes */
+    (char)USB_CFG_DEVICE_ID,/* 2 bytes */
+    USB_CFG_DEVICE_VERSION, /* 2 bytes */
+    USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
+    USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
+    USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
+    1,          /* number of configurations */
+};
+#endif
+
+/* ----------------------- Configuration Descriptor ------------------------ */
+
+#if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
+#undef USB_CFG_DESCR_PROPS_HID
+#define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
+#endif
+
+#if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
+#undef USB_CFG_DESCR_PROPS_CONFIGURATION
+#define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
+PROGMEM const char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
+    9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
+    USBDESCR_CONFIG,    /* descriptor type */
+    18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
+                (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
+                /* total length of data returned (including inlined descriptors) */
+    1,          /* number of interfaces in this configuration */
+    1,          /* index of this configuration */
+    0,          /* configuration name string index */
+#if USB_CFG_IS_SELF_POWERED
+    (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
+#else
+    (1 << 7),                           /* attributes */
+#endif
+    USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
+/* interface descriptor follows inline: */
+    9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
+    USBDESCR_INTERFACE, /* descriptor type */
+    0,          /* index of this interface */
+    0,          /* alternate setting for this interface */
+    USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of endpoint descriptors to follow */
+    USB_CFG_INTERFACE_CLASS,
+    USB_CFG_INTERFACE_SUBCLASS,
+    USB_CFG_INTERFACE_PROTOCOL,
+    0,          /* string index for interface */
+#if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
+    9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
+    USBDESCR_HID,   /* descriptor type: HID */
+    0x01, 0x01, /* BCD representation of HID version */
+    0x00,       /* target country code */
+    0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
+    0x22,       /* descriptor type: report */
+    USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)0x81, /* IN endpoint number 1 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
+    7,          /* sizeof(usbDescrEndpoint) */
+    USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
+    (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
+    0x03,       /* attrib: Interrupt endpoint */
+    8, 0,       /* maximum packet size */
+    USB_CFG_INTR_POLL_INTERVAL, /* in ms */
+#endif
+};
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+static inline void  usbResetDataToggling(void)
+{
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
+#   if USB_CFG_HAVE_INTRIN_ENDPOINT3
+    USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
+#   endif
+#endif
+}
+
+static inline void  usbResetStall(void)
+{
+#if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
+        usbTxLen1 = USBPID_NAK;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+        usbTxLen3 = USBPID_NAK;
+#endif
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+#if !USB_CFG_SUPPRESS_INTR_CODE
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
+{
+uchar   *p;
+char    i;
+
+#if USB_CFG_IMPLEMENT_HALT
+    if(usbTxLen1 == USBPID_STALL)
+        return;
+#endif
+    if(txStatus->len & 0x10){   /* packet buffer was empty */
+        txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
+    }else{
+        txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
+    }
+    p = txStatus->buffer + 1;
+    i = len;
+    do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
+        *p++ = *data++;
+    }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
+    usbCrc16Append(&txStatus->buffer[1], len);
+    txStatus->len = len + 4;    /* len must be given including sync byte */
+    DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
+}
+
+USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
+{
+    usbGenericSetInterrupt(data, len, &usbTxStatus1);
+}
+#endif
+
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
+{
+    usbGenericSetInterrupt(data, len, &usbTxStatus3);
+}
+#endif
+#endif /* USB_CFG_SUPPRESS_INTR_CODE */
+
+/* ------------------ utilities for code following below ------------------- */
+
+/* Use defines for the switch statement so that we can choose between an
+ * if()else if() and a switch/case based implementation. switch() is more
+ * efficient for a LARGE set of sequential choices, if() is better in all other
+ * cases.
+ */
+#if USB_CFG_USE_SWITCH_STATEMENT
+#   define SWITCH_START(cmd)       switch(cmd){{
+#   define SWITCH_CASE(value)      }break; case (value):{
+#   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
+#   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
+#   define SWITCH_DEFAULT          }break; default:{
+#   define SWITCH_END              }}
+#else
+#   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
+#   define SWITCH_CASE(value)      }else if(_cmd == (value)){
+#   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
+#   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
+#   define SWITCH_DEFAULT          }else{
+#   define SWITCH_END              }}
+#endif
+
+#ifndef USB_RX_USER_HOOK
+#define USB_RX_USER_HOOK(data, len)
+#endif
+#ifndef USB_SET_ADDRESS_HOOK
+#define USB_SET_ADDRESS_HOOK()
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+/* We use if() instead of #if in the macro below because #if can't be used
+ * in macros and the compiler optimizes constant conditions anyway.
+ * This may cause problems with undefined symbols if compiled without
+ * optimizing!
+ */
+#define GET_DESCRIPTOR(cfgProp, staticName)         \
+    if(cfgProp){                                    \
+        if((cfgProp) & USB_PROP_IS_RAM)             \
+            flags = 0;                              \
+        if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
+            len = usbFunctionDescriptor(rq);        \
+        }else{                                      \
+            len = USB_PROP_LENGTH(cfgProp);         \
+            usbMsgPtr = (usbMsgPtr_t)(staticName);  \
+        }                                           \
+    }
+
+/* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
+ * internally for all types of descriptors.
+ */
+static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
+{
+usbMsgLen_t len = 0;
+uchar       flags = USB_FLG_MSGPTR_IS_ROM;
+
+    SWITCH_START(rq->wValue.bytes[1])
+    SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
+    SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
+    SWITCH_CASE(USBDESCR_STRING)    /* 3 */
+#if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
+        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
+            flags = 0;
+        len = usbFunctionDescriptor(rq);
+#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
+        SWITCH_START(rq->wValue.bytes[0])
+        SWITCH_CASE(0)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
+        SWITCH_CASE(1)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
+        SWITCH_CASE(2)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
+        SWITCH_CASE(3)
+            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumber)
+        SWITCH_DEFAULT
+            if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
+                len = usbFunctionDescriptor(rq);
+            }
+        SWITCH_END
+#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
+#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
+    SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
+    SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
+        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
+#endif
+    SWITCH_DEFAULT
+        if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
+            len = usbFunctionDescriptor(rq);
+        }
+    SWITCH_END
+    usbMsgFlags = flags;
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
+ * standard requests instead of class and custom requests.
+ */
+static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
+{
+usbMsgLen_t len = 0;
+uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
+uchar   value = rq->wValue.bytes[0];
+#if USB_CFG_IMPLEMENT_HALT
+uchar   index = rq->wIndex.bytes[0];
+#endif
+
+    dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
+    SWITCH_START(rq->bRequest)
+    SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
+        uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to enforce byte size */
+        if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
+            dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
+#if USB_CFG_IMPLEMENT_HALT
+        if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
+            dataPtr[0] = usbTxLen1 == USBPID_STALL;
+#endif
+        dataPtr[1] = 0;
+        len = 2;
+#if USB_CFG_IMPLEMENT_HALT
+    SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
+        if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
+            usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
+            usbResetDataToggling();
+        }
+#endif
+    SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
+        usbNewDeviceAddr = value;
+        USB_SET_ADDRESS_HOOK();
+    SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
+        len = usbDriverDescriptor(rq);
+        goto skipMsgPtrAssignment;
+    SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
+        dataPtr = &usbConfiguration;  /* send current configuration value */
+        len = 1;
+    SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
+        usbConfiguration = value;
+        usbResetStall();
+    SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
+        len = 1;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
+        usbResetDataToggling();
+        usbResetStall();
+#endif
+    SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
+        /* Should we add an optional hook here? */
+    SWITCH_END
+    usbMsgPtr = (usbMsgPtr_t)dataPtr;
+skipMsgPtrAssignment:
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbProcessRx() is called for every message received by the interrupt
+ * routine. It distinguishes between SETUP and DATA packets and processes
+ * them accordingly.
+ */
+static inline void usbProcessRx(uchar *data, uchar len)
+{
+usbRequest_t    *rq = (void *)data;
+
+/* usbRxToken can be:
+ * 0x2d 00101101 (USBPID_SETUP for setup data)
+ * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
+ * 0...0x0f for OUT on endpoint X
+ */
+    DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
+    USB_RX_USER_HOOK(data, len)
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+    if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
+        usbFunctionWriteOut(data, len);
+        return;
+    }
+#endif
+    if(usbRxToken == (uchar)USBPID_SETUP){
+        if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
+            return;
+        usbMsgLen_t replyLen;
+        usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
+        usbTxLen = USBPID_NAK;              /* abort pending transmit */
+        usbMsgFlags = 0;
+        uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
+        if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
+            replyLen = usbFunctionSetup(data);
+        }else{
+            replyLen = usbDriverSetup(rq);
+        }
+#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
+        if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
+            /* do some conditioning on replyLen, but on IN transfers only */
+            if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
+                if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
+                    replyLen = rq->wLength.bytes[0];
+                }else{
+                    replyLen = rq->wLength.word;
+                }
+            }
+            usbMsgFlags = USB_FLG_USE_USER_RW;
+        }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */
+#endif
+        if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
+            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max */
+                replyLen = rq->wLength.bytes[0];
+        }else{
+            if(replyLen > rq->wLength.word)     /* limit length to max */
+                replyLen = rq->wLength.word;
+        }
+        usbMsgLen = replyLen;
+    }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
+#if USB_CFG_IMPLEMENT_FN_WRITE
+        if(usbMsgFlags & USB_FLG_USE_USER_RW){
+            uchar rval = usbFunctionWrite(data, len);
+            if(rval == 0xff){   /* an error occurred */
+                usbTxLen = USBPID_STALL;
+            }else if(rval != 0){    /* This was the final package */
+                usbMsgLen = 0;  /* answer with a zero-sized data packet */
+            }
+        }
+#endif
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* This function is similar to usbFunctionRead(), but it's also called for
+ * data handled automatically by the driver (e.g. descriptor reads).
+ */
+static uchar usbDeviceRead(uchar *data, uchar len)
+{
+    if(len > 0){    /* don't bother app with 0 sized reads */
+#if USB_CFG_IMPLEMENT_FN_READ
+        if(usbMsgFlags & USB_FLG_USE_USER_RW){
+            len = usbFunctionRead(data, len);
+        }else
+#endif
+        {
+            uchar i = len;
+            usbMsgPtr_t r = usbMsgPtr;
+            if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
+                do{
+                    uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte ops */
+                    *data++ = c;
+                    r++;
+                }while(--i);
+            }else{  /* RAM data */
+                do{
+                    *data++ = *((uchar *)r);
+                    r++;
+                }while(--i);
+            }
+            usbMsgPtr = r;
+        }
+    }
+    return len;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/* usbBuildTxBlock() is called when we have data to transmit and the
+ * interrupt routine's transmit buffer is empty.
+ */
+static inline void usbBuildTxBlock(void)
+{
+usbMsgLen_t wantLen;
+uchar       len;
+
+    wantLen = usbMsgLen;
+    if(wantLen > 8)
+        wantLen = 8;
+    usbMsgLen -= wantLen;
+    usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
+    len = usbDeviceRead(usbTxBuf + 1, wantLen);
+    if(len <= 8){           /* valid data packet */
+        usbCrc16Append(&usbTxBuf[1], len);
+        len += 4;           /* length including sync byte */
+        if(len < 12)        /* a partial package identifies end of message */
+            usbMsgLen = USB_NO_MSG;
+    }else{
+        len = USBPID_STALL;   /* stall the endpoint */
+        usbMsgLen = USB_NO_MSG;
+    }
+    usbTxLen = len;
+    DBG2(0x20, usbTxBuf, len-1);
+}
+
+/* ------------------------------------------------------------------------- */
+
+static inline void usbHandleResetHook(uchar notResetState)
+{
+#ifdef USB_RESET_HOOK
+static uchar    wasReset;
+uchar           isReset = !notResetState;
+
+    if(wasReset != isReset){
+        USB_RESET_HOOK(isReset);
+        wasReset = isReset;
+    }
+#else
+    notResetState = notResetState;  // avoid compiler warning
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
+
+USB_PUBLIC void usbPoll(void)
+{
+schar   len;
+uchar   i;
+
+    len = usbRxLen - 3;
+    if(len >= 0){
+/* We could check CRC16 here -- but ACK has already been sent anyway. If you
+ * need data integrity checks with this driver, check the CRC in your app
+ * code and report errors back to the host. Since the ACK was already sent,
+ * retries must be handled on application level.
+ * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
+ */
+        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
+#if USB_CFG_HAVE_FLOWCONTROL
+        if(usbRxLen > 0)    /* only mark as available if not inactivated */
+            usbRxLen = 0;
+#else
+        usbRxLen = 0;       /* mark rx buffer as available */
+#endif
+    }
+    if(usbTxLen & 0x10){    /* transmit system idle */
+        if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
+            usbBuildTxBlock();
+        }
+    }
+    for(i = 20; i > 0; i--){
+        uchar usbLineStatus = USBIN & USBMASK;
+        if(usbLineStatus != 0)  /* SE0 has ended */
+            goto isNotReset;
+    }
+    /* RESET condition, called multiple times during reset */
+    usbNewDeviceAddr = 0;
+    usbDeviceAddr = 0;
+    usbResetStall();
+    DBG1(0xff, 0, 0);
+isNotReset:
+    usbHandleResetHook(i);
+}
+
+/* ------------------------------------------------------------------------- */
+
+USB_PUBLIC void usbInit(void)
+{
+#if USB_INTR_CFG_SET != 0
+    USB_INTR_CFG |= USB_INTR_CFG_SET;
+#endif
+#if USB_INTR_CFG_CLR != 0
+    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
+#endif
+    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
+    usbResetDataToggling();
+#if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
+    usbTxLen1 = USBPID_NAK;
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+    usbTxLen3 = USBPID_NAK;
+#endif
+#endif
+}
+
+/* ------------------------------------------------------------------------- */
Index: vusb-20121206/usbdrv/usbdrv.h
===================================================================
--- vusb-20121206/usbdrv/usbdrv.h	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrv.h	(working copy)
@@ -0,0 +1,746 @@
+/* Name: usbdrv.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+#ifndef __usbdrv_h_included__
+#define __usbdrv_h_included__
+#include "usbconfig.h"
+#include "usbportability.h"
+
+/*
+Hardware Prerequisites:
+=======================
+USB lines D+ and D- MUST be wired to the same I/O port. We recommend that D+
+triggers the interrupt (best achieved by using INT0 for D+), but it is also
+possible to trigger the interrupt from D-. If D- is used, interrupts are also
+triggered by SOF packets. D- requires a pull-up of 1.5k to +3.5V (and the
+device must be powered at 3.5V) to identify as low-speed USB device. A
+pull-down or pull-up of 1M SHOULD be connected from D+ to +3.5V to prevent
+interference when no USB master is connected. If you use Zener diodes to limit
+the voltage on D+ and D-, you MUST use a pull-down resistor, not a pull-up.
+We use D+ as interrupt source and not D- because it does not trigger on
+keep-alive and RESET states. If you want to count keep-alive events with
+USB_COUNT_SOF, you MUST use D- as an interrupt source.
+
+As a compile time option, the 1.5k pull-up resistor on D- can be made
+switchable to allow the device to disconnect at will. See the definition of
+usbDeviceConnect() and usbDeviceDisconnect() further down in this file.
+
+Please adapt the values in usbconfig.h according to your hardware!
+
+The device MUST be clocked at exactly 12 MHz, 15 MHz, 16 MHz or 20 MHz
+or at 12.8 MHz resp. 16.5 MHz +/- 1%. See usbconfig-prototype.h for details.
+
+
+Limitations:
+============
+Robustness with respect to communication errors:
+The driver assumes error-free communication. It DOES check for errors in
+the PID, but does NOT check bit stuffing errors, SE0 in middle of a byte,
+token CRC (5 bit) and data CRC (16 bit). CRC checks can not be performed due
+to timing constraints: We must start sending a reply within 7 bit times.
+Bit stuffing and misplaced SE0 would have to be checked in real-time, but CPU
+performance does not permit that. The driver does not check Data0/Data1
+toggling, but application software can implement the check.
+
+Input characteristics:
+Since no differential receiver circuit is used, electrical interference
+robustness may suffer. The driver samples only one of the data lines with
+an ordinary I/O pin's input characteristics. However, since this is only a
+low speed USB implementation and the specification allows for 8 times the
+bit rate over the same hardware, we should be on the safe side. Even the spec
+requires detection of asymmetric states at high bit rate for SE0 detection.
+
+Number of endpoints:
+The driver supports the following endpoints:
+
+- Endpoint 0, the default control endpoint.
+- Any number of interrupt- or bulk-out endpoints. The data is sent to
+  usbFunctionWriteOut() and USB_CFG_IMPLEMENT_FN_WRITEOUT must be defined
+  to 1 to activate this feature. The endpoint number can be found in the
+  global variable 'usbRxToken'.
+- One default interrupt- or bulk-in endpoint. This endpoint is used for
+  interrupt- or bulk-in transfers which are not handled by any other endpoint.
+  You must define USB_CFG_HAVE_INTRIN_ENDPOINT in order to activate this
+  feature and call usbSetInterrupt() to send interrupt/bulk data.
+- One additional interrupt- or bulk-in endpoint. This was endpoint 3 in
+  previous versions of this driver but can now be configured to any endpoint
+  number. You must define USB_CFG_HAVE_INTRIN_ENDPOINT3 in order to activate
+  this feature and call usbSetInterrupt3() to send interrupt/bulk data. The
+  endpoint number can be set with USB_CFG_EP3_NUMBER.
+
+Please note that the USB standard forbids bulk endpoints for low speed devices!
+Most operating systems allow them anyway, but the AVR will spend 90% of the CPU
+time in the USB interrupt polling for bulk data.
+
+Maximum data payload:
+Data payload of control in and out transfers may be up to 254 bytes. In order
+to accept payload data of out transfers, you need to implement
+'usbFunctionWrite()'.
+
+USB Suspend Mode supply current:
+The USB standard limits power consumption to 500uA when the bus is in suspend
+mode. This is not a problem for self-powered devices since they don't need
+bus power anyway. Bus-powered devices can achieve this only by putting the
+CPU in sleep mode. The driver does not implement suspend handling by itself.
+However, the application may implement activity monitoring and wakeup from
+sleep. The host sends regular SE0 states on the bus to keep it active. These
+SE0 states can be detected by using D- as the interrupt source. Define
+USB_COUNT_SOF to 1 and use the global variable usbSofCount to check for bus
+activity.
+
+Operation without an USB master:
+The driver behaves neutral without connection to an USB master if D- reads
+as 1. To avoid spurious interrupts, we recommend a high impedance (e.g. 1M)
+pull-down or pull-up resistor on D+ (interrupt). If Zener diodes are used,
+use a pull-down. If D- becomes statically 0, the driver may block in the
+interrupt routine.
+
+Interrupt latency:
+The application must ensure that the USB interrupt is not disabled for more
+than 25 cycles (this is for 12 MHz, faster clocks allow longer latency).
+This implies that all interrupt routines must either have the "ISR_NOBLOCK"
+attribute set (see "avr/interrupt.h") or be written in assembler with "sei"
+as the first instruction.
+
+Maximum interrupt duration / CPU cycle consumption:
+The driver handles all USB communication during the interrupt service
+routine. The routine will not return before an entire USB message is received
+and the reply is sent. This may be up to ca. 1200 cycles @ 12 MHz (= 100us) if
+the host conforms to the standard. The driver will consume CPU cycles for all
+USB messages, even if they address another (low-speed) device on the same bus.
+
+*/
+
+/* ------------------------------------------------------------------------- */
+/* --------------------------- Module Interface ---------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#define USBDRV_VERSION  20121206
+/* This define uniquely identifies a driver version. It is a decimal number
+ * constructed from the driver's release date in the form YYYYMMDD. If the
+ * driver's behavior or interface changes, you can use this constant to
+ * distinguish versions. If it is not defined, the driver's release date is
+ * older than 2006-01-25.
+ */
+
+
+#ifndef USB_PUBLIC
+#define USB_PUBLIC
+#endif
+/* USB_PUBLIC is used as declaration attribute for all functions exported by
+ * the USB driver. The default is no attribute (see above). You may define it
+ * to static either in usbconfig.h or from the command line if you include
+ * usbdrv.c instead of linking against it. Including the C module of the driver
+ * directly in your code saves a couple of bytes in flash memory.
+ */
+
+#ifndef __ASSEMBLER__
+#ifndef uchar
+#define uchar   unsigned char
+#endif
+#ifndef schar
+#define schar   signed char
+#endif
+/* shortcuts for well defined 8 bit integer types */
+
+#if USB_CFG_LONG_TRANSFERS  /* if more than 254 bytes transfer size required */
+#   define usbMsgLen_t unsigned
+#else
+#   define usbMsgLen_t uchar
+#endif
+/* usbMsgLen_t is the data type used for transfer lengths. By default, it is
+ * defined to uchar, allowing a maximum of 254 bytes (255 is reserved for
+ * USB_NO_MSG below). If the usbconfig.h defines USB_CFG_LONG_TRANSFERS to 1,
+ * a 16 bit data type is used, allowing up to 16384 bytes (the rest is used
+ * for flags in the descriptor configuration).
+ */
+#define USB_NO_MSG  ((usbMsgLen_t)-1)   /* constant meaning "no message" */
+
+#ifndef usbMsgPtr_t
+#define usbMsgPtr_t uchar *
+#endif
+/* Making usbMsgPtr_t a define allows the user of this library to define it to
+ * an 8 bit type on tiny devices. This reduces code size, especially if the
+ * compiler supports a tiny memory model.
+ * The type can be a pointer or scalar type, casts are made where necessary.
+ * Although it's paradoxical, Gcc 4 generates slightly better code for scalar
+ * types than for pointers.
+ */
+
+struct usbRequest;  /* forward declaration */
+
+USB_PUBLIC void usbInit(void);
+/* This function must be called before interrupts are enabled and the main
+ * loop is entered. We exepct that the PORT and DDR bits for D+ and D- have
+ * not been changed from their default status (which is 0). If you have changed
+ * them, set both back to 0 (configure them as input with no internal pull-up).
+ */
+USB_PUBLIC void usbPoll(void);
+/* This function must be called at regular intervals from the main loop.
+ * Maximum delay between calls is somewhat less than 50ms (USB timeout for
+ * accepting a Setup message). Otherwise the device will not be recognized.
+ * Please note that debug outputs through the UART take ~ 0.5ms per byte
+ * at 19200 bps.
+ */
+extern usbMsgPtr_t usbMsgPtr;
+/* This variable may be used to pass transmit data to the driver from the
+ * implementation of usbFunctionWrite(). It is also used internally by the
+ * driver for standard control requests.
+ */
+USB_PUBLIC usbMsgLen_t usbFunctionSetup(uchar data[8]);
+/* This function is called when the driver receives a SETUP transaction from
+ * the host which is not answered by the driver itself (in practice: class and
+ * vendor requests). All control transfers start with a SETUP transaction where
+ * the host communicates the parameters of the following (optional) data
+ * transfer. The SETUP data is available in the 'data' parameter which can
+ * (and should) be casted to 'usbRequest_t *' for a more user-friendly access
+ * to parameters.
+ *
+ * If the SETUP indicates a control-in transfer, you should provide the
+ * requested data to the driver. There are two ways to transfer this data:
+ * (1) Set the global pointer 'usbMsgPtr' to the base of the static RAM data
+ * block and return the length of the data in 'usbFunctionSetup()'. The driver
+ * will handle the rest. Or (2) return USB_NO_MSG in 'usbFunctionSetup()'. The
+ * driver will then call 'usbFunctionRead()' when data is needed. See the
+ * documentation for usbFunctionRead() for details.
+ *
+ * If the SETUP indicates a control-out transfer, the only way to receive the
+ * data from the host is through the 'usbFunctionWrite()' call. If you
+ * implement this function, you must return USB_NO_MSG in 'usbFunctionSetup()'
+ * to indicate that 'usbFunctionWrite()' should be used. See the documentation
+ * of this function for more information. If you just want to ignore the data
+ * sent by the host, return 0 in 'usbFunctionSetup()'.
+ *
+ * Note that calls to the functions usbFunctionRead() and usbFunctionWrite()
+ * are only done if enabled by the configuration in usbconfig.h.
+ */
+USB_PUBLIC usbMsgLen_t usbFunctionDescriptor(struct usbRequest *rq);
+/* You need to implement this function ONLY if you provide USB descriptors at
+ * runtime (which is an expert feature). It is very similar to
+ * usbFunctionSetup() above, but it is called only to request USB descriptor
+ * data. See the documentation of usbFunctionSetup() above for more info.
+ */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT
+USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len);
+/* This function sets the message which will be sent during the next interrupt
+ * IN transfer. The message is copied to an internal buffer and must not exceed
+ * a length of 8 bytes. The message may be 0 bytes long just to indicate the
+ * interrupt status to the host.
+ * If you need to transfer more bytes, use a control read after the interrupt.
+ */
+#define usbInterruptIsReady()   (usbTxLen1 & 0x10)
+/* This macro indicates whether the last interrupt message has already been
+ * sent. If you set a new interrupt message before the old was sent, the
+ * message already buffered will be lost.
+ */
+#if USB_CFG_HAVE_INTRIN_ENDPOINT3
+USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len);
+#define usbInterruptIsReady3()   (usbTxLen3 & 0x10)
+/* Same as above for endpoint 3 */
+#endif
+#endif /* USB_CFG_HAVE_INTRIN_ENDPOINT */
+#if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH    /* simplified interface for backward compatibility */
+#define usbHidReportDescriptor  usbDescriptorHidReport
+/* should be declared as: PROGMEM char usbHidReportDescriptor[]; */
+/* If you implement an HID device, you need to provide a report descriptor.
+ * The HID report descriptor syntax is a bit complex. If you understand how
+ * report descriptors are constructed, we recommend that you use the HID
+ * Descriptor Tool from usb.org, see http://www.usb.org/developers/hidpage/.
+ * Otherwise you should probably start with a working example.
+ */
+#endif  /* USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH */
+#if USB_CFG_IMPLEMENT_FN_WRITE
+USB_PUBLIC uchar usbFunctionWrite(uchar *data, uchar len);
+/* This function is called by the driver to provide a control transfer's
+ * payload data (control-out). It is called in chunks of up to 8 bytes. The
+ * total count provided in the current control transfer can be obtained from
+ * the 'length' property in the setup data. If an error occurred during
+ * processing, return 0xff (== -1). The driver will answer the entire transfer
+ * with a STALL token in this case. If you have received the entire payload
+ * successfully, return 1. If you expect more data, return 0. If you don't
+ * know whether the host will send more data (you should know, the total is
+ * provided in the usbFunctionSetup() call!), return 1.
+ * NOTE: If you return 0xff for STALL, 'usbFunctionWrite()' may still be called
+ * for the remaining data. You must continue to return 0xff for STALL in these
+ * calls.
+ * In order to get usbFunctionWrite() called, define USB_CFG_IMPLEMENT_FN_WRITE
+ * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_WRITE */
+#if USB_CFG_IMPLEMENT_FN_READ
+USB_PUBLIC uchar usbFunctionRead(uchar *data, uchar len);
+/* This function is called by the driver to ask the application for a control
+ * transfer's payload data (control-in). It is called in chunks of up to 8
+ * bytes each. You should copy the data to the location given by 'data' and
+ * return the actual number of bytes copied. If you return less than requested,
+ * the control-in transfer is terminated. If you return 0xff, the driver aborts
+ * the transfer with a STALL token.
+ * In order to get usbFunctionRead() called, define USB_CFG_IMPLEMENT_FN_READ
+ * to 1 in usbconfig.h and return 0xff in usbFunctionSetup()..
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_READ */
+
+extern uchar usbRxToken;    /* may be used in usbFunctionWriteOut() below */
+#if USB_CFG_IMPLEMENT_FN_WRITEOUT
+USB_PUBLIC void usbFunctionWriteOut(uchar *data, uchar len);
+/* This function is called by the driver when data is received on an interrupt-
+ * or bulk-out endpoint. The endpoint number can be found in the global
+ * variable usbRxToken. You must define USB_CFG_IMPLEMENT_FN_WRITEOUT to 1 in
+ * usbconfig.h to get this function called.
+ */
+#endif /* USB_CFG_IMPLEMENT_FN_WRITEOUT */
+#ifdef USB_CFG_PULLUP_IOPORTNAME
+#define usbDeviceConnect()      ((USB_PULLUP_DDR |= (1<<USB_CFG_PULLUP_BIT)), \
+                                  (USB_PULLUP_OUT |= (1<<USB_CFG_PULLUP_BIT)))
+#define usbDeviceDisconnect()   ((USB_PULLUP_DDR &= ~(1<<USB_CFG_PULLUP_BIT)), \
+                                  (USB_PULLUP_OUT &= ~(1<<USB_CFG_PULLUP_BIT)))
+#else /* USB_CFG_PULLUP_IOPORTNAME */
+#define usbDeviceConnect()      (USBDDR &= ~(1<<USBMINUS))
+#define usbDeviceDisconnect()   (USBDDR |= (1<<USBMINUS))
+#endif /* USB_CFG_PULLUP_IOPORTNAME */
+/* The macros usbDeviceConnect() and usbDeviceDisconnect() (intended to look
+ * like a function) connect resp. disconnect the device from the host's USB.
+ * If the constants USB_CFG_PULLUP_IOPORT and USB_CFG_PULLUP_BIT are defined
+ * in usbconfig.h, a disconnect consists of removing the pull-up resisitor
+ * from D-, otherwise the disconnect is done by brute-force pulling D- to GND.
+ * This does not conform to the spec, but it works.
+ * Please note that the USB interrupt must be disabled while the device is
+ * in disconnected state, or the interrupt handler will hang! You can either
+ * turn off the USB interrupt selectively with
+ *     USB_INTR_ENABLE &= ~(1 << USB_INTR_ENABLE_BIT)
+ * or use cli() to disable interrupts globally.
+ */
+extern unsigned usbCrc16(unsigned data, uchar len);
+#define usbCrc16(data, len) usbCrc16((unsigned)(data), len)
+/* This function calculates the binary complement of the data CRC used in
+ * USB data packets. The value is used to build raw transmit packets.
+ * You may want to use this function for data checksums or to verify received
+ * data. We enforce 16 bit calling conventions for compatibility with IAR's
+ * tiny memory model.
+ */
+extern unsigned usbCrc16Append(unsigned data, uchar len);
+#define usbCrc16Append(data, len)    usbCrc16Append((unsigned)(data), len)
+/* This function is equivalent to usbCrc16() above, except that it appends
+ * the 2 bytes CRC (lowbyte first) in the 'data' buffer after reading 'len'
+ * bytes.
+ */
+#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
+extern unsigned usbMeasureFrameLength(void);
+/* This function MUST be called IMMEDIATELY AFTER USB reset and measures 1/7 of
+ * the number of CPU cycles during one USB frame minus one low speed bit
+ * length. In other words: return value = 1499 * (F_CPU / 10.5 MHz)
+ * Since this is a busy wait, you MUST disable all interrupts with cli() before
+ * calling this function.
+ * This can be used to calibrate the AVR's RC oscillator.
+ */
+#endif
+extern uchar    usbConfiguration;
+/* This value contains the current configuration set by the host. The driver
+ * allows setting and querying of this variable with the USB SET_CONFIGURATION
+ * and GET_CONFIGURATION requests, but does not use it otherwise.
+ * You may want to reflect the "configured" status with a LED on the device or
+ * switch on high power parts of the circuit only if the device is configured.
+ */
+#if USB_COUNT_SOF
+extern volatile uchar   usbSofCount;
+/* This variable is incremented on every SOF packet. It is only available if
+ * the macro USB_COUNT_SOF is defined to a value != 0.
+ */
+#endif
+#if USB_CFG_CHECK_DATA_TOGGLING
+extern uchar    usbCurrentDataToken;
+/* This variable can be checked in usbFunctionWrite() and usbFunctionWriteOut()
+ * to ignore duplicate packets.
+ */
+#endif
+
+#define USB_STRING_DESCRIPTOR_HEADER(stringLength) ((2*(stringLength)+2) | (3<<8))
+/* This macro builds a descriptor header for a string descriptor given the
+ * string's length. See usbdrv.c for an example how to use it.
+ */
+#if USB_CFG_HAVE_FLOWCONTROL
+extern volatile schar   usbRxLen;
+#define usbDisableAllRequests()     usbRxLen = -1
+/* Must be called from usbFunctionWrite(). This macro disables all data input
+ * from the USB interface. Requests from the host are answered with a NAK
+ * while they are disabled.
+ */
+#define usbEnableAllRequests()      usbRxLen = 0
+/* May only be called if requests are disabled. This macro enables input from
+ * the USB interface after it has been disabled with usbDisableAllRequests().
+ */
+#define usbAllRequestsAreDisabled() (usbRxLen < 0)
+/* Use this macro to find out whether requests are disabled. It may be needed
+ * to ensure that usbEnableAllRequests() is never called when requests are
+ * enabled.
+ */
+#endif
+
+#define USB_SET_DATATOKEN1(token)   usbTxBuf1[0] = token
+#define USB_SET_DATATOKEN3(token)   usbTxBuf3[0] = token
+/* These two macros can be used by application software to reset data toggling
+ * for interrupt-in endpoints 1 and 3. Since the token is toggled BEFORE
+ * sending data, you must set the opposite value of the token which should come
+ * first.
+ */
+
+#endif  /* __ASSEMBLER__ */
+
+
+/* ------------------------------------------------------------------------- */
+/* ----------------- Definitions for Descriptor Properties ----------------- */
+/* ------------------------------------------------------------------------- */
+/* This is advanced stuff. See usbconfig-prototype.h for more information
+ * about the various methods to define USB descriptors. If you do nothing,
+ * the default descriptors will be used.
+ */
+#define USB_PROP_IS_DYNAMIC     (1u << 14)
+/* If this property is set for a descriptor, usbFunctionDescriptor() will be
+ * used to obtain the particular descriptor. Data directly returned via
+ * usbMsgPtr are FLASH data by default, combine (OR) with USB_PROP_IS_RAM to
+ * return RAM data.
+ */
+#define USB_PROP_IS_RAM         (1u << 15)
+/* If this property is set for a descriptor, the data is read from RAM
+ * memory instead of Flash. The property is used for all methods to provide
+ * external descriptors.
+ */
+#define USB_PROP_LENGTH(len)    ((len) & 0x3fff)
+/* If a static external descriptor is used, this is the total length of the
+ * descriptor in bytes.
+ */
+
+/* all descriptors which may have properties: */
+#ifndef USB_CFG_DESCR_PROPS_DEVICE
+#define USB_CFG_DESCR_PROPS_DEVICE                  0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_CONFIGURATION
+#define USB_CFG_DESCR_PROPS_CONFIGURATION           0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRINGS
+#define USB_CFG_DESCR_PROPS_STRINGS                 0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_0
+#define USB_CFG_DESCR_PROPS_STRING_0                0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_VENDOR
+#define USB_CFG_DESCR_PROPS_STRING_VENDOR           0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_PRODUCT
+#define USB_CFG_DESCR_PROPS_STRING_PRODUCT          0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
+#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    0
+#endif
+#ifndef USB_CFG_DESCR_PROPS_HID
+#define USB_CFG_DESCR_PROPS_HID                     0
+#endif
+#if !(USB_CFG_DESCR_PROPS_HID_REPORT)
+#   undef USB_CFG_DESCR_PROPS_HID_REPORT
+#   if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH /* do some backward compatibility tricks */
+#       define USB_CFG_DESCR_PROPS_HID_REPORT       USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH
+#   else
+#       define USB_CFG_DESCR_PROPS_HID_REPORT       0
+#   endif
+#endif
+#ifndef USB_CFG_DESCR_PROPS_UNKNOWN
+#define USB_CFG_DESCR_PROPS_UNKNOWN                 0
+#endif
+
+/* ------------------ forward declaration of descriptors ------------------- */
+/* If you use external static descriptors, they must be stored in global
+ * arrays as declared below:
+ */
+#ifndef __ASSEMBLER__
+extern
+#if !(USB_CFG_DESCR_PROPS_DEVICE & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorDevice[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_CONFIGURATION & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorConfiguration[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_HID_REPORT & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorHidReport[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_0 & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+char usbDescriptorString0[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_VENDOR & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+int usbDescriptorStringVendor[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_PRODUCT & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+int usbDescriptorStringDevice[];
+
+extern
+#if !(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER & USB_PROP_IS_RAM)
+PROGMEM const
+#endif
+int usbDescriptorStringSerialNumber[];
+
+#endif /* __ASSEMBLER__ */
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------ General Purpose Macros ------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#define USB_CONCAT(a, b)            a ## b
+#define USB_CONCAT_EXPANDED(a, b)   USB_CONCAT(a, b)
+
+#define USB_OUTPORT(name)           USB_CONCAT(PORT, name)
+#define USB_INPORT(name)            USB_CONCAT(PIN, name)
+#define USB_DDRPORT(name)           USB_CONCAT(DDR, name)
+/* The double-define trick above lets us concatenate strings which are
+ * defined by macros.
+ */
+
+/* ------------------------------------------------------------------------- */
+/* ------------------------- Constant definitions -------------------------- */
+/* ------------------------------------------------------------------------- */
+
+#if !defined __ASSEMBLER__ && (!defined USB_CFG_VENDOR_ID || !defined USB_CFG_DEVICE_ID)
+#warning "You should define USB_CFG_VENDOR_ID and USB_CFG_DEVICE_ID in usbconfig.h"
+/* If the user has not defined IDs, we default to obdev's free IDs.
+ * See USB-IDs-for-free.txt for details.
+ */
+#endif
+
+/* make sure we have a VID and PID defined, byte order is lowbyte, highbyte */
+#ifndef USB_CFG_VENDOR_ID
+#   define  USB_CFG_VENDOR_ID   0xc0, 0x16  /* = 0x16c0 = 5824 = voti.nl */
+#endif
+
+#ifndef USB_CFG_DEVICE_ID
+#   if USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH
+#       define USB_CFG_DEVICE_ID    0xdf, 0x05  /* = 0x5df = 1503, shared PID for HIDs */
+#   elif USB_CFG_INTERFACE_CLASS == 2
+#       define USB_CFG_DEVICE_ID    0xe1, 0x05  /* = 0x5e1 = 1505, shared PID for CDC Modems */
+#   else
+#       define USB_CFG_DEVICE_ID    0xdc, 0x05  /* = 0x5dc = 1500, obdev's free PID */
+#   endif
+#endif
+
+/* Derive Output, Input and DataDirection ports from port names */
+#ifndef USB_CFG_IOPORTNAME
+#error "You must define USB_CFG_IOPORTNAME in usbconfig.h, see usbconfig-prototype.h"
+#endif
+
+#define USBOUT          USB_OUTPORT(USB_CFG_IOPORTNAME)
+#define USB_PULLUP_OUT  USB_OUTPORT(USB_CFG_PULLUP_IOPORTNAME)
+#define USBIN           USB_INPORT(USB_CFG_IOPORTNAME)
+#define USBDDR          USB_DDRPORT(USB_CFG_IOPORTNAME)
+#define USB_PULLUP_DDR  USB_DDRPORT(USB_CFG_PULLUP_IOPORTNAME)
+
+#define USBMINUS    USB_CFG_DMINUS_BIT
+#define USBPLUS     USB_CFG_DPLUS_BIT
+#define USBIDLE     (1<<USB_CFG_DMINUS_BIT) /* value representing J state */
+#define USBMASK     ((1<<USB_CFG_DPLUS_BIT) | (1<<USB_CFG_DMINUS_BIT))  /* mask for USB I/O bits */
+
+/* defines for backward compatibility with older driver versions: */
+#define USB_CFG_IOPORT          USB_OUTPORT(USB_CFG_IOPORTNAME)
+#ifdef USB_CFG_PULLUP_IOPORTNAME
+#define USB_CFG_PULLUP_IOPORT   USB_OUTPORT(USB_CFG_PULLUP_IOPORTNAME)
+#endif
+
+#ifndef USB_CFG_EP3_NUMBER  /* if not defined in usbconfig.h */
+#define USB_CFG_EP3_NUMBER  3
+#endif
+
+#ifndef USB_CFG_HAVE_INTRIN_ENDPOINT3
+#define USB_CFG_HAVE_INTRIN_ENDPOINT3   0
+#endif
+
+#define USB_BUFSIZE     11  /* PID, 8 bytes data, 2 bytes CRC */
+
+/* ----- Try to find registers and bits responsible for ext interrupt 0 ----- */
+
+#ifndef USB_INTR_CFG    /* allow user to override our default */
+#   if defined  EICRA
+#       define USB_INTR_CFG EICRA
+#   else
+#       define USB_INTR_CFG MCUCR
+#   endif
+#endif
+#ifndef USB_INTR_CFG_SET    /* allow user to override our default */
+#   if defined(USB_COUNT_SOF) || defined(USB_SOF_HOOK)
+#       define USB_INTR_CFG_SET (1 << ISC01)                    /* cfg for falling edge */
+        /* If any SOF logic is used, the interrupt must be wired to D- where
+         * we better trigger on falling edge
+         */
+#   else
+#       define USB_INTR_CFG_SET ((1 << ISC00) | (1 << ISC01))   /* cfg for rising edge */
+#   endif
+#endif
+#ifndef USB_INTR_CFG_CLR    /* allow user to override our default */
+#   define USB_INTR_CFG_CLR 0    /* no bits to clear */
+#endif
+
+#ifndef USB_INTR_ENABLE     /* allow user to override our default */
+#   if defined GIMSK
+#       define USB_INTR_ENABLE  GIMSK
+#   elif defined EIMSK
+#       define USB_INTR_ENABLE  EIMSK
+#   else
+#       define USB_INTR_ENABLE  GICR
+#   endif
+#endif
+#ifndef USB_INTR_ENABLE_BIT /* allow user to override our default */
+#   define USB_INTR_ENABLE_BIT  INT0
+#endif
+
+#ifndef USB_INTR_PENDING    /* allow user to override our default */
+#   if defined  EIFR
+#       define USB_INTR_PENDING EIFR
+#   else
+#       define USB_INTR_PENDING GIFR
+#   endif
+#endif
+#ifndef USB_INTR_PENDING_BIT    /* allow user to override our default */
+#   define USB_INTR_PENDING_BIT INTF0
+#endif
+
+/*
+The defines above don't work for the following chips
+at90c8534: no ISC0?, no PORTB, can't find a data sheet
+at86rf401: no PORTB, no MCUCR etc, low clock rate
+atmega103: no ISC0? (maybe omission in header, can't find data sheet)
+atmega603: not defined in avr-libc
+at43usb320, at43usb355, at76c711: have USB anyway
+at94k: is different...
+
+at90s1200, attiny11, attiny12, attiny15, attiny28: these have no RAM
+*/
+
+/* ------------------------------------------------------------------------- */
+/* ----------------- USB Specification Constants and Types ----------------- */
+/* ------------------------------------------------------------------------- */
+
+/* USB Token values */
+#define USBPID_SETUP    0x2d
+#define USBPID_OUT      0xe1
+#define USBPID_IN       0x69
+#define USBPID_DATA0    0xc3
+#define USBPID_DATA1    0x4b
+
+#define USBPID_ACK      0xd2
+#define USBPID_NAK      0x5a
+#define USBPID_STALL    0x1e
+
+#ifndef USB_INITIAL_DATATOKEN
+#define USB_INITIAL_DATATOKEN   USBPID_DATA1
+#endif
+
+#ifndef __ASSEMBLER__
+
+typedef struct usbTxStatus{
+    volatile uchar   len;
+    uchar   buffer[USB_BUFSIZE];
+}usbTxStatus_t;
+
+extern usbTxStatus_t   usbTxStatus1, usbTxStatus3;
+#define usbTxLen1   usbTxStatus1.len
+#define usbTxBuf1   usbTxStatus1.buffer
+#define usbTxLen3   usbTxStatus3.len
+#define usbTxBuf3   usbTxStatus3.buffer
+
+
+typedef union usbWord{
+    unsigned    word;
+    uchar       bytes[2];
+}usbWord_t;
+
+typedef struct usbRequest{
+    uchar       bmRequestType;
+    uchar       bRequest;
+    usbWord_t   wValue;
+    usbWord_t   wIndex;
+    usbWord_t   wLength;
+}usbRequest_t;
+/* This structure matches the 8 byte setup request */
+#endif
+
+/* bmRequestType field in USB setup:
+ * d t t r r r r r, where
+ * d ..... direction: 0=host->device, 1=device->host
+ * t ..... type: 0=standard, 1=class, 2=vendor, 3=reserved
+ * r ..... recipient: 0=device, 1=interface, 2=endpoint, 3=other
+ */
+
+/* USB setup recipient values */
+#define USBRQ_RCPT_MASK         0x1f
+#define USBRQ_RCPT_DEVICE       0
+#define USBRQ_RCPT_INTERFACE    1
+#define USBRQ_RCPT_ENDPOINT     2
+
+/* USB request type values */
+#define USBRQ_TYPE_MASK         0x60
+#define USBRQ_TYPE_STANDARD     (0<<5)
+#define USBRQ_TYPE_CLASS        (1<<5)
+#define USBRQ_TYPE_VENDOR       (2<<5)
+
+/* USB direction values: */
+#define USBRQ_DIR_MASK              0x80
+#define USBRQ_DIR_HOST_TO_DEVICE    (0<<7)
+#define USBRQ_DIR_DEVICE_TO_HOST    (1<<7)
+
+/* USB Standard Requests */
+#define USBRQ_GET_STATUS        0
+#define USBRQ_CLEAR_FEATURE     1
+#define USBRQ_SET_FEATURE       3
+#define USBRQ_SET_ADDRESS       5
+#define USBRQ_GET_DESCRIPTOR    6
+#define USBRQ_SET_DESCRIPTOR    7
+#define USBRQ_GET_CONFIGURATION 8
+#define USBRQ_SET_CONFIGURATION 9
+#define USBRQ_GET_INTERFACE     10
+#define USBRQ_SET_INTERFACE     11
+#define USBRQ_SYNCH_FRAME       12
+
+/* USB descriptor constants */
+#define USBDESCR_DEVICE         1
+#define USBDESCR_CONFIG         2
+#define USBDESCR_STRING         3
+#define USBDESCR_INTERFACE      4
+#define USBDESCR_ENDPOINT       5
+#define USBDESCR_HID            0x21
+#define USBDESCR_HID_REPORT     0x22
+#define USBDESCR_HID_PHYS       0x23
+
+//#define USBATTR_BUSPOWER        0x80  // USB 1.1 does not define this value any more
+#define USBATTR_BUSPOWER        0
+#define USBATTR_SELFPOWER       0x40
+#define USBATTR_REMOTEWAKE      0x20
+
+/* USB HID Requests */
+#define USBRQ_HID_GET_REPORT    0x01
+#define USBRQ_HID_GET_IDLE      0x02
+#define USBRQ_HID_GET_PROTOCOL  0x03
+#define USBRQ_HID_SET_REPORT    0x09
+#define USBRQ_HID_SET_IDLE      0x0a
+#define USBRQ_HID_SET_PROTOCOL  0x0b
+
+/* ------------------------------------------------------------------------- */
+
+#endif /* __usbdrv_h_included__ */
Index: vusb-20121206/usbdrv/usbdrvasm.asm
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm.asm	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm.asm	(working copy)
@@ -0,0 +1,20 @@
+/* Name: usbdrvasm.asm
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2006-03-01
+ * Tabsize: 4
+ * Copyright: (c) 2006 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+The IAR compiler/assembler system prefers assembler files with file extension
+".asm". We simply provide this file as an alias for usbdrvasm.S.
+
+Thanks to Oleg Semyonov for his help with the IAR tools port!
+*/
+
+#include "usbdrvasm.S"
+
+end
Index: vusb-20121206/usbdrv/usbdrvasm.S
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm.S	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm.S	(working copy)
@@ -0,0 +1,392 @@
+/* Name: usbdrvasm.S
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-13
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This module is the assembler part of the USB driver. This file contains
+general code (preprocessor acrobatics and CRC computation) and then includes
+the file appropriate for the given clock rate.
+*/
+
+#define __SFR_OFFSET 0      /* used by avr-libc's register definitions */
+#include "usbportability.h"
+#include "usbdrv.h"         /* for common defs */
+
+/* register names */
+#define x1      r16
+#define x2      r17
+#define shift   r18
+#define cnt     r19
+#define x3      r20
+#define x4      r21
+#define x5		r22
+#define bitcnt  x5
+#define phase   x4
+#define leap    x4
+
+/* Some assembler dependent definitions and declarations: */
+
+#ifdef __IAR_SYSTEMS_ASM__
+    extern  usbRxBuf, usbDeviceAddr, usbNewDeviceAddr, usbInputBufOffset
+    extern  usbCurrentTok, usbRxLen, usbRxToken, usbTxLen
+    extern  usbTxBuf, usbTxStatus1, usbTxStatus3
+#   if USB_COUNT_SOF
+        extern usbSofCount
+#   endif
+    public  usbCrc16
+    public  usbCrc16Append
+
+    COMMON  INTVEC
+#   ifndef USB_INTR_VECTOR
+        ORG     INT0_vect
+#   else /* USB_INTR_VECTOR */
+        ORG     USB_INTR_VECTOR
+#       undef   USB_INTR_VECTOR
+#   endif /* USB_INTR_VECTOR */
+#   define  USB_INTR_VECTOR usbInterruptHandler
+    rjmp    USB_INTR_VECTOR
+    RSEG    CODE
+
+#else /* __IAR_SYSTEMS_ASM__ */
+
+#   ifndef USB_INTR_VECTOR /* default to hardware interrupt INT0 */
+#       ifdef INT0_vect
+#           define USB_INTR_VECTOR  INT0_vect       // this is the "new" define for the vector
+#       else
+#           define USB_INTR_VECTOR  SIG_INTERRUPT0  // this is the "old" vector
+#       endif
+#   endif
+    .text
+    .global USB_INTR_VECTOR
+    .type   USB_INTR_VECTOR, @function
+    .global usbCrc16
+    .global usbCrc16Append
+#endif /* __IAR_SYSTEMS_ASM__ */
+
+
+#if USB_INTR_PENDING < 0x40 /* This is an I/O address, use in and out */
+#   define  USB_LOAD_PENDING(reg)   in reg, USB_INTR_PENDING
+#   define  USB_STORE_PENDING(reg)  out USB_INTR_PENDING, reg
+#else   /* It's a memory address, use lds and sts */
+#   define  USB_LOAD_PENDING(reg)   lds reg, USB_INTR_PENDING
+#   define  USB_STORE_PENDING(reg)  sts USB_INTR_PENDING, reg
+#endif
+
+#define usbTxLen1   usbTxStatus1
+#define usbTxBuf1   (usbTxStatus1 + 1)
+#define usbTxLen3   usbTxStatus3
+#define usbTxBuf3   (usbTxStatus3 + 1)
+
+
+;----------------------------------------------------------------------------
+; Utility functions
+;----------------------------------------------------------------------------
+
+#ifdef __IAR_SYSTEMS_ASM__
+/* Register assignments for usbCrc16 on IAR cc */
+/* Calling conventions on IAR:
+ * First parameter passed in r16/r17, second in r18/r19 and so on.
+ * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+ * Result is passed in r16/r17
+ * In case of the "tiny" memory model, pointers are only 8 bit with no
+ * padding. We therefore pass argument 1 as "16 bit unsigned".
+ */
+RTMODEL "__rt_version", "3"
+/* The line above will generate an error if cc calling conventions change.
+ * The value "3" above is valid for IAR 4.10B/W32
+ */
+#   define argLen   r18 /* argument 2 */
+#   define argPtrL  r16 /* argument 1 */
+#   define argPtrH  r17 /* argument 1 */
+
+#   define resCrcL  r16 /* result */
+#   define resCrcH  r17 /* result */
+
+#   define ptrL     ZL
+#   define ptrH     ZH
+#   define ptr      Z
+#   define byte     r22
+#   define bitCnt   r19
+#   define polyL    r20
+#   define polyH    r21
+#   define scratch  r23
+
+#else  /* __IAR_SYSTEMS_ASM__ */ 
+/* Register assignments for usbCrc16 on gcc */
+/* Calling conventions on gcc:
+ * First parameter passed in r24/r25, second in r22/23 and so on.
+ * Callee must preserve r1-r17, r28/r29
+ * Result is passed in r24/r25
+ */
+#   define argLen   r22 /* argument 2 */
+#   define argPtrL  r24 /* argument 1 */
+#   define argPtrH  r25 /* argument 1 */
+
+#   define resCrcL  r24 /* result */
+#   define resCrcH  r25 /* result */
+
+#   define ptrL     XL
+#   define ptrH     XH
+#   define ptr      x
+#   define byte     r18
+#   define bitCnt   r19
+#   define polyL    r20
+#   define polyH    r21
+#   define scratch  r23
+
+#endif
+
+#if USB_USE_FAST_CRC
+
+; This implementation is faster, but has bigger code size
+; Thanks to Slawomir Fras (BoskiDialer) for this code!
+; It implements the following C pseudo-code:
+; unsigned table(unsigned char x)
+; {
+; unsigned    value;
+; 
+;     value = (unsigned)x << 6;
+;     value ^= (unsigned)x << 7;
+;     if(parity(x))
+;         value ^= 0xc001;
+;     return value;
+; }
+; unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen)
+; {
+; unsigned crc = 0xffff;
+; 
+;     while(argLen--)
+;         crc = table(lo8(crc) ^ *argPtr++) ^ hi8(crc);
+;     return ~crc;
+; }
+
+; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+;   argPtr  r24+25 / r16+r17
+;   argLen  r22 / r18
+; temp variables:
+;   byte    r18 / r22
+;   scratch r23
+;   resCrc  r24+r25 / r16+r17
+;   ptr     X / Z
+usbCrc16:
+    mov     ptrL, argPtrL
+    mov     ptrH, argPtrH
+    ldi     resCrcL, 0xFF
+    ldi     resCrcH, 0xFF
+    rjmp    usbCrc16LoopTest
+usbCrc16ByteLoop:
+    ld      byte, ptr+
+    eor     resCrcL, byte   ; resCrcL is now 'x' in table()
+    mov     byte, resCrcL   ; compute parity of 'x'
+    swap    byte
+    eor     byte, resCrcL
+    mov     scratch, byte
+    lsr     byte
+    lsr     byte
+    eor     byte, scratch
+    inc     byte
+    lsr     byte
+    andi    byte, 1         ; byte is now parity(x)
+    mov     scratch, resCrcL
+    mov     resCrcL, resCrcH
+    eor     resCrcL, byte   ; low byte of if(parity(x)) value ^= 0xc001;
+    neg     byte
+    andi    byte, 0xc0
+    mov     resCrcH, byte   ; high byte of if(parity(x)) value ^= 0xc001;
+    clr     byte
+    lsr     scratch
+    ror     byte
+    eor     resCrcH, scratch
+    eor     resCrcL, byte
+    lsr     scratch
+    ror     byte
+    eor     resCrcH, scratch
+    eor     resCrcL, byte
+usbCrc16LoopTest:
+    subi    argLen, 1
+    brsh    usbCrc16ByteLoop
+    com     resCrcL
+    com     resCrcH
+    ret
+
+#else   /* USB_USE_FAST_CRC */
+
+; This implementation is slower, but has less code size
+;
+; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
+;   argPtr  r24+25 / r16+r17
+;   argLen  r22 / r18
+; temp variables:
+;   byte    r18 / r22
+;   bitCnt  r19
+;   poly    r20+r21
+;   scratch r23
+;   resCrc  r24+r25 / r16+r17
+;   ptr     X / Z
+usbCrc16:
+    mov     ptrL, argPtrL
+    mov     ptrH, argPtrH
+    ldi     resCrcL, 0
+    ldi     resCrcH, 0
+    ldi     polyL, lo8(0xa001)
+    ldi     polyH, hi8(0xa001)
+    com     argLen      ; argLen = -argLen - 1: modified loop to ensure that carry is set
+    ldi     bitCnt, 0   ; loop counter with starnd condition = end condition
+    rjmp    usbCrcLoopEntry
+usbCrcByteLoop:
+    ld      byte, ptr+
+    eor     resCrcL, byte
+usbCrcBitLoop:
+    ror     resCrcH     ; carry is always set here (see brcs jumps to here)
+    ror     resCrcL
+    brcs    usbCrcNoXor
+    eor     resCrcL, polyL
+    eor     resCrcH, polyH
+usbCrcNoXor:
+    subi    bitCnt, 224 ; (8 * 224) % 256 = 0; this loop iterates 8 times
+    brcs    usbCrcBitLoop
+usbCrcLoopEntry:
+    subi    argLen, -1
+    brcs    usbCrcByteLoop
+usbCrcReady:
+    ret
+; Thanks to Reimar Doeffinger for optimizing this CRC routine!
+
+#endif /* USB_USE_FAST_CRC */
+
+; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
+usbCrc16Append:
+    rcall   usbCrc16
+    st      ptr+, resCrcL
+    st      ptr+, resCrcH
+    ret
+
+#undef argLen
+#undef argPtrL
+#undef argPtrH
+#undef resCrcL
+#undef resCrcH
+#undef ptrL
+#undef ptrH
+#undef ptr
+#undef byte
+#undef bitCnt
+#undef polyL
+#undef polyH
+#undef scratch
+
+
+#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
+#ifdef __IAR_SYSTEMS_ASM__
+/* Register assignments for usbMeasureFrameLength on IAR cc */
+/* Calling conventions on IAR:
+ * First parameter passed in r16/r17, second in r18/r19 and so on.
+ * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
+ * Result is passed in r16/r17
+ * In case of the "tiny" memory model, pointers are only 8 bit with no
+ * padding. We therefore pass argument 1 as "16 bit unsigned".
+ */
+#   define resL     r16
+#   define resH     r17
+#   define cnt16L   r30
+#   define cnt16H   r31
+#   define cntH     r18
+
+#else  /* __IAR_SYSTEMS_ASM__ */ 
+/* Register assignments for usbMeasureFrameLength on gcc */
+/* Calling conventions on gcc:
+ * First parameter passed in r24/r25, second in r22/23 and so on.
+ * Callee must preserve r1-r17, r28/r29
+ * Result is passed in r24/r25
+ */
+#   define resL     r24
+#   define resH     r25
+#   define cnt16L   r24
+#   define cnt16H   r25
+#   define cntH     r26
+#endif
+#   define cnt16    cnt16L
+
+; extern unsigned usbMeasurePacketLength(void);
+; returns time between two idle strobes in multiples of 7 CPU clocks
+.global usbMeasureFrameLength
+usbMeasureFrameLength:
+    ldi     cntH, 6         ; wait ~ 10 ms for D- == 0
+    clr     cnt16L
+    clr     cnt16H
+usbMFTime16:
+    dec     cntH
+    breq    usbMFTimeout
+usbMFWaitStrobe:            ; first wait for D- == 0 (idle strobe)
+    sbiw    cnt16, 1        ;[0] [6]
+    breq    usbMFTime16     ;[2]
+    sbic    USBIN, USBMINUS ;[3]
+    rjmp    usbMFWaitStrobe ;[4]
+usbMFWaitIdle:              ; then wait until idle again
+    sbis    USBIN, USBMINUS ;1 wait for D- == 1
+    rjmp    usbMFWaitIdle   ;2
+    ldi     cnt16L, 1       ;1 represents cycles so far
+    clr     cnt16H          ;1
+usbMFWaitLoop:
+    in      cntH, USBIN     ;[0] [7]
+    adiw    cnt16, 1        ;[1]
+    breq    usbMFTimeout    ;[3]
+    andi    cntH, USBMASK   ;[4]
+    brne    usbMFWaitLoop   ;[5]
+usbMFTimeout:
+#if resL != cnt16L
+    mov     resL, cnt16L
+    mov     resH, cnt16H
+#endif
+    ret
+
+#undef resL
+#undef resH
+#undef cnt16
+#undef cnt16L
+#undef cnt16H
+#undef cntH
+
+#endif  /* USB_CFG_HAVE_MEASURE_FRAME_LENGTH */
+
+;----------------------------------------------------------------------------
+; Now include the clock rate specific code
+;----------------------------------------------------------------------------
+
+#ifndef USB_CFG_CLOCK_KHZ
+#   ifdef F_CPU
+#       define USB_CFG_CLOCK_KHZ (F_CPU/1000)
+#   else
+#       error "USB_CFG_CLOCK_KHZ not defined in usbconfig.h and no F_CPU set!"
+#   endif
+#endif
+
+#if USB_CFG_CHECK_CRC   /* separate dispatcher for CRC type modules */
+#   if USB_CFG_CLOCK_KHZ == 18000
+#       include "usbdrvasm18-crc.inc"
+#   else
+#       error "USB_CFG_CLOCK_KHZ is not one of the supported crc-rates!"
+#   endif
+#else   /* USB_CFG_CHECK_CRC */
+#   if USB_CFG_CLOCK_KHZ == 12000
+#       include "usbdrvasm12.inc"
+#   elif USB_CFG_CLOCK_KHZ == 12800
+#       include "usbdrvasm128.inc"
+#   elif USB_CFG_CLOCK_KHZ == 15000
+#       include "usbdrvasm15.inc"
+#   elif USB_CFG_CLOCK_KHZ == 16000
+#       include "usbdrvasm16.inc"
+#   elif USB_CFG_CLOCK_KHZ == 16500
+#       include "usbdrvasm165.inc"
+#   elif USB_CFG_CLOCK_KHZ == 20000
+#       include "usbdrvasm20.inc"
+#   else
+#       error "USB_CFG_CLOCK_KHZ is not one of the supported non-crc-rates!"
+#   endif
+#endif /* USB_CFG_CHECK_CRC */
Index: vusb-20121206/usbdrv/usbdrvasm12.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm12.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm12.inc	(working copy)
@@ -0,0 +1,392 @@
+/* Name: usbdrvasm12.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2004-12-29
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 12 MHz version of the asssembler part of the USB driver. It
+requires a 12 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+
+
+Timing constraints according to spec (in bit times):
+timing subject                                      min max    CPUcycles
+---------------------------------------------------------------------------
+EOP of OUT/SETUP to sync pattern of DATA0 (both rx) 2   16     16-128
+EOP of IN to sync pattern of DATA0 (rx, then tx)    2   7.5    16-60
+DATAx (rx) to ACK/NAK/STALL (tx)                    2   7.5    16-60
+*/
+
+;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
+;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
+;max allowable interrupt latency: 34 cycles -> max 25 cycles interrupt disable
+;max stack usage: [ret(2), YL, SREG, YH, shift, x1, x2, x3, cnt, x4] = 11 bytes
+;Numbers in brackets are maximum cycles since SOF.
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt
+    push    YL              ;2 [35] push only what is necessary to sync with edge ASAP
+    in      YL, SREG        ;1 [37]
+    push    YL              ;2 [39]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    YH                  ;2 [2]
+    lds     YL, usbInputBufOffset;2 [4]
+    clr     YH                  ;1 [5]
+    subi    YL, lo8(-(usbRxBuf));1 [6]
+    sbci    YH, hi8(-(usbRxBuf));1 [7]
+
+    sbis    USBIN, USBMINUS ;1 [8] we want two bits K [sample 1 cycle too early]
+    rjmp    haveTwoBitsK    ;2 [10]
+    pop     YH              ;2 [11] undo the push from before
+    rjmp    waitForK        ;2 [13] this was not the end of sync, retry
+haveTwoBitsK:
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+    push    shift           ;2 [16]
+    push    x1              ;2 [12]
+    push    x2              ;2 [14]
+
+    in      x1, USBIN       ;1 [17] <-- sample bit 0
+    ldi     shift, 0xff     ;1 [18]
+    bst     x1, USBMINUS    ;1 [19]
+    bld     shift, 0        ;1 [20]
+    push    x3              ;2 [22]
+    push    cnt             ;2 [24]
+    
+    in      x2, USBIN       ;1 [25] <-- sample bit 1
+    ser     x3              ;1 [26] [inserted init instruction]
+    eor     x1, x2          ;1 [27]
+    bst     x1, USBMINUS    ;1 [28]
+    bld     shift, 1        ;1 [29]
+    ldi     cnt, USB_BUFSIZE;1 [30] [inserted init instruction]
+    rjmp    rxbit2          ;2 [32]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+
+unstuff0:               ;1 (branch taken)
+    andi    x3, ~0x01   ;1 [15]
+    mov     x1, x2      ;1 [16] x2 contains last sampled (stuffed) bit
+    in      x2, USBIN   ;1 [17] <-- sample bit 1 again
+    ori     shift, 0x01 ;1 [18]
+    rjmp    didUnstuff0 ;2 [20]
+
+unstuff1:               ;1 (branch taken)
+    mov     x2, x1      ;1 [21] x1 contains last sampled (stuffed) bit
+    andi    x3, ~0x02   ;1 [22]
+    ori     shift, 0x02 ;1 [23]
+    nop                 ;1 [24]
+    in      x1, USBIN   ;1 [25] <-- sample bit 2 again
+    rjmp    didUnstuff1 ;2 [27]
+
+unstuff2:               ;1 (branch taken)
+    andi    x3, ~0x04   ;1 [29]
+    ori     shift, 0x04 ;1 [30]
+    mov     x1, x2      ;1 [31] x2 contains last sampled (stuffed) bit
+    nop                 ;1 [32]
+    in      x2, USBIN   ;1 [33] <-- sample bit 3
+    rjmp    didUnstuff2 ;2 [35]
+
+unstuff3:               ;1 (branch taken)
+    in      x2, USBIN   ;1 [34] <-- sample stuffed bit 3 [one cycle too late]
+    andi    x3, ~0x08   ;1 [35]
+    ori     shift, 0x08 ;1 [36]
+    rjmp    didUnstuff3 ;2 [38]
+
+unstuff4:               ;1 (branch taken)
+    andi    x3, ~0x10   ;1 [40]
+    in      x1, USBIN   ;1 [41] <-- sample stuffed bit 4
+    ori     shift, 0x10 ;1 [42]
+    rjmp    didUnstuff4 ;2 [44]
+
+unstuff5:               ;1 (branch taken)
+    andi    x3, ~0x20   ;1 [48]
+    in      x2, USBIN   ;1 [49] <-- sample stuffed bit 5
+    ori     shift, 0x20 ;1 [50]
+    rjmp    didUnstuff5 ;2 [52]
+
+unstuff6:               ;1 (branch taken)
+    andi    x3, ~0x40   ;1 [56]
+    in      x1, USBIN   ;1 [57] <-- sample stuffed bit 6
+    ori     shift, 0x40 ;1 [58]
+    rjmp    didUnstuff6 ;2 [60]
+
+; extra jobs done during bit interval:
+; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs]
+; bit 1:    se0 check
+; bit 2:    overflow check
+; bit 3:    recovery from delay [bit 0 tasks took too long]
+; bit 4:    none
+; bit 5:    none
+; bit 6:    none
+; bit 7:    jump, eor
+rxLoop:
+    eor     x3, shift   ;1 [0] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    in      x1, USBIN   ;1 [1] <-- sample bit 0
+    st      y+, x3      ;2 [3] store data
+    ser     x3          ;1 [4]
+    nop                 ;1 [5]
+    eor     x2, x1      ;1 [6]
+    bst     x2, USBMINUS;1 [7]
+    bld     shift, 0    ;1 [8]
+    in      x2, USBIN   ;1 [9] <-- sample bit 1 (or possibly bit 0 stuffed)
+    andi    x2, USBMASK ;1 [10]
+    breq    se0         ;1 [11] SE0 check for bit 1
+    andi    shift, 0xf9 ;1 [12]
+didUnstuff0:
+    breq    unstuff0    ;1 [13]
+    eor     x1, x2      ;1 [14]
+    bst     x1, USBMINUS;1 [15]
+    bld     shift, 1    ;1 [16]
+rxbit2:
+    in      x1, USBIN   ;1 [17] <-- sample bit 2 (or possibly bit 1 stuffed)
+    andi    shift, 0xf3 ;1 [18]
+    breq    unstuff1    ;1 [19] do remaining work for bit 1
+didUnstuff1:
+    subi    cnt, 1      ;1 [20]
+    brcs    overflow    ;1 [21] loop control
+    eor     x2, x1      ;1 [22]
+    bst     x2, USBMINUS;1 [23]
+    bld     shift, 2    ;1 [24]
+    in      x2, USBIN   ;1 [25] <-- sample bit 3 (or possibly bit 2 stuffed)
+    andi    shift, 0xe7 ;1 [26]
+    breq    unstuff2    ;1 [27]
+didUnstuff2:
+    eor     x1, x2      ;1 [28]
+    bst     x1, USBMINUS;1 [29]
+    bld     shift, 3    ;1 [30]
+didUnstuff3:
+    andi    shift, 0xcf ;1 [31]
+    breq    unstuff3    ;1 [32]
+    in      x1, USBIN   ;1 [33] <-- sample bit 4
+    eor     x2, x1      ;1 [34]
+    bst     x2, USBMINUS;1 [35]
+    bld     shift, 4    ;1 [36]
+didUnstuff4:
+    andi    shift, 0x9f ;1 [37]
+    breq    unstuff4    ;1 [38]
+    nop2                ;2 [40]
+    in      x2, USBIN   ;1 [41] <-- sample bit 5
+    eor     x1, x2      ;1 [42]
+    bst     x1, USBMINUS;1 [43]
+    bld     shift, 5    ;1 [44]
+didUnstuff5:
+    andi    shift, 0x3f ;1 [45]
+    breq    unstuff5    ;1 [46]
+    nop2                ;2 [48]
+    in      x1, USBIN   ;1 [49] <-- sample bit 6
+    eor     x2, x1      ;1 [50]
+    bst     x2, USBMINUS;1 [51]
+    bld     shift, 6    ;1 [52]
+didUnstuff6:
+    cpi     shift, 0x02 ;1 [53]
+    brlo    unstuff6    ;1 [54]
+    nop2                ;2 [56]
+    in      x2, USBIN   ;1 [57] <-- sample bit 7
+    eor     x1, x2      ;1 [58]
+    bst     x1, USBMINUS;1 [59]
+    bld     shift, 7    ;1 [60]
+didUnstuff7:
+    cpi     shift, 0x04 ;1 [61]
+    brsh    rxLoop      ;2 [63] loop control
+unstuff7:
+    andi    x3, ~0x80   ;1 [63]
+    ori     shift, 0x80 ;1 [64]
+    in      x2, USBIN   ;1 [65] <-- sample stuffed bit 7
+    nop                 ;1 [66]
+    rjmp    didUnstuff7 ;2 [68]
+
+macro POP_STANDARD ; 12 cycles
+    pop     cnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;----------------------------------------------------------------------------
+; Transmitting data
+;----------------------------------------------------------------------------
+
+txByteLoop:
+txBitloop:
+stuffN1Delay:                   ;     [03]
+    ror     shift               ;[-5] [11] [59]
+    brcc    doExorN1            ;[-4]      [60]
+    subi    x4, 1               ;[-3]
+    brne    commonN1            ;[-2]
+    lsl     shift               ;[-1] compensate ror after rjmp stuffDelay
+    nop                         ;[00] stuffing consists of just waiting 8 cycles
+    rjmp    stuffN1Delay        ;[01] after ror, C bit is reliably clear
+
+sendNakAndReti:                 ;0 [-19] 19 cycles until SOP
+    ldi     x3, USBPID_NAK      ;1 [-18]
+    rjmp    usbSendX3           ;2 [-16]
+sendAckAndReti:                 ;0 [-19] 19 cycles until SOP
+    ldi     x3, USBPID_ACK      ;1 [-18]
+    rjmp    usbSendX3           ;2 [-16]
+sendCntAndReti:                 ;0 [-17] 17 cycles until SOP
+    mov     x3, cnt             ;1 [-16]
+usbSendX3:                      ;0 [-16]
+    ldi     YL, 20              ;1 [-15] 'x3' is R20
+    ldi     YH, 0               ;1 [-14]
+    ldi     cnt, 2              ;1 [-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
+; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
+; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte
+;uses: x1...x2, x4, shift, cnt, Y [x1 = mirror USBOUT, x2 = USBMASK, x4 = bitstuff cnt]
+;Numbers in brackets are time since first bit of sync pattern is sent (start of instruction)
+usbSendAndReti:
+    in      x2, USBDDR          ;[-12] 12 cycles until SOP
+    ori     x2, USBMASK         ;[-11]
+    sbi     USBOUT, USBMINUS    ;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    out     USBDDR, x2          ;[-8] <--- acquire bus
+    in      x1, USBOUT          ;[-7] port mirror for tx loop
+    ldi     shift, 0x40         ;[-6] sync byte is first byte sent (we enter loop after ror)
+    ldi     x2, USBMASK         ;[-5]
+    push    x4                  ;[-4]
+doExorN1:
+    eor     x1, x2              ;[-2] [06] [62]
+    ldi     x4, 6               ;[-1] [07] [63]
+commonN1:
+stuffN2Delay:
+    out     USBOUT, x1          ;[00] [08] [64] <--- set bit
+    ror     shift               ;[01]
+    brcc    doExorN2            ;[02]
+    subi    x4, 1               ;[03]
+    brne    commonN2            ;[04]
+    lsl     shift               ;[05] compensate ror after rjmp stuffDelay
+    rjmp    stuffN2Delay        ;[06] after ror, C bit is reliably clear
+doExorN2:
+    eor     x1, x2              ;[04] [12]
+    ldi     x4, 6               ;[05] [13]
+commonN2:
+    nop                         ;[06] [14]
+    subi    cnt, 171            ;[07] [15] trick: (3 * 171) & 0xff = 1
+    out     USBOUT, x1          ;[08] [16] <--- set bit
+    brcs    txBitloop           ;[09]      [25] [41]
+
+stuff6Delay:
+    ror     shift               ;[42] [50]
+    brcc    doExor6             ;[43]
+    subi    x4, 1               ;[44]
+    brne    common6             ;[45]
+    lsl     shift               ;[46] compensate ror after rjmp stuffDelay
+    nop                         ;[47] stuffing consists of just waiting 8 cycles
+    rjmp    stuff6Delay         ;[48] after ror, C bit is reliably clear
+doExor6:
+    eor     x1, x2              ;[45] [53]
+    ldi     x4, 6               ;[46]
+common6:
+stuff7Delay:
+    ror     shift               ;[47] [55]
+    out     USBOUT, x1          ;[48] <--- set bit
+    brcc    doExor7             ;[49]
+    subi    x4, 1               ;[50]
+    brne    common7             ;[51]
+    lsl     shift               ;[52] compensate ror after rjmp stuffDelay
+    rjmp    stuff7Delay         ;[53] after ror, C bit is reliably clear
+doExor7:
+    eor     x1, x2              ;[51] [59]
+    ldi     x4, 6               ;[52]
+common7:
+    ld      shift, y+           ;[53]
+    tst     cnt                 ;[55]
+    out     USBOUT, x1          ;[56] <--- set bit
+    brne    txByteLoop          ;[57]
+
+;make SE0:
+    cbr     x1, USBMASK         ;[58] prepare SE0 [spec says EOP may be 15 to 18 cycles]
+    lds     x2, usbNewDeviceAddr;[59]
+    lsl     x2                  ;[61] we compare with left shifted address
+    subi    YL, 2 + 20          ;[62] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0               ;[63]
+    out     USBOUT, x1          ;[00] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign      ;[01]
+    sts     usbDeviceAddr, x2   ; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[03] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)       ;[04]
+    ori     x1, USBIDLE         ;[05]
+    in      x2, USBDDR          ;[06]
+    cbr     x2, USBMASK         ;[07] set both pins to input
+    mov     x3, x1              ;[08]
+    cbr     x3, USBMASK         ;[09] configure no pullup on both pins
+    pop     x4                  ;[10]
+    nop2                        ;[12]
+    nop2                        ;[14]
+    out     USBOUT, x1          ;[16] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2          ;[17] <-- release bus now
+    out     USBOUT, x3          ;[18] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: vusb-20121206/usbdrv/usbdrvasm128.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm128.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm128.inc	(working copy)
@@ -0,0 +1,749 @@
+/* Name: usbdrvasm128.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-10-11
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 12.8 MHz version of the USB driver. It is intended for use
+with the internal RC oscillator. Although 12.8 MHz is outside the guaranteed
+calibration range of the oscillator, almost all AVRs can reach this frequency.
+This version contains a phase locked loop in the receiver routine to cope with
+slight clock rate deviations of up to +/- 1%.
+
+See usbdrv.h for a description of the entire driver.
+
+LIMITATIONS
+===========
+Although it may seem very handy to save the crystal and use the internal
+RC oscillator of the CPU, this method (and this module) has some serious
+limitations:
+(1) The guaranteed calibration range of the oscillator is only 8.1 MHz.
+They typical range is 14.5 MHz and most AVRs can actually reach this rate.
+(2) Writing EEPROM and Flash may be unreliable (short data lifetime) since
+the write procedure is timed from the RC oscillator.
+(3) End Of Packet detection (SE0) should be in bit 1, bit it is only checked
+if bits 0 and 1 both read as 0 on D- and D+ read as 0 in the middle. This may
+cause problems with old hubs which delay SE0 by up to one cycle.
+(4) Code size is much larger than that of the other modules.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+
+Implementation notes:
+======================
+min frequency: 67 cycles for 8 bit -> 12.5625 MHz
+max frequency: 69.286 cycles for 8 bit -> 12.99 MHz
+nominal frequency: 12.77 MHz ( = sqrt(min * max))
+
+sampling positions: (next even number in range [+/- 0.5])
+cycle index range: 0 ... 66
+bits:
+.5, 8.875, 17.25, 25.625, 34, 42.375, 50.75, 59.125
+[0/1], [9], [17], [25/+26], [34], [+42/43], [51], [59]
+
+bit number:     0   1   2   3   4   5   6   7
+spare cycles    1   2   1   2   1   1   1   0
+
+operations to perform:      duration cycle
+                            ----------------
+    eor     fix, shift          1 -> 00
+    andi    phase, USBMASK      1 -> 08
+    breq    se0                 1 -> 16 (moved to 11)
+    st      y+, data            2 -> 24, 25
+    mov     data, fix           1 -> 33
+    ser     data                1 -> 41
+    subi    cnt, 1              1 -> 49
+    brcs    overflow            1 -> 50
+
+layout of samples and operations:
+[##] = sample bit
+<##> = sample phase
+*##* = operation
+
+0:  *00* [01]  02   03   04  <05>  06   07
+1:  *08* [09]  10   11   12  <13>  14   15  *16*
+2:  [17]  18   19   20  <21>  22   23
+3:  *24* *25* [26]  27   28   29  <30>  31   32
+4:  *33* [34]  35   36   37  <38>  39   40
+5:  *41* [42]  43   44   45  <46>  47   48
+6:  *49* *50* [51]  52   53   54  <55>  56   57   58
+7:  [59]  60   61   62  <63>  64   65   66
+*****************************************************************************/
+
+/* we prefer positive expressions (do if condition) instead of negative
+ * (skip if condition), therefore use defines for skip instructions:
+ */
+#define ifioclr sbis
+#define ifioset sbic
+#define ifrclr  sbrs
+#define ifrset  sbrc
+
+/* The registers "fix" and "data" swap their meaning during the loop. Use
+ * defines to keep their name constant.
+ */
+#define fix     x2
+#define data    x1
+#undef phase        /* phase has a default definition to x4 */
+#define phase   x3
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt, r0
+    push    YL              ;2 push only what is necessary to sync with edge ASAP
+    in      YL, SREG        ;1
+    push    YL              ;2
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS ;[0]
+    rjmp    foundK          ;[1]
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+
+foundK:
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    YH                  ;[2]
+    lds     YL, usbInputBufOffset;[4]
+    clr     YH                  ;[6]
+    subi    YL, lo8(-(usbRxBuf));[7]
+    sbci    YH, hi8(-(usbRxBuf));[8]
+
+    sbis    USBIN, USBMINUS     ;[9] we want two bits K [we want to sample at 8 + 4 - 1.5 = 10.5]
+    rjmp    haveTwoBitsK        ;[10]
+    pop     YH                  ;[11] undo the push from before
+    rjmp    waitForK            ;[13] this was not the end of sync, retry
+haveTwoBitsK:
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+#define fix     x2
+#define data    x1
+
+    push    shift               ;[12]
+    push    x1                  ;[14]
+    push    x2                  ;[16]
+    ldi     shift, 0x80         ;[18] prevent bit-unstuffing but init low bits to 0
+    ifioset USBIN, USBMINUS     ;[19] [01] <--- bit 0 [10.5 + 8 = 18.5]
+    ori     shift, 1<<0         ;[02]
+    push    x3                  ;[03]
+    push    cnt                 ;[05]
+    push    r0                  ;[07]
+    ifioset USBIN, USBMINUS     ;[09] <--- bit 1
+    ori     shift, 1<<1         ;[10]
+    ser     fix                 ;[11]
+    ldi     cnt, USB_BUFSIZE    ;[12]
+    mov     data, shift         ;[13]
+    lsl     shift               ;[14]
+    nop2                        ;[15]
+    ifioset USBIN, USBMINUS     ;[17] <--- bit 2
+    ori     data, 3<<2          ;[18] store in bit 2 AND bit 3
+    eor     shift, data         ;[19] do nrzi decoding
+    andi    data, 1<<3          ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    brne    jumpToEntryAfterSet ;[22] if USBMINS at bit 3 was 1
+    nop                         ;[23]
+    rjmp    entryAfterClr       ;[24]
+jumpToEntryAfterSet:
+    rjmp    entryAfterSet       ;[24]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+#undef  fix
+#define  fix    x1
+#undef  data
+#define data    x2
+
+bit7IsSet:
+    ifrclr  phase, USBMINUS     ;[62] check phase only if D- changed
+    lpm                         ;[63]
+    in      phase, USBIN        ;[64] <- phase (one cycle too late)
+    ori     shift, 1 << 7       ;[65]
+    nop                         ;[66]
+;;;;rjmp    bit0AfterSet        ; -> [00] == [67] moved block up to save jump
+bit0AfterSet:
+    eor     fix, shift          ;[00]
+#undef  fix
+#define fix     x2
+#undef  data
+#define data    x1  /* we now have result in data, fix is reset to 0xff */
+    ifioclr USBIN, USBMINUS     ;[01] <--- sample 0
+    rjmp    bit0IsClr           ;[02]
+    andi    shift, ~(7 << 0)    ;[03]
+    breq    unstuff0s           ;[04]
+    in      phase, USBIN        ;[05] <- phase
+    rjmp    bit1AfterSet        ;[06]
+unstuff0s:
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    andi    fix, ~(1 << 0)      ;[07]
+    ifioclr USBIN, USBMINUS     ;[00]
+    ifioset USBIN, USBPLUS      ;[01]
+    rjmp    bit0IsClr           ;[02] executed if first expr false or second true
+se0AndStore:                    ; executed only if both bits 0
+    st      y+, x1              ;[15/17] cycles after start of byte
+    rjmp    se0                 ;[17/19]
+
+bit0IsClr:
+    ifrset  phase, USBMINUS     ;[04] check phase only if D- changed
+    lpm                         ;[05]
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    ori     shift, 1 << 0       ;[07]
+bit1AfterClr:
+    andi    phase, USBMASK      ;[08]
+    ifioset USBIN, USBMINUS     ;[09] <--- sample 1
+    rjmp    bit1IsSet           ;[10]
+    breq    se0AndStore         ;[11] if D- was 0 in bits 0 AND 1 and D+ was 0 in between, we have SE0
+    andi    shift, ~(7 << 1)    ;[12]
+    in      phase, USBIN        ;[13] <- phase
+    breq    unstuff1c           ;[14]
+    rjmp    bit2AfterClr        ;[15]
+unstuff1c:
+    andi    fix, ~(1 << 1)      ;[16]
+    nop2                        ;[08]
+    nop2                        ;[10]
+bit1IsSet:
+    ifrclr  phase, USBMINUS     ;[12] check phase only if D- changed
+    lpm                         ;[13]
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    ori     shift, 1 << 1       ;[15]
+    nop                         ;[16]
+bit2AfterSet:
+    ifioclr USBIN, USBMINUS     ;[17] <--- sample 2
+    rjmp    bit2IsClr           ;[18]
+    andi    shift, ~(7 << 2)    ;[19]
+    breq    unstuff2s           ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    rjmp    bit3AfterSet        ;[22]
+unstuff2s:
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    andi    fix, ~(1 << 2)      ;[23]
+    nop2                        ;[16]
+    nop2                        ;[18]
+bit2IsClr:
+    ifrset  phase, USBMINUS     ;[20] check phase only if D- changed
+    lpm                         ;[21]
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    ori     shift, 1 << 2       ;[23]
+bit3AfterClr:
+    st      y+, data            ;[24]
+entryAfterClr:
+    ifioset USBIN, USBMINUS     ;[26] <--- sample 3
+    rjmp    bit3IsSet           ;[27]
+    andi    shift, ~(7 << 3)    ;[28]
+    breq    unstuff3c           ;[29]
+    in      phase, USBIN        ;[30] <- phase
+    rjmp    bit4AfterClr        ;[31]
+unstuff3c:
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    andi    fix, ~(1 << 3)      ;[32]
+    nop2                        ;[25]
+    nop2                        ;[27]
+bit3IsSet:
+    ifrclr  phase, USBMINUS     ;[29] check phase only if D- changed
+    lpm                         ;[30]
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    ori     shift, 1 << 3       ;[32]
+bit4AfterSet:
+    mov     data, fix           ;[33] undo this move by swapping defines
+#undef  fix
+#define fix     x1
+#undef  data
+#define data    x2
+    ifioclr USBIN, USBMINUS     ;[34] <--- sample 4
+    rjmp    bit4IsClr           ;[35]
+    andi    shift, ~(7 << 4)    ;[36]
+    breq    unstuff4s           ;[37]
+    in      phase, USBIN        ;[38] <- phase
+    rjmp    bit5AfterSet        ;[39]
+unstuff4s:
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    andi    fix, ~(1 << 4)      ;[40]
+    nop2                        ;[33]
+    nop2                        ;[35]
+bit4IsClr:
+    ifrset  phase, USBMINUS     ;[37] check phase only if D- changed
+    lpm                         ;[38]
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    ori     shift, 1 << 4       ;[40]
+bit5AfterClr:
+    ser     data                ;[41]
+    ifioset USBIN, USBMINUS     ;[42] <--- sample 5
+    rjmp    bit5IsSet           ;[43]
+    andi    shift, ~(7 << 5)    ;[44]
+    breq    unstuff5c           ;[45]
+    in      phase, USBIN        ;[46] <- phase
+    rjmp    bit6AfterClr        ;[47]
+unstuff5c:
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    andi    fix, ~(1 << 5)      ;[48]
+    nop2                        ;[41]
+    nop2                        ;[43]
+bit5IsSet:
+    ifrclr  phase, USBMINUS     ;[45] check phase only if D- changed
+    lpm                         ;[46]
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    ori     shift, 1 << 5       ;[48]
+bit6AfterSet:
+    subi    cnt, 1              ;[49]
+    brcs    jumpToOverflow      ;[50]
+    ifioclr USBIN, USBMINUS     ;[51] <--- sample 6
+    rjmp    bit6IsClr           ;[52]
+    andi    shift, ~(3 << 6)    ;[53]
+    cpi     shift, 2            ;[54]
+    in      phase, USBIN        ;[55] <- phase
+    brlt    unstuff6s           ;[56]
+    rjmp    bit7AfterSet        ;[57]
+
+jumpToOverflow:
+    rjmp    overflow
+
+unstuff6s:
+    andi    fix, ~(1 << 6)      ;[50]
+    lpm                         ;[51]
+bit6IsClr:
+    ifrset  phase, USBMINUS     ;[54] check phase only if D- changed
+    lpm                         ;[55]
+    in      phase, USBIN        ;[56] <- phase (one cycle too late)
+    ori     shift, 1 << 6       ;[57]
+    nop                         ;[58]
+bit7AfterClr:
+    ifioset USBIN, USBMINUS     ;[59] <--- sample 7
+    rjmp    bit7IsSet           ;[60]
+    andi    shift, ~(1 << 7)    ;[61]
+    cpi     shift, 4            ;[62]
+    in      phase, USBIN        ;[63] <- phase
+    brlt    unstuff7c           ;[64]
+    rjmp    bit0AfterClr        ;[65] -> [00] == [67]
+unstuff7c:
+    andi    fix, ~(1 << 7)      ;[58]
+    nop                         ;[59]
+    rjmp    bit7IsSet           ;[60]
+
+bit7IsClr:
+    ifrset  phase, USBMINUS     ;[62] check phase only if D- changed
+    lpm                         ;[63]
+    in      phase, USBIN        ;[64] <- phase (one cycle too late)
+    ori     shift, 1 << 7       ;[65]
+    nop                         ;[66]
+;;;;rjmp    bit0AfterClr        ; -> [00] == [67] moved block up to save jump
+bit0AfterClr:
+    eor     fix, shift          ;[00]
+#undef  fix
+#define fix     x2
+#undef  data
+#define data    x1  /* we now have result in data, fix is reset to 0xff */
+    ifioset USBIN, USBMINUS     ;[01] <--- sample 0
+    rjmp    bit0IsSet           ;[02]
+    andi    shift, ~(7 << 0)    ;[03]
+    breq    unstuff0c           ;[04]
+    in      phase, USBIN        ;[05] <- phase
+    rjmp    bit1AfterClr        ;[06]
+unstuff0c:
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    andi    fix, ~(1 << 0)      ;[07]
+    ifioclr USBIN, USBMINUS     ;[00]
+    ifioset USBIN, USBPLUS      ;[01]
+    rjmp    bit0IsSet           ;[02] executed if first expr false or second true
+    rjmp    se0AndStore         ;[03] executed only if both bits 0
+bit0IsSet:
+    ifrclr  phase, USBMINUS     ;[04] check phase only if D- changed
+    lpm                         ;[05]
+    in      phase, USBIN        ;[06] <- phase (one cycle too late)
+    ori     shift, 1 << 0       ;[07]
+bit1AfterSet:
+    andi    shift, ~(7 << 1)    ;[08] compensated by "ori shift, 1<<1" if bit1IsClr
+    ifioclr USBIN, USBMINUS     ;[09] <--- sample 1
+    rjmp    bit1IsClr           ;[10]
+    breq    unstuff1s           ;[11]
+    nop2                        ;[12] do not check for SE0 if bit 0 was 1
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    rjmp    bit2AfterSet        ;[15]
+unstuff1s:
+    in      phase, USBIN        ;[13] <- phase
+    andi    fix, ~(1 << 1)      ;[14]
+    lpm                         ;[07]
+    nop2                        ;[10]
+bit1IsClr:
+    ifrset  phase, USBMINUS     ;[12] check phase only if D- changed
+    lpm                         ;[13]
+    in      phase, USBIN        ;[14] <- phase (one cycle too late)
+    ori     shift, 1 << 1       ;[15]
+    nop                         ;[16]
+bit2AfterClr:
+    ifioset USBIN, USBMINUS     ;[17] <--- sample 2
+    rjmp    bit2IsSet           ;[18]
+    andi    shift, ~(7 << 2)    ;[19]
+    breq    unstuff2c           ;[20]
+    in      phase, USBIN        ;[21] <- phase
+    rjmp    bit3AfterClr        ;[22]
+unstuff2c:
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    andi    fix, ~(1 << 2)      ;[23]
+    nop2                        ;[16]
+    nop2                        ;[18]
+bit2IsSet:
+    ifrclr  phase, USBMINUS     ;[20] check phase only if D- changed
+    lpm                         ;[21]
+    in      phase, USBIN        ;[22] <- phase (one cycle too late)
+    ori     shift, 1 << 2       ;[23]
+bit3AfterSet:
+    st      y+, data            ;[24]
+entryAfterSet:
+    ifioclr USBIN, USBMINUS     ;[26] <--- sample 3
+    rjmp    bit3IsClr           ;[27]
+    andi    shift, ~(7 << 3)    ;[28]
+    breq    unstuff3s           ;[29]
+    in      phase, USBIN        ;[30] <- phase
+    rjmp    bit4AfterSet        ;[31]
+unstuff3s:
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    andi    fix, ~(1 << 3)      ;[32]
+    nop2                        ;[25]
+    nop2                        ;[27]
+bit3IsClr:
+    ifrset  phase, USBMINUS     ;[29] check phase only if D- changed
+    lpm                         ;[30]
+    in      phase, USBIN        ;[31] <- phase (one cycle too late)
+    ori     shift, 1 << 3       ;[32]
+bit4AfterClr:
+    mov     data, fix           ;[33] undo this move by swapping defines
+#undef  fix
+#define fix     x1
+#undef  data
+#define data    x2
+    ifioset USBIN, USBMINUS     ;[34] <--- sample 4
+    rjmp    bit4IsSet           ;[35]
+    andi    shift, ~(7 << 4)    ;[36]
+    breq    unstuff4c           ;[37]
+    in      phase, USBIN        ;[38] <- phase
+    rjmp    bit5AfterClr        ;[39]
+unstuff4c:
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    andi    fix, ~(1 << 4)      ;[40]
+    nop2                        ;[33]
+    nop2                        ;[35]
+bit4IsSet:
+    ifrclr  phase, USBMINUS     ;[37] check phase only if D- changed
+    lpm                         ;[38]
+    in      phase, USBIN        ;[39] <- phase (one cycle too late)
+    ori     shift, 1 << 4       ;[40]
+bit5AfterSet:
+    ser     data                ;[41]
+    ifioclr USBIN, USBMINUS     ;[42] <--- sample 5
+    rjmp    bit5IsClr           ;[43]
+    andi    shift, ~(7 << 5)    ;[44]
+    breq    unstuff5s           ;[45]
+    in      phase, USBIN        ;[46] <- phase
+    rjmp    bit6AfterSet        ;[47]
+unstuff5s:
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    andi    fix, ~(1 << 5)      ;[48]
+    nop2                        ;[41]
+    nop2                        ;[43]
+bit5IsClr:
+    ifrset  phase, USBMINUS     ;[45] check phase only if D- changed
+    lpm                         ;[46]
+    in      phase, USBIN        ;[47] <- phase (one cycle too late)
+    ori     shift, 1 << 5       ;[48]
+bit6AfterClr:
+    subi    cnt, 1              ;[49]
+    brcs    overflow            ;[50]
+    ifioset USBIN, USBMINUS     ;[51] <--- sample 6
+    rjmp    bit6IsSet           ;[52]
+    andi    shift, ~(3 << 6)    ;[53]
+    cpi     shift, 2            ;[54]
+    in      phase, USBIN        ;[55] <- phase
+    brlt    unstuff6c           ;[56]
+    rjmp    bit7AfterClr        ;[57]
+unstuff6c:
+    andi    fix, ~(1 << 6)      ;[50]
+    lpm                         ;[51]
+bit6IsSet:
+    ifrclr  phase, USBMINUS     ;[54] check phase only if D- changed
+    lpm                         ;[55]
+    in      phase, USBIN        ;[56] <- phase (one cycle too late)
+    ori     shift, 1 << 6       ;[57]
+bit7AfterSet:
+    ifioclr USBIN, USBMINUS     ;[59] <--- sample 7
+    rjmp    bit7IsClr           ;[60]
+    andi    shift, ~(1 << 7)    ;[61]
+    cpi     shift, 4            ;[62]
+    in      phase, USBIN        ;[63] <- phase
+    brlt    unstuff7s           ;[64]
+    rjmp    bit0AfterSet        ;[65] -> [00] == [67]
+unstuff7s:
+    andi    fix, ~(1 << 7)      ;[58]
+    nop                         ;[59]
+    rjmp    bit7IsClr           ;[60]
+
+macro POP_STANDARD ; 14 cycles
+    pop     r0
+    pop     cnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;----------------------------------------------------------------------------
+; Transmitting data
+;----------------------------------------------------------------------------
+
+txByteLoop:
+txBitloop:
+stuffN1Delay:                   ;     [03]
+    ror     shift               ;[-5] [11] [63]
+    brcc    doExorN1            ;[-4]      [64]
+    subi    x3, 1               ;[-3]
+    brne    commonN1            ;[-2]
+    lsl     shift               ;[-1] compensate ror after rjmp stuffDelay
+    nop                         ;[00] stuffing consists of just waiting 8 cycles
+    rjmp    stuffN1Delay        ;[01] after ror, C bit is reliably clear
+
+sendNakAndReti:
+    ldi     cnt, USBPID_NAK ;[-19]
+    rjmp    sendCntAndReti  ;[-18]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     r0, cnt         ;[-16]
+    ldi     YL, 0           ;[-15] R0 address is 0
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
+; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
+; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte
+;uses: x1...x3, shift, cnt, Y [x1 = mirror USBOUT, x2 = USBMASK, x3 = bitstuff cnt]
+;Numbers in brackets are time since first bit of sync pattern is sent (start of instruction)
+usbSendAndReti:
+    in      x2, USBDDR          ;[-10] 10 cycles until SOP
+    ori     x2, USBMASK         ;[-9]
+    sbi     USBOUT, USBMINUS    ;[-8] prepare idle state; D+ and D- must have been 0 (no pullups)
+    out     USBDDR, x2          ;[-6] <--- acquire bus
+    in      x1, USBOUT          ;[-5] port mirror for tx loop
+    ldi     shift, 0x40         ;[-4] sync byte is first byte sent (we enter loop after ror)
+    ldi     x2, USBMASK         ;[-3]
+doExorN1:
+    eor     x1, x2              ;[-2] [06] [62]
+    ldi     x3, 6               ;[-1] [07] [63]
+commonN1:
+stuffN2Delay:
+    out     USBOUT, x1          ;[00] [08] [64] <--- set bit
+    ror     shift               ;[01]
+    brcc    doExorN2            ;[02]
+    subi    x3, 1               ;[03]
+    brne    commonN2            ;[04]
+    lsl     shift               ;[05] compensate ror after rjmp stuffDelay
+    rjmp    stuffN2Delay        ;[06] after ror, C bit is reliably clear
+doExorN2:
+    eor     x1, x2              ;[04] [12]
+    ldi     x3, 6               ;[05] [13]
+commonN2:
+    nop2                        ;[06] [14]
+    subi    cnt, 171            ;[08] [16] trick: (3 * 171) & 0xff = 1
+    out     USBOUT, x1          ;[09] [17] <--- set bit
+    brcs    txBitloop           ;[10]      [27] [44]
+
+stuff6Delay:
+    ror     shift               ;[45] [53]
+    brcc    doExor6             ;[46]
+    subi    x3, 1               ;[47]
+    brne    common6             ;[48]
+    lsl     shift               ;[49] compensate ror after rjmp stuffDelay
+    nop                         ;[50] stuffing consists of just waiting 8 cycles
+    rjmp    stuff6Delay         ;[51] after ror, C bit is reliably clear
+doExor6:
+    eor     x1, x2              ;[48] [56]
+    ldi     x3, 6               ;[49]
+common6:
+stuff7Delay:
+    ror     shift               ;[50] [58]
+    out     USBOUT, x1          ;[51] <--- set bit
+    brcc    doExor7             ;[52]
+    subi    x3, 1               ;[53]
+    brne    common7             ;[54]
+    lsl     shift               ;[55] compensate ror after rjmp stuffDelay
+    rjmp    stuff7Delay         ;[56] after ror, C bit is reliably clear
+doExor7:
+    eor     x1, x2              ;[54] [62]
+    ldi     x3, 6               ;[55]
+common7:
+    ld      shift, y+           ;[56]
+    nop                         ;[58]
+    tst     cnt                 ;[59]
+    out     USBOUT, x1          ;[60] [00]<--- set bit
+    brne    txByteLoop          ;[61] [01]
+;make SE0:
+    cbr     x1, USBMASK         ;[02] prepare SE0 [spec says EOP may be 15 to 18 cycles]
+    lds     x2, usbNewDeviceAddr;[03]
+    lsl     x2                  ;[05] we compare with left shifted address
+    subi    YL, 2 + 0           ;[06] Only assign address on data packets, not ACK/NAK in r0
+    sbci    YH, 0               ;[07]
+    out     USBOUT, x1          ;[00] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign      ;[01]
+    sts     usbDeviceAddr, x2   ; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[03] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)       ;[04]
+    ori     x1, USBIDLE         ;[05]
+    in      x2, USBDDR          ;[06]
+    cbr     x2, USBMASK         ;[07] set both pins to input
+    mov     x3, x1              ;[08]
+    cbr     x3, USBMASK         ;[09] configure no pullup on both pins
+    lpm                         ;[10]
+    lpm                         ;[13]
+    out     USBOUT, x1          ;[16] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2          ;[17] <-- release bus now
+    out     USBOUT, x3          ;[18] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
+
+
+/*****************************************************************************
+The following PHP script generates a code skeleton for the receiver routine:
+
+<?php
+
+function printCmdBuffer($thisBit)
+{
+global $cycle;
+
+    $nextBit = ($thisBit + 1) % 8;
+    $s = ob_get_contents();
+    ob_end_clean();
+    $s = str_replace("#", $thisBit, $s);
+    $s = str_replace("@", $nextBit, $s);
+    $lines = explode("\n", $s);
+    for($i = 0; $i < count($lines); $i++){
+        $s = $lines[$i];
+        if(ereg("\\[([0-9-][0-9])\\]", $s, $regs)){
+            $c = $cycle + (int)$regs[1];
+            $s = ereg_replace("\\[[0-9-][0-9]\\]", sprintf("[%02d]", $c), $s);
+        }
+        if(strlen($s) > 0)
+            echo "$s\n";
+    }
+}
+
+function printBit($isAfterSet, $bitNum)
+{
+    ob_start();
+    if($isAfterSet){
+?>
+    ifioclr USBIN, USBMINUS     ;[00] <--- sample
+    rjmp    bit#IsClr           ;[01]
+    andi    shift, ~(7 << #)    ;[02]
+    breq    unstuff#s           ;[03]
+    in      phase, USBIN        ;[04] <- phase
+    rjmp    bit@AfterSet        ;[05]
+unstuff#s:
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    andi    fix, ~(1 << #)      ;[06]
+    nop2                        ;[-1]
+    nop2                        ;[01]
+bit#IsClr:
+    ifrset  phase, USBMINUS     ;[03] check phase only if D- changed
+    lpm                         ;[04]
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    ori     shift, 1 << #       ;[06]
+<?php
+    }else{
+?>
+    ifioset USBIN, USBMINUS     ;[00] <--- sample
+    rjmp    bit#IsSet           ;[01]
+    andi    shift, ~(7 << #)    ;[02]
+    breq    unstuff#c           ;[03]
+    in      phase, USBIN        ;[04] <- phase
+    rjmp    bit@AfterClr        ;[05]
+unstuff#c:
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    andi    fix, ~(1 << #)      ;[06]
+    nop2                        ;[-1]
+    nop2                        ;[01]
+bit#IsSet:
+    ifrclr  phase, USBMINUS     ;[03] check phase only if D- changed
+    lpm                         ;[04]
+    in      phase, USBIN        ;[05] <- phase (one cycle too late)
+    ori     shift, 1 << #       ;[06]
+<?php
+    }
+    printCmdBuffer($bitNum);
+}
+
+$bitStartCycles = array(1, 9, 17, 26, 34, 42, 51, 59);
+for($i = 0; $i < 16; $i++){
+    $bit = $i % 8;
+    $emitClrCode = ($i + (int)($i / 8)) % 2;
+    $cycle = $bitStartCycles[$bit];
+    if($emitClrCode){
+        printf("bit%dAfterClr:\n", $bit);
+    }else{
+        printf("bit%dAfterSet:\n", $bit);
+    }
+    ob_start();
+    echo "    *****                       ;[-1]\n";
+    printCmdBuffer($bit);
+    printBit(!$emitClrCode, $bit);
+    if($i == 7)
+        echo "\n";
+}
+
+?>
+*****************************************************************************/
Index: vusb-20121206/usbdrv/usbdrvasm15.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm15.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm15.inc	(working copy)
@@ -0,0 +1,422 @@
+/* Name: usbdrvasm15.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: contributed by V. Bosch
+ * Creation Date: 2007-08-06
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 15 MHz version of the asssembler part of the USB driver. It
+requires a 15 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 15 MHz -> 10.0 cycles per bit, 80.0 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+;----------------------------------------------------------------------------
+; order of registers pushed: 
+;	YL, SREG [sofError] YH, shift, x1, x2, x3, bitcnt, cnt, x4
+;----------------------------------------------------------------------------
+USB_INTR_VECTOR:              
+    push    YL                   ;2 	push only what is necessary to sync with edge ASAP
+    in      YL, SREG             ;1 
+    push    YL                   ;2 
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;
+;   sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;   sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+;-------------------------------------------------------------------------------
+; The following code results in a sampling window of < 1/4 bit 
+;	which meets the spec.
+;-------------------------------------------------------------------------------
+waitForK:			 ;- 
+    sbis    USBIN, USBMINUS      ;1 [00] <-- sample
+    rjmp    foundK               ;2 [01]
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+    sbis    USBIN, USBMINUS	 ;	 <-- sample
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+;------------------------------------------------------------------------------
+; {3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for 
+;	center sampling] 
+; 	we have 1 bit time for setup purposes, then sample again. 
+;	Numbers in brackets are cycles from center of first sync (double K) 
+;	bit after the instruction
+;------------------------------------------------------------------------------
+foundK:                          ;- [02]
+    lds     YL, usbInputBufOffset;2 [03+04]	tx loop
+    push    YH                   ;2 [05+06]
+    clr     YH                   ;1 [07]
+    subi    YL, lo8(-(usbRxBuf)) ;1 [08] 	[rx loop init]
+    sbci    YH, hi8(-(usbRxBuf)) ;1 [09] 	[rx loop init]
+    push    shift                ;2 [10+11]
+    ser	    shift		 ;1 [12]
+    sbis    USBIN, USBMINUS      ;1 [-1] [13] <--sample:we want two bits K (sample 1 cycle too early)
+    rjmp    haveTwoBitsK         ;2 [00] [14]
+    pop     shift                ;2 	 [15+16] undo the push from before
+    pop     YH 			 ;2 	 [17+18] undo the push from before
+    rjmp    waitForK             ;2 	 [19+20] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 20 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:			;- [01]
+    push    x1              	;2 [02+03]
+    push    x2              	;2 [04+05]
+    push    x3              	;2 [06+07]
+    push    bitcnt              ;2 [08+09]	
+    in      x1, USBIN       	;1 [00] [10] <-- sample bit 0
+    bst     x1, USBMINUS    	;1 [01]
+    bld     shift, 0        	;1 [02]
+    push    cnt             	;2 [03+04]
+    ldi     cnt, USB_BUFSIZE	;1 [05] 
+    push    x4              	;2 [06+07] tx loop
+    rjmp    rxLoop          	;2 [08]
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+unstuff0:               	;- [07] (branch taken)
+    andi    x3, ~0x01   	;1 [08]
+    mov     x1, x2      	;1 [09] x2 contains last sampled (stuffed) bit
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 1 again
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 1 
+    ori     shift, 0x01 	;1 [03] 0b00000001
+    nop				;1 [04]
+    rjmp    didUnstuff0 	;2 [05]
+;-----------------------------------------------------
+unstuff1:               	;- [05] (branch taken)
+    mov     x2, x1      	;1 [06] x1 contains last sampled (stuffed) bit
+    andi    x3, ~0x02   	;1 [07]
+    ori     shift, 0x02 	;1 [08] 0b00000010
+    nop                 	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 2 again
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 2 
+    rjmp    didUnstuff1 	;2 [03]
+;-----------------------------------------------------
+unstuff2:               	;- [05] (branch taken)
+    andi    x3, ~0x04   	;1 [06]
+    ori     shift, 0x04 	;1 [07] 0b00000100
+    mov     x1, x2      	;1 [08] x2 contains last sampled (stuffed) bit
+    nop                 	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 3
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 3 
+    rjmp    didUnstuff2 	;2 [03]
+;-----------------------------------------------------
+unstuff3:               	;- [00] [10]  (branch taken)
+    in      x2, USBIN   	;1 [01] [11] <-- sample stuffed bit 3 one cycle too late
+    andi    x2, USBMASK 	;1 [02]
+    breq    se0Hop         	;1 [03] SE0 check for stuffed bit 3 
+    andi    x3, ~0x08   	;1 [04]
+    ori     shift, 0x08 	;1 [05] 0b00001000
+    rjmp    didUnstuff3 	;2 [06]
+;----------------------------------------------------------------------------
+; extra jobs done during bit interval:
+;
+; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs], 
+; 		overflow check, jump to the head of rxLoop
+; bit 1:    SE0 check
+; bit 2:    SE0 check, recovery from delay [bit 0 tasks took too long]
+; bit 3:    SE0 check, recovery from delay [bit 0 tasks took too long]
+; bit 4:    SE0 check, none
+; bit 5:    SE0 check, none
+; bit 6:    SE0 check, none
+; bit 7:    SE0 check, reconstruct: x3 is 0 at bit locations we changed, 1 at others
+;----------------------------------------------------------------------------
+rxLoop:				;- [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 1 (or possibly bit 0 stuffed)
+    andi    x2, USBMASK 	;1 [01]
+    brne    SkipSe0Hop		;1 [02]
+se0Hop:				;- [02]
+    rjmp    se0         	;2 [03] SE0 check for bit 1 
+SkipSe0Hop:			;- [03]
+    ser     x3          	;1 [04]
+    andi    shift, 0xf9 	;1 [05] 0b11111001
+    breq    unstuff0    	;1 [06]
+didUnstuff0:			;- [06]
+    eor     x1, x2      	;1 [07]
+    bst     x1, USBMINUS	;1 [08]
+    bld     shift, 1    	;1 [09] 
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 2 (or possibly bit 1 stuffed)
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 2 
+    andi    shift, 0xf3 	;1 [03] 0b11110011
+    breq    unstuff1    	;1 [04] do remaining work for bit 1
+didUnstuff1:			;- [04]
+    eor     x2, x1      	;1 [05]
+    bst     x2, USBMINUS	;1 [06]
+    bld     shift, 2    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 3 (or possibly bit 2 stuffed)
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 3 
+    andi    shift, 0xe7 	;1 [03] 0b11100111
+    breq    unstuff2    	;1 [04]
+didUnstuff2:			;- [04]
+    eor     x1, x2      	;1 [05]
+    bst     x1, USBMINUS	;1 [06]
+    bld     shift, 3    	;1 [07]
+didUnstuff3:			;- [07]
+    andi    shift, 0xcf 	;1 [08] 0b11001111
+    breq    unstuff3    	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 4
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0Hop         	;1 [02] SE0 check for bit 4
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 4    	;1 [05]
+didUnstuff4:			;- [05]
+    andi    shift, 0x9f 	;1 [06] 0b10011111
+    breq    unstuff4    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 5
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 5
+    eor     x1, x2      	;1 [03]
+    bst     x1, USBMINUS	;1 [04]
+    bld     shift, 5    	;1 [05]
+didUnstuff5:			;- [05]
+    andi    shift, 0x3f 	;1 [06] 0b00111111
+    breq    unstuff5    	;1 [07]
+    nop2			;2 [08+09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample bit 6
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 6
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 6   	 	;1 [05]
+didUnstuff6:			;- [05]
+    cpi     shift, 0x02 	;1 [06] 0b00000010
+    brlo    unstuff6    	;1 [07]
+    nop2			;2 [08+09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample bit 7
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for bit 7
+    eor     x1, x2      	;1 [03]
+    bst     x1, USBMINUS	;1 [04]
+    bld     shift, 7    	;1 [05]
+didUnstuff7:			;- [05] 
+    cpi     shift, 0x04 	;1 [06] 0b00000100
+    brlo    unstuff7		;1 [07]
+    eor     x3, shift   	;1 [08] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    nop				;1 [09]
+    in      x1, USBIN   	;1 [00]	[10] <-- sample bit 0
+    st      y+, x3      	;2 [01+02] store data
+    eor     x2, x1      	;1 [03]
+    bst     x2, USBMINUS	;1 [04]
+    bld     shift, 0    	;1 [05]
+    subi    cnt, 1		;1 [06]
+    brcs    overflow	;1 [07]
+    rjmp    rxLoop		;2 [08]
+;-----------------------------------------------------
+unstuff4:               	;- [08] 
+    andi    x3, ~0x10   	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample stuffed bit 4
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 4
+    ori     shift, 0x10 	;1 [03]
+    rjmp    didUnstuff4 	;2 [04]
+;-----------------------------------------------------
+unstuff5:               	;- [08] 
+    ori     shift, 0x20 	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample stuffed bit 5
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 5
+    andi    x3, ~0x20   	;1 [03]
+    rjmp    didUnstuff5		;2 [04]
+;-----------------------------------------------------
+unstuff6:               	;- [08] 
+    andi    x3, ~0x40   	;1 [09]
+    in      x1, USBIN   	;1 [00] [10] <-- sample stuffed bit 6
+    andi    x1, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 6
+    ori     shift, 0x40 	;1 [03]
+    rjmp    didUnstuff6 	;2 [04]
+;-----------------------------------------------------
+unstuff7:			;- [08]
+    andi    x3, ~0x80   	;1 [09]
+    in      x2, USBIN   	;1 [00] [10] <-- sample stuffed bit 7
+    andi    x2, USBMASK 	;1 [01]
+    breq    se0         	;1 [02] SE0 check for stuffed bit 7
+    ori     shift, 0x80 	;1 [03]
+    rjmp    didUnstuff7 	;2 [04]
+    
+macro POP_STANDARD ; 16 cycles
+    pop     x4    
+    pop     cnt
+    pop     bitcnt
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+;---------------------------------------------------------------------------
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+;---------------------------------------------------------------------------
+bitstuffN:		    	;- [04]
+    eor     x1, x4          	;1 [05]
+    clr	    x2			;1 [06]
+    nop				;1 [07]
+    rjmp    didStuffN       	;1 [08]
+;---------------------------------------------------------------------------    
+bitstuff6:		    	;- [04]
+    eor     x1, x4          	;1 [05]
+    clr	    x2			;1 [06]
+    rjmp    didStuff6       	;1 [07]
+;---------------------------------------------------------------------------
+bitstuff7:		    	;- [02]
+    eor     x1, x4          	;1 [03]
+    clr	    x2			;1 [06]
+    nop			    	;1 [05]
+    rjmp    didStuff7       	;1 [06]
+;---------------------------------------------------------------------------
+sendNakAndReti:			;- [-19]
+    ldi     x3, USBPID_NAK  	;1 [-18]
+    rjmp    sendX3AndReti   	;1 [-17]
+;---------------------------------------------------------------------------
+sendAckAndReti:			;- [-17]
+    ldi     cnt, USBPID_ACK 	;1 [-16]
+sendCntAndReti:			;- [-16]
+    mov     x3, cnt         	;1 [-15]
+sendX3AndReti:			;- [-15]
+    ldi     YL, 20          	;1 [-14] x3==r20 address is 20
+    ldi     YH, 0           	;1 [-13]
+    ldi     cnt, 2          	;1 [-12]
+;   rjmp    usbSendAndReti      fallthrough
+;---------------------------------------------------------------------------
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We need not to match the transfer rate exactly because the spec demands 
+;only 1.5% precision anyway.
+usbSendAndReti:             	;- [-13] 13 cycles until SOP
+    in      x2, USBDDR      	;1 [-12]
+    ori     x2, USBMASK     	;1 [-11]
+    sbi     USBOUT, USBMINUS	;2 [-09-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      	;1 [-08] port mirror for tx loop
+    out     USBDDR, x2      	;1 [-07] <- acquire bus
+	; need not init x2 (bitstuff history) because sync starts with 0 
+    ldi     x4, USBMASK     	;1 [-06] 	exor mask
+    ldi     shift, 0x80     	;1 [-05] 	sync byte is first byte sent
+    ldi     bitcnt, 6    	;1 [-04] 
+txBitLoop:		    	;- [-04] [06]
+    sbrs    shift, 0        	;1 [-03] [07]
+    eor     x1, x4          	;1 [-02] [08] 
+    ror     shift           	;1 [-01] [09]  
+didStuffN:		    	;-       [09]
+    out     USBOUT, x1      	;1 [00]  [10] <-- out N
+    ror     x2              	;1 [01]
+    cpi     x2, 0xfc        	;1 [02]
+    brcc    bitstuffN       	;1 [03]
+    dec     bitcnt          	;1 [04]
+    brne    txBitLoop       	;1 [05]
+    sbrs    shift, 0        	;1 [06]
+    eor     x1, x4          	;1 [07]
+    ror     shift           	;1 [08]
+didStuff6:			;- [08]
+    nop				;1 [09]
+    out     USBOUT, x1      	;1 [00] [10] <-- out 6
+    ror     x2              	;1 [01] 
+    cpi     x2, 0xfc        	;1 [02]
+    brcc    bitstuff6       	;1 [03]
+    sbrs    shift, 0        	;1 [04]
+    eor     x1, x4          	;1 [05]
+    ror     shift           	;1 [06]
+    ror     x2              	;1 [07]
+didStuff7:			;- [07]
+    ldi     bitcnt, 6    	;1 [08]
+    cpi     x2, 0xfc        	;1 [09]
+    out     USBOUT, x1      	;1 [00] [10] <-- out 7
+    brcc    bitstuff7       	;1 [01]
+    ld      shift, y+       	;2 [02+03]
+    dec     cnt             	;1 [04]
+    brne    txBitLoop      	;1 [05]
+makeSE0:
+    cbr     x1, USBMASK     	;1 [06] 	prepare SE0 [spec says EOP may be 19 to 23 cycles]
+    lds     x2, usbNewDeviceAddr;2 [07+08]
+    lsl     x2                  ;1 [09] we compare with left shifted address
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    out     USBOUT, x1      	;1 [00] [10] <-- out SE0-- from now 2 bits==20 cycl. until bus idle
+    subi    YL, 20 + 2          ;1 [01] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           	;1 [02]
+    breq    skipAddrAssign  	;1 [03]
+    sts     usbDeviceAddr, x2	;2 [04+05] if not skipped: SE0 is one cycle longer
+;----------------------------------------------------------------------------
+;end of usbDeviceAddress transfer
+skipAddrAssign:				;- [03/04]
+    ldi     x2, 1<<USB_INTR_PENDING_BIT	;1 [05] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)           ;1 [06]
+    ori     x1, USBIDLE     		;1 [07]
+    in      x2, USBDDR      		;1 [08]
+    cbr     x2, USBMASK     		;1 [09] set both pins to input
+    mov     x3, x1          		;1 [10]
+    cbr     x3, USBMASK     		;1 [11] configure no pullup on both pins
+    ldi     x4, 3           		;1 [12]
+se0Delay:				;- [12] [15] 
+    dec     x4              		;1 [13] [16] 
+    brne    se0Delay        		;1 [14] [17] 
+    nop2				;2      [18+19]
+    out     USBOUT, x1      		;1      [20] <--out J (idle) -- end of SE0 (EOP sig.)
+    out     USBDDR, x2      		;1      [21] <--release bus now
+    out     USBOUT, x3      		;1      [22] <--ensure no pull-up resistors are active
+    rjmp    doReturn			;1	[23]
+;---------------------------------------------------------------------------
Index: vusb-20121206/usbdrv/usbdrvasm16.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm16.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm16.inc	(working copy)
@@ -0,0 +1,345 @@
+/* Name: usbdrvasm16.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-06-15
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 16 MHz version of the asssembler part of the USB driver. It
+requires a 16 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 16 MHz -> 10.6666666 cycles per bit, 85.333333333 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-25] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-23]
+    push    YL                  ;[-22]
+    push    YH                  ;[-20]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-15]
+    rjmp    foundK              ;[-14]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-12]
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    bitcnt              ;[-12]
+;   [---]                       ;[-11]
+    lds     YL, usbInputBufOffset;[-10]
+;   [---]                       ;[-9]
+    clr     YH                  ;[-8]
+    subi    YL, lo8(-(usbRxBuf));[-7] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-6] [rx loop init]
+    push    shift               ;[-5]
+;   [---]                       ;[-4]
+    ldi     bitcnt, 0x55        ;[-3] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-2] we want two bits K (sample 2 cycles too early)
+    rjmp    haveTwoBitsK        ;[-1]
+    pop     shift               ;[0] undo the push from before
+    pop     bitcnt              ;[2] undo the push from before
+    rjmp    waitForK            ;[4] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 21 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1              ;[1]
+    push    x2              ;[3]
+    push    x3              ;[5]
+    ldi     shift, 0        ;[7]
+    ldi     x3, 1<<4        ;[8] [rx loop init] first sample is inverse bit, compensate that
+    push    x4              ;[9] == leap
+
+    in      x1, USBIN       ;[11] <-- sample bit 0
+    andi    x1, USBMASK     ;[12]
+    bst     x1, USBMINUS    ;[13]
+    bld     shift, 7        ;[14]
+    push    cnt             ;[15]
+    ldi     leap, 0         ;[17] [rx loop init]
+    ldi     cnt, USB_BUFSIZE;[18] [rx loop init]
+    rjmp    rxbit1          ;[19] arrives at [21]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+
+; duration of unstuffing code should be 10.66666667 cycles. We adjust "leap"
+; accordingly to approximate this value in the long run.
+
+unstuff6:
+    andi    x2, USBMASK ;[03]
+    ori     x3, 1<<6    ;[04] will not be shifted any more
+    andi    shift, ~0x80;[05]
+    mov     x1, x2      ;[06] sampled bit 7 is actually re-sampled bit 6
+    subi    leap, -1    ;[07] total duration = 11 bits -> subtract 1/3
+    rjmp    didUnstuff6 ;[08]
+
+unstuff7:
+    ori     x3, 1<<7    ;[09] will not be shifted any more
+    in      x2, USBIN   ;[00] [10]  re-sample bit 7
+    andi    x2, USBMASK ;[01]
+    andi    shift, ~0x80;[02]
+    subi    leap, 2     ;[03] total duration = 10 bits -> add 1/3
+    rjmp    didUnstuff7 ;[04]
+
+unstuffEven:
+    ori     x3, 1<<6    ;[09] will be shifted right 6 times for bit 0
+    in      x1, USBIN   ;[00] [10]
+    andi    shift, ~0x80;[01]
+    andi    x1, USBMASK ;[02]
+    breq    se0         ;[03]
+    subi    leap, -1    ;[04] total duration = 11 bits -> subtract 1/3
+    nop2                ;[05]
+    rjmp    didUnstuffE ;[06]
+
+unstuffOdd:
+    ori     x3, 1<<5    ;[09] will be shifted right 4 times for bit 1
+    in      x2, USBIN   ;[00] [10]
+    andi    shift, ~0x80;[01]
+    andi    x2, USBMASK ;[02]
+    breq    se0         ;[03]
+    subi    leap, -1    ;[04] total duration = 11 bits -> subtract 1/3
+    nop2                ;[05]
+    rjmp    didUnstuffO ;[06]
+
+rxByteLoop:
+    andi    x1, USBMASK ;[03]
+    eor     x2, x1      ;[04]
+    subi    leap, 1     ;[05]
+    brpl    skipLeap    ;[06]
+    subi    leap, -3    ;1 one leap cycle every 3rd byte -> 85 + 1/3 cycles per byte
+    nop                 ;1
+skipLeap:
+    subi    x2, 1       ;[08]
+    ror     shift       ;[09]
+didUnstuff6:
+    cpi     shift, 0xfc ;[10]
+    in      x2, USBIN   ;[00] [11] <-- sample bit 7
+    brcc    unstuff6    ;[01]
+    andi    x2, USBMASK ;[02]
+    eor     x1, x2      ;[03]
+    subi    x1, 1       ;[04]
+    ror     shift       ;[05]
+didUnstuff7:
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuff7    ;[07]
+    eor     x3, shift   ;[08] reconstruct: x3 is 1 at bit locations we changed, 0 at others
+    st      y+, x3      ;[09] store data
+rxBitLoop:
+    in      x1, USBIN   ;[00] [11] <-- sample bit 0/2/4
+    andi    x1, USBMASK ;[01]
+    eor     x2, x1      ;[02]
+    andi    x3, 0x3f    ;[03] topmost two bits reserved for 6 and 7
+    subi    x2, 1       ;[04]
+    ror     shift       ;[05]
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuffEven ;[07]
+didUnstuffE:
+    lsr     x3          ;[08]
+    lsr     x3          ;[09]
+rxbit1:
+    in      x2, USBIN   ;[00] [10] <-- sample bit 1/3/5
+    andi    x2, USBMASK ;[01]
+    breq    se0         ;[02]
+    eor     x1, x2      ;[03]
+    subi    x1, 1       ;[04]
+    ror     shift       ;[05]
+    cpi     shift, 0xfc ;[06]
+    brcc    unstuffOdd  ;[07]
+didUnstuffO:
+    subi    bitcnt, 0xab;[08] == addi 0x55, 0x55 = 0x100/3
+    brcs    rxBitLoop   ;[09]
+
+    subi    cnt, 1      ;[10]
+    in      x1, USBIN   ;[00] [11] <-- sample bit 6
+    brcc    rxByteLoop  ;[01]
+    rjmp    overflow
+
+macro POP_STANDARD ; 14 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     bitcnt
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+
+bitstuffN:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6]
+    nop2                    ;[7]
+    nop                     ;[9]
+    out     USBOUT, x1      ;[10] <-- out
+    rjmp    didStuffN       ;[0]
+    
+bitstuff6:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6] Carry is zero due to brcc
+    rol     shift           ;[7] compensate for ror shift at branch destination
+    rjmp    didStuff6       ;[8]
+
+bitstuff7:
+    ldi     x2, 0           ;[2] Carry is zero due to brcc
+    rjmp    didStuff7       ;[3]
+
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We don't match the transfer rate exactly (don't insert leap cycles every third
+;byte) because the spec demands only 1.5% precision anyway.
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x35    ;[-4] [6] binary 0011 0101
+txBitLoop:
+    sbrs    shift, 0        ;[-3] [7]
+    eor     x1, x4          ;[-2] [8]
+    out     USBOUT, x1      ;[-1] [9] <-- out N
+    ror     shift           ;[0] [10]
+    ror     x2              ;[1]
+didStuffN:
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuffN       ;[3]
+    lsr     bitcnt          ;[4]
+    brcc    txBitLoop       ;[5]
+    brne    txBitLoop       ;[6]
+
+    sbrs    shift, 0        ;[7]
+    eor     x1, x4          ;[8]
+didStuff6:
+    out     USBOUT, x1      ;[-1] [9] <-- out 6
+    ror     shift           ;[0] [10]
+    ror     x2              ;[1]
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuff6       ;[3]
+    ror     shift           ;[4]
+didStuff7:
+    ror     x2              ;[5]
+    sbrs    x2, 7           ;[6]
+    eor     x1, x4          ;[7]
+    nop                     ;[8]
+    cpi     x2, 0xfc        ;[9]
+    out     USBOUT, x1      ;[-1][10] <-- out 7
+    brcc    bitstuff7       ;[0] [11]
+    ld      shift, y+       ;[1]
+    dec     cnt             ;[3]
+    brne    txByteLoop      ;[4]
+;make SE0:
+    cbr     x1, USBMASK     ;[5] prepare SE0 [spec says EOP may be 21 to 25 cycles]
+    lds     x2, usbNewDeviceAddr;[6]
+    lsl     x2              ;[8] we compare with left shifted address
+    subi    YL, 20 + 2      ;[9] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[10]
+    out     USBOUT, x1      ;[11] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[0]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[2] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[3]
+    ori     x1, USBIDLE     ;[4]
+    in      x2, USBDDR      ;[5]
+    cbr     x2, USBMASK     ;[6] set both pins to input
+    mov     x3, x1          ;[7]
+    cbr     x3, USBMASK     ;[8] configure no pullup on both pins
+    ldi     x4, 4           ;[9]
+se0Delay:
+    dec     x4              ;[10] [13] [16] [19]
+    brne    se0Delay        ;[11] [14] [17] [20]
+    out     USBOUT, x1      ;[21] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[22] <-- release bus now
+    out     USBOUT, x3      ;[23] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: vusb-20121206/usbdrv/usbdrvasm165.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm165.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm165.inc	(working copy)
@@ -0,0 +1,452 @@
+/* Name: usbdrvasm165.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2007-04-22
+ * Tabsize: 4
+ * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 16.5 MHz version of the USB driver. It is intended for the
+ATTiny45 and similar controllers running on 16.5 MHz internal RC oscillator.
+This version contains a phase locked loop in the receiver routine to cope with
+slight clock rate deviations of up to +/- 1%.
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
+;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
+;max allowable interrupt latency: 59 cycles -> max 52 cycles interrupt disable
+;max stack usage: [ret(2), r0, SREG, YL, YH, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 16.5 MHz -> 11 cycles per bit
+; 16.3125 MHz < F_CPU < 16.6875 MHz (+/- 1.1%)
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG [sofError], r0, YH, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-23] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-21]
+    push    YL                  ;[-20]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-15]
+    rjmp    foundK              ;[-14]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-12]
+;{3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for center sampling]
+;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    r0                  ;[-12]
+;   [---]                       ;[-11]
+    push    YH                  ;[-10]
+;   [---]                       ;[-9]
+    lds     YL, usbInputBufOffset;[-8]
+;   [---]                       ;[-7]
+    clr     YH                  ;[-6]
+    subi    YL, lo8(-(usbRxBuf));[-5] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-4] [rx loop init]
+    mov     r0, x2              ;[-3] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-2] we want two bits K (sample 2 cycles too early)
+    rjmp    haveTwoBitsK        ;[-1]
+    pop     YH                  ;[0] undo the pushes from before
+    pop     r0                  ;[2]
+    rjmp    waitForK            ;[4] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 22 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:               ;[1]
+    push    shift           ;[1]
+    push    x1              ;[3]
+    push    x2              ;[5]
+    push    x3              ;[7]
+    ldi     shift, 0xff     ;[9] [rx loop init]
+    ori     x3, 0xff        ;[10] [rx loop init] == ser x3, clear zero flag
+
+    in      x1, USBIN       ;[11] <-- sample bit 0
+    bst     x1, USBMINUS    ;[12]
+    bld     shift, 0        ;[13]
+    push    x4              ;[14] == phase
+;   [---]                   ;[15]
+    push    cnt             ;[16]
+;   [---]                   ;[17]
+    ldi     phase, 0        ;[18] [rx loop init]
+    ldi     cnt, USB_BUFSIZE;[19] [rx loop init]
+    rjmp    rxbit1          ;[20]
+;   [---]                   ;[21]
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+/*
+byte oriented operations done during loop:
+bit 0: store data
+bit 1: SE0 check
+bit 2: overflow check
+bit 3: catch up
+bit 4: rjmp to achieve conditional jump range
+bit 5: PLL
+bit 6: catch up
+bit 7: jump, fixup bitstuff
+; 87 [+ 2] cycles
+------------------------------------------------------------------
+*/
+continueWithBit5:
+    in      x2, USBIN       ;[055] <-- bit 5
+    eor     r0, x2          ;[056]
+    or      phase, r0       ;[057]
+    sbrc    phase, USBMINUS ;[058]
+    lpm                     ;[059] optional nop3; modifies r0
+    in      phase, USBIN    ;[060] <-- phase
+    eor     x1, x2          ;[061]
+    bst     x1, USBMINUS    ;[062]
+    bld     shift, 5        ;[063]
+    andi    shift, 0x3f     ;[064]
+    in      x1, USBIN       ;[065] <-- bit 6
+    breq    unstuff5        ;[066] *** unstuff escape
+    eor     phase, x1       ;[067]
+    eor     x2, x1          ;[068]
+    bst     x2, USBMINUS    ;[069]
+    bld     shift, 6        ;[070]
+didUnstuff6:                ;[   ]
+    in      r0, USBIN       ;[071] <-- phase
+    cpi     shift, 0x02     ;[072]
+    brlo    unstuff6        ;[073] *** unstuff escape
+didUnstuff5:                ;[   ]
+    nop2                    ;[074]
+;   [---]                   ;[075]
+    in      x2, USBIN       ;[076] <-- bit 7
+    eor     x1, x2          ;[077]
+    bst     x1, USBMINUS    ;[078]
+    bld     shift, 7        ;[079]
+didUnstuff7:                ;[   ]
+    eor     r0, x2          ;[080]
+    or      phase, r0       ;[081]
+    in      r0, USBIN       ;[082] <-- phase
+    cpi     shift, 0x04     ;[083]
+    brsh    rxLoop          ;[084]
+;   [---]                   ;[085]
+unstuff7:                   ;[   ]
+    andi    x3, ~0x80       ;[085]
+    ori     shift, 0x80     ;[086]
+    in      x2, USBIN       ;[087] <-- sample stuffed bit 7
+    nop                     ;[088]
+    rjmp    didUnstuff7     ;[089]
+;   [---]                   ;[090]
+                            ;[080]
+
+unstuff5:                   ;[067]
+    eor     phase, x1       ;[068]
+    andi    x3, ~0x20       ;[069]
+    ori     shift, 0x20     ;[070]
+    in      r0, USBIN       ;[071] <-- phase
+    mov     x2, x1          ;[072]
+    nop                     ;[073]
+    nop2                    ;[074]
+;   [---]                   ;[075]
+    in      x1, USBIN       ;[076] <-- bit 6
+    eor     r0, x1          ;[077]
+    or      phase, r0       ;[078]
+    eor     x2, x1          ;[079]
+    bst     x2, USBMINUS    ;[080]
+    bld     shift, 6        ;[081] no need to check bitstuffing, we just had one
+    in      r0, USBIN       ;[082] <-- phase
+    rjmp    didUnstuff5     ;[083]
+;   [---]                   ;[084]
+                            ;[074]
+
+unstuff6:                   ;[074]
+    andi    x3, ~0x40       ;[075]
+    in      x1, USBIN       ;[076] <-- bit 6 again
+    ori     shift, 0x40     ;[077]
+    nop2                    ;[078]
+;   [---]                   ;[079]
+    rjmp    didUnstuff6     ;[080]
+;   [---]                   ;[081]
+                            ;[071]
+
+unstuff0:                   ;[013]
+    eor     r0, x2          ;[014]
+    or      phase, r0       ;[015]
+    andi    x2, USBMASK     ;[016] check for SE0
+    in      r0, USBIN       ;[017] <-- phase
+    breq    didUnstuff0     ;[018] direct jump to se0 would be too long
+    andi    x3, ~0x01       ;[019]
+    ori     shift, 0x01     ;[020]
+    mov     x1, x2          ;[021] mov existing sample
+    in      x2, USBIN       ;[022] <-- bit 1 again
+    rjmp    didUnstuff0     ;[023]
+;   [---]                   ;[024]
+                            ;[014]
+
+unstuff1:                   ;[024]
+    eor     r0, x1          ;[025]
+    or      phase, r0       ;[026]
+    andi    x3, ~0x02       ;[027]
+    in      r0, USBIN       ;[028] <-- phase
+    ori     shift, 0x02     ;[029]
+    mov     x2, x1          ;[030]
+    rjmp    didUnstuff1     ;[031]
+;   [---]                   ;[032]
+                            ;[022]
+
+unstuff2:                   ;[035]
+    eor     r0, x2          ;[036]
+    or      phase, r0       ;[037]
+    andi    x3, ~0x04       ;[038]
+    in      r0, USBIN       ;[039] <-- phase
+    ori     shift, 0x04     ;[040]
+    mov     x1, x2          ;[041]
+    rjmp    didUnstuff2     ;[042]
+;   [---]                   ;[043]
+                            ;[033]
+
+unstuff3:                   ;[043]
+    in      x2, USBIN       ;[044] <-- bit 3 again
+    eor     r0, x2          ;[045]
+    or      phase, r0       ;[046]
+    andi    x3, ~0x08       ;[047]
+    ori     shift, 0x08     ;[048]
+    nop                     ;[049]
+    in      r0, USBIN       ;[050] <-- phase
+    rjmp    didUnstuff3     ;[051]
+;   [---]                   ;[052]
+                            ;[042]
+
+unstuff4:                   ;[053]
+    andi    x3, ~0x10       ;[054]
+    in      x1, USBIN       ;[055] <-- bit 4 again
+    ori     shift, 0x10     ;[056]
+    rjmp    didUnstuff4     ;[057]
+;   [---]                   ;[058]
+                            ;[048]
+
+rxLoop:                     ;[085]
+    eor     x3, shift       ;[086] reconstruct: x3 is 0 at bit locations we changed, 1 at others
+    in      x1, USBIN       ;[000] <-- bit 0
+    st      y+, x3          ;[001]
+;   [---]                   ;[002]
+    eor     r0, x1          ;[003]
+    or      phase, r0       ;[004]
+    eor     x2, x1          ;[005]
+    in      r0, USBIN       ;[006] <-- phase
+    ser     x3              ;[007]
+    bst     x2, USBMINUS    ;[008]
+    bld     shift, 0        ;[009]
+    andi    shift, 0xf9     ;[010]
+rxbit1:                     ;[   ]
+    in      x2, USBIN       ;[011] <-- bit 1
+    breq    unstuff0        ;[012] *** unstuff escape
+    andi    x2, USBMASK     ;[013] SE0 check for bit 1
+didUnstuff0:                ;[   ] Z only set if we detected SE0 in bitstuff
+    breq    se0             ;[014]
+    eor     r0, x2          ;[015]
+    or      phase, r0       ;[016]
+    in      r0, USBIN       ;[017] <-- phase
+    eor     x1, x2          ;[018]
+    bst     x1, USBMINUS    ;[019]
+    bld     shift, 1        ;[020]
+    andi    shift, 0xf3     ;[021]
+didUnstuff1:                ;[   ]
+    in      x1, USBIN       ;[022] <-- bit 2
+    breq    unstuff1        ;[023] *** unstuff escape
+    eor     r0, x1          ;[024]
+    or      phase, r0       ;[025]
+    subi    cnt, 1          ;[026] overflow check
+    brcs    overflow        ;[027]
+    in      r0, USBIN       ;[028] <-- phase
+    eor     x2, x1          ;[029]
+    bst     x2, USBMINUS    ;[030]
+    bld     shift, 2        ;[031]
+    andi    shift, 0xe7     ;[032]
+didUnstuff2:                ;[   ]
+    in      x2, USBIN       ;[033] <-- bit 3
+    breq    unstuff2        ;[034] *** unstuff escape
+    eor     r0, x2          ;[035]
+    or      phase, r0       ;[036]
+    eor     x1, x2          ;[037]
+    bst     x1, USBMINUS    ;[038]
+    in      r0, USBIN       ;[039] <-- phase
+    bld     shift, 3        ;[040]
+    andi    shift, 0xcf     ;[041]
+didUnstuff3:                ;[   ]
+    breq    unstuff3        ;[042] *** unstuff escape
+    nop                     ;[043]
+    in      x1, USBIN       ;[044] <-- bit 4
+    eor     x2, x1          ;[045]
+    bst     x2, USBMINUS    ;[046]
+    bld     shift, 4        ;[047]
+didUnstuff4:                ;[   ]
+    eor     r0, x1          ;[048]
+    or      phase, r0       ;[049]
+    in      r0, USBIN       ;[050] <-- phase
+    andi    shift, 0x9f     ;[051]
+    breq    unstuff4        ;[052] *** unstuff escape
+    rjmp    continueWithBit5;[053]
+;   [---]                   ;[054]
+
+macro POP_STANDARD ; 16 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     YH
+    pop     r0
+    endm
+macro POP_RETI     ; 5 cycles
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+#include "asmcommon.inc"
+
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+
+bitstuff7:
+    eor     x1, x4          ;[4]
+    ldi     x2, 0           ;[5]
+    nop2                    ;[6] C is zero (brcc)
+    rjmp    didStuff7       ;[8]
+
+bitstuffN:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6]
+    lpm                     ;[7] 3 cycle NOP, modifies r0
+    out     USBOUT, x1      ;[10] <-- out
+    rjmp    didStuffN       ;[0]
+
+#define bitStatus   x3
+
+sendNakAndReti:
+    ldi     cnt, USBPID_NAK ;[-19]
+    rjmp    sendCntAndReti  ;[-18]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     r0, cnt         ;[-16]
+    ldi     YL, 0           ;[-15] R0 address is 0
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+    ldi     bitStatus, 0xff ;[-4] init bit loop counter, works for up to 12 bytes
+byteloop:
+bitloop:
+    sbrs    shift, 0        ;[8] [-3]
+    eor     x1, x4          ;[9] [-2]
+    out     USBOUT, x1      ;[10] [-1] <-- out
+    ror     shift           ;[0]
+    ror     x2              ;[1]
+didStuffN:
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuffN       ;[3]
+    nop                     ;[4]
+    subi    bitStatus, 37   ;[5] 256 / 7 ~=~ 37
+    brcc    bitloop         ;[6] when we leave the loop, bitStatus has almost the initial value
+    sbrs    shift, 0        ;[7]
+    eor     x1, x4          ;[8]
+    ror     shift           ;[9]
+didStuff7:
+    out     USBOUT, x1      ;[10] <-- out
+    ror     x2              ;[0]
+    cpi     x2, 0xfc        ;[1]
+    brcc    bitstuff7       ;[2]
+    ld      shift, y+       ;[3]
+    dec     cnt             ;[5]
+    brne    byteloop        ;[6]
+;make SE0:
+    cbr     x1, USBMASK     ;[7] prepare SE0 [spec says EOP may be 21 to 25 cycles]
+    lds     x2, usbNewDeviceAddr;[8]
+    lsl     x2              ;[10] we compare with left shifted address
+    out     USBOUT, x1      ;[11] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    subi    YL, 2           ;[0] Only assign address on data packets, not ACK/NAK in r0
+    sbci    YH, 0           ;[1]
+    breq    skipAddrAssign  ;[2]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[5]
+    ori     x1, USBIDLE     ;[6]
+    in      x2, USBDDR      ;[7]
+    cbr     x2, USBMASK     ;[8] set both pins to input
+    mov     x3, x1          ;[9]
+    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
+    ldi     x4, 4           ;[11]
+se0Delay:
+    dec     x4              ;[12] [15] [18] [21]
+    brne    se0Delay        ;[13] [16] [19] [22]
+    out     USBOUT, x1      ;[23] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[24] <-- release bus now
+    out     USBOUT, x3      ;[25] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
Index: vusb-20121206/usbdrv/usbdrvasm18-crc.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm18-crc.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm18-crc.inc	(working copy)
@@ -0,0 +1,706 @@
+/* Name: usbdrvasm18.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Lukas Schrittwieser (based on 20 MHz usbdrvasm20.inc by Jeroen Benschop)
+ * Creation Date: 2009-01-20
+ * Tabsize: 4
+ * Copyright: (c) 2008 by Lukas Schrittwieser and OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 18 MHz version of the asssembler part of the USB driver. It
+requires a 18 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+
+;max stack usage: [ret(2), YL, SREG, YH, [sofError], bitcnt(x5), shift, x1, x2, x3, x4, cnt, ZL, ZH] = 14 bytes
+;nominal frequency: 18 MHz -> 12 cycles per bit
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+;register use in receive loop to receive the data bytes:
+; shift assembles the byte currently being received
+; x1 holds the D+ and D- line state
+; x2 holds the previous line state
+; cnt holds the number of bytes left in the receive buffer
+; x3 holds the higher crc byte (see algorithm below)
+; x4 is used as temporary register for the crc algorithm
+; x5 is used for unstuffing: when unstuffing the last received bit is inverted in shift (to prevent further
+;    unstuffing calls. In the same time the corresponding bit in x5 is cleared to mark the bit as beening iverted
+; zl lower crc value and crc table index
+; zh used for crc table accesses
+
+;--------------------------------------------------------------------------------------------------------------
+; CRC mods:
+;  table driven crc checker, Z points to table in prog space
+;   ZL is the lower crc byte, x3 is the higher crc byte
+;	x4 is used as temp register to store different results
+;	the initialization of the crc register is not 0xFFFF but 0xFE54. This is because during the receipt of the
+;	first data byte an virtual zero data byte is added to the crc register, this results in the correct initial
+;	value of 0xFFFF at beginning of the second data byte before the first data byte is added to the crc.
+;	The magic number 0xFE54 results form the crc table: At tabH[0x54] = 0xFF = crcH (required) and
+;	tabL[0x54] = 0x01  ->  crcL = 0x01 xor 0xFE = 0xFF
+;  bitcnt is renamed to x5 and is used for unstuffing purposes, the unstuffing works like in the 12MHz version
+;--------------------------------------------------------------------------------------------------------------
+; CRC algorithm:
+;	The crc register is formed by x3 (higher byte) and ZL (lower byte). The algorithm uses a 'reversed' form
+;	i.e. that it takes the least significant bit first and shifts to the right. So in fact the highest order
+;	bit seen from the polynomial devision point of view is the lsb of ZL. (If this sounds strange to you i
+;	propose a research on CRC :-) )
+;	Each data byte received is xored to ZL, the lower crc byte. This byte now builds the crc
+;	table index. Next the new high byte is loaded from the table and stored in x4 until we have space in x3
+;	(its destination).
+;	Afterwards the lower table is loaded from the table and stored in ZL (the old index is overwritten as
+;	we don't need it anymore. In fact this is a right shift by 8 bits.) Now the old crc high value is xored
+;	to ZL, this is the second shift of the old crc value. Now x4 (the temp reg) is moved to x3 and the crc
+; 	calculation is done.
+;	Prior to the first byte the two CRC register have to be initialized to 0xFFFF (as defined in usb spec)
+;	however the crc engine also runs during the receipt of the first byte, therefore x3 and zl are initialized
+;	to a magic number which results in a crc value of 0xFFFF after the first complete byte.
+;
+;	This algorithm is split into the extra cycles of the different bits:
+;	bit7:	XOR the received byte to ZL
+;	bit5:	load the new high byte to x4
+;	bit6:	load the lower xor byte from the table, xor zl and x3, store result in zl (=the new crc low value)
+;			move x4 (the new high byte) to x3, the crc value is ready
+;
+
+
+macro POP_STANDARD ; 18 cycles
+    pop		ZH
+    pop		ZL
+	pop     cnt
+    pop     x5
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     x4
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+macro CRC_CLEANUP_AND_CHECK
+	; the last byte has already been xored with the lower crc byte, we have to do the table lookup and xor
+	; x3 is the higher crc byte, zl the lower one
+	ldi		ZH, hi8(usbCrcTableHigh);[+1] get the new high byte from the table
+	lpm		x2, Z				;[+2][+3][+4]
+	ldi		ZH, hi8(usbCrcTableLow);[+5] get the new low xor byte from the table
+	lpm		ZL, Z				;[+6][+7][+8]
+	eor		ZL, x3				;[+7] xor the old high byte with the value from the table, x2:ZL now holds the crc value
+	cpi		ZL, 0x01			;[+8] if the crc is ok we have a fixed remainder value of 0xb001 in x2:ZL (see usb spec)
+	brne	ignorePacket		;[+9] detected a crc fault -> paket is ignored and retransmitted by the host
+	cpi		x2, 0xb0			;[+10]
+	brne	ignorePacket		;[+11] detected a crc fault -> paket is ignored and retransmitted by the host
+    endm
+
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG, YH, [sofError], x4, shift, x1, x2, x3, x5, cnt, ZL, ZH
+    push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-26]
+    push    YL                  ;[-25]
+    push    YH                  ;[-23]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-17]
+    rjmp    foundK              ;[-16]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-15]
+;{3, 5} after falling D- edge, average delay: 4 cycles
+;bit0 should be at 30  (2.5 bits) for center sampling. Currently at 4 so 26 cylces till bit 0 sample
+;use 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    x4                  ;[-14]
+;   [---]                       ;[-13]
+    lds     YL, usbInputBufOffset;[-12] used to toggle the two usb receive buffers
+;   [---]                       ;[-11]
+    clr     YH                  ;[-10]
+    subi    YL, lo8(-(usbRxBuf));[-9] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-8] [rx loop init]
+    push    shift               ;[-7]
+;   [---]                       ;[-6]
+    ldi		shift, 0x80			;[-5] the last bit is the end of byte marker for the pid receiver loop
+    clc			      	      	;[-4] the carry has to be clear for receipt of pid bit 0
+    sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
+    rjmp    haveTwoBitsK        ;[-2]
+    pop     shift               ;[-1] undo the push from before
+    pop     x4                  ;[1]
+    rjmp    waitForK            ;[3] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 24 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1                  ;[0]
+    push    x2                  ;[2]
+    push    x3                  ;[4] crc high byte
+    ldi     x2, 1<<USBPLUS      ;[6] [rx loop init] current line state is K state. D+=="1", D-=="0"
+    push    x5                  ;[7]
+    push    cnt                 ;[9]
+    ldi     cnt, USB_BUFSIZE    ;[11]
+
+
+;--------------------------------------------------------------------------------------------------------------
+; receives the pid byte
+; there is no real unstuffing algorithm implemented here as a stuffing bit is impossible in the pid byte.
+; That's because the last four bits of the byte are the inverted of the first four bits. If we detect a
+; unstuffing condition something went wrong and abort
+; shift has to be initialized to 0x80
+;--------------------------------------------------------------------------------------------------------------
+
+; pid bit 0 - used for even more register saving (we need the z pointer)
+	in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    eor		x2, x1				;[2] generate inverted of actual bit
+	sbrc	x2, USBMINUS		;[3] if the bit is set we received a zero
+	sec							;[4]
+	ror		shift				;[5] we perform no unstuffing check here as this is the first bit
+	mov		x2, x1				;[6]
+	push	ZL					;[7]
+								;[8]
+	push	ZH					;[9]
+								;[10]
+	ldi		x3, 0xFE			;[11] x3 is the high order crc value
+
+
+bitloopPid:						
+	in      x1, USBIN           ;[0] sample line state
+   	andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    breq    nse0                ;[2] both lines are low so handle se0	
+	eor		x2, x1				;[3] generate inverted of actual bit
+	sbrc	x2, USBMINUS		;[4] set the carry if we received a zero
+	sec							;[5]
+	ror		shift				;[6]
+	ldi		ZL, 0x54			;[7] ZL is the low order crc value
+	ser		x4					;[8] the is no bit stuffing check here as the pid bit can't be stuffed. if so
+								; some error occured. In this case the paket is discarded later on anyway.
+	mov		x2, x1				;[9] prepare for the next cycle
+	brcc	bitloopPid			;[10] while 0s drop out of shift we get the next bit
+	eor		x4, shift			;[11] invert all bits in shift and store result in x4
+
+;--------------------------------------------------------------------------------------------------------------
+; receives data bytes and calculates the crc
+; the last USBIN state has to be in x2
+; this is only the first half, due to branch distanc limitations the second half of the loop is near the end
+; of this asm file
+;--------------------------------------------------------------------------------------------------------------
+
+rxDataStart:
+    in      x1, USBIN           ;[0] sample line state (note: a se0 check is not useful due to bit dribbling)
+    ser		x5					;[1] prepare the unstuff marker register
+    eor		x2, x1             	;[2] generates the inverted of the actual bit
+    bst		x2, USBMINUS       	;[3] copy the bit from x2
+    bld		shift, 0	        ;[4] and store it in shift
+    mov		x2, shift	     	;[5] make a copy of shift for unstuffing check
+    andi	x2, 0xF9	      	;[6] mask the last six bits, if we got six zeros (which are six ones in fact)
+    breq	unstuff0	      	;[7] then Z is set now and we branch to the unstuffing handler
+didunstuff0:
+	subi    cnt, 1         		;[8] cannot use dec because it doesn't affect the carry flag
+    brcs    nOverflow    		;[9] Too many bytes received. Ignore packet							
+    st		Y+, x4				;[10] store the last received byte
+								;[11] st needs two cycles
+
+; bit1							
+	in		x2, USBIN			;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0 during bit 0
+    breq	nse0				;[2]
+    andi	x2, USBMASK			;[3] check se0 during bit 1
+    breq	nse0				;[4]
+	eor		x1, x2				;[5]
+    bst		x1, USBMINUS		;[6]
+    bld 	shift, 1	 		;[7]
+    mov		x1, shift			;[8]
+    andi	x1, 0xF3			;[9]
+    breq	unstuff1			;[10]
+didunstuff1:
+	nop							;[11]	
+
+; bit2
+	in      x1, USBIN           ;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0 (as there is nothing else to do here
+	breq	nOverflow	 		;[2]
+    eor		x2, x1              ;[3] generates the inverted of the actual bit
+    bst		x2, USBMINUS		;[4]
+    bld		shift, 2			;[5] store the bit
+    mov		x2, shift			;[6]
+    andi	x2, 0xE7			;[7] if we have six zeros here (which means six 1 in the stream)
+    breq	unstuff2			;[8] the next bit is a stuffing bit
+didunstuff2:
+	nop2						;[9]
+								;[10]
+	nop							;[11]					
+					
+; bit3							
+	in		x2, USBIN			;[0] sample line state
+    andi	x2, USBMASK			;[1] check for se0
+    breq	nOverflow           ;[2]
+    eor		x1, x2				;[3]
+    bst		x1, USBMINUS		;[4]
+    bld 	shift, 3	 		;[5]
+    mov		x1, shift			;[6]
+    andi	x1, 0xCF			;[7]
+    breq	unstuff3			;[8]
+didunstuff3:
+	nop							;[9]
+	rjmp 	rxDataBit4			;[10]
+								;[11]				
+
+; the avr branch instructions allow an offset of +63 insturction only, so we need this
+; 'local copy' of se0
+nse0:		
+	rjmp	se0					;[4]
+								;[5]
+; the same same as for se0 is needed for overflow and StuffErr
+nOverflow:
+stuffErr:
+	rjmp	overflow
+
+
+unstuff0:						;[8] this is the branch delay of breq unstuffX
+	andi	x1, USBMASK			;[9] do an se0 check here (if the last crc byte ends with 5 one's we might end up here
+	breq	didunstuff0			;[10] event tough the message is complete -> jump back and store the byte
+	ori		shift, 0x01			;[11] invert the last received bit to prevent furhter unstuffing
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	andi	x5, 0xFE			;[1] mark this bit as inverted (will be corrected before storing shift)
+	eor		x1, x2				;[2] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[3] mask the interesting bits
+	breq	stuffErr			;[4] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[5] the next bit expects the last state to be in x1
+	rjmp 	didunstuff0			;[6]
+								;[7] jump delay of rjmp didunstuffX	
+
+unstuff1:						;[11] this is the jump delay of breq unstuffX
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	ori		shift, 0x02			;[1] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xFD			;[2] mark this bit as inverted (will be corrected before storing shift)
+	eor		x2, x1				;[3] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[4] mask the interesting bits
+	breq	stuffErr			;[5] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[6] the next bit expects the last state to be in x2
+	nop2						;[7]
+								;[8]
+	rjmp 	didunstuff1			;[9]
+								;[10] jump delay of rjmp didunstuffX		
+
+unstuff2:						;[9] this is the jump delay of breq unstuffX
+	ori		shift, 0x04			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xFB			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff2			;[7]
+								;[8] jump delay of rjmp didunstuffX	
+
+unstuff3:						;[9] this is the jump delay of breq unstuffX
+	ori		shift, 0x08			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xF7			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff3			;[7]
+								;[8] jump delay of rjmp didunstuffX			
+
+
+
+; the include has to be here due to branch distance restirctions
+#define __USE_CRC__
+#include "asmcommon.inc"
+
+	
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+; 7.5 bit times is 90 cycles. ...there is plenty of time
+
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-6] <- acquire bus
+	ldi		x2, 0			;[-6] init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-5] exor mask
+    ldi     shift, 0x80     ;[-4] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x40    ;[-3]=[9]     binary 01000000
+txBitLoop:					; the loop sends the first 7 bits of the byte
+    sbrs    shift, 0        ;[-2]=[10] if we have to send a 1 don't change the line state
+    eor     x1, x4          ;[-1]=[11]
+    out     USBOUT, x1      ;[0]
+    ror     shift           ;[1]
+    ror     x2              ;[2] transfers the last sent bit to the stuffing history
+didStuffN:
+    nop	                    ;[3]
+    nop                     ;[4]
+    cpi     x2, 0xfc        ;[5] if we sent six consecutive ones
+    brcc    bitstuffN       ;[6]
+    lsr     bitcnt          ;[7]
+    brne    txBitLoop       ;[8] restart the loop while the 1 is still in the bitcount
+
+; transmit bit 7
+    sbrs    shift, 0        ;[9]
+    eor     x1, x4          ;[10]
+didStuff7:
+    ror     shift           ;[11]
+	out     USBOUT, x1      ;[0] transfer bit 7 to the pins
+    ror     x2              ;[1] move the bit into the stuffing history	
+    cpi     x2, 0xfc        ;[2]
+    brcc    bitstuff7       ;[3]
+    ld      shift, y+       ;[4] get next byte to transmit
+    dec     cnt             ;[5] decrement byte counter
+    brne    txByteLoop      ;[7] if we have more bytes start next one
+    						;[8] branch delay
+    						
+;make SE0:
+    cbr     x1, USBMASK     ;[8] 		prepare SE0 [spec says EOP may be 25 to 30 cycles]
+    lds     x2, usbNewDeviceAddr;[9]
+    lsl     x2              ;[11] 		we compare with left shifted address
+    out     USBOUT, x1      ;[0] 		<-- out SE0 -- from now 2 bits = 24 cycles until bus idle
+    subi    YL, 20 + 2      ;[1] 		Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[2]
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[3]
+    sts     usbDeviceAddr, x2		; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[5] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[6]
+    ori     x1, USBIDLE     ;[7]
+    in      x2, USBDDR      ;[8]
+    cbr     x2, USBMASK     ;[9] set both pins to input
+    mov     x3, x1          ;[10]
+    cbr     x3, USBMASK     ;[11] configure no pullup on both pins
+    ldi     x4, 4           ;[12]
+se0Delay:
+    dec     x4              ;[13] [16] [19] [22]
+    brne    se0Delay        ;[14] [17] [20] [23]
+    out     USBOUT, x1      ;[24] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[25] <-- release bus now
+    out     USBOUT, x3      ;[26] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
+
+bitstuffN:
+    eor     x1, x4          ;[8] generate a zero
+    ldi     x2, 0           ;[9] reset the bit stuffing history
+    nop2                    ;[10]
+    out     USBOUT, x1      ;[0] <-- send the stuffing bit
+    rjmp    didStuffN       ;[1]
+
+bitstuff7:
+    eor     x1, x4          ;[5]
+    ldi     x2, 0           ;[6] reset bit stuffing history
+    clc						;[7] fill a zero into the shift register
+    rol     shift           ;[8] compensate for ror shift at branch destination
+    rjmp    didStuff7       ;[9]
+    						;[10] jump delay
+
+;--------------------------------------------------------------------------------------------------------------
+; receives data bytes and calculates the crc
+; second half of the data byte receiver loop
+; most parts of the crc algorithm are here
+;--------------------------------------------------------------------------------------------------------------
+
+nOverflow2:
+	rjmp overflow
+
+rxDataBit4:
+	in      x1, USBIN           ;[0] sample line state
+    andi	x1, USBMASK			;[1] check for se0
+    breq	nOverflow2			;[2]
+    eor		x2, x1              ;[3]
+    bst		x2, USBMINUS		;[4]
+    bld		shift, 4			;[5]
+    mov		x2, shift			;[6]
+    andi	x2, 0x9F			;[7]
+    breq	unstuff4			;[8]
+didunstuff4:
+	nop2						;[9][10]
+	nop							;[11]
+
+; bit5							
+	in		x2, USBIN			;[0] sample line state
+    ldi		ZH, hi8(usbCrcTableHigh);[1] use the table for the higher byte
+    eor		x1, x2				;[2]
+    bst		x1, USBMINUS		;[3]
+    bld 	shift, 5	 		;[4]
+    mov		x1, shift			;[5]
+    andi	x1, 0x3F			;[6]
+    breq	unstuff5			;[7]
+didunstuff5:
+	lpm		x4, Z				;[8] load the higher crc xor-byte and store it for later use
+								;[9] lpm needs 3 cycles
+								;[10]			
+	ldi		ZH, hi8(usbCrcTableLow);[11] load the lower crc xor byte adress
+
+; bit6	    					
+	in      x1, USBIN           ;[0] sample line state
+    eor		x2, x1              ;[1]
+    bst		x2, USBMINUS		;[2]
+    bld		shift, 6			;[3]
+    mov		x2, shift			;[4]
+    andi	x2, 0x7E			;[5]
+    breq	unstuff6			;[6]
+didunstuff6:
+	lpm		ZL, Z				;[7] load the lower xor crc byte
+								;[8] lpm needs 3 cycles
+	    						;[9]
+	eor		ZL, x3				;[10] xor the old high crc byte with the low xor-byte
+	mov		x3, x4				;[11] move the new high order crc value from temp to its destination
+			
+; bit7							
+	in		x2, USBIN			;[0] sample line state
+    eor		x1, x2				;[1]
+    bst		x1, USBMINUS		;[2]
+    bld 	shift, 7	 		;[3] now shift holds the complete but inverted data byte
+    mov		x1, shift			;[4]
+    andi	x1, 0xFC			;[5]
+    breq	unstuff7			;[6]
+didunstuff7:
+	eor		x5, shift			;[7] x5 marks all bits which have not been inverted by the unstuffing subs
+	mov		x4, x5				;[8] keep a copy of the data byte it will be stored during next bit0
+	eor		ZL, x4				;[9] feed the actual byte into the crc algorithm
+	rjmp	rxDataStart			;[10] next byte
+								;[11] during the reception of the next byte this one will be fed int the crc algorithm
+
+unstuff4:						;[9] this is the jump delay of rjmp unstuffX
+	ori		shift, 0x10			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xEF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	nop2						;[5]
+								;[6]
+	rjmp 	didunstuff4			;[7]
+								;[8] jump delay of rjmp didunstuffX	
+
+unstuff5:						;[8] this is the jump delay of rjmp unstuffX
+	nop							;[9]
+	ori		shift, 0x20			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xDF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	nop							;[5]
+	rjmp 	didunstuff5			;[6]
+								;[7] jump delay of rjmp didunstuffX													
+
+unstuff6:						;[7] this is the jump delay of rjmp unstuffX
+	nop2						;[8]
+								;[9]
+	ori		shift, 0x40			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0xBF			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x2, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x1, x2				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x1, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x1, x2				;[4] the next bit expects the last state to be in x1
+	rjmp 	didunstuff6			;[5]
+								;[6] jump delay of rjmp didunstuffX	
+
+unstuff7:						;[7] this is the jump delay of rjmp unstuffX
+	nop							;[8]
+	nop							;[9]
+	ori		shift, 0x80			;[10] invert the last received bit to prevent furhter unstuffing
+	andi	x5, 0x7F			;[11] mark this bit as inverted (will be corrected before storing shift)
+	in		x1, USBIN			;[0] we have some free cycles so we could check for bit stuffing errors
+	eor		x2, x1				;[1] x1 and x2 have to be different because the stuff bit is always a zero
+	andi	x2, USBMASK			;[2] mask the interesting bits
+	breq	stuffErr2			;[3] if the stuff bit is a 1-bit something went wrong
+	mov 	x2, x1				;[4] the next bit expects the last state to be in x2
+	rjmp 	didunstuff7			;[5]
+								;[6] jump delay of rjmp didunstuff7
+
+; local copy of the stuffErr desitnation for the second half of the receiver loop
+stuffErr2:
+	rjmp	stuffErr
+
+;--------------------------------------------------------------------------------------------------------------
+; The crc table follows. It has to be aligned to enable a fast loading of the needed bytes.
+; There are two tables of 256 entries each, the low and the high byte table.
+; Table values were generated with the following C code:
+/*
+#include <stdio.h>
+int main (int argc, char **argv)
+{
+	int i, j;
+	for (i=0; i<512; i++){
+		unsigned short crc = i & 0xff;
+		for(j=0; j<8; j++) crc = (crc >> 1) ^ ((crc & 1) ? 0xa001 : 0);
+		if((i & 7) == 0) printf("\n.byte ");
+		printf("0x%02x, ", (i > 0xff ? (crc >> 8) : crc) & 0xff);
+		if(i == 255) printf("\n");
+	}
+	return 0;
+}
+
+// Use the following algorithm to compute CRC values:
+ushort computeCrc(uchar *msg, uchar msgLen)
+{
+    uchar i;
+	ushort crc = 0xffff;
+	for(i = 0; i < msgLen; i++)
+		crc = usbCrcTable16[lo8(crc) ^ msg[i]] ^ hi8(crc);
+    return crc;
+}
+*/
+
+.balign 256
+usbCrcTableLow:	
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41
+.byte 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
+
+; .balign 256
+usbCrcTableHigh:
+.byte 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2
+.byte 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04
+.byte 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E
+.byte 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8
+.byte 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A
+.byte 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC
+.byte 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6
+.byte 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10
+.byte 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32
+.byte 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4
+.byte 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE
+.byte 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38
+.byte 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA
+.byte 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C
+.byte 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26
+.byte 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0
+.byte 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62
+.byte 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4
+.byte 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE
+.byte 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68
+.byte 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA
+.byte 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C
+.byte 0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76
+.byte 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0
+.byte 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92
+.byte 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54
+.byte 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E
+.byte 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98
+.byte 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A
+.byte 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C
+.byte 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86
+.byte 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40	
+
Index: vusb-20121206/usbdrv/usbdrvasm20.inc
===================================================================
--- vusb-20121206/usbdrv/usbdrvasm20.inc	(nonexistent)
+++ vusb-20121206/usbdrv/usbdrvasm20.inc	(working copy)
@@ -0,0 +1,359 @@
+/* Name: usbdrvasm20.inc
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Jeroen Benschop
+ * Based on usbdrvasm16.inc from Christian Starkjohann
+ * Creation Date: 2008-03-05
+ * Tabsize: 4
+ * Copyright: (c) 2008 by Jeroen Benschop and OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/* Do not link this file! Link usbdrvasm.S instead, which includes the
+ * appropriate implementation!
+ */
+
+/*
+General Description:
+This file is the 20 MHz version of the asssembler part of the USB driver. It
+requires a 20 MHz crystal (not a ceramic resonator and not a calibrated RC
+oscillator).
+
+See usbdrv.h for a description of the entire driver.
+
+Since almost all of this code is timing critical, don't change unless you
+really know what you are doing! Many parts require not only a maximum number
+of CPU cycles, but even an exact number of cycles!
+*/
+
+#define leap2   x3
+#ifdef __IAR_SYSTEMS_ASM__
+#define nextInst    $+2
+#else
+#define nextInst    .+0
+#endif
+
+;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
+;nominal frequency: 20 MHz -> 13.333333 cycles per bit, 106.666667 cycles per byte
+; Numbers in brackets are clocks counted from center of last sync bit
+; when instruction starts
+;register use in receive loop:
+; shift assembles the byte currently being received
+; x1 holds the D+ and D- line state
+; x2 holds the previous line state
+; x4 (leap)  is used to add a leap cycle once every three bytes received
+; X3 (leap2) is used to add a leap cycle once every three stuff bits received
+; bitcnt is used to determine when a stuff bit is due
+; cnt holds the number of bytes left in the receive buffer
+
+USB_INTR_VECTOR:
+;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
+    push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
+    in      YL, SREG            ;[-26]
+    push    YL                  ;[-25]
+    push    YH                  ;[-23]
+;----------------------------------------------------------------------------
+; Synchronize with sync pattern:
+;----------------------------------------------------------------------------
+;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
+;sync up with J to K edge during sync pattern -- use fastest possible loops
+;The first part waits at most 1 bit long since we must be in sync pattern.
+;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
+;waitForJ, ensure that this prerequisite is met.
+waitForJ:
+    inc     YL
+    sbis    USBIN, USBMINUS
+    brne    waitForJ        ; just make sure we have ANY timeout
+waitForK:
+;The following code results in a sampling window of < 1/4 bit which meets the spec.
+    sbis    USBIN, USBMINUS     ;[-19]
+    rjmp    foundK              ;[-18]
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+    sbis    USBIN, USBMINUS
+    rjmp    foundK
+#if USB_COUNT_SOF
+    lds     YL, usbSofCount
+    inc     YL
+    sts     usbSofCount, YL
+#endif  /* USB_COUNT_SOF */
+#ifdef USB_SOF_HOOK
+    USB_SOF_HOOK
+#endif
+    rjmp    sofError
+foundK:                         ;[-16]
+;{3, 5} after falling D- edge, average delay: 4 cycles
+;bit0 should be at 34 for center sampling. Currently at 4 so 30 cylces till bit 0 sample
+;use 1 bit time for setup purposes, then sample again. Numbers in brackets
+;are cycles from center of first sync (double K) bit after the instruction
+    push    bitcnt              ;[-16]
+;   [---]                       ;[-15]
+    lds     YL, usbInputBufOffset;[-14]
+;   [---]                       ;[-13]
+    clr     YH                  ;[-12]
+    subi    YL, lo8(-(usbRxBuf));[-11] [rx loop init]
+    sbci    YH, hi8(-(usbRxBuf));[-10] [rx loop init]
+    push    shift               ;[-9]
+;   [---]                       ;[-8]
+    ldi     shift,0x40          ;[-7] set msb to "1" so processing bit7 can be detected
+    nop2                        ;[-6]
+;   [---]                       ;[-5]
+    ldi     bitcnt, 5           ;[-4] [rx loop init]
+    sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
+    rjmp    haveTwoBitsK        ;[-2]
+    pop     shift               ;[-1] undo the push from before
+    pop     bitcnt              ;[1] 
+    rjmp    waitForK            ;[3] this was not the end of sync, retry
+; The entire loop from waitForK until rjmp waitForK above must not exceed two
+; bit times (= 27 cycles).
+
+;----------------------------------------------------------------------------
+; push more registers and initialize values while we sample the first bits:
+;----------------------------------------------------------------------------
+haveTwoBitsK:
+    push    x1                  ;[0]
+    push    x2                  ;[2]
+    push    x3                  ;[4] (leap2)
+    ldi     leap2, 0x55         ;[6] add leap cycle on 2nd,5th,8th,... stuff bit
+    push    x4                  ;[7] == leap
+    ldi     leap, 0x55          ;[9] skip leap cycle on 2nd,5th,8th,... byte received
+    push    cnt                 ;[10]
+    ldi     cnt, USB_BUFSIZE    ;[12] [rx loop init]
+    ldi     x2, 1<<USBPLUS      ;[13] current line state is K state. D+=="1", D-=="0"
+bit0:       
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    rjmp    handleBit           ;[2] make bit0 14 cycles long
+
+;----------------------------------------------------------------------------
+; Process bit7. However, bit 6 still may need unstuffing.
+;----------------------------------------------------------------------------
+
+b6checkUnstuff:
+    dec     bitcnt              ;[9]
+    breq    unstuff6            ;[10]
+bit7:
+    subi    cnt, 1              ;[11] cannot use dec becaus it does not affect the carry flag
+    brcs    overflow            ;[12] Too many bytes received. Ignore packet
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    cpse    x1, x2              ;[2] when previous line state equals current line state, handle "1"
+    rjmp    b7handle0           ;[3] when line state differs, handle "0"
+    sec                         ;[4]
+    ror     shift               ;[5] shift "1" into the data
+    st      y+, shift           ;[6] store the data into the buffer
+    ldi     shift, 0x40         ;[7] reset data for receiving the next byte
+    subi    leap, 0x55          ;[9] trick to introduce a leap cycle every 3 bytes
+    brcc    nextInst            ;[10 or 11] it will fail after 85 bytes. However low speed can only receive 11
+    dec     bitcnt              ;[11 or 12]
+    brne    bit0                ;[12 or 13]
+    ldi     x1, 1               ;[13 or 14] unstuffing bit 7
+    in      bitcnt, USBIN       ;[0] sample stuff bit
+    rjmp    unstuff             ;[1]
+
+b7handle0:
+    mov     x2,x1               ;[5] Set x2 to current line state
+    ldi     bitcnt, 6           ;[6]
+    lsr     shift               ;[7] shift "0" into the data
+    st      y+, shift           ;[8] store data into the buffer
+    ldi     shift, 0x40         ;[10] reset data for receiving the next byte
+    subi    leap, 0x55          ;[11] trick to introduce a leap cycle every 3 bytes
+    brcs    bit0                ;[12] it will fail after 85 bytes. However low speed can only receive 11
+    rjmp    bit0                ;[13]
+
+
+;----------------------------------------------------------------------------
+; Handle unstuff
+; x1==0xFF indicate unstuffing bit6
+;----------------------------------------------------------------------------
+
+unstuff6:
+    ldi     x1,0xFF             ;[12] indicate unstuffing bit 6
+    in      bitcnt, USBIN       ;[0]  sample stuff bit
+    nop                         ;[1]  fix timing
+unstuff:                        ;b0-5  b6   b7
+    mov     x2,bitcnt           ;[3]  [2]  [3]  Set x2 to match line state
+    subi    leap2, 0x55         ;[4]  [3]  [4]  delay loop
+    brcs    nextInst            ;[5]  [4]  [5]  add one cycle every three stuff bits
+    sbci    leap2,0             ;[6]  [5]  [6]
+    ldi     bitcnt,6            ;[7]  [6]  [7]  reset bit stuff counter
+    andi    x2, USBMASK         ;[8]  [7]  [8] only keep D+ and D-
+    cpi     x1,0                ;[9]  [8]  [9]
+    brmi    bit7                ;[10] [9]  [10] finished unstuffing bit6 When x1<0
+    breq    bitloop             ;[11] ---  [11] finished unstuffing bit0-5 when x1=0
+    nop                         ;---  ---  [12]
+    in      x1, USBIN           ;---  ---  [0] sample line state for bit0
+    andi    x1, USBMASK         ;---  ---  [1] filter only D+ and D- bits
+    rjmp    handleBit           ;---  ---  [2] make bit0 14 cycles long
+
+;----------------------------------------------------------------------------
+; Receiver loop (numbers in brackets are cycles within byte after instr)
+;----------------------------------------------------------------------------
+bitloop:
+    in      x1, USBIN           ;[0] sample line state
+    andi    x1, USBMASK         ;[1] filter only D+ and D- bits
+    breq    se0                 ;[2] both lines are low so handle se0
+handleBit:
+    cpse    x1, x2              ;[3] when previous line state equals current line state, handle "1"
+    rjmp    handle0             ;[4] when line state differs, handle "0"
+    sec                         ;[5]
+    ror     shift               ;[6] shift "1" into the data
+    brcs    b6checkUnstuff      ;[7] When after shift C is set, next bit is bit7
+    nop2                        ;[8]
+    dec     bitcnt              ;[10]
+    brne    bitloop             ;[11]
+    ldi     x1,0                ;[12] indicate unstuff for bit other than bit6 or bit7
+    in      bitcnt, USBIN       ;[0] sample stuff bit
+    rjmp    unstuff             ;[1]
+
+handle0:
+    mov     x2, x1              ;[6] Set x2 to current line state
+    ldi     bitcnt, 6           ;[7] reset unstuff counter. 
+    lsr     shift               ;[8] shift "0" into the data
+    brcs    bit7                ;[9] When after shift C is set, next bit is bit7
+    nop                         ;[10]
+    rjmp    bitloop             ;[11] 
+    
+;----------------------------------------------------------------------------
+; End of receive loop. Now start handling EOP
+;----------------------------------------------------------------------------
+
+macro POP_STANDARD ; 14 cycles
+    pop     cnt
+    pop     x4
+    pop     x3
+    pop     x2
+    pop     x1
+    pop     shift
+    pop     bitcnt
+    endm
+macro POP_RETI     ; 7 cycles
+    pop     YH
+    pop     YL
+    out     SREG, YL
+    pop     YL
+    endm
+
+
+
+#include "asmcommon.inc"
+
+; USB spec says:
+; idle = J
+; J = (D+ = 0), (D- = 1)
+; K = (D+ = 1), (D- = 0)
+; Spec allows 7.5 bit times from EOP to SOP for replies
+; 7.5 bit times is 100 cycles. This implementation arrives a bit later at se0
+; then specified in the include file but there is plenty of time
+
+bitstuffN:
+    eor     x1, x4          ;[8]
+    ldi     x2, 0           ;[9]
+    nop2                    ;[10]
+    out     USBOUT, x1      ;[12] <-- out
+    rjmp    didStuffN       ;[0]
+    
+bitstuff7:
+    eor     x1, x4          ;[6]
+    ldi     x2, 0           ;[7] Carry is zero due to brcc
+    rol     shift           ;[8] compensate for ror shift at branch destination
+    nop2                    ;[9]
+    rjmp    didStuff7       ;[11]
+
+sendNakAndReti:
+    ldi     x3, USBPID_NAK  ;[-18]
+    rjmp    sendX3AndReti   ;[-17]
+sendAckAndReti:
+    ldi     cnt, USBPID_ACK ;[-17]
+sendCntAndReti:
+    mov     x3, cnt         ;[-16]
+sendX3AndReti:
+    ldi     YL, 20          ;[-15] x3==r20 address is 20
+    ldi     YH, 0           ;[-14]
+    ldi     cnt, 2          ;[-13]
+;   rjmp    usbSendAndReti      fallthrough
+
+;usbSend:
+;pointer to data in 'Y'
+;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
+;uses: x1...x4, btcnt, shift, cnt, Y
+;Numbers in brackets are time since first bit of sync pattern is sent
+;We don't match the transfer rate exactly (don't insert leap cycles every third
+;byte) because the spec demands only 1.5% precision anyway.
+usbSendAndReti:             ; 12 cycles until SOP
+    in      x2, USBDDR      ;[-12]
+    ori     x2, USBMASK     ;[-11]
+    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
+    in      x1, USBOUT      ;[-8] port mirror for tx loop
+    out     USBDDR, x2      ;[-7] <- acquire bus
+; need not init x2 (bitstuff history) because sync starts with 0
+    ldi     x4, USBMASK     ;[-6] exor mask
+    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
+txByteLoop:
+    ldi     bitcnt, 0x49    ;[-4]        [10] binary 01001001
+txBitLoop:
+    sbrs    shift, 0        ;[-3] [10]   [11]
+    eor     x1, x4          ;[-2] [11]   [12]
+    out     USBOUT, x1      ;[-1] [12]   [13]   <-- out N
+    ror     shift           ;[0]  [13]   [14]
+    ror     x2              ;[1]
+didStuffN:
+    nop2                    ;[2]
+    nop                     ;[4]
+    cpi     x2, 0xfc        ;[5]
+    brcc    bitstuffN       ;[6]
+    lsr     bitcnt          ;[7]
+    brcc    txBitLoop       ;[8]
+    brne    txBitLoop       ;[9]
+
+    sbrs    shift, 0        ;[10]
+    eor     x1, x4          ;[11]
+didStuff7:
+    out     USBOUT, x1      ;[-1] [13] <-- out 7
+    ror     shift           ;[0] [14]
+    ror     x2              ;[1]
+    nop                     ;[2]
+    cpi     x2, 0xfc        ;[3]
+    brcc    bitstuff7       ;[4]
+    ld      shift, y+       ;[5]
+    dec     cnt             ;[7]
+    brne    txByteLoop      ;[8]
+;make SE0:
+    cbr     x1, USBMASK     ;[9] prepare SE0 [spec says EOP may be 25 to 30 cycles]
+    lds     x2, usbNewDeviceAddr;[10]
+    lsl     x2              ;[12] we compare with left shifted address
+    out     USBOUT, x1      ;[13] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
+    subi    YL, 20 + 2      ;[0] Only assign address on data packets, not ACK/NAK in x3
+    sbci    YH, 0           ;[1]
+;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
+;set address only after data packet was sent, not after handshake
+    breq    skipAddrAssign  ;[2]
+    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
+skipAddrAssign:
+;end of usbDeviceAddress transfer
+    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
+    USB_STORE_PENDING(x2)   ;[5]
+    ori     x1, USBIDLE     ;[6]
+    in      x2, USBDDR      ;[7]
+    cbr     x2, USBMASK     ;[8] set both pins to input
+    mov     x3, x1          ;[9]
+    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
+    ldi     x4, 5           ;[11]
+se0Delay:
+    dec     x4              ;[12] [15] [18] [21] [24]
+    brne    se0Delay        ;[13] [16] [19] [22] [25]
+    out     USBOUT, x1      ;[26] <-- out J (idle) -- end of SE0 (EOP signal)
+    out     USBDDR, x2      ;[27] <-- release bus now
+    out     USBOUT, x3      ;[28] <-- ensure no pull-up resistors are active
+    rjmp    doReturn
Index: vusb-20121206/usbdrv/usbportability.h
===================================================================
--- vusb-20121206/usbdrv/usbportability.h	(nonexistent)
+++ vusb-20121206/usbdrv/usbportability.h	(working copy)
@@ -0,0 +1,143 @@
+/* Name: usbportability.h
+ * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
+ * Author: Christian Starkjohann
+ * Creation Date: 2008-06-17
+ * Tabsize: 4
+ * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
+ * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
+ */
+
+/*
+General Description:
+This header is intended to contain all (or at least most of) the compiler
+and library dependent stuff. The C code is written for avr-gcc and avr-libc.
+The API of other development environments is converted to gcc's and avr-libc's
+API by means of defines.
+
+This header also contains all system includes since they depend on the
+development environment.
+
+Thanks to Oleg Semyonov for his help with the IAR tools port!
+*/
+
+#ifndef __usbportability_h_INCLUDED__
+#define __usbportability_h_INCLUDED__
+
+/* We check explicitly for IAR and CodeVision. Default is avr-gcc/avr-libc. */
+
+/* ------------------------------------------------------------------------- */
+#if defined __IAR_SYSTEMS_ICC__ || defined __IAR_SYSTEMS_ASM__  /* check for IAR */
+/* ------------------------------------------------------------------------- */
+
+#ifndef ENABLE_BIT_DEFINITIONS
+#   define ENABLE_BIT_DEFINITIONS	1   /* Enable bit definitions */
+#endif
+
+/* Include IAR headers */
+#include <ioavr.h>
+#ifndef __IAR_SYSTEMS_ASM__
+#   include <inavr.h>
+#endif
+
+#define __attribute__(arg)  /* not supported on IAR */
+
+#ifdef __IAR_SYSTEMS_ASM__
+#   define __ASSEMBLER__    /* IAR does not define standard macro for asm */
+#endif
+
+#ifdef __HAS_ELPM__
+#   define PROGMEM __farflash
+#else
+#   define PROGMEM __flash
+#endif
+
+#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+
+/* The following definitions are not needed by the driver, but may be of some
+ * help if you port a gcc based project to IAR.
+ */
+#define cli()       __disable_interrupt()
+#define sei()       __enable_interrupt()
+#define wdt_reset() __watchdog_reset()
+#define _BV(x)      (1 << (x))
+
+/* assembler compatibility macros */
+#define nop2    rjmp    $+2 /* jump to next instruction */
+#define XL      r26
+#define XH      r27
+#define YL      r28
+#define YH      r29
+#define ZL      r30
+#define ZH      r31
+#define lo8(x)  LOW(x)
+#define hi8(x)  (((x)>>8) & 0xff)   /* not HIGH to allow XLINK to make a proper range check */
+
+/* Depending on the device you use, you may get problems with the way usbdrv.h
+ * handles the differences between devices. Since IAR does not use #defines
+ * for MCU registers, we can't check for the existence of a particular
+ * register with an #ifdef. If the autodetection mechanism fails, include
+ * definitions for the required USB_INTR_* macros in your usbconfig.h. See
+ * usbconfig-prototype.h and usbdrv.h for details.
+ */
+
+/* ------------------------------------------------------------------------- */
+#elif __CODEVISIONAVR__ /* check for CodeVision AVR */
+/* ------------------------------------------------------------------------- */
+/* This port is not working (yet) */
+
+/* #define F_CPU   _MCU_CLOCK_FREQUENCY_    seems to be defined automatically */
+
+#include <io.h>
+#include <delay.h>
+
+#define __attribute__(arg)  /* not supported on IAR */
+
+#define PROGMEM                 __flash
+#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
+
+#ifndef __ASSEMBLER__
+static inline void  cli(void)
+{
+    #asm("cli");
+}
+static inline void  sei(void)
+{
+    #asm("sei");
+}
+#endif
+#define _delay_ms(t)    delay_ms(t)
+#define _BV(x)          (1 << (x))
+#define USB_CFG_USE_SWITCH_STATEMENT 1  /* macro for if() cascase fails for unknown reason */
+
+#define macro   .macro
+#define endm    .endmacro
+#define nop2    rjmp    .+0 /* jump to next instruction */
+
+/* ------------------------------------------------------------------------- */
+#else   /* default development environment is avr-gcc/avr-libc */
+/* ------------------------------------------------------------------------- */
+
+#include <avr/io.h>
+#ifdef __ASSEMBLER__
+#   define _VECTOR(N)   __vector_ ## N   /* io.h does not define this for asm */
+#else
+#   include <avr/pgmspace.h>
+#endif
+
+#if USB_CFG_DRIVER_FLASH_PAGE
+#   define USB_READ_FLASH(addr)    pgm_read_byte_far(((long)USB_CFG_DRIVER_FLASH_PAGE << 16) | (long)(addr))
+#else
+#   define USB_READ_FLASH(addr)    pgm_read_byte(addr)
+#endif
+
+#define macro   .macro
+#define endm    .endm
+#define nop2    rjmp    .+0 /* jump to next instruction */
+
+#endif  /* development environment */
+
+/* for conveniecne, ensure that PRG_RDB exists */
+#ifndef PRG_RDB
+#   define PRG_RDB(addr)    USB_READ_FLASH(addr)
+#endif
+#endif  /* __usbportability_h_INCLUDED__ */

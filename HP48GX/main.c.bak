/*---------------------------------------------------------------------------
------------------------------HP48GX-----------------------------------------
---------------------------------------------------------------------------*/

//-------------------------------defines-----------------------------------
#include <avr/io.h>
#include <util/delay.h>
#include <math.h>
#include "usbconfig.h"
#include "usbdrv/usbdrv.h"
#include <avr/wdt.h>
#include <avr/interrupt.h>
#include <stddef.h>

#define PWRLED (PORTC | 0b00100000)
#define A12OUT (PORTC & 0b00101111)
#define A10OUT (PORTD & 0b11111101)
#define A1IN   (PINC2)

#define STATE_WAIT 0
#define STATE_SEND_KEY 1
#define STATE_RELEASE_KEY 2

//-------------------------------globale Variablen----------------------------

uchar state = STATE_WAIT;

PROGMEM char usbHidReportDescriptor[USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH] = {
    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
    0x09, 0x06,                    // USAGE (Keyboard)
    0xa1, 0x01,
    0x75, 0x01,                    //   REPORT_SIZE (1)
    0x95, 0x08,                    //   REPORT_COUNT (8)
    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
    0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)(224)
    0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)(231)
    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
    0x81, 0x02,                    //   INPUT (Data,Var,Abs) ; Modifier byte
    0x95, 0x01,                    //   REPORT_COUNT (1)
    0x75, 0x08,                    //   REPORT_SIZE (8)
    0x81, 0x03,                    //   INPUT (Cnst,Var,Abs) ; Reserved byte
    0x95, 0x05,                    //   REPORT_COUNT (5)
    0x75, 0x01,                    //   REPORT_SIZE (1)
    0x05, 0x08,                    //   USAGE_PAGE (LEDs)
    0x19, 0x01,                    //   USAGE_MINIMUM (Num Lock)
    0x29, 0x05,                    //   USAGE_MAXIMUM (Kana)
    0x91, 0x02,                    //   OUTPUT (Data,Var,Abs) ; LED report
    0x95, 0x01,                    //   REPORT_COUNT (1)
    0x75, 0x03,                    //   REPORT_SIZE (3)
    0x91, 0x03,                    //   OUTPUT (Cnst,Var,Abs) ; LED report padding
    0x95, 0x06,                    //   REPORT_COUNT (6)
    0x75, 0x08,                    //   REPORT_SIZE (8)
    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
    0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
    0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))(0)
    0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)(101)
    0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
    0xc0                           // END_COLLECTION
};


uchar ScanCode [10][6] = {{0,5,6,7,8,9},
             /*[y][x]*/  {0,11,12,13,14,15},
                         {0,17,18,19,20,21},
                         {0,23,24,25,26,27},
                         {0,88,28,29,76,42},
                         {43,22,36,37,38,84},
                         {225,16,33,34,35,85},
                         {224,10,30,31,32,86},
                         {0,4,62,37,44,87},
                         {41,0,0,0,0,0}};


/*  enter 88
    delete 76
    backspace 42
    operationen 84 - 87 /*-+
    tab 43
    control 224
    shift 225
    esc 41
	space 44
	f13 104*/

typedef struct {
	uint8_t modifier;
	uint8_t reserved;
	uint8_t keycode[6];
} keyboard_report_t;

static keyboard_report_t keyboard_report; // sent to PC
static uchar idleRate; // repeat rate for keyboards


usbMsgLen_t usbFunctionSetup(unsigned char data[8]) {
    usbRequest_t *rq = (void *)data;

    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS) {
        switch(rq->bRequest) {
        case USBRQ_HID_GET_REPORT: // send "no keys pressed" if asked here
            // wValue: ReportType (highbyte), ReportID (lowbyte)
            usbMsgPtr = (void *)&keyboard_report; // we only have this one
            keyboard_report.modifier = 0;
            keyboard_report.keycode[0] = 0;
            return sizeof(keyboard_report);
		case USBRQ_HID_SET_REPORT: // if wLength == 1, should be LED state
            return (rq->wLength.word == 1) ? USB_NO_MSG : 0;
        case USBRQ_HID_GET_IDLE: // send idle rate to PC as required by spec
            usbMsgPtr = &idleRate;
            return 1;
        case USBRQ_HID_SET_IDLE: // save idle rate as required by spec
            idleRate = rq->wValue.bytes[1];
            return 0;
        }
    }

    return 0; // by default don't return any data
}



usbMsgLen_t usbFunctionWrite(uint8_t * data, uchar len) {
	//if (data[0] == LED_state)
        return 1;
    //else
    //    LED_state = data[0];PORTD = PORTD & 0b11110111;
	//TIMSK0 |= (1<<TOIE0); //enables Overflow Interrupt
    //// LED state changed
	//if(LED_state & CAPS_LOCK)
	//	PORTB |= 1 << PB0; // LED on
	//else
	//	PORTB &= ~(1 << PB0); // LED off
	//
	//return 1; // Data read, not expecting more
}
void buildReport(uchar send_key) {
	keyboard_report.modifier = 0;
    if(send_key != 0)
		keyboard_report.keycode[0] = send_key;
    else
		keyboard_report.keycode[0] = 0;
}
#define VBAT 3
#define ROWS 10
#define DEBOUNCE_CYCLES 10
uint16_t activeRow = 0x01;
uint8_t activeRowIdx = 0;
uint8_t keyStates[ROWS];
uint8_t debouncing[DEBOUNCE_CYCLES][ROWS];

int isrFlag = 0;

ISR(TIMER0_OVF_vect)
{
    isrFlag = 1;
}
int scanMatrix(void)
{
    if(!isrFlag)
        return 0;
    isrFlag = 0;

    int idx = 0;
    int allEqual = 1;

    uint8_t newVal = PIND & 0xF3; /// mask data lines
    for (idx = 0 ; idx < DEBOUNCE_CYCLES - 1; ++idx)
    {
        allEqual &= newVal == debouncing[idx][activeRowIdx];
        debouncing[idx][activeRowIdx] = debouncing[idx+1][activeRowIdx];
    }
    allEqual &= newVal == debouncing[idx][activeRowIdx];
    debouncing[idx][activeRowIdx] = newVal;

    uint8_t changedKeys = keyStates[activeRowIdx] ^ newVal;
    if(allEqual && changedKeys)
    {
        if(((changedKeys & 0x01)&~(keyStates[activeRowIdx]|0xFE))== 0x01 ){
            state = STATE_SEND_KEY;
            return (ScanCode[activeRowIdx-1][0]);
            }
        else if(((changedKeys & 0x02)&~(keyStates[activeRowIdx]|0xFD))== 0x02 ){
            state = STATE_SEND_KEY;
            return (ScanCode[activeRowIdx-1][1]);
            }
        else if(((changedKeys & 0x04)&~(keyStates[activeRowIdx]|0xFB))== 0x04 ){
            state = STATE_SEND_KEY;
            return (ScanCode[activeRowIdx-1][2]);
            }
        else if(((changedKeys & 0x08)&~(keyStates[activeRowIdx]|0xF7))== 0x08 ){
            state = STATE_SEND_KEY;
            return (ScanCode[activeRowIdx-1][3]);
            }
        else if(((changedKeys & 0x10)&~(keyStates[activeRowIdx]|0xEF))== 0x10 ){
            state = STATE_SEND_KEY;
            return (ScanCode[activeRowIdx-1][4]);
            }
        else if(((changedKeys & 0x20)&~(keyStates[activeRowIdx]|0xDF))== 0x20 ){
            state = STATE_SEND_KEY;
            return (ScanCode[activeRowIdx-1][5]);
            }
        keyStates[activeRowIdx] = newVal;
    }

    else
    {
        int ONKEY = 0;
        for(idx = 0; idx < DEBOUNCE_CYCLES-1; ++idx)
        {
            ONKEY = (PINB & 0x80);
            allEqual &= ONKEY == debouncing[idx][activeRowIdx];
            debouncing[idx][activeRowIdx] = debouncing[idx+1][activeRowIdx];
        }
        allEqual &= ONKEY == debouncing[idx][activeRowIdx];
        debouncing[idx][activeRowIdx] = ONKEY;
        uint8_t changedONKEY = keyStates[activeRowIdx] ^ ONKEY;
        if(allEqual && changedONKEY)
        {
            if(((changedONKEY & 0x80)&~(keyStates[activeRowIdx]|0x7F))== 0x80){
            state = STATE_SEND_KEY;
            return (ScanCode[activeRowIdx-1][0]);
            }
        }
    }
    DDRC =  ~activeRow     & 0xff;     //DDRC
    activeRow <<= 1;
    activeRowIdx += 1;
    if (activeRow & (1 << ROWS))
    {
        activeRow = 0x01;
        activeRowIdx = 0;
    }
    DDRC =  ~activeRow     & 0xff;     //DDRC
    DDRA = (~activeRow>>8) & 0xff;     //DDRA

    return 0;
}
int main(void)
{
    /*DDRC  = 0b00000000;
    PORTC = 0b01000000;
    DDRD  &= 0b00001100;
    PORTD &= 0b00001100;
    DDRA  = 0b00000000;
    PORTA = 0b00000000;
    DDRB  = 0b01111111;
    PORTB = 0b01111111;*/

    DDRC = 0b00110000;
    PORTC = 0b00000000;

    TCCR0A |= 0b00000011; //clk/64 ==> timeout 1.35ms
//-------------------------------------
    uchar report_size,i, button_release_counter = 0;
    //cli();

    for(report_size=0; report_size<sizeof(keyboard_report); report_size++) // clear report initially
        ((uchar *)&keyboard_report)[report_size] = 0;

    wdt_enable(WDTO_1S); // enable 1s watchdog timer

    usbInit();

    usbDeviceDisconnect(); // enforce re-enumeration
    for(i = 0; i<250; i++) // wait 500 ms
    {
        wdt_reset(); // keep the watchdog happy
        _delay_ms(2);
    }
    usbDeviceConnect();

    sei(); // Enable interrupts after re-enumeration
    int keybuild = 0;
    while(1)
    {
     //   keybuild = scanMatrix();
        wdt_reset(); // keep the watchdog happy
        usbPoll();

        if(!(PINC & (1<<A1IN))) { // button pressed (PB1 at ground voltage)
			// also check if some time has elapsed since last button press
			if(state == STATE_WAIT && button_release_counter == 255)
				state = STATE_SEND_KEY;
				button_release_counter = 0; // now button needs to be released a while until retrigger
		}

		if(button_release_counter < 255)
			button_release_counter++; // increase release counter*/

        if(usbInterruptIsReady() && state != STATE_WAIT)
        {

			switch(state)
			{
			case STATE_SEND_KEY:
				buildReport('1');
				state = STATE_RELEASE_KEY; // release next
				break;
			case STATE_RELEASE_KEY:
				buildReport(NULL);
				state = STATE_WAIT; // go back to waiting
				break;
			default:
				state = STATE_WAIT; // should not happen
			}
        }
        // start sending
        usbSetInterrupt((void *)&keyboard_report, sizeof(keyboard_report));
    }

    return 0;
}
